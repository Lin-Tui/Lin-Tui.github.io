---
title: 《数据结构与算法之美》学习笔记(4) 二分查找及其变形问题
date: 1585137594084.2253
tags:
- 数据结构与算法
category:
- 《数据结构与算法之美》学习笔记
---
# 二分查找及其变形问题

## 二分查找

二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。

#### （1）O(logn) 惊人的查找速度

二分查找是一种非常高效的查找算法。

即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。

#### （2）二分查找实现

我的博客:

[算法 -查找算法](https://blog.csdn.net/weixin_46124214/article/details/104978186)

#### （3）二分查找应用场景的局限性

二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。

* **首先，二分查找依赖的是顺序表结构，简单点说就是数组。**

  那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。

  二分查找只能用在数据是通过顺序表来存储的数据结构上。如果数据是通过其他数据结构存储的，则无法应用二分查找。

* **其次，二分查找针对的是有序数据**。

  二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，需要先排序。

  如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。

* **再次，数据量太小不适合二分查找。**

  如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。

  不过，有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。

* **最后，数据量太大也不适合二分查找。**

  二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。

  注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。

## 二分查找变形问题

为了简化讲解，以下的内容，都以数据是从小到大排列为前提。

#### （1）查找第一个值等于给定值的元素

上面二分查找是最简单的一种，即有序数据集合中不存在重复的数据，在其中查找值等于某个给定值的数据。如果将这个问题稍微修改下，有序数据集合中存在重复的数据，希望找到第一个值等于给定值的数据。

**例子：**

比如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。希望查找第一个等于 8 的数据，也就是下标是 5 的元素。

![1585139248573](C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585139248573.png)

如果用之前的二分查找的代码实现，首先拿 8 与区间的中间值 a[4] 比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7] 正好等于 8，所以代码就返回了。

尽管 a[7] 也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。

**算法实现：**

```js
function bsearch(arr, value) {
    let low = 0;
    let high = arr.length - 1;
    while(low <= high) {
        let mid = low + ((high - low) / 2);
        if (a[mid] > value) {
            high = mid - 1;
        } else if (a[mid] < value) {
            low = mid + 1;
        } else {
            if ((mid == 0) || a[mid - 1] != value) return mid;
            else high = mid - 1;
        }
    }
    return -1;
}
```

**算法理解：**

* a[mid] 跟要查找的 value 的大小关系有三种情况：大于、小于、等于。
* 对于 a[mid]>value 的情况，我们需要更新 high= mid-1；
* 对于 a[mid]<value 的情况，我们需要更新 low=mid+1。

* 那当 a[mid]=value 的时候应该如何处理呢？

  当 a[mid] 等于要查找的值时，a[mid] 就是要找的元素。但是，如果求解的是第一个值等于给定值的元素，当 a[mid] 等于要查找的值时，就需要先确认一下这个 a[mid] 是不是第一个值等于给定值的元素。

  如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是要找的；如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是要找的第一个值等于给定值的元素。

  如果经过检查之后发现 a[mid] 前面的一个元素 a[mid-1] 也等于 value，那说明此时的 a[mid] 肯定不是要查找的第一个值等于给定值的元素。那就更新 high=mid-1，因为要找的元素肯定出现在 [low, mid-1] 之间。

#### （2）查找最后一个值等于给定值的元素

如果掌握了前面的写法，那这个问题你应该很轻松就能解决。

**算法实现：**

```js
function bsearch(arr, value) {
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
        let mid = low + ((high - low) / 2);
        if (arr[mid] > value) {
            high = mid - 1;
        } else if (arr[mid] < value) {
            low = mid + 1;
        } else {
            if ((mid == arr.length - 1 || arr[mid + 1] != value)) return mid;
            else low mid + 1;
        }
        return -1
    }
}
```

**算法理解：**

重点看第 11 行代码。

* 如果 a[mid] 这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid] 的后一个元素 a[mid+1] 不等于 value，那也说明 a[mid] 就是要找的最后一个值等于给定值的元素。

* 如果经过检查之后，发现 a[mid] 后面的一个元素 a[mid+1] 也等于 value，那说明当前的这个 a[mid] 并不是最后一个值等于给定值的元素。就更新 low=mid+1，因为要找的元素肯定出现在 [mid+1, high] 之间。

#### （3）查找第一个大于大于给定值的元素

在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。

**算法实现：**

```js
function bsearch(arr, value) {
    let low = 0;
    let high = arr.length - 1;
    while(low <= high) {
        let mid = low + ((high - low) / 2);
        if (arr[mid] >= value) {
            if((mid == 0) || arr[mid - 1] < value) return mid;
            else high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
```

**算法理解：**

* 如果 a[mid] 小于要查找的值 value，那要查找的值肯定在 [mid+1, high] 之间，所以，我们更新 low=mid+1。

* 对于 a[mid] 大于等于给定值 value 的情况，要先看下这个 a[mid] 是不是要找的第一个值大于等于给定值的元素。如果 a[mid] 前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid] 就是要找的元素。这段逻辑对应的代码是第 7 行。

* 如果 a[mid-1] 也大于等于要查找的值 value，那说明要查找的元素在 [low, mid-1] 之间，所以，我们将 high 更新为 mid-1。

#### （4）查找最后一个小于等于给定值的元素

比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。

```js
function bsearch(arr, value) {
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
        let mid = low + ((high - low) / 2);
        if (arr[mid] <= value) {
            if (mid == arr.length - 1 || arr[mid] > value) return mid;
            else low = mid + 1;
        }
    }
    return -1;
}
```













































































