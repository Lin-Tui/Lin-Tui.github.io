---
title: 算法 - 回溯算法
date: 1585488497895.7373
tags:
- 算法
category:
- 数据结构与算法学习笔记
---
# 回溯算法

#### （1）基本概念

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

#### （2）基本思想

回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。[八皇后问题](https://baike.baidu.com/item/八皇后问题)就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的[节点](https://baike.baidu.com/item/节点)，从而减少状态空间树节点的生成。[回溯法](https://baike.baidu.com/item/回溯法)是一个既带有系统性又带有跳跃性的的[搜索算法](https://baike.baidu.com/item/搜索算法)。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而[回溯法](https://baike.baidu.com/item/回溯法)在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。

#### （3）解空间的树结构

使用回溯法的解空间一般有两种解空间：**子集树和排列树**

- **子集树**

  当所给的问题从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。常用于0-1问题，如0-1背包问题。

- **排列树**

  当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称之为排列树。排序树通常有n！叶结点。

#### （4）用回溯法解题的一般步骤

- 针对所给问题，确定问题的解空间：
  首先明确定义问题的解空间，问题的解空间应该至少包含问题的一个解

- 确定结点扩展搜索规则

- 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索

确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。[回溯法](https://baike.baidu.com/item/回溯法)即以这种工作方式[递归](https://baike.baidu.com/item/递归)地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。

#### （5）算法框架

* **问题框架**

  设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。

* **递归回溯框架**

  回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：

  ```js
  function backtrack (t) //t表示递归深度
  {
         if (t>n) output(x); //n表示深度界限
         else
           for (let i=f(n,t);i<=g(n,t);i++) // f(n,t)，g(n,t)分别表示当前扩展结点未搜索过的子树的起始编号和终止编号
             {
             x[t]=h(i); 
             if (constraint(t) && bound(t)) //满足约束函数和限界函数
                backtrack(t+1);
             }
  }
  ```

* **非递归的算法框架**

  ```js
  function iterativeBacktrack ()
  {
    let t=1;
    while (t>0) {
      if (f(n,t)<=g(n,t)) 
        for (let i=f(n,t);i<=g(n,t);i++) {
          x[t]=h(i);
          if (constraint(t) && bound(t)) {
            if (solution(t)) output(x);
            else t++;}
          }
      else t--;
      }
  }
  ```

**学习参考于：**

[回溯算法](https://www.jianshu.com/p/f6d3732e86fb)



















































































