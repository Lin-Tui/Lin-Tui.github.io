

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#252d38">
  <meta name="author" content="Lin Tui">
  <meta name="keywords" content="">
  
    <meta name="description" content="《现代前端技术解析》阅读笔记第一章  Web前端技术基础思考一些问题：   页面内容多而复杂，怎样保证开发效率？需要借助符合特定场合的前端框架来提高效率。  页面内容多且复杂，项目管理和维护该如何去做？考虑用模块化和组件化的思路管理，所谓模块化和组件化是指采用代码管理中分治的思想，将复杂的代码拆分成多个独立，简单，解耦合的结构或文件分开管理，使项目结构更加清晰。  页面加载内容很多，怎样保证尽快将">
<meta property="og:type" content="article">
<meta property="og:title" content="《现代前端技术解析》阅读笔记">
<meta property="og:url" content="https://lin-tui.github.io.com/2020/01/06/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E3%80%8A%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Lin Tui">
<meta property="og:description" content="《现代前端技术解析》阅读笔记第一章  Web前端技术基础思考一些问题：   页面内容多而复杂，怎样保证开发效率？需要借助符合特定场合的前端框架来提高效率。  页面内容多且复杂，项目管理和维护该如何去做？考虑用模块化和组件化的思路管理，所谓模块化和组件化是指采用代码管理中分治的思想，将复杂的代码拆分成多个独立，简单，解耦合的结构或文件分开管理，使项目结构更加清晰。  页面加载内容很多，怎样保证尽快将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105211453932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105211646780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020010521170894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105211927585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105211942454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020010521201331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105212026981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105212046558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105212114126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105212226960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105212233800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105212411931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200105212419126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="c:/Users/lin/Desktop/1.png">
<meta property="og:image" content="c:/Users/lin/Desktop/2.png">
<meta property="og:image" content="c:/Users/lin/Desktop/3.png">
<meta property="og:image" content="c:/Users/lin/Desktop/4.png">
<meta property="og:image" content="c:/Users/lin/Desktop/5.png">
<meta property="og:image" content="c:/Users/lin/Desktop/6.png">
<meta property="og:image" content="c:/Users/lin/Desktop/7.png">
<meta property="og:image" content="c:/Users/lin/Desktop/8.png">
<meta property="og:image" content="c:/Users/lin/Desktop/9.png">
<meta property="og:image" content="c:/Users/lin/Desktop/19.png">
<meta property="og:image" content="c:/Users/lin/Desktop/10.png">
<meta property="og:image" content="c:/Users/lin/Desktop/11.png">
<meta property="og:image" content="c:/Users/lin/Desktop/12.png">
<meta property="og:image" content="c:/Users/lin/Desktop/13.png">
<meta property="og:image" content="c:/Users/lin/Desktop/14.png">
<meta property="og:image" content="c:/Users/lin/Desktop/15.png">
<meta property="og:image" content="c:/Users/lin/Desktop/16.png">
<meta property="og:image" content="c:/Users/lin/Desktop/17.png">
<meta property="og:image" content="c:/Users/lin/Desktop/18.png">
<meta property="og:image" content="c:/Users/lin/Desktop/20.png">
<meta property="og:image" content="c:/Users/lin/Desktop/21.png">
<meta property="article:published_time" content="2020-01-06T01:28:11.277Z">
<meta property="article:modified_time" content="2022-01-22T04:37:43.486Z">
<meta property="article:author" content="Lin Tui">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200105211453932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">
  
  
  <title>《现代前端技术解析》阅读笔记 - Lin Tui</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lin-tui.github.io.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lin Tui</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="《现代前端技术解析》阅读笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-01-06 09:28" pubdate>
        2020年1月6日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      170 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《现代前端技术解析》阅读笔记</h1>
            
            <div class="markdown-body">
              <h1 id="《现代前端技术解析》阅读笔记"><a href="#《现代前端技术解析》阅读笔记" class="headerlink" title="《现代前端技术解析》阅读笔记"></a>《现代前端技术解析》阅读笔记</h1><h2 id="第一章-Web前端技术基础"><a href="#第一章-Web前端技术基础" class="headerlink" title="第一章  Web前端技术基础"></a>第一章  Web前端技术基础</h2><p><strong>思考一些问题：</strong> </p>
<ol>
<li><p>页面内容多而复杂，怎样保证开发效率？<br>需要借助符合特定场合的前端框架来提高效率。</p>
</li>
<li><p>页面内容多且复杂，项目管理和维护该如何去做？<br>考虑用模块化和组件化的思路管理，所谓模块化和组件化是指采用代码管理中分治的思想，将复杂的代码拆分成多个独立，简单，解耦合的结构或文件分开管理，使项目结构更加清晰。</p>
</li>
<li><p>页面加载内容很多，怎样保证尽快将网页内容显示给用户？<br>通过异步的方式来实现，即将一部分内容先展示给用户，然后根据用户的操作，异步加载用户需要的其他内容，避免用户长时间等待。</p>
</li>
<li><p>怎样限制页面内图片的大小以保证页面快速展示？<br>需要考虑图片的优化处理。</p>
</li>
<li><p>对于重复打开的页面，能否让浏览器不再向服务器重复请求的内容呢？<br>合理的文件缓存就能做到这一点，这样可以大幅度提高网页资源的加载速度。</p>
<p><strong>以上问题，涉及了前端开发框架，模块化和组件化开发，资源异步加载，响应式站点开发，缓存和前端优化等多个方面。</strong></p>
</li>
</ol>
<p><strong>前端应用开发模式演变：</strong></p>
<ol>
<li>静态黄页</li>
<li>服务器组装动态网页数据</li>
<li>后端为主的MVC</li>
<li>前后端分离</li>
<li>纯前端MV*为主，中间层直出</li>
<li>前端Virtual DOM，MNV*，前后端同构</li>
</ol>
<h3 id="1-2-浏览器应用基础"><a href="#1-2-浏览器应用基础" class="headerlink" title="1.2 浏览器应用基础"></a>1.2 浏览器应用基础</h3><h4 id="1-2-1-浏览器组成结构"><a href="#1-2-1-浏览器组成结构" class="headerlink" title="1.2.1 浏览器组成结构"></a>1.2.1 浏览器组成结构</h4><p><strong>1. 打开浏览器输入一个网址后：</strong></p>
<ol>
<li>在接收到用户输入的网址后， 浏览器会开启一个线程来处理这个请求，对用户输入的URL地址进行分析判断，如果是HTTP协议就按照HTTP方式来处理。</li>
<li>调用浏览器引擎中的对应方法，分析并加载这个URL地址。</li>
<li>通过DNS解析获取该网站地址对应的IP 地址，查询完成后连同浏览器的Cookis，userAgent等信息向网站目的IP发出GET请求。</li>
<li>进行 HTTP协议会话，浏览器客户端向Web服务器发送报文。</li>
<li>进入网站后台上的Web 服务器处理请求，如Apache Tomcat. Nodejs等服务器。</li>
<li>进入部署好的后端应用， 如PHP、Java， JavaScript， Python 等后端程序，找到对应请求处理逻辑，这期间可能会读取服务器级存或查询数据库等。</li>
<li>服务器处理请求并返回响应报文， 此时如果浏览器访问过该页面，缓存上有对应资源，会与服务器最后修改记录对比，一致则返回304,否则返回!200和对应的内容。</li>
<li>浏览器开始下载 HTML文档(响应报头状态码为200时) 或者从本地缓有更存读取文件 (浏览器缓存有效或响应报头状态码为304时)。  </li>
<li>浏览器根据下载接收到的HTML文件解析结构建立DOM 文档树，井根据HTML中的标记请求下载指定的MIME类型文件(如CSS、JavaScript 脚本等)，同时设置缓存等内容。</li>
<li>页面开始解析谊染 DOM, CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染，JavaScript 根据DOM API 操作DOM，并读取浏览器缓存、执行事件绑定等，页面整个展示过程完成。</li>
</ol>
<p><strong>2. 浏览器组成部分：</strong></p>
<ol>
<li>用户界面</li>
<li>网络</li>
<li>JavaScript引擎</li>
<li><strong>渲染引擎</strong></li>
<li>UI后端</li>
<li>JavaScript解释器</li>
<li>持久化数据存储</li>
</ol>
<h4 id="1-2-2-浏览器渲染引擎简介"><a href="#1-2-2-浏览器渲染引擎简介" class="headerlink" title="1.2.2 浏览器渲染引擎简介"></a>1.2.2 浏览器渲染引擎简介</h4><p>浏览器渲染引擎（浏览器内核）的主要用于解析HTML文档和CSS文档，然后将CSS规则运用到HTML标签元素上并将HTML渲染到浏览器窗口中以展示具体DOM内容。</p>
<p><strong>工作流程:</strong></p>
<ol>
<li>解析HTML构建DOM树</li>
<li>构建渲染树</li>
<li>渲染树布局阶段</li>
<li>绘制渲染树</li>
</ol>
<h4 id="1-2-3-浏览器数据持久化存储技术"><a href="#1-2-3-浏览器数据持久化存储技术" class="headerlink" title="1.2.3 浏览器数据持久化存储技术"></a>1.2.3 浏览器数据持久化存储技术</h4><p>这里所说的数据持久化存储主要是针对浏览器的，所以我们统称为浏览器缓存(Browser Caching)，浏览器缓存是浏览器端用于在本地保存数据并进行快速读取以避免重复资源请求的传输机制的统称。有效的缓存可以避免重复的网络资源请求并让浏览器快速地响应用户操作，提高页面内容的加载速度。</p>
<p>浏览器端缓存的实现机制种类较多，一般可以分为九种</p>
<ol>
<li><p><strong>HTTP文件缓存</strong>：</p>
<p> 是基于HTTP协议的浏览器文件缓存机制。在文件重复请求的情况下，浏览器可以根据HTTP响应的协议头判断是从服务器请求文件还是从本地读取文件。</p>
</li>
</ol>
<p>流程：<br><img src="https://img-blog.csdnimg.cn/20200105211453932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ol start="2">
<li><p><strong>localStorage</strong>：</p>
<p>是一种HTML5的一种本地缓存方案。主要用于浏览器端保存体积较大的数据（如Ajax返回结果等）。localStorage在不同浏览器的长度限制各不相同。将数据保存在客户端本地硬件设备上，即使浏览器被关闭，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p>
</li>
<li><p><strong>sessionStorage</strong>：</p>
<p>和localStorage功能类似，但是其将数据保存在session对象中，（所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭经过的这段时间。session对象可以用来保存这段时间内要求保存的任何数据）sessionStorage在浏览器关闭时会自动清空。</p>
</li>
<li><p><strong>Cookie</strong>：</p>
<p>指网站为了辨别用户身份或者Session跟踪而存储在用户浏览器端的数据。Cookie信息一般会通过HTTP发送到服务器端。Cookie分两种：Session Cookie 和持久型Cookie。</p>
</li>
<li><p><strong>WebSQL</strong>：</p>
<p>浏览器端用于存储大量数据的缓存机制。</p>
</li>
<li><p><strong>IndexDB</strong>：</p>
<p>也是一个可在客户端存储大量结构化数据并且这些数据上使用索引进行高性能检索的一套API。由于WebSQL不是HTML5规范，很多浏览器不兼容，一般推荐使用IndexDB进行大量数据存储。</p>
</li>
<li><p><strong>CacheStorage</strong></p>
</li>
<li><p><strong>Application Cache</strong></p>
</li>
<li><p><strong>Flash 缓存方式</strong></p>
</li>
</ol>
<h2 id="第二章-前端与协议"><a href="#第二章-前端与协议" class="headerlink" title="第二章 前端与协议"></a>第二章 前端与协议</h2><p> 浏览器上解析执行的HTML、CSS和JavaScript文件通常是通过网络请求从Web服务器上下载解析的，加载过程中，浏览器通过网络模块创建下载进程，发起HTTP请求，将HTML文本、CSS 样式或JavaScript脚本装载进浏览器解析或运行。这里就涉及了一些相关的网络协议，我们可以认为与前端关系最密切的协议是HTTP协议，因为几乎所有的前端相关资源文件均是通过HTTP协议请求完成的。前端Web应用的发展加速了前后端技术的分离，这种开发模式降低了前端与服务端的耦合，但是前端和服务端之间的交互数据通信仍是通过协议来完成的，这里的协议可以认为是前后端开发者之间主观协商形成的一层数据接口规范。当然，还有基于SSL (Secure Sockets Layer,安全套接字层)层的HTTPS协议。进入移动互联网时代后，移动端Web脚本开始需要与移动端原生程序进行交互，这便涉及与移动端Native原生程序交互的协议。除了这些还有HTML5的WebSocket实时通信协议、与服务端交互的RESTful协议等。</p>
<h3 id="2-1-HTTP协议简介"><a href="#2-1-HTTP协议简介" class="headerlink" title="2.1 HTTP协议简介"></a>2.1 HTTP协议简介</h3><h4 id="2-1-1-HTTP协议概述"><a href="#2-1-1-HTTP协议概述" class="headerlink" title="2.1.1 HTTP协议概述"></a>2.1.1 HTTP协议概述</h4><p>HTTP（超文本传输协议）协议是www服务器和用户请求代理之间通过请求模式传输超文本内容的一种协议。</p>
<p><strong>HTTP请求头部结构</strong>：<br><img src="https://img-blog.csdnimg.cn/20200105211646780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>HTTP协议响应头</strong>：<br><img src="https://img-blog.csdnimg.cn/2020010521170894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>HTTP报文的头部域字段的设置</strong>：<br><img src="https://img-blog.csdnimg.cn/20200105211927585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200105211942454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020010521201331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200105212026981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200105212046558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200105212114126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="2-2-Web安全机制"><a href="#2-2-Web安全机制" class="headerlink" title="2.2 Web安全机制"></a>2.2 Web安全机制</h3><h4 id="2-1-1-基础安全知识"><a href="#2-1-1-基础安全知识" class="headerlink" title="2.1.1 基础安全知识"></a>2.1.1 基础安全知识</h4><p>XSS（跨站脚本攻击），SQL（结构化查询语言）注入，CSRF（跨站请求伪造）均属于基础的前端安全知识。</p>
<p><strong>XSS</strong>：通常是由带有页面可解析内容的数据未经处理直接到页面上解析导致的。</p>
<p>需要注意，XSS分为 存储型XSS，反射性XSS，MXSS三种。这里区分不同类型主要是根据攻击脚本的引入位置。</p>
<p>存储型XSS的攻击脚本常常是由前端提交的数据未经处理直接存储到数据库中读取出来后有直接插入到页面所导致的。</p>
<p>反射型XSS可能是在网页URL参数中注入了课解析内容的数据导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击。</p>
<p>MXSS则是在渲染DOM属性时将脚本插入DOM属性中被解析而导致的。</p>
<p>XSS主要的防范方法是验证输入到页面上所有内容来源数据是否安全，如果可能含有脚本标签等内容则需要进行必要的转义。</p>
<p><strong>SQL</strong>：主要是因为页面提交数据到服务器端后，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因为产生执行与预期不同的现象。</p>
<p>SQL主要防范措施是对前端网页提交的数据内容进行严格的检查效验。</p>
<p><strong>CSRF</strong>：是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。非源站点在取得用户登录验证信息的情况下，可以直接对源站点的某个数据接口进行提交，如果源站点对该提交请求的数据来源未经验证，该请求可能被成功执行，这其实并不合理。</p>
<p>通常比较安全的是通过页面Token（令牌）提交验证的方式来验证请求是否为源站点页面提交的，来阻止伪请求的发生。</p>
<p>CSRL攻击原理图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105212226960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>CSRF预防机制：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105212233800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="2-2-2-请求劫持与HTTPS"><a href="#2-2-2-请求劫持与HTTPS" class="headerlink" title="2.2.2 请求劫持与HTTPS"></a>2.2.2 请求劫持与HTTPS</h4><p>除了正常的前后端脚本安全问题，网络请求劫持的发生也越来越频繁。网络劫持一般指网站资源请求在请求过程中因为人为的攻击导致没有加载到预期的资源内容。</p>
<p>网络劫持目前主要分两种：DNS劫持与HTTP劫持。</p>
<p><strong>DNS劫持</strong>：</p>
<p>通常是指攻击者劫持了DNS服务器，通过某些手段取得域名记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，其结果就是让正确的网址不能解析或指向另一个网站IP，实现获取用户资料或者破坏原有网站正常服务的目的。DNS劫持一般通过篡改DNS服务器上的域名解析记录，来返回给用户一个错误的DNS查询结果实现。</p>
<p>DNS劫持原理：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105212411931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>HTTP劫持</strong>：</p>
<p>HTTP劫持是指，在用户浏览器与访问的目的服务器之间所建立的网络数据通道中从网关或防火墙层上监视特定数据信息，当满足一定条件时，就会在正常的数据包中插入或修改成为攻击者设计的网络数据包，目的是让用户浏览器解释“错误”的数据，或者以弹出新窗口的形式在使用者浏览器界面上展示宣传栏广告或者直接显示其他内容。</p>
<p>HTTP劫持原理：<br><img src="https://img-blog.csdnimg.cn/20200105212419126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="2-2-3-HTTPS协议通信过程"><a href="#2-2-3-HTTPS协议通信过程" class="headerlink" title="2.2.3 HTTPS协议通信过程"></a>2.2.3 HTTPS协议通信过程</h4><p>HTTPS协议是通过加入SSL层来加密HTTP数据进行安全传输的HTTP协议。同时启用默认的443端口进行数据传输。</p>
<h3 id="2-3-前端实时协议"><a href="#2-3-前端实时协议" class="headerlink" title="2.3 前端实时协议"></a>2.3 前端实时协议</h3><p>前端浏览器进行实时通信的功能实现方式主要有WebSocket，Poll，Long-poll，DDP协议。</p>
<h3 id="2-4-RESTful数据协议规范"><a href="#2-4-RESTful数据协议规范" class="headerlink" title="2.4 RESTful数据协议规范"></a>2.4 RESTful数据协议规范</h3><p>REST并不是某一种数据交互调用接口的协议，而是定义了一种网络应用软件之间的架构关系，并提出了一套与之对应的网络之间交互调用的规则。</p>
<p>在REST形式的软件应用服务中。每个资源都有一个与之对应的URL地址，资源本身都有方法调用的目标。</p>
<p>RESTful是一种软件架构之间交互调用数据的协议风格规范，它建议以一种通用的方式定义和管理</p>
<h3 id="2-5-与Native交互协议"><a href="#2-5-与Native交互协议" class="headerlink" title="2.5 与Native交互协议"></a>2.5 与Native交互协议</h3><p>一般将移动端原生应用的开发称为移动端Native开发。</p>
<p>Hybrid App是在Native App应用的基础上结合了Web App应用所形成的模式，称为混合App。</p>
<h1 id="第三章-前端三层结构与应用"><a href="#第三章-前端三层结构与应用" class="headerlink" title="第三章  前端三层结构与应用"></a>第三章  前端三层结构与应用</h1><h3 id="3-1-HTML结构层基础"><a href="#3-1-HTML结构层基础" class="headerlink" title="3.1 HTML结构层基础"></a>3.1 HTML结构层基础</h3><p>前端三个基本构成：</p>
<p>结构层：HTML</p>
<p>表现层：CSS</p>
<p>行为层：JavaScript</p>
<h4 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1"></a>3.1.1</h4><p>虽然目前几乎所有浏览器均支持以HTML5的方式声明文档类型，即&lt;！DOCUTYPE html&gt;，但不代表HTML5的新标签元素就可以在这些浏览器上正常解析。这是因为DOCUTYPE声明只用于指示Web浏览器页面使用哪个HTML版本编写的指令进行解析。</p>
<h4 id="3-1-2-Web语义化标签"><a href="#3-1-2-Web语义化标签" class="headerlink" title="3.1.2 Web语义化标签"></a>3.1.2 Web语义化标签</h4><p>Web语义化：是指在HTML结构的恰当位置上使用语义恰当的标签，使页面具有良好的结构，使页面标签元素具有含义，能够让人或搜索引擎更容易理解。</p>
<p><strong>根据标签元素的display属性特点，可以将HTML标签分为以下几类</strong>：</p>
<ol>
<li>行内元素：<a>, <b>, <span>, <img>, <input>, <button>, <select>, <strong>等，其默认宽度是由内容宽度决定的。</li>
<li>块级元素：<div>, <ul>, <ol>, <li>, <dl>, <dt>, <dd>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <p>, <table>等，其默认宽度为父元素的100%。</li>
<li>常见空元素：<hr>, <br>, <link>, <meta>, <area>, <base>, <col>, <command>, <embed>, <keygen>, <param>, <source>, <track>等不能显示内容甚至不会在页面出现，但对页面的解析有着其他重要作用的元素。</li>
</ol>
<h4 id="3-1-3-HTML糟糕部分"><a href="#3-1-3-HTML糟糕部分" class="headerlink" title="3.1.3 HTML糟糕部分"></a>3.1.3 HTML糟糕部分</h4><h4 id="3-1-4-AMP-HTML"><a href="#3-1-4-AMP-HTML" class="headerlink" title="3.1.4 AMP HTML"></a>3.1.4 AMP HTML</h4><p>流动网页提速（AMP）是Google推行的一个提升页面资源载入效率的HTML提议规范。</p>
<p>基本思路有两点：使用严格受限的高效HTML标签以及使用静态网页缓存技术来提高网络访问静态资源的性能和用户体验。也就是，尽量避免使用目前网页上渲染或展示性能比较差的标签，并将部分网页静态内容缓存到页面上进行分发，例如内联体积较小的样式和图片，延时加载较大的静态资源文件，进而提高网页的初始加入速度。</p>
<p>使用AMP提升网页性能的基本原则：</p>
<ol>
<li>只允许异步的script脚本</li>
<li>只加载静态的资源</li>
<li>不能让内容阻塞</li>
<li>不在关键路径中加载第三方JavaScript</li>
<li>所有CSS必须内联</li>
<li>字体使用声明必须高效</li>
<li>最小化样式声明</li>
<li>只运行GPU加速的动画</li>
<li>处理好资源加载顺序问题</li>
<li>页面必须立即加载</li>
<li>提升AMP元素性能</li>
</ol>
<h3 id="3-4-JavaScript标准实践"><a href="#3-4-JavaScript标准实践" class="headerlink" title="3.4 JavaScript标准实践"></a>3.4 JavaScript标准实践</h3><h4 id="3-4-1-ECMAScript-5"><a href="#3-4-1-ECMAScript-5" class="headerlink" title="3.4.1 ECMAScript 5"></a>3.4.1 ECMAScript 5</h4><ol>
<li><p><strong>严格模式</strong>：为开发者提供了更加安全规范的编程范围，限制了原有一些不规范的写法，让一些不合理的语法直接报错，从而提高代码安全性和规范性。</p>
<p>严格模式的添加消除了JavaScript语法的一些不合理，不严谨之处，减少了一些怪异行为，可以在一定程度上提高编译器效率，加快运行速度，为未来新版本的JavaScript标准化做铺垫。</p>
</li>
</ol>
<h3 id="3-6-前端界面技术"><a href="#3-6-前端界面技术" class="headerlink" title="3.6 前端界面技术"></a>3.6 前端界面技术</h3><h4 id="3-6-1-CSS样式统一化"><a href="#3-6-1-CSS样式统一化" class="headerlink" title="3.6.1 CSS样式统一化"></a>3.6.1 CSS样式统一化</h4><p>由于浏览器间内核实现的差异性，不同浏览器可能对同一元素标签的默认设置是不同的，如果不对CSS样式进行统一化处理，可能会出现同一个网页在不同浏览器下打开时显示不同或样式不一致的问题。</p>
<p>处理这一问题，目前主要有三种实现思路：reset，normalize，neat。</p>
<p><strong>reset</strong>：</p>
<p>将不同浏览器中标签元素的默认样式全部清除，消除不同浏览器下默认样式的差异性。</p>
<p>典型的reset默认样式的代码如下：</p>
<p><img src="C:\Users\lin\Desktop\1.png" srcset="/img/loading.gif" lazyload></p>
<p>这种方法可以将不同浏览器上大多数标签的内外边距清除，但这个例子中的规则不能消除标签所有的差异性，只是针对消除内外边距。</p>
<p><strong>normalize</strong>：</p>
<p>它的做法是在整站样式基本确定的情况下对标签元素统一使用同一默认样式规则。</p>
<p>例如：</p>
<p><img src="C:\Users\lin\Desktop\2.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>neat</strong>：</p>
<p>是上面两种实现的综合。</p>
<p><img src="C:\Users\lin\Desktop\3.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-6-2-CSS预处理"><a href="#3-6-2-CSS预处理" class="headerlink" title="3.6.2 CSS预处理"></a>3.6.2 CSS预处理</h4><p>预处理工具：SASS，LESS，Stylus，postCSS等。</p>
<p>预处理工具的最终目的：通过编写更高效，易管理的类CSS脚本并将它们自动生成浏览器解释执行的CSS代码，现实高效开发和便捷管理。</p>
<h4 id="3-6-3-表现层动画实现"><a href="#3-6-3-表现层动画实现" class="headerlink" title="3.6.3 表现层动画实现"></a>3.6.3 表现层动画实现</h4><p>实现动画的方案主要有6种：</p>
<ol>
<li>JavaScript直接实现动画</li>
<li>可伸缩矢量图形（SVG）动画</li>
<li>CSS3 transition</li>
<li>CSS3 animation</li>
<li>Canvas动画</li>
<li>requestAnimationFrame</li>
</ol>
<h3 id="3-7-响应式网站开发技术"><a href="#3-7-响应式网站开发技术" class="headerlink" title="3.7 响应式网站开发技术"></a>3.7 响应式网站开发技术</h3><h4 id="3-7-1-响应式页面实现概述"><a href="#3-7-1-响应式页面实现概述" class="headerlink" title="3.7.1 响应式页面实现概述"></a>3.7.1 响应式页面实现概述</h4><p>​    通常认为，响应式设计是根据不同设备浏览器尺寸或分辨率来展示不同页面结构层，行为层，表现层的设计方式。</p>
<p>​    响应式设计网站，目前比较主流的实现方法有两种：一是通过前端或后端判断userAgent来跳转不同页面完成不同设备浏览器的适配，也就是维护两个不同的站点来根据用户设备进行对应的跳转；二是使用media query媒体查询等手段，让页面根据不同设备浏览器自动改变页面的布局和显示，但不做跳转。</p>
<p>​    <strong>第一种方案：</strong></p>
<p>典型响应式站点实现：</p>
<p><img src="C:\Users\lin\Desktop\4.png" srcset="/img/loading.gif" lazyload></p>
<p>这种情况存在一些问题：</p>
<ol>
<li>需要开发为维护至少两个站点跳转来适配不同用户的设备浏览器。</li>
<li>下载使用哪个站点内容由设备的userAgent信息来判断，无法根据屏幕尺寸或分辨率来决定。</li>
<li>多一次跳转。</li>
</ol>
<p>​    <strong>第二种方案：</strong> 桌面浏览器和移动端浏览器使用同一个站点域名来加载内容，只需要开发维护一个站点就可以，然后根据media query来实现不同屏幕下的布局显示，适用于访问量较小，性能要求不高的应用场景。</p>
<p> 存在的问题：</p>
<ol>
<li>移动端加载了与桌面端浏览器相同的资源，例如图片，脚本资源等，导致移动端加载了冗余或体积较大的资源。</li>
<li>桌面端浏览器和移动端浏览器访问站点需要展示的内容可能不完全相同，这种响应式的方式只实现了内容布局显示的适应，但要做到更多差异性的功能布局难。</li>
<li>桌面端和移动端浏览器页面功能具有差异性，使用一套处理方式，会有更多兼容性问题。</li>
</ol>
<p>​    <strong>总结两种方式的所有问题：</strong></p>
<ol>
<li>能否使用同一个站点域名避免跳转的问题</li>
<li>能否保证移动端加载的资源内容最优</li>
<li>如何做移动端和桌面端浏览器的差异化功能</li>
<li>如何根据更多的信息进行更加灵活的判断，而不仅仅是userAgent</li>
</ol>
<p>合理开发方式和网站访问架构设计是可以解决上述四个问题。下面看看在响应式的三层结构上具体能做什么处理。</p>
<h4 id="3-7-2-结构层响应式"><a href="#3-7-2-结构层响应式" class="headerlink" title="3.7.2 结构层响应式"></a>3.7.2 结构层响应式</h4><p>结构层响应设计可以理解成HTML内容的自适应渲染实现方式，即根据不同的设备浏览器渲染不同的页面内容结构，而不是直接进行页面跳转。</p>
<p>这里页面中结构层渲染的方式可能不同，包括前端渲染数据和后端渲染数据，这样主要就有两种不同的设计思路：一是页面内容在前端渲染，二是页面内容在后端渲染。</p>
<ol>
<li><strong>前端数据渲染响应式</strong></li>
</ol>
<p>根据不同平台浏览器的情况加载不同的异步静态JavaScript。然后异步渲染不同的模块内容，生成不同的表现层结构。</p>
<p>这种方式尽管可以让桌面端和移动端附庸一个页面并做页面的差异性，但是由于使用了应该HTML结构层为基础进行渲染和操作，因此页面的功能实现仍然有部分耦合的地方。</p>
<ol start="2">
<li><strong>后端数据渲染响应式</strong></li>
</ol>
<p>这种情况的处理方式其实可以做到更优化，只要尽可能将桌面端和移动端的业务层模板分开维护就可以。</p>
<ol start="3">
<li><strong>结构层媒体响应式</strong></li>
</ol>
<p>通过对不同开发模式中的渲染思路的分析，我们基础解决了结构层HTML响应式所面临的主要问题。</p>
<p>细节上，有一点需要强调：结构层媒体响应式的实现。根据统计，目前主要的网站60%以上的流量数据来自图片，所以如何在保证用户访问网站体验不降低的前提下尽可能地降低网站图片的输出流量具有很重要的意义。</p>
<p>这里提到的媒体主要是指图片，即我们需要在根据浏览器设备屏幕分辨率和屏幕宽度来加载不同大小和尺寸的图片，避免在移动端上加载体积过大的资源，下面来看看前端图片响应式的几种解决方案。</p>
<div class="code-wrapper"><pre><code class="hljs">    1. 使用Media Query背景图片代替
</code></pre></div>
<ol start="2">
<li><p>  <picture>  标签元素 （HTML5标签，大多浏览器可能不兼容）</p>
</li>
<li><p>模板判断响应式图片</p>
<p>在前端渲染数据的开发模式下，使用前端模板进行判断渲染输出不同的图片是最简单，最直接的响应式图片实现方式。</p>
</li>
<li><p>图片服务器判断输出内容</p>
</li>
</ol>
<h4 id="3-7-3-表现层响应式"><a href="#3-7-3-表现层响应式" class="headerlink" title="3.7.3 表现层响应式"></a>3.7.3 表现层响应式</h4><p>这里至少要了解两个方面的内容：响应式布局和屏幕适配布局</p>
<p><strong>响应式布局</strong>是根据浏览器宽度，分辨率，横屏，竖屏等情况来自动改变页面元素展示的一种布局，一般可以使用栅格方式来实现，实现思路有两种：一种是桌面端优先。扩展到移动端浏览器适配，另一种则是以移动端浏览器优先，扩展到桌面端浏览器适配，由于移动端的网络和计算资源较少，所以一般比较推荐从移动端扩展到桌面端的方式进行适配，这样避免了在移动端加载冗余的桌面端CSS样式。</p>
<p><strong>屏幕适配布局</strong>则是主要针对移动端的，由于目前移动端屏幕大小各部相同，屏幕适配布局是为了实现网页内容根据移动端设备屏幕大小等比例缩放所提出的一种布局计算方式。</p>
<p>​    首先为了固定浏览器对HTML文件的渲染，会在HTML的<head> 里面加上下面一段<meta> 声明来控制页面使用移动端浏览器展示并保持内容不缩放。</p>
<div class="code-wrapper"><pre><code class="hljs">&lt;meta name=&#39;viewport&#39; content=&#39;width=device-width,initial-scale=1,maximum-scale=1,user-calable=no&#39;/&gt;
</code></pre></div>
<h4 id="3-7-4-行为层响应式"><a href="#3-7-4-行为层响应式" class="headerlink" title="3.7.4 行为层响应式"></a>3.7.4 行为层响应式</h4><p>在页面响应式设计中。行为层脚本也是需要根据浏览器来执行不同逻辑的。</p>
<p>行为层的响应式分为：JavaScript内容在前端引入和在后端引入这两种情况。</p>
<h1 id="第四章-现代前端交互框架"><a href="#第四章-现代前端交互框架" class="headerlink" title="第四章 现代前端交互框架"></a>第四章 现代前端交互框架</h1><p>（需要进行理解，再完善笔记）</p>
<p>​    数据的处理和操作的核心就是DOM的处理和操作，即便是今天，所有前端JavaScript框架最终要解决的仍然是如何实现高效，高性能DOM交互操作的问题。</p>
<p>​    DOM API类型分为以下几种类型：节点查询型，节点创建型，节点修改型，节点关系型，节点属性型和内容加载型。</p>
<p>​    JQuery主要实现了选择器，DOM操作方法，事件绑定封装，AJAX，Deferred这五个方面的封装和常见的兼容性问题的处理，我们还可以基于jQuery扩展更多的方法功能来提高业务开发效率。</p>
<p>​    SPA的思路是将整个应用的内容都在一个页面中实现并完全通过异步交互来根据用户操作加载不同的内容。</p>
<p>​    通过DOM交互框架已经可以比较高效地处理DOM操作和事件绑定等问题。这种高效的方式带来了效率上的提升，但随着页面结构和交互复杂性的提升，仅靠这种方式会增加管理的难度。随着AJAX技术的盛行，SPA应用开始被广泛使用，而直接操作DOM的方式进行SPA的开发和维护是比较麻烦的。为解决这个问题，通常将页面上与DOM相关的内容抽象成数据模型，视图，事件控制函数三部分，这就有了前端MVC设计思路。</p>
<p>​    <strong>MVC</strong>可以认为是一种开发设计模式，其基本思路是将DOM交互的内容分为数据模型，视图和事件控制函数三个部分，并对他们进行统一管理。Model用来存放数据结果和数据对象，View用于页面DOM的更新与修改，Controller则用于根据前端路由条件来调用不同的Model给View渲染不同的数据内容。</p>
<p>​    前端框架从直接的DOM操作到MVC设计模式，然后到MVP，再到MVVM框架，前端设计模式改进原则一直向着高效，易实现，易维护，易扩展的基本方向发展。虽然目前前端各类框架也已经成熟并开始向高版本迭代。但是还没有结束，我们现在的编程对象依然没有脱离DOM编程的基本套路，一次次框架的改进大大提高了开发效率，但是DOM元素运行的效率仍然没有变。</p>
<h3 id="4-3-Virtual-DOM-交互模式"><a href="#4-3-Virtual-DOM-交互模式" class="headerlink" title="4.3 Virtual DOM 交互模式"></a>4.3 Virtual DOM 交互模式</h3><h4 id="4-3-1-Virtual-DOM-设计理念"><a href="#4-3-1-Virtual-DOM-设计理念" class="headerlink" title="4.3.1 Virtual DOM 设计理念"></a>4.3.1 Virtual DOM 设计理念</h4><p>​    MVVM的前端交互模式大大提高了编程效率，自动双向数据绑定让我们可以将页面逻辑实现的核心转移到数据层的修改操作上，而不再是在页面中直接操作DOM。但实际上，尽管MVVM改变了前端开发的逻辑方式，但是最终数据层反应到页面上View层的渲染和改变仍是通过对应的指令进行DOM操作来完成的。而且通常一次ViewModel的变化可能会触发页面上多个指令操作DOM的变化，带来大量的页面结构层DOM操作来渲染。</p>
<p>​    <strong>Virtual DOM是一个能够直接描述一段HTML DOM结构的JavaScript对象，浏览器可以根据它的结构按照一定规则创建出确定唯一的HTML DOM结构。</strong></p>
<p>​    整体来看，Virtual DOM的交互模式减少了MVVM或其他框架中对DOM的扫描和操作次数，并且在数据发生改变后只在合适的地方根据JavaScript对象来进行最小化的页面DOM操作，避免大量重新渲染。</p>
<h4 id="4-3-2-Virtual-DOM的核心实现"><a href="#4-3-2-Virtual-DOM的核心实现" class="headerlink" title="4.3.2 Virtual DOM的核心实现"></a>4.3.2 Virtual DOM的核心实现</h4><p>​    Virtual DOM模式来控制页面DOM结构更新的过程：创建原始页面或组件的Virtual DOM结构，用户操作后需要进行DOM更新时，生成用户操作后页面或组件的Virtual DOM结构并与之前的结构进行比对，找到最小变化Virtual DOM的差异化描述对象，最后把差异化的Virtual DOM根据特定的规则渲染到页面上。</p>
<p>​    所以<strong>核心操作</strong>可以抽象成三个步骤：</p>
<div class="code-wrapper"><pre><code class="hljs">    1. 创建Virtual DOM
      2. 对比两个Virtual DOM生成差异化Virtual DOM
        3. 将差异化Virtual DOM渲染到页面上
</code></pre></div>
<p>其中 ： </p>
<p>​    创建Virtual DOM：创建Virtual DOM即把一段HTML字符串文本解析成一个能够描述它的JavaScript对象。</p>
<p>根据HTML字符串解析创建Virtual DOM的过程相当于实现一个HTML文本解析器，但是没有生成DOM对象树，只是生成一个操作效率更高的JavaScript对象，因此通常不会直接将HTML交给浏览器去解析，因为浏览器的DOM解析很慢，这也是Virtual DOM交互模式和普通DOM编程最本质的区别。</p>
<p>​    当用户进行了页面操作需要进行页面视图改变时，通常会生成一个新的Virtual DOM结构来表示改变后的状态，而且不会将这个改变后的Virtual DOM内容立即重新渲染到页面中，而是通过对比找出两个Virtual DOM的差异性，得到一个差异树对象。对于Virtual DOM的对比算法实际上是对于多叉树结构的遍历算法。对多叉树遍历就有广度优先算法和深度优先算法。</p>
<p>​    经过Virtual DOM的差异性对比，我们获得了用户操作后的差异性Virtual DOM，差异性类型和差异性的位置，那么剩下的操作就是根据对比返回的结构将差异化内容经过DOM操作渲染到页面上，整个交互过程就完成了。</p>
<p>​    </p>
<p><strong>Virtual DOM交互模式的优势</strong> 与以前交互模式相比，Virtual DOM最本质的区别在于减少了对DOM对象的操作，通过JavaScript 对象来代替DOM对象树，并且在页面结构改变进行最小代价的DOM渲染操作，提高了交互的性能和效率。这也是提高前端交互性能的根本原因。</p>
<h3 id="4-4-前端MNV-时代"><a href="#4-4-前端MNV-时代" class="headerlink" title="4.4 前端MNV*时代"></a>4.4 前端MNV*时代</h3><p>尽管Virtual DOM的交互模式能在页面数据的渲染和变更时尽可能地减少DOM操作，但仍无法完成脱离DOM交互的模式，我们知道DOM的操作效率不高，在移动设备的Hybrid WebView上表现会更慢，所以为了进一步改进Hybrid应用中DOM性能，希望完全脱离DOM的编程模式来进行结构层的操作。</p>
<p>为什么可以这样子实现：首先，目前，主要主流Hybrid App的Web内容通常是在原生应用中嵌入WebView来实现的，而原生应用的界面数据渲染可以通过调用原生控件来实现，它不仅没有HTML DOM的性能缺陷，而且还可以调用Native系统底层的API；其次，Hybrid App可以通过统一的JavaScript交互协议来调用原生的方法和控件，所以使用JavaScript直接调用和产生原生控件进行界面数据渲染的方式是可以实现的。</p>
<h4 id="4-4-1-MNV-模式简介"><a href="#4-4-1-MNV-模式简介" class="headerlink" title="4.4.1 MNV*模式简介"></a>4.4.1 MNV*模式简介</h4><p>我们把这种使用JavaScript调用原生控件或事件绑定生成应用程序的交互模式称为前端MNV*开发模式。这种模式目前仅使用于移动端Hybrid应用，因为需要依赖原生控件的调用支持，而只有这种特殊的应用场景才满足条件。</p>
<h4 id="4-4-2-MNV-模式的实现原理"><a href="#4-4-2-MNV-模式的实现原理" class="headerlink" title="4.4.2 MNV* 模式的实现原理"></a>4.4.2 MNV* 模式的实现原理</h4><p>主要是将JSBridge和DOM编程的方式进行结合，让前端能够快速构建开发原生界面的应用，从而脱离DOM的交互模式。</p>
<h1 id="第五章-前端项目与技术实践"><a href="#第五章-前端项目与技术实践" class="headerlink" title="第五章 前端项目与技术实践"></a>第五章 前端项目与技术实践</h1><p>现代前端技术飞速发展，最终形成了以效率和质量为核心的两大趋势。</p>
<h3 id="5-1-前端开发规范"><a href="#5-1-前端开发规范" class="headerlink" title="5.1 前端开发规范"></a>5.1 前端开发规范</h3><p>开发规范可以认为软件开发工程师之间的另一种语言，它在一定程度上决定了团队协作过程中开发的程序代码是否具有一致性和易维护性，统一的开发规范可以降低代码的出错率和团队开发的协作成本。</p>
<h4 id="5-1-1-前端通用规范"><a href="#5-1-1-前端通用规范" class="headerlink" title="5.1.1 前端通用规范"></a>5.1.1 前端通用规范</h4><ol>
<li><p>三层结构分离</p>
<p>前端页面开发应做到结构层（HTML），表现层（CSS），行为层（JavaScript）分离，保证它们之间的最小耦合，这对前端开发和后期维护都是至关重要。推荐相关样式和JavaScript逻辑在外部引入的CSS和JavaScript文件中。</p>
</li>
<li><p>缩进</p>
<p>统一使用tab（或4个进行缩进）来进行缩进，可以在开发编辑器或IDE里进行设置。</p>
</li>
<li><p>内容编码</p>
<p>在HTML文档中使用<meta charset='utf-8'>来指定编码，一避免出现页面乱码问题。</p>
</li>
<li><p>小写</p>
<p>所有的HTML标签，HTML标签属性，样式名及规则建议使用小写，我们一般习惯使用小写英文字符。</p>
<p>HTML属性的id属性可以使用驼峰大小写组合的命名方式，因为id属性常常只用于JavaScript的DOM查询引用，而JavaScript语言标准推荐使用驼峰大小写组合的命名方式，因此HTML页面上的id属性也尽量使用这种标准来写。</p>
</li>
<li><p>代码单行长度限制</p>
<p>代码单行长度不要超过120字符（或80字符，根据团队习惯决定），长字符串并接通常使用加号来连接换行的内容</p>
</li>
<li><p>注释</p>
<p>尽可能为代码写上注释，HTML，CSS 还是JavaScript，必要的注释是不能少的。</p>
</li>
<li><p>行尾空格与符号</p>
<p>删除行尾空格与多余的符号，这些内容是没有必要存在的。</p>
</li>
</ol>
<h4 id="5-1-2-前端HTML规范"><a href="#5-1-2-前端HTML规范" class="headerlink" title="5.1.2 前端HTML规范"></a>5.1.2 前端HTML规范</h4><ol>
<li><p>文档类型定义</p>
<p>统一使用HTML5 的标准文档类型&lt;! DOCTYPE html&gt;来定义，这样更简洁，而且向后兼容。不使用HTML4.01的DTD定义。</p>
</li>
<li><p>head内容</p>
<p>head中必须定义title，keyword，description，保证基本的SEO页面关键字和内容描述。移动端页面head要添加viewport控制页面缩放，有利于提高页面渲染性能。</p>
</li>
<li><p>省略type属性</p>
<p>在引用CSS或JavaScript时，可以省略type属性不写，因为HTML5在引入CSS时默认type值为text/css，在引入JavaScript时默认type为text/javaScritp</p>
</li>
<li><p>使用双引号包裹属性值</p>
<p>所有的标签属性值必须要用双引号包裹，不推荐单引号，不允许有的双引号，有的单引号。</p>
</li>
<li><p>属性值省略</p>
<p>非必要的属性值可以省略，例如输入框里的readonly，disabled，required等属性值是非必要的，可以省略不写。如<input type="text" disabled></p>
</li>
<li><p>嵌套</p>
<p>所有元素必须正确嵌套，尽量使用语义化标签，不允许交叉，也不允许在inline元素中包含block元素。</p>
</li>
<li><p>标签闭合</p>
<p>非自闭合标签必须添加标识，自闭合标签无须关闭。</p>
</li>
<li><p>使用img的alt属性</p>
<p>为img加上alt属性</p>
</li>
<li><p>使用lable的for属性</p>
<p>为表单内部元素<lable>加上for属性或者将对应的控件放在<lable>标签内部。这样在点击<lable>标签时，会关联到对应的input或textarea上选中，可以增加输入的响应区域。</p>
<p><img src="C:\Users\lin\Desktop\5.png" srcset="/img/loading.gif" lazyload></p>
<ol start="10">
<li><p>按模块添加注释</p>
<p>在每个大的模块的开始和结束的地方添加起始注释标记，便于开发者识别，维护。</p>
</li>
<li><p>标签元素格式</p>
<p>块级元素一般另起一行写，行内元素可以根据情况换行，尽量保证行内元素代码长度不超过一行，否则要考虑另起一行。HTML的子元素要尽量相对父级进行缩进，这样更有层次。</p>
<p><img src="C:\Users\lin\Desktop\6.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>语义化标签</p>
<p>在合适的地方选择合适的标签。不要使用被HTML废弃用于样式表现的无语义标签。</p>
</li>
</ol>
<h4 id="5-1-3-前端CSS规范"><a href="#5-1-3-前端CSS规范" class="headerlink" title="5.1.3 前端CSS规范"></a>5.1.3 前端CSS规范</h4><ol>
<li><p>CSS引用规范</p>
<p>使用link的方式调用外部样式文件，外部样式文件可以复用并能用浏览器缓存提高加载速度。禁止在标签内使用内联样式，否则后期很不容易管理，强烈不建议使用。</p>
</li>
<li><p>样式的命名</p>
<p>CSS类名命名一般由单词，中画线，当然也有BEM方案，这里推荐一种规范—–所有命名都使用小写，加上ui-等前缀，表示这个类名只用于控制元素的样式展示，不推荐使用拼音作为样式名，尤其是使用缩写的拼音和英文混合的方式，很让人费解。尽量不以info，current，news等单个单词类名直接作为类名称，单独一级命名很容易造成冲突覆盖，并且很难理解。</p>
</li>
<li><p>CSS高效实现规范</p>
<p>标签名，与id或class组合的选择器会造成冗余，而且降低CSS的解析速度，应避免。</p>
</li>
<li><p>使用预处理脚本编码开发</p>
<p>使用预处理嵌套的方式描述元素之间的层次关系，尽可能使用预处理器的高效语法来提高开发效率，如嵌套，变量，嵌套属性，注释，继承等，避免直接使用CSS开发。使用SASS来编写CSS就高效很多。</p>
</li>
<li><p>简写方式</p>
<p>单位0的缩写。如果属性值为0，则不需要为0加单位，如果以0为个数为的小数，前面的0可以省略不写。尽量带上分号。如  opacity：.6</p>
<p>去掉url中引用资源的引号，这是没必要的。如background-image:url(sprites.png)</p>
<p>颜色值写法，所有的颜色值要使用小写并尽量缩写至3位 如#FF0000  可写成#f00</p>
</li>
<li><p>属性书写顺序</p>
<p>CSS属性书写顺序遵循先布局后内容，即先写元素的布局属性，再写元素的内容属性。常用布局属性有：position, display, float, overflow等</p>
</li>
<li><p>hack写法</p>
<p>尽可能减少对CSS hack的使用和依赖，可以使用其他的解决方案替代hack思路。如果必须要使用浏览器hack，尽量选择稳定，常用并易于理解的书写方式。</p>
</li>
</ol>
<h4 id="5-1-4-ECMAScript5-常用规范"><a href="#5-1-4-ECMAScript5-常用规范" class="headerlink" title="5.1.4 ECMAScript5 常用规范"></a>5.1.4 ECMAScript5 常用规范</h4><ol>
<li><p>分号</p>
<p>JavaScript语句后面统一加上分号</p>
</li>
<li><p>空格</p>
<p>在所有运算符，符号与英文单词之间添加必要的空格，利于开发者阅读。</p>
</li>
<li><p>空行</p>
<p>一般推荐在代码块后面保留一行空行，显得块内容层次更加分明</p>
</li>
<li><p>引号</p>
<p>推荐JavaScript字符串最外层统一使用单引号</p>
<p><img src="C:\Users\lin\Desktop\7.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>变量命名</p>
<p>标准变量采用驼峰式命名。常量使用全大写形式命名，并采用下画线连接。构造函数首字母大写，jQuery对象推荐以”$”为开头命名，便于分辨JQuery对象和普通对象。</p>
</li>
<li><p>对象</p>
<p>对象属性名不需要加引号。对象属性键值以缩进的形式书写，不要写在同一行。数组，对象属性后不能有逗号，否则部分浏览器可能会解析出错。</p>
<p><img src="C:\Users\lin\Desktop\8.png" srcset="/img/loading.gif" lazyload></p>
<ol start="7">
<li><p>大括号</p>
<p>程序中的代码块推荐使用大括号包裹，要注意换行，这样更加清晰，而且方便后面扩展增加内容。</p>
</li>
<li><p>条件判断</p>
<p>尽量不要直接使用undefined进行变量判断，使用typeof和字符串“undefined”对变量类型进行判断。分别用===，！==代替==，！=更加严谨</p>
</li>
<li><p>不要在条件语句或循环语句中声明函数</p>
</li>
</ol>
<h4 id="5-1-5-ECMAScript-6-参考规范"><a href="#5-1-5-ECMAScript-6-参考规范" class="headerlink" title="5.1.5 ECMAScript 6+ 参考规范"></a>5.1.5 ECMAScript 6+ 参考规范</h4><ol>
<li><p>正确使用ECMAScript 6 的变量声明关键字</p>
</li>
<li><p>字符串拼接使用字符串模板完成</p>
<p><img src="C:\Users\lin\Desktop\9.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>解析赋值尽量使用一层结构，否则声明变量嵌套太深难以理解</p>
</li>
<li><p>数组拷贝推荐使用…实现，更加简洁高效</p>
<p><img src="C:\Users\lin\Desktop\19.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>数组循环遍历使用for…of非必须情况下不推荐使用forEach，map，简单循环</p>
<p><img src="C:\Users\lin\Desktop\10.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>使用ECMAScript6 的类来代替之前的实现方式，尽量使用constructor进行属性成员变量赋值</p>
<p><img src="C:\Users\lin\Desktop\11.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="C:\Users\lin\Desktop\12.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>模块化多变量导出时尽量使用对象解构，不使用全局导出。尽量不要把import和export写在一行</p>
<p><img src="C:\Users\lin\Desktop\13.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>导出类名时，保持模块名称和文件名相同，类名首字母需要大写</p>
<p><img src="C:\Users\lin\Desktop\14.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>生成器中yield进行异步操作时需要使用try…catch包裹，方便对异常进行处理。</p>
<p><img src="C:\Users\lin\Desktop\15.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>推荐使用promise，避免使用第三方库或直接回调，原生的异步处理性能更好而且符合语言规范。</p>
<p><img src="C:\Users\lin\Desktop\16.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>如果不是必须，避免使用迭代器</p>
</li>
<li><p>不要使用统一码，中文的正则匹配和计算较消耗时间，而且容易出问题</p>
</li>
<li><p>合理使用Generator，推荐使用ascyn/await，更加简洁</p>
</li>
</ol>
<h4 id="5-1-6-前端防御性编程规范"><a href="#5-1-6-前端防御性编程规范" class="headerlink" title="5.1.6 前端防御性编程规范"></a>5.1.6 前端防御性编程规范</h4><p>防御性编程是指通过检测任何可能存在的逻辑异常问题的代码实现，提高脚本执行过程的健壮性的一种编程手段。防御性编程要求我们对程序的实现进行更加全面，严谨的考虑。</p>
<ol>
<li><p>对外部数据的安全检测判断</p>
</li>
<li><p>规范化的错误处理</p>
<p>对于常用的AJAX请求或长时间文件读写等可能失败的异步操作，需要进行错误情况的处理或异常捕获处理，而不应该被静默，否则一旦出错，用户得不到正常的提示，对用户体验影响极大。</p>
<p><img src="C:\Users\lin\Desktop\17.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="C:\Users\lin\Desktop\18.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<h3 id="5-2-前端组件规范"><a href="#5-2-前端组件规范" class="headerlink" title="5.2 前端组件规范"></a>5.2 前端组件规范</h3><p>​    什么是组件规范?</p>
<p>​    为什么需要组件规范?</p>
<p>​    组件规范和开发规范有什么区别和联系呢?</p>
<p>​    组件通常是指采用代码管理中的分治思想，将复杂的项目代码结构拆分成多个独立、简单、解耦合的结构或文件的形式进行分开管理，达到让项目代码和模块更加清晰的目的。</p>
<p>​    组件规范则是我们进行拆分、组织、管理项目代码方法的一种约定。</p>
<p>​    所以，和开发规范相似，组件规范也是一种约定。不同的是，开发规范关注文件内部代码级别的一致性， 组件规范则更关注项目中业务功能模块内容组织的一致性。 一定程度上，组件规范包含了开发规范，因为若开发规范不统一，开发出来的组件风格便不一致，组件规范便也无从说起了。组件规范能够帮助我们对功能模块进行统一的约定管理， 通过这一约定， 任何一个独立的功能模块之间都应该是无耦合并能和其他模块很好对接和组合的。</p>
<p>​    目前前端主流的一些组件相关规范: UI (User Interface， 用户界面)组件规范、模块化规范、项目组件化设计规范。注意这三者的区别和联系，UI规范一般指UI层设计和实现的规范及统一性， 而模块化主要指的是JavaScript 模块化开发的文件模块封装方式，项目组件规范则指的是实际开发中整个项目业务代码之间的组织形式。</p>
<h4 id="5-2-1-UI组件规范"><a href="#5-2-1-UI组件规范" class="headerlink" title="5.2.1 UI组件规范"></a>5.2.1 UI组件规范</h4><p>简单来说，UI 组件规范强调了一个网站中所有网页结构层和表现层实现的一致性。 多个地方出现的相同按钮样式可以通过公共定义的样式规范类来描述，而不用每个地方都重复书写样式，避免使用不同的代码实现同一个效果。试想如果没有规范的存在，相同作用的按钮有时是红色，有时是绿色，开发维护时就比较难统一处理了。 从Web前端的角度来看，UI层的规范能带来一些明显的好处。</p>
<ol>
<li>UI层风格统一化。UI层风格统一化避免了不同页面的差异化设计风格，能让用户使<br>用Web站点的不同网页外观风格是一致的。</li>
<li>增加UI层复用性。使用UI规范的情况下，UI层代码复用性增强，可以提高开发效率，<br>相同功能的结构和样式不用重复实现。</li>
<li>更符合用户的体验习惯。例如红色按钮统一 用来表示警告，绿色按钮统一 表示安全或<br>成功操作等。</li>
<li>增加了 开发规范的统一-性。 遵循统一的规范， 避免重复开发，避免产生多种风格的代码。</li>
</ol>
<p>在实际团队开发中，UI组件规范的完成可能需要以下几个方面的协作：</p>
<ol>
<li><p>UI设计一致</p>
</li>
<li><p>，开发实现一致。这就涉及开始说的编码开发规范，尽可能让所有UI层实现使用同样的开发规范和方式。例如样式定义，图片引用，命名规范等，就图片引用来说，图标使用base64实现还是使用小图片实现，又或者使用iconfont实现，都需要统一，不能多种方法混合，否则增加UI组件的使用复杂度。</p>
<p>从开发实现上，如果想设计一个具有通用组件规范的UI库，必须考虑以下几个方面的问题。</p>
<ol>
<li>统一的页面布局方案。页面布局使用网格布局还是REM方案，是否需要支持响应式，<br>如果是移动端应该怎样适配，这些是需要优先考虑的。</li>
<li>基础UI结构和样式实现。样式reset、 按钮、图片、菜单、表单等基础结构与样式的统一化设计实现，可以极大提高页面内容的复用性和开发效率。</li>
<li>组件化UI结构和样式实现。例如按钮组、字体图标、下拉菜单、输入框组、导航组、面包屑、分页、标签、轮播、弹出框、列表、多媒体、警告框等常用组件的实现。当然网站可能不会一次性用到这么 多，但是如果要考虑设计一个通用的UI组件库，这些仍然是要考虑的。</li>
<li>响应式布局。如果需要支持页面响应式，布局、结构、样式、媒体、javascript响应式。</li>
</ol>
</li>
</ol>
<h4 id="5-2-2-模块化规范"><a href="#5-2-2-模块化规范" class="headerlink" title="5.2.2 模块化规范"></a>5.2.2 模块化规范</h4><p>模块化规范是JavaScript文件之间相互依赖引用的一种通用语法约定，就是按照一定的规范来写JavaScript文件，让它可以方便地被其他JavaScript文件引用。</p>
<p>就规范种类来说，主要包括AMD（异步模块定义），CMD（通用模块定义），CommonJS，import/export等。</p>
<ol>
<li><p>AMD</p>
<p>AMD是运行在浏览器端的模块异步加载规范，主要以requireJS为代表。基本原理是定义define和require方法异步请求对应的JavaScript模块文件到浏览器端运行。模块执行导出时可以使用函数中的return返回结果。</p>
</li>
<li><p>CMD</p>
<p>CMD是seajs提出的一种模块化规范，在浏览器端调用类似CommonJs的书写方式进行模块引用，但却不是完全的CommonJs规范，CMD遵循按需执行依赖的原则，只有在用到某个模块的时候才会执行模块内部的require语句，同时加载完某个依赖模块文件后并不会立即执行，在所有依赖模块加载完成后进入主模块逻辑，遇到模块运行语句的时候才执行对应的模块，这和AMD是有区别的。</p>
</li>
<li><p>CommonJs</p>
<p>CommonJs是Node端使用的JavaScript模块化规范，使用require进行模块引入，并使用modules.exports来定义模块导出。与前面两种方法来比，它的写法更加清晰简洁。</p>
</li>
<li><p>import/export</p>
<p>import/export是ECMAScript6定义的JavaScript模块引用方式，是唯一一个遵循JavaScript语言标准的模块化规范，使用import引入其他模块，export来进行模块导出。</p>
</li>
</ol>
<h4 id="5-2-3-项目组件化设计规范"><a href="#5-2-3-项目组件化设计规范" class="headerlink" title="5.2.3 项目组件化设计规范"></a>5.2.3 项目组件化设计规范</h4><p>目前组件化的方案已经越来越多，Web Component组件化，MVVM框架组件化，基于Virtual DOM框架组件化，直接基于目录管理的组件化等</p>
<p>高效组件化规范应该解决哪些问题：</p>
<ol>
<li>组件之间独立、松耦合。组件之间的HTML、JavaScript、 CSS之间相互独立，尽量不重复，相同部分通过父级或基础组件来实现，最大限度减少重复代码</li>
<li>组件间嵌套使用。组件可以嵌套使用，但嵌套后仍然是独立、松耦合的。</li>
<li>组件间通信。主要指组件之间的函数调用或通信，例如A组件完成某个操作后希望B组件执行某个行为，这种情况就可以使用监听或观察者模式在B组件中注册该行为的事件监听或加入观察者，然后选择合适的时机在A组件中触发这个事件监听或通知观察者来触发B组件中的行为操作，而不是在A组件中直接拿到B组件的引用并直接进行操作，因为这样组件之间的行为就会产生耦合。</li>
<li>组件公用部分设计。组件的公用部分应该被抽离出来形成基础库，用来增加代码的复用性。</li>
<li>组件的构建打包。构建工具能够自动解析和打包组件内容。</li>
<li>异步组件的加载模式。在移动端，通常考虑到页面首屏，异步的场景应用非常广泛，所有异步组件不能和同步组件一起处理。这时可以将异步组件区别于普通组件的目录存放，并在打包构建时进行异步打包处理。</li>
<li>组件继承与复用性。对于类似的组件要做到基础组件复用来减少重复编码。</li>
<li>私有组件的统一管理。为了提高协作效率，可以通过搭建私有源的方式来统- - 管理组件库，例如使用包管理工具等。但这点即使在大的团队里面也很难实施，因为业务组件的实现常常需要定制化而且经常变更，这样维护组件库成本反而更大，目前可以做的是将公用的组件模块使用私有源管理起来。</li>
<li>根据特定场景进行扩展或自定义。如果当前的组件框架不能满足需求，我们应该能够很便捷地拓展新的框架和样式，这样就能适应更多的场景需求。比如在通过目录管理组件的方案下，既可以使用MVVM框架进行开发，也可以使用Virtual DOM框架进行开发，但要保持基本的规范结构不变。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-3-自动化构建"><a href="#5-3-自动化构建" class="headerlink" title="5.3 自动化构建"></a>5.3 自动化构建</h3><h4 id="5-3-1-自动化构建的目的"><a href="#5-3-1-自动化构建的目的" class="headerlink" title="5.3.1 自动化构建的目的"></a>5.3.1 自动化构建的目的</h4><p>前端构建工具的作用可以认为是对源项目文件或资源进行文件级处理，将文件或资源处理成需要的最佳输出结构和形式。在处理过程中，我们可以对文件进行模块化引入、依赖分析，资源合并、压缩优化、文件嵌入、路径替换、生成资源包等多种操作，这样就能完成很多原本需要手动完成的事情，极大地提高开发效率。</p>
<h4 id="5-3-2-自动化构建的原理"><a href="#5-3-2-自动化构建的原理" class="headerlink" title="5.3.2 自动化构建的原理"></a>5.3.2 自动化构建的原理</h4><p>构建的流程主要分为7个基本步骤（不同构建工具各有差异，但基本原理是类似的）：</p>
<p>读取入口文件  -&gt;    分析模块引用  -&gt;   按照引用加载模块   -&gt;   模块文件编译处理    -&gt;    模块文件合并  -&gt;   文件优化处理  -&gt;    写入生成目录</p>
<p><img src="C:\Users\lin\Desktop\20.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-4-前端性能优化"><a href="#5-4-前端性能优化" class="headerlink" title="5.4 前端性能优化"></a>5.4 前端性能优化</h3><p>​    前端优化的最终目的都是 提升用户体验，改善页面性能。</p>
<p>​    前端性能可以认为是用户获取所需要页面数据或执行某个页面动作的一个实时性指标，一般以用户希望获取的数据操作到用户实际获得数据的时间间隔来衡量。</p>
<p>​    例如用户希望获得数据的操作时打开某个页面，那么这个操作的前端性能就可以用用户操作开始到屏幕展示页面内容给用户的这段时间间隔来评判。</p>
<p>​    用户的等待延时可以分为两部分：可控等待延时和不可控等待延时。可控等待延时可以理解为能通过技术手段和优化来改进缩短的部分，例如减少图片大小让请求加载更快，减少HTTP请求数等。不可控等待延时则是不能或很难通过前后端技术手段来改进优化的，例如CPU计算时间延时，ISP网络传输延时等。</p>
<p>​    前端中，所有优化大师针对可控等待延时这部分来进行的。</p>
<h4 id="5-4-1-前端性能测试"><a href="#5-4-1-前端性能测试" class="headerlink" title="5.4.1 前端性能测试"></a>5.4.1 前端性能测试</h4><p>获取和衡量一个页面的性能，主要可以通过以下几个方面：Performance Timing API，Profile工具，页面埋点计时，资源加载时序图分析。</p>
<h4 id="5-4-2-桌面浏览器前端优化策略"><a href="#5-4-2-桌面浏览器前端优化策略" class="headerlink" title="5.4.2 桌面浏览器前端优化策略"></a>5.4.2 桌面浏览器前端优化策略</h4><p><strong>网络加载类</strong></p>
<ol>
<li>减少HTTP资源请求次数</li>
</ol>
<p> 在前端页面中，通常建议尽可能合并静态资源图片、JavaScript 或CSS代码，减少页面请求数和资源请求消耗，这样可以缩短页面首次访问的用户等待时间。通过构建工具合并雪碧图、CSS、JavaScript 文件等都是为了减少HTTP资源请求次数。另外也要尽量避免重复的资源，防止增加多余请求。</p>
<ol start="2">
<li><p>减小HTTP请求大小.<br>除了减少HTTP资源请求次数，也要尽量减小每个HTTP请求的大小。如减少没必要的图片、JavaScript、 CSS及HTML代码，对文件进行压缩优化，或者使用gzip压缩传输内容等都可以用来减小文件大小，缩短网络传输等待时延。前面我们使用构建工具来压缩静态图片资源以及移除代码中的注释并压缩，目 的都是为了减小HTTP请求的大小。</p>
</li>
<li><p>将CSS或JavaScript放到外部文件中，避免使用<style>或<script>标签直接引入</p>
</li>
<li><p>避免页面中空的href和src</p>
</li>
<li><p>为HTML指定Cache-Control或Expires</p>
<p>为HTML内容设置Cache-Control或Expires可以将HTML内容缓存起来，避免频繁向服务器端发送请求。前面讲到，在页面Cache-Control或Expires 头部有效时，浏览器将直接从缓存中读取内容，不向服务器端发送请求。</p>
<meta http-equiv="Cache-Control" content= "max-age=7200" / >
<meta http-equiv="Expires" content="Mon， 20 Jul 2016 23:00:00 GMT" /></li>
<li><p>合理设置Etag和Last-Modified</p>
<p>合理设置Etag和Last-Modified使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器端返回304，让浏览器从缓存中读取文件，减少Web资源下载的带宽消耗并降低服务器负载。</p>
<meta http-equiv="last -modified" content="Mon, 03 Oct 2016 17:45:57 GMT"/></li>
<li><p>减少页面重定向</p>
<p>页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要600毫秒的时间开销，为了保证用户尽快看到页面内容，要尽量避免页面重定向。</p>
</li>
<li><p>使用静态资源分域存放来增加下载并行数</p>
<p>浏览器在同一时刻向同一个域名请求文件的并行下载数是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数,缩短页面资源加载的时间。通常根据多个域名来分别存储JavaScript、CSS和图片文件。</p>
</li>
<li><p>使用静态资源CDN来存储文件</p>
</li>
<li><p>使用CDN Combo下载传输内容</p>
</li>
<li><p>使用可缓存的AJAX</p>
</li>
<li><p>使用GET来完成AJAX请求</p>
<p>使用XMLHttpRequest时,浏览器中的POST方法发送请求首先发送文件头,然后发送HTTP正文数据。而使用GET时只发送头部，所以在拉取服务端数据时使用GET请求效率更高。</p>
</li>
<li><p>减少Cookie的大小并进行Cookie隔离</p>
<p>HTTP请求通常默认带上浏览器端的Cookie一起发送给服务器，所以在非必要的情况下，要尽量减少Cookie来减小HTTP请求的大小。对于静态资源，尽量使用不同的域名来存放，因为Cookie默认是不能跨域的，这样就做到了不同域名下静态资源请求的Cookie隔离。</p>
</li>
<li><p>缩小favicon.ico并缓存</p>
</li>
<li><p>推荐使用异步JavaScript资源</p>
<p>异步的JavaScript 资源不会阻塞文档解析，所以允许在浏览器中优先渲染页面，延后加载脚本执行。例如JavaScript的引用可以如下设置，也可以使用模块化加载机制来实现。</p>
<script src="main. js" defer></script><script src="main.js" async></script></li>
<li><p>消除阻塞渲染的CSS及JavaScript</p>
<p>对于页面中加载时间过长的CSS或JavaScript文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成。</p>
</li>
<li><p>避免使用CSS import引用加载CSS</p>
<p>CSS中的@import可以从另一个样式文件中引入样式，但应该避免这种用法，因为这样会增加CSS资源加载的关键路径长度，带有@import的CSS样式需要在CSS文件串行解析到@import时才会加载另外的CSS文件，大大延后CSS渲染完成的时间。</p>
</li>
</ol>
<p><strong>页面渲染类</strong></p>
<ol>
<li><p>把CSS资源引用放在HTML文件顶部</p>
<p>一般推荐将所有CSS资源尽早指定在HTML文档<head>中，这样浏览器可以优先下载CSS并尽早完成页面渲染。</p>
</li>
<li><p>JavaScript资源引用放到HTML文件底部</p>
<p>JavaScript资源放到HTML文档底部可以防止JavaScript的加载和解析执行对页面渲染造成阻塞。由于JavaScript资源默认是解析阻塞的，除非被标记为异步或者通过其他的异步方式加载，否则会阻塞HTMLDOM解析和CSS渲染的过程。</p>
</li>
<li><p>不要在HTML中直接缩放图片</p>
</li>
<li><p>减少DOM元素数量和深度</p>
<p>HTML中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持DOM元素简洁和层级较少。</p>
</li>
<li><p>尽量避免使用<table>、<iframe>等慢元素</p>
<table>内容的渲染是将table的DOM渲染树全部生成完并--次性绘制到页面上的，所以在长表格渲染时很耗性能，应该尽量避免使用它，可以考虑使用列表元素<u1>代替。尽量使用异步的方式动态添加iframe,因为iframe内资源的下载进程会阻塞父页面静态资源的下载与CSS及HTML DOM的解析。</li>
<li><p>避免运行耗时的JavaScript</p>
<p>长时间运行的JavaScript会阻塞浏览器构建DOM树、DOM渲染树、渲染页面。所以，任何与页面初次渲染无关的逻辑功能都应该延迟加载执行，这和JavaScript资源的异步加载思路是一致的。</p>
</li>
<li><p>避免使用CSS表达式或CSS滤镜</p>
</li>
</ol>
<h3 id="5-6-前端搜索引擎优化基础"><a href="#5-6-前端搜索引擎优化基础" class="headerlink" title="5.6 前端搜索引擎优化基础"></a>5.6 前端搜索引擎优化基础</h3><p>搜索引擎优化简称SEO</p>
<h4 id="5-6-1-title-keywords-description的优化"><a href="#5-6-1-title-keywords-description的优化" class="headerlink" title="5.6.1 title, keywords, description的优化"></a>5.6.1 title, keywords, description的优化</h4><p>  title、keywords、 description 是可以在HTML的<meta>标签内定义的，有助于搜索引擎抓取到网页的内容。要注意的是，一般title的权重是最高的，也是最重要的，因此我们应该好好利用title来提高页面的权重。keywords相对权重较低，可以作为页面的辅助关键词搜索。description的描述一般会直接显示在搜索结果的介绍中，可以使用户快速了解页面内容的描述文字，所以要尽量让这段文字能够描述整个页面的内容，增加用户进入页面的概率。</p>
<ol>
<li><p>title的优化</p>
<p> 一般title的设置要尽量能够概括页面的内容，可以使用多个title关键字组合的形式，并用分隔符连接起来。分隔符一般有“_”, “-”, “ ”, “，”等，其中 “_” 分隔符比较容易被百度搜索引擎检索到，“-”分隔符则容易被谷歌搜索引擎检索到，“,”则在英文站点中使用比较多，可以使用空格。title 的长度在桌面浏览器端一般建 议控制在30个字以内，在移动端控制在20个字以内，若长度超出时浏览器会默认截断并显示省略号。</p>
<p> 关于title格式的优化设置可以遵循以下规则:</p>
<div class="code-wrapper"><pre><code class="hljs">   1. 每个网页都应该有独一无二的标题，切忌所有的页面都使用同样的默认标题
 2. 标题主题明确， 应该包含网页中最重要的信息
 3. 简明精练， 不应该罗列与网页内容不相关的信息
 4. 用户浏览通常从左到右的， 建议将重要的内容放到title靠前的位置
 5. 使用用户所熟知的语言描述，如果有中、英文两种网站名称，尽量使用用户熟知的语 言作为标题描述
</code></pre></div>
<p>对于网站不同页面title的定义可以设置如下:</p>
<div class="code-wrapper"><pre><code class="hljs">1. 首页:网站名称_提供服务介绍或产品介绍
 2. 列表页: 列表名称_网站名称
 3. 文章页:文章标题_文章分类_网站名称
</code></pre></div>
</li>
</ol>
<p><img src="C:\Users\lin\Desktop\21.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="5-6-2-语义化标签的优化"><a href="#5-6-2-语义化标签的优化" class="headerlink" title="5.6.2 语义化标签的优化"></a>5.6.2 语义化标签的优化</h4><ol>
<li>使用具有语义化的HTML5标签结构</li>
<li>唯一的H1标题</li>
<li><img>添加alt属性</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/">前端技术知识归纳</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/01/17/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E9%9B%B6%E7%A2%8E%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">零碎前端基础知识笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/01/05/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">前端相关概念笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
