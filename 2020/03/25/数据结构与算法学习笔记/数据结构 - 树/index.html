

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#252d38">
  <meta name="author" content="Lin Tui">
  <meta name="keywords" content="">
  
    <meta name="description" content="树（1）相关概念兄弟节点：节点的父节点是同一个节点，所以它们之间互称为兄弟节点。 根节点：没有父节点的节点叫作根节点 叶子节点：没有子节点的节点叫作叶子节点或者叶节点。 节点的高度：节点到叶子节点的最长路径（边数）。 节点的深度：根节点到这个节点所经历的边的个数。 节点的层数：节点的深度 + 1. 树的高度：根节点的高度。  记这几个概念，还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构 - 树">
<meta property="og:url" content="https://lin-tui.github.io.com/2020/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%A0%91/index.html">
<meta property="og:site_name" content="Lin Tui">
<meta property="og:description" content="树（1）相关概念兄弟节点：节点的父节点是同一个节点，所以它们之间互称为兄弟节点。 根节点：没有父节点的节点叫作根节点 叶子节点：没有子节点的节点叫作叶子节点或者叶节点。 节点的高度：节点到叶子节点的最长路径（边数）。 节点的深度：根节点到这个节点所经历的边的个数。 节点的层数：节点的深度 + 1. 树的高度：根节点的高度。  记这几个概念，还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585227146916.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585228609837.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585228784320.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585229479175.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585229609566.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585229773296.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585232103561.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585231319498.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585231510341.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585232443213.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585232936669.png">
<meta property="og:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585233813271.png">
<meta property="article:published_time" content="2020-03-25T13:31:24.981Z">
<meta property="article:modified_time" content="2022-01-22T04:40:15.130Z">
<meta property="article:author" content="Lin Tui">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:/Users/lin/AppData/Roaming/Typora/typora-user-images/1585227146916.png">
  
  
  <title>数据结构 - 树 - Lin Tui</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lin-tui.github.io.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lin Tui</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构 - 树">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-03-25 21:31" pubdate>
        2020年3月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      52 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构 - 树</h1>
            
            <div class="markdown-body">
              <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="（1）相关概念"><a href="#（1）相关概念" class="headerlink" title="（1）相关概念"></a>（1）相关概念</h3><p><strong>兄弟节点</strong>：节点的父节点是同一个节点，所以它们之间互称为兄弟节点。</p>
<p><strong>根节点</strong>：没有父节点的节点叫作根节点</p>
<p><strong>叶子节点</strong>：没有子节点的节点叫作叶子节点或者叶节点。</p>
<p><strong>节点的高度</strong>：节点到叶子节点的最长路径（边数）。</p>
<p><strong>节点的深度</strong>：根节点到这个节点所经历的边的个数。</p>
<p><strong>节点的层数</strong>：节点的深度 + 1.</p>
<p><strong>树的高度</strong>：根节点的高度。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585227146916.png" srcset="/img/loading.gif" lazyload alt="1585227146916"></p>
<p>记这几个概念，还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在生活中的含义。</p>
<p>在生活中，“高度”这个概念，其实就是从下往上度量，比如要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。</p>
<p>“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。</p>
<p>“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。</p>
<h3 id="（2）二叉树（Binary-Tree）"><a href="#（2）二叉树（Binary-Tree）" class="headerlink" title="（2）二叉树（Binary Tree）"></a>（2）二叉树（Binary Tree）</h3><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585228609837.png" srcset="/img/loading.gif" lazyload alt="1585228609837"></p>
<p>编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong>。</p>
<p>编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong>。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585228784320.png" srcset="/img/loading.gif" lazyload alt="1585228784320"></p>
<p>存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>
<h5 id="1-链式存储法"><a href="#1-链式存储法" class="headerlink" title="1. 链式存储法"></a>1. 链式存储法</h5><p>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。</p>
<p>只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585229479175.png" srcset="/img/loading.gif" lazyload alt="1585229479175"></p>
<h5 id="2-顺序存储法"><a href="#2-顺序存储法" class="headerlink" title="2. 顺序存储法"></a>2. 顺序存储法</h5><p>把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</p>
<p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585229609566.png" srcset="/img/loading.gif" lazyload alt="1585229609566"></p>
<p>不过，上面的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585229773296.png" srcset="/img/loading.gif" lazyload alt="1585229773296"></p>
<p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p>
<h5 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3. 二叉树的遍历"></a>3. 二叉树的遍历</h5><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585232103561.png" srcset="/img/loading.gif" lazyload alt="1585232103561"></p>
<p>经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。</p>
<ul>
<li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">preOrderTraverse</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> preOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;<br>            callback(node.key)<br>            preOrderTraverseNode(node.left, callback)<br>            preOrderTraverseNode(node.right, callback)<br>        &#125;<br>    &#125;<br>    preOrderTraverseNode(<span class="hljs-built_in">this</span>.root, callback)<br>&#125;<br>tree.inOrderTraverse(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(value) &#125;)<br></code></pre></td></tr></table></figure></li>
<li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">inOrderTraverse</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> inOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;<br>            inOrderTraverseNode(node.left, callback)<br>            callback(node.key)<br>            inOrderTraverseNode(node.right, callback)<br>        &#125;<br>    &#125;<br>    inOrderTraverseNode(<span class="hljs-built_in">this</span>.root, callback)<br>&#125;<br>tree.inOrderTraverse(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(value) &#125;)<br></code></pre></td></tr></table></figure></li>
<li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">postOrderTraverse</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> postOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;<br>            postOrderTraverseNode(node.left, callback)<br>            postOrderTraverseNode(node.right, callback)<br>            callback(node.key)<br>        &#125;<br>    &#125;<br>    postOrderTraverseNode(<span class="hljs-built_in">this</span>.root, callback)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p>
<p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)。</p>
<h3 id="（3）二叉查找树（Binary-Search-Tree）"><a href="#（3）二叉查找树（Binary-Search-Tree）" class="headerlink" title="（3）二叉查找树（Binary Search Tree）"></a>（3）二叉查找树（Binary Search Tree）</h3><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。</p>
<p>顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？这些都依赖于二叉查找树的特殊结构。</p>
<p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong> </p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585231319498.png" srcset="/img/loading.gif" lazyload alt="1585231319498"></p>
<h5 id="1-二叉查找树的查找操作"><a href="#1-二叉查找树的查找操作" class="headerlink" title="1. 二叉查找树的查找操作"></a>1. 二叉查找树的查找操作</h5><p>先取根节点，如果它等于我们要查找的数据，那就返回。</p>
<p>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</p>
<p>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585231510341.png" srcset="/img/loading.gif" lazyload alt="1585231510341"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">search</span>(<span class="hljs-params">key</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> searchNode = <span class="hljs-function">(<span class="hljs-params">node, key</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">if</span> (node.key === key) <span class="hljs-keyword">return</span> node<br>        <span class="hljs-keyword">return</span> searchNode((key &lt; node.key) ? node.left : node.right, key)<br>    &#125;<br>    <span class="hljs-keyword">return</span> searchNode(root, key)<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-二叉查找树的插入操作"><a href="#2-二叉查找树的插入操作" class="headerlink" title="2. 二叉查找树的插入操作"></a>2. 二叉查找树的插入操作</h5><p>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585232443213.png" srcset="/img/loading.gif" lazyload alt="1585232443213"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key<br>        <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span><br>        <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> Node(key)<br>        <span class="hljs-keyword">const</span> insertNode = <span class="hljs-function">(<span class="hljs-params">node, newNode</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (newNode.key &lt; node.key) &#123;<br>                <span class="hljs-keyword">if</span> (node.left === <span class="hljs-literal">null</span>) &#123;<br>                    node.left = newNode<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    insertNode(node.left, newNode)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (node.right === <span class="hljs-literal">null</span>) &#123;<br>                    node.right = newNode<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    insertNode(node.right, newNode)<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.root) &#123;<br>            <span class="hljs-built_in">this</span>.root = newNode<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            insertNode(<span class="hljs-built_in">this</span>.root, newNode)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> tree = <span class="hljs-keyword">new</span> BinarySearchTree()<br>tree.insert(<span class="hljs-number">11</span>)<br>tree.insert(<span class="hljs-number">7</span>)<br>tree.insert(<span class="hljs-number">5</span>)<br>tree.insert(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<h5 id="3-二叉查找树的删除操作"><a href="#3-二叉查找树的删除操作" class="headerlink" title="3. 二叉查找树的删除操作"></a>3. 二叉查找树的删除操作</h5><p>删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p>
<ul>
<li><p>第一种情况是，如果要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。</p>
</li>
<li><p>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</p>
</li>
<li><p>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</p>
</li>
</ul>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585232936669.png" srcset="/img/loading.gif" lazyload alt="1585232936669"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteNode</span>(<span class="hljs-params">root, key</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!root)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;删除失败&quot;</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (root.value &gt; key)&#123;  <span class="hljs-comment">//若当前结点值大于删除值，则继续在左子树中寻找删除值</span><br>        root.left = deleteNode(root.left, key);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.value &lt; key)&#123;  <span class="hljs-comment">//若当前结点值小于删除值，则继续在右子树中寻找删除值</span><br>        root.right = deleteNode(root.right, key);<br>    &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//找到与删除中相等的结点</span><br>        <span class="hljs-keyword">if</span> (root.left === <span class="hljs-literal">null</span> &amp; root.right === <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">//叶子结点</span><br>            root = <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left === <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">//只有右子树</span><br>            root = root.right;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right === <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">//只有左子树</span><br>            root = root.left;<br>        &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//同时具有左右子树</span><br>            <span class="hljs-keyword">let</span> prevNode = root.left;<br>            <span class="hljs-keyword">while</span>(prevNode.right)&#123;  <span class="hljs-comment">//寻找不大于当前结点值的最大结点值</span><br>                prevNode = prevNode.right;<br>            &#125;<br>            root.value = prevNode.value;  <span class="hljs-comment">//替换值</span><br>            root.left = deleteNode(root.left, prevNode.value);  <span class="hljs-comment">//递归左子树，删除重复值的结点</span><br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="4-搜索最小值和最大值"><a href="#4-搜索最小值和最大值" class="headerlink" title="4. 搜索最小值和最大值"></a>4. 搜索最小值和最大值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">min</span>(<span class="hljs-params">node</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> minNode = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> node ? (node.left ? minNode(node.left) : node) : <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> minNode(node || <span class="hljs-built_in">this</span>.root)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">max</span>(<span class="hljs-params">node</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> maxNode = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> node ? (node.right ? maxNode(node.right) : node) : <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> maxNode(node || <span class="hljs-built_in">this</span>.root)<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="5-时间复杂度分析"><a href="#5-时间复杂度分析" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h5><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。</p>
<p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585233813271.png" srcset="/img/loading.gif" lazyload alt="1585233813271"></p>
<p>图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。这是一种最糟糕的情况。</p>
<p>最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。不管操作是插入、删除还是查找，**时间复杂度其实都跟树的高度成正比，也就是 O(height)**。</p>
<h3 id="（4）相对散列表，二叉树的优势"><a href="#（4）相对散列表，二叉树的优势" class="headerlink" title="（4）相对散列表，二叉树的优势"></a>（4）相对散列表，二叉树的优势</h3><ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li>
<li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
<li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li>
</ul>
<p><strong>学习于：</strong></p>
<p>极客时间《数据结构与算法之美》</p>
<p><a target="_blank" rel="noopener" href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构与算法学习</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">数据结构与算法学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%95%A3%E5%88%97/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构 - 散列</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/03/25/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/">
                        <span class="hidden-mobile">《数据结构与算法之美》学习笔记(4) 二分查找及其变形问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
