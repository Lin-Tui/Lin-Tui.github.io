<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>page</title>
    <link href="/2022/01/31/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E6%B5%85%E8%B0%88%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <url>/2022/01/31/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E6%B5%85%E8%B0%88%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一-微前端是什么"><a href="#一-微前端是什么" class="headerlink" title="一. 微前端是什么"></a><strong>一.</strong> <strong>微前端是什么</strong></h1><p>微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立运行、独立部署。<strong>微前端不是单纯的前端框架或者工具，而是一套架构体系。</strong></p><h1 id="二-微前端产生的背景"><a href="#二-微前端产生的背景" class="headerlink" title="二. 微前端产生的背景"></a><strong>二.</strong> <strong>微前端产生的背景</strong></h1><p>在提倡拥抱变化的前端社区可以看到新的框架、技术、概念层出不穷，并且随着WEB标准的演进，前端应用已经具备更好的性能、更快的开发效率。但随着而来的是应用的复杂程度更高、涉及的团队规模更广、更高的性能要求，应用复杂度已经成为阻塞业务发展的重要瓶颈。如何让现有系统拥抱最新技术提高生产力、并且解耦单体应用，是现在前端工程不得不面临的挑战。</p><p>微前端就是诞生于 Web 应用日益复杂化的场景中，尽管 Web 应用的复杂度和参与人数以爆炸式的增长速度，但却没有一种新的架构模式来解决现有的困境，并同时兼顾 DX（developer experience）和 UX（user experience）。</p><p>以字节跳动内「研发中台」举例，在研发日常工作中需要使用非常多的研发系统，例如：代码管理、代码构建、域名管理、应用发布、CDN 资源管理、对象存储等。站在整个公司研发的角度考虑，最好的产品形态就是将所有的研发系统都放置同一个产品内，用户是无法感知他在使用不同的产品，对于用户而言就是单个产品不存割裂感。由于整个系统涉及范围很广，在实际的研发过程中必然会以功能或业务需求垂直的切分成更小的子系统，由不同的团队进行开发维护 。</p><p><strong>以传统的前端研发模式开发大规模且涉及多研发团队的web应用时，有两种项目设计策略：</strong></p><h2 id="1-策略1"><a href="#1-策略1" class="headerlink" title="1. 策略1"></a><strong>1. 策略1</strong></h2><p>将平台内多个系统放置同一个代码仓库维护 ，采用 SPA（Single-page Application） 单页应用模式</p><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li><p> 统一的权限管控、统一的 Open API 开发能力 </p></li><li><p> 更好的代码复用，基础库复用 </p></li><li><p> 统一的运营管理能力 </p></li><li><p> 不同系统可以很好的通信 </p></li><li><p> SPA 应用特有优势： </p></li><li><ul><li>更好的性能</li><li>具备局部更新，无缝的用户体验</li></ul></li><li><ul><li>提前预加载用户下一页的内容</li></ul></li></ul><h3 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h3><ul><li><p> 代码权限管控问题 </p></li><li><p> 项目构建时间长 </p></li><li><p> 需求发布相互阻塞 </p></li><li><p> 代码 commit 混乱、分支混乱 </p></li><li><p> 技术体系要求统一 </p></li><li><p> 无法同时灰度多条产品功能 </p></li><li><p> 代码回滚相互影响 </p></li><li><p> 错误监控无法细粒度拆分 </p></li></ul><p>采用该方案的劣势非常明显，在日常开发中研发：代码构建半小时以上、发布需求时被需求阻塞、无法局部灰度局部升级、项目遇到问题时回滚影响其他业务、无法快速引进新的技术体系提高生产力，各应用技术栈之间是强耦合的，项目的迭代和维护对于研发同学而言无疑是噩梦。</p><p>尽管降低了开发体验，如果对项目整体的代码拆分，懒加载控制得当，其实对于使用平台的用户而言体验却是提升的，这一切都归因于 SPA 应用带来的优势，SPA 应用跳转页面时无需刷新整个页面，路由变化时仅更新局部，不用让用户产生在 MPA 应用切换时整个页面刷新带来的抖动感而降低体验，并且由于页面不刷新的特性可以极大程度的复用页面间的资源，降低切换页面时带来的性能损耗，用户也不会感知他在使用不同平台。</p><h2 id="2-策略2"><a href="#2-策略2" class="headerlink" title="2. 策略2"></a><strong>2. 策略2</strong></h2><p>将系统分为多个仓库维护，在首页聚合所有平台的入口，采用 MPA（Multi-page Application）多页应用模式</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p> 可以以项目维度拆分代码，解决权限管控问题 </p></li><li><p> 仅构建本项目代码，构建速度快 </p></li><li><p> 可以使用不同的技术体系 </p></li><li><p> 不存在同一个仓库维护时的 commit 混乱和分支混乱等问题 </p></li><li><p> 功能灰度互不影响 </p></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li><p> 用户在使用时体验割裂，会在不同平台间跳转，无法达到 SPA 应用带来的用户体验 </p></li><li><p> 只能以页面维度拆分，无法拆分至区块部分，只能以业务为维度划分 </p></li><li><p> 多系统同灰度策略困难 </p></li><li><p> 公共包基础库重复加载 </p></li><li><p> 不同系统间不可以直接通信 </p></li><li><p> 公共部分只能每个系统独立实现，同一运维通知困难 </p></li><li><p> 产品权限无法进行统一收敛 </p></li></ul><p>采用该方案的优点在于部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性，在一定程度上提升了开发体验，但缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点，降低了用户体验。</p><h2 id="3-背景和意义总结"><a href="#3-背景和意义总结" class="headerlink" title="3. 背景和意义总结"></a><strong>3. 背景和意义总结</strong></h2><p>通过以上场景案例，其实可以发现由于 Web 应用在逐步取代传统的 PC 软件时，传统 Web 应用的研发模式：SPA、MPA 在涉及团队成员广和项目复杂度高的场景下，无法同时保证 DX 和 UX 的困境。因此衍生出了微前端这样一种新的架构模式，与后端微服务相同，它同样是延续了分而治之的设计模式，不过却以全新的方法来实现，能够同时具备 SPA 和 MPA 两种架构优势，即保证应用具备独立开发权的同时，又有将它们整合到一起保证产品完整的流程体验的能力，提升 DX和 UX。</p><h1 id="三-微前端解决的问题"><a href="#三-微前端解决的问题" class="headerlink" title="三. 微前端解决的问题"></a><strong>三.</strong> <strong>微前端解决的问题</strong></h1><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，在研发、维护、升级、变迁时因耦合而造成的维护性降低的问题，在超大型前端应用中尤为明显。</p><h1 id="四-微前端的核心理念"><a href="#四-微前端的核心理念" class="headerlink" title="四. 微前端的核心理念"></a><strong>四.</strong> <strong>微前端的核心理念</strong></h1><p>微前端架构具备以下几个核心价值：</p><ul><li><p> 技术栈无关。主框架不限制接入应用的技术栈，微应用具备完全自主权。不再与单一技术栈捆绑在一起，有助于新技术、新交互模式的实验性试错。（这是由于在被基座应用加载前， 所有子应用已经编译成原生代码输出，所以基座应用可以加载各类技术栈编写的应用。） </p></li><li><p> 独立开发、独立部署。微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新。 </p></li><li><p> 增量升级。在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略，能够低风险局部替换，渐进地完成大规模重构。 </p></li><li><p> 独立运行时。每个微应用之间状态隔离，运行时状态不共享。 </p></li><li><p> 中心化路由。主应用统一注册子应用，统一管理各个子应用的路由。 </p></li><li><p> 一致的开发体验。 开发者在微前端下开发子应用，和平时开发其它 Web 应用没有太大区别，没有因为是微前端架构而做过多的特殊处理； </p></li></ul><p>微前端并不是单单技术上的创新，它在团队协同、用户体验上都给我们带来非常大的提升，它借鉴了微服务的概念，在技术架构上它能够做到各个系统模块的拆分，既能让模块之间低耦合，又能让所有的模块聚合到同一个页面上运行。</p><h1 id="五-微前端的几种实现方案"><a href="#五-微前端的几种实现方案" class="headerlink" title="五. 微前端的几种实现方案"></a><strong>五.</strong> <strong>微前端的几种实现方案</strong></h1><p>单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：</p><table><thead><tr><th><strong>方案</strong></th><th><strong>描述</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>路由分发式</td><td>通过HTTP服务器反向代理来实现(Nginx)将不同路径映射到不同应用，又或者是应用框架自带的路由来解决。例如<a href="http://www.abc.com/app1">www.abc.com/app1</a>对应app1，<a href="http://www.abc.com/app2">www.abc.com/app2</a>对应app2。</td><td>简单，快速，易配置</td><td>在切换应用时会触发浏览器刷新，重新加载了资源，影响体验</td></tr><tr><td>iframe嵌套</td><td>父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式</td><td>实现简单，子应用之间自带沙箱，天然隔离，互不影响</td><td>ifame的样式显示、兼容性都具有局限性</td></tr><tr><td>Web Components</td><td>每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式</td><td>每个子应用拥有独立的script和css，也可以单独部署</td><td>对历史系统改造成本高，子应用通信较为复杂易踩坑</td></tr><tr><td>组合式应用路由分发</td><td>每个子应用独立构建和部署，运行时由父应用来进行路由管理、应用加载，启动，卸载，以及通信机制</td><td>纯前端改造，体验良好，可无感知切换，子应用相互隔离</td><td>需要设计和开发，由于父子应用处于同一页面，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点</td></tr></tbody></table><p>上述方案中，每种都有自己的优劣。</p><p>路由分发式这种方式看上去更像是多个前端应用的聚合，只是将不同的前端应用拼凑到一起，使他们看起来像是一个完整的整体。但是实际并不是，每次用户从 A 应用到 B 应用的时候，往往需要刷新页面，重新加载资源文件。</p><p>而iframe嵌套是最简单和最快速的方案，从浏览器原生的方案来说，iframe 不从体验角度上来看几乎是最可靠的微前端方案了，主应用通过iframe 来加载子应用，iframe 自带的样式、环境隔离机制使得它具备天然的沙盒机制，但也是由于它的隔离性导致其并不适合作为加载子应用的加载器，iframe 的特性不仅会导致用户体验的下降，也会在研发在日常工作中造成较多困扰。</p><p>以下总结了 iframe 作为子应用的一些劣势：</p><ul><li><p> 性能消耗大，使用Iframe 会大幅增加内存和计算资源。因为每一个 iframe 都可以看成是一个小的浏览器窗口，iframe 内所承载的页面需要一个全新并且完整的文档环境，应用每次进入相当于打开多个窗口。一般会比单页应用更慢。 </p></li><li><p> Iframe 与上层应用并非同一个文档上下文导致 </p></li><li><ul><li>事件冒泡不穿透到主文档树上，焦点在子应用时，事件无法传递上一个文档流 </li></ul></li><li><ul><li><ul><li>主应用劫持快捷键操作</li><li>事件无法冒泡顶层，针对整个应用统一处理时效</li></ul></li></ul></li><li><ul><li>URL 状态的问题，跳转路径无法与上层文档同步，刷新丢失路由状态、后退前进按钮无法使用。</li><li>Iframe 内元素会被限制在文档树中，视窗宽高限制问题</li></ul></li><li><ul><li>Iframe 登录态无法共享，子应用需要重新登录</li><li>Iframe 在禁用三方 cookie 时，iframe 平台服务不可用</li></ul></li><li><ul><li>Iframe 应用加载失败，内容发生错误主应用无法感知</li><li>难以计算出 iframe 作为页面一部分时的性能情况</li></ul></li><li><ul><li>UI 完全隔离。iframe 内的 UI 只能在 iframe 内，这在需要弹框，或者层叠的时候会特别丑。比如一个 iframe 内部弹窗，遮罩智能盖住 iframe，无法影响到外面，导致看起来很不协调</li></ul></li><li><p> 无法预加载缓存 iframe 内容 </p></li><li><p> 无法共享基础库进一步减少包体积 </p></li><li><p> 事件通信繁琐且限制多 </p></li><li><p> 上下文隔离。iframe 内外通信极其不方便，一般通过 url、cookie 等方案来通信 </p></li></ul><p>而Web Components的方案则需要大量的改造成本。</p><p>最后的组合式应用路由分发方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问。本文后面的内容也是主要基于这种方案进行阐述。</p><h1 id="六-微前端架构模式"><a href="#六-微前端架构模式" class="headerlink" title="六. 微前端架构模式"></a><strong>六.</strong> <strong>微前端架构模式</strong></h1><p>微前端应用间的关系来看，分为两种：基座模式（管理式）、自组织式。</p><p>分别也对应了两者不同的架构模式：</p><ul><li> <strong>基座模式</strong>。通过一个主应用（基座）来管理其它应用。设计难度小，方便实践，但是通用度低。（基座主要是作为承载子应用的容器，子应用通过导出对应的格式，主应用在进入到对应路由时加载对应的子应用。） </li><li> <strong>自组织模式</strong>。应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高。 </li></ul><h2 id="1-基座模式"><a href="#1-基座模式" class="headerlink" title="1. 基座模式"></a><strong>1. 基座模式</strong></h2><p>基座模式，是由一个主应用和一系列业务子应用构成的系统，并由这个主应用来管理其他子应用，包括从子应用的生命周期管理到应用间的通信机制。</p><p>基座模式中的主应用，类似于API Gateway的概念，它作为系统的统一入口，负责将对应的请求指向对应的服务。子应用，则是负责各个子模块的业务实现。</p><p>主应用既可以只带有单纯的基座功能，也可以带有业务功能。它所处理的业务功能指的是核心部分的业务功能。如：</p><ul><li><p> 用户的登录、注册管理 </p></li><li><p> 系统的统一鉴权管理 </p></li><li><p> 导航菜单管理 </p></li><li><p> 路由管理 </p></li><li><p> 数据管理 </p></li><li><p> 通信代理 </p></li></ul><p>作为应用的基础核心，还需要：</p><ul><li> 维护应用注册表。在应用注册表上表明系统有多少个服务、能否找到对应的应用等。 </li><li> 管理其他子应用。如在何时加载应用、何时卸载应用等。 </li></ul><h2 id="2-自组织模式"><a href="#2-自组织模式" class="headerlink" title="2. 自组织模式"></a><strong>2. 自组织模式</strong></h2><p>自组织指的是，系统内部各子系统之间能自行按照某种规则形成一定的结构或功能。采用这种模式可以使系统内的各种前端应用，都各自拥有一个小型的基座管理功能，也相当于每个应用都可以使基座。</p><p>在采用基座模式时，用户要想访问A应用需要先加载主应用，然后才能加载A应用。采用自组织模式时，用户想要访问A应用则只访问A应用，不要加载主应用。因此拥有更高的自主性。</p><p>不过多数时候，我们并不需要自组织模式的微前端架构，因为它设计起来复杂，拥有大量的重复代码。</p><h1 id="七-微前端架构解决方案的两类场景"><a href="#七-微前端架构解决方案的两类场景" class="headerlink" title="七. 微前端架构解决方案的两类场景"></a><strong>七.</strong> <strong>微前端架构解决方案的两类场景</strong></h1><h2 id="1-单实例"><a href="#1-单实例" class="headerlink" title="1. 单实例"></a><strong>1. 单实例</strong></h2><p>即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。通常基于 url 的变化来做子应用的切换。</p><h2 id="2-多实例"><a href="#2-多实例" class="headerlink" title="2.  多实例"></a><strong>2.  多实例</strong></h2><p>同一时刻可展示多个子应用。通常使用 Web Components 方案来做子应用封装，子应用更像是一个业务组件而不是应用。</p><h1 id="八-微前端架构下，主框架和子应用集成的方式"><a href="#八-微前端架构下，主框架和子应用集成的方式" class="headerlink" title="八. 微前端架构下，主框架和子应用集成的方式"></a><strong>八.</strong> <strong>微前端架构下，主框架和子应用集成的方式</strong></h1><p>微前端架构模式下，子应用打包的方式，基本分为两种：</p><table><thead><tr><th><strong>方案</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>构建时组合</td><td>子应用通过Package Registry（可以是npm package，也可以是git tags等其他方式）的方式，与主应用一起打包发布。</td><td>主应用、子应用之间可以做打包优化，如依赖共享等</td><td>子应用与主应用之间产品工具链耦合。工具链也是技术栈的一部分。 子应用每次发布依赖，主应用需要重新打包发布。</td></tr><tr><td>运行时组合</td><td>子应用独立构建打包，主应用运行时动态加载子应用资源。</td><td>主应用与子应用完全技术栈无关</td><td>会多出一些运行时的复杂度和开销</td></tr></tbody></table><p>在组合时机的选择上，我们有两个选择：第一个是在构建时，把主子应用打包在一起，这实际上就是一种多包的方案。这个方案它的好处是构建的时候可以做公共依赖的提取，但是它的缺点在于我们把主子应用构建方案和工具都耦合在一起了，这非常不灵活地，这样也没办法做到动态加载。很显然，要实现真正的技术栈无关跟独立部署两个核心目标，大部分场景下我们需要使用运行时去组合，就是运行的时候才去动态的加载子应用，把它加载、渲染到框架应用里。</p><h1 id="九-以qiankun为例浅谈微前端运行时框架如何实现"><a href="#九-以qiankun为例浅谈微前端运行时框架如何实现" class="headerlink" title="九. 以qiankun为例浅谈微前端运行时框架如何实现"></a><strong>九. 以qiankun为例浅谈微前端运行时框架如何实现</strong></h1><p><strong>详细可阅读：</strong></p><p><strong>single-spa微前端项目示例：</strong> </p><ul><li> <a href="https://github.dev/liyongning/micro-frontend">https://github.dev/liyongning/micro-frontend</a> </li></ul><p><strong>single-spa源码：</strong></p><ul><li><a href="https://github.com/single-spa/single-spa">https://github.com/single-spa/single-spa</a></li></ul><p><strong>single-spa源码分析：</strong></p><ul><li> <a href="https://juejin.cn/post/6862661545592111111#heading-72">微前端</a><a href="https://juejin.cn/post/6862661545592111111#heading-72">框架 之 single-spa 从入门到精通 - </a><a href="https://juejin.cn/post/6862661545592111111#heading-72">掘金</a> </li><li> <a href="https://www.cnblogs.com/synY/p/13958963.html">微前端</a><a href="https://www.cnblogs.com/synY/p/13958963.html">single-spa原理学习 - 余圣源 - 博客园</a> </li></ul><p><strong>qiankun微前端项目示例：</strong></p><ul><li><a href="https://github.dev/a1029563229/micro-front-template/tree/feature-inject-sub-apps">https://github.dev/a1029563229/micro-front-template/tree/feature-inject-sub-apps</a></li></ul><p><strong>qiankun源码：</strong></p><ul><li><a href="https://github.com/umijs/qiankun">https://github.com/umijs/qiankun</a></li></ul><p><strong>qiankun源码分析：</strong></p><ul><li><p> <a href="https://juejin.cn/post/6844904115999342600#heading-14">万字长文+图文并茂+全面解析</a><a href="https://juejin.cn/post/6844904115999342600#heading-14">微前端</a><a href="https://juejin.cn/post/6844904115999342600#heading-14">框架 qiankun 源码 - qiankun 篇 - </a><a href="https://juejin.cn/post/6844904115999342600#heading-14">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6885211340999229454">微前端</a><a href="https://juejin.cn/post/6885211340999229454">框架 之 qiankun 从入门到源码分析 - </a><a href="https://juejin.cn/post/6885211340999229454">掘金</a> </p></li><li><p> <a href="https://www.cnblogs.com/synY/p/13969785.html">微前端</a><a href="https://www.cnblogs.com/synY/p/13969785.html">qiankun原理学习 - 余圣源 - 博客园</a> </p></li><li><p> <a href="https://www.jianshu.com/p/9703726b4c9f">qiankun源码深挖</a> </p></li></ul><p>qiankun（乾坤）是一款由蚂蚁金服推出的比较成熟的微前端框架，基于single-spa进行二次开发，用于将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</p><p>而在qiankun之前，比较好的微前端基础框架是single-spa，single-spa是一个扩展性极高的微前端框架，single-spa很好地解决了路由和应用接入两个问题，但并没有解决应用加载问题，而是将该问题暴露出来由使用者实现（一般可以用system.js或原生script标签来实现），qiankun在此基础上封装了一个应用加载方案（即import-html-entry），并给出了js隔离、css样式隔离和应用间通信三个问题的解决方案，同时提供了预加载功能。</p><p>要实现微前端需要解决的技术问题有：</p><ul><li><p> <strong>应用接入</strong> </p></li><li><p> <strong>应用入口</strong> </p></li><li><p> <strong>应用隔离(Js隔离、样式隔离)</strong> </p></li><li><p> <strong>应用路由</strong> </p></li><li><p> <strong>应用通信</strong> </p></li></ul><p>而 qiankun 的实现原理如下：</p><h2 id="1-应用接入"><a href="#1-应用接入" class="headerlink" title="1. 应用接入"></a><strong>1. 应用接入</strong></h2><p>qiankun是基于single-spa进行二次开发的，而在single-spa中已经帮qiankun解决了应用接入问题，所以在应用接入这块，qiankun采用的仍然是single-spa的方式。 single-spa采用的是<strong>协议入口</strong>，即只要实现 single-spa的入口协议规范，它就是可加载的应用。single-spa的规范要求应用入口必须暴露出以下三个生命周期钩子函数，且必须返回Promise，以保证single-spa可以注册回调函数。</p><p>因此在 qiankun 框架中，也约定子应用必须实现并导出 bootstrap 、mount和 unmount三个生命周期钩子，且必须以umd的格式导出模块。（  将子应用入口文件的返回值即生命周期方法暴露给 window，这样基座应用就可以从 window 中获取子应用的生命周期方法。 ）有这三个函数导出，我们的框架应用就可以知道如何加载这个子应用。</p><p><strong>我们的 library 就暴露为所有的模块定义下都可运行的方式，主应用就可以获取到微应用的生命周期钩子函数了</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// one time initialization</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// use a framework to create dom nodes and mount the parcel</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmount</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// use a framework to unmount dom nodes and perform other cleauo</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()<br>&#125;<br></code></pre></td></tr></table></figure><p>这三个生命周期函数分别的含义是：</p><ul><li><p> bootstrap 初始化子应用。在应用首次初始化时触发， 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。 </p></li><li><p> mount  挂载子应用。在应用需要显示时触发，此时，基座已经为子应用分配了 DOM 节点，然后调用 mount 函数。子应用在 mount 函数中可以根据基座分配的 DOM 节点，将子应用的内容渲染进去。（应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法） </p></li><li><p> unmount 卸载子应用。在子应用被关闭时触发，子应用需要在此函数中做一些清理操作。（应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例） </p></li></ul><p>需要注意的是，bootstrap 函数只会执行一次，而 mount 和 unmount 会根据基座对子应用的控制可能会执行多次。</p><p>qiankun 在加载子应用时，会为 window 注入标志性变量  window.<strong>POWERD_BY_QIANKUN</strong>，子应用通过此标志来决定在基座中的加载逻辑和独立运行的加载逻辑，从而实现子应用可以在基座内外均可独立运行。</p><p><strong>详细可阅读：</strong></p><ul><li><a href="https://www.jianshu.com/p/9703726b4c9f">qiankun源码深挖</a></li></ul><h2 id="2-应用入口"><a href="#2-应用入口" class="headerlink" title="2. 应用入口"></a><strong>2. 应用入口</strong></h2><p>子应用提供什么形式的资源作为渲染入口？ JS entry or HTML entry</p><ul><li> JS Entry - 子应用打包时将所有资源（html、css、js）全部打包成一个 js 文件。基座通过加载这个 js 加载子应用。 </li><li> HTML Entry - 子应用按照原有的模式打包，基座通过加载应用的入口文件（index.html），然后再加载入口文件中的页面资源，最终汇总成 html、css、js 资源再加载到页面。 </li></ul><p>这里做一个简单的对比：</p><table><thead><tr><th></th><th><strong>说明</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>html</td><td>html作为子应用入口</td><td>解耦更彻底，子应用不依赖主应用DOM，子应用独立开发，能独立部署</td><td>多个一次对html的请求，解析有性能损耗，无法做构建时优化</td></tr><tr><td>js</td><td>js作为子应用入口</td><td>便于做构建时优化</td><td>依赖主应用提供挂载节点，打包产物体积膨胀，资源无法并行加载</td></tr></tbody></table><p>两种方式各有优劣，从体验的角度出发，HTML Entry 的体验更好，且侵入性更低，可以把子应用和主应用更加的解耦了。</p><p>qiankun 的第一选择是 HTML Entry，由 import-html-entry库实现的。 import-html-entry暴露出的核心接口是importHTML用于加载html文件 ，他的主要执行过程如下：</p><ol><li><p> 检查是否有缓存，如果有，直接从缓存中返回 </p></li><li><p> 如果没有，则通过fetch下载html文件，并字符串化 </p></li><li><p> 调用processTpl进行一次模板字符串解析，主要任务是扫描出外联脚本和外联样式，保存在数组变量scripts和styles中。 </p></li><li><p> 调用getEmbedHTML，将外联样式下载下来，并替换到模板内，使其变成内部样式 </p></li><li><p> 返回一个Promise对象，该对象包含处理后的模板，以及getExternalScripts、getExternalStyleSheets、execScripts等几个核心方法 </p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-comment">// template 是将script注释掉、将link 替换为 style 后的 template</span><br>  <span class="hljs-attr">template</span>: embedHTML,<br>  <span class="hljs-comment">// 资源地址根路径，可用于加载子应用资源</span><br>  assetPublicPath,<br>  <span class="hljs-comment">// 获取外部脚本，最终得到所有脚本的代码内容</span><br>  <span class="hljs-attr">getExternalScripts</span>: <span class="hljs-function">() =&gt;</span> getExternalScripts(scripts, fetch),<br>  <span class="hljs-comment">// 获取外部样式文件的内容</span><br>  <span class="hljs-attr">getExternalStyleSheets</span>: <span class="hljs-function">() =&gt;</span> getExternalStyleSheets(styles, fetch),<br>  <span class="hljs-comment">// 脚本执行器，让 JS 代码(scripts)在指定 上下文 中运行</span><br>  <span class="hljs-attr">execScripts</span>: <span class="hljs-function">(<span class="hljs-params">proxy, strictGlobal</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!scripts.length) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();<br>    &#125;<br>    <span class="hljs-keyword">return</span> execScripts(entry, scripts, proxy, &#123; fetch, strictGlobal &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是 HTML Entry的原理。</p><p>HTML Entry最终会返回一个Promise对象，qiankun就用了这个对象中的template、 assetPublicPath和 execScripts三项，将template通过DOM操作添加到主应用中，执行 execScripts方法得到微应用导出的生命周期方法，并且还顺便解决了JS全局污染的问题，因为执行 execScripts方法的时候可以通过proxy参数指定 JS 的执行上下文。</p><p><strong>详细可阅读：</strong></p><ul><li> <a href="https://juejin.cn/post/6885212507837825038">HTML Entry 源码分析 - </a><a href="https://juejin.cn/post/6885212507837825038">掘金</a> </li><li> <a href="https://juejin.cn/post/6891888458919641096">解密</a><a href="https://juejin.cn/post/6891888458919641096">微前端</a><a href="https://juejin.cn/post/6891888458919641096">:从qiankun看子应用加载 - </a><a href="https://juejin.cn/post/6891888458919641096">掘金</a> </li></ul><h2 id="3-应用隔离"><a href="#3-应用隔离" class="headerlink" title="3. 应用隔离"></a><strong>3. 应用隔离</strong></h2><p>应用隔离问题主要分为主应用和微应用、微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离。</p><h3 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a><strong>样式隔离</strong></h3><p>在微前端框架里所面临的样式冲突就两种：一种是<strong>主子应用样式冲突</strong>，你的主应用和你的子应用两者之间样式会发生冲突，另一种是<strong>子应用之间样式冲突</strong>，当你挂载了应用 A 又挂载了应用 B 的时候，这两个应用是平级的，它们之间样式也会发生冲突。</p><p>qiankun 提供了 3 种模式来实现不同效果的样式隔离：</p><h4 id="动态样式表-Dynamic-Stylesheet"><a href="#动态样式表-Dynamic-Stylesheet" class="headerlink" title="动态样式表-Dynamic Stylesheet"></a><strong>动态样式表-Dynamic Stylesheet</strong></h4><p>qiankun 所做的第一件事情其实是动态样式表。这种模式的做法是通过重写 DOM 操作方法，来劫持动态样式的添加，直接让样式添加到正确的地方，即将子应用的样式（ css 列表）全部直接加载到子应用挂载的 DOM 节点内，这样在卸载子应用的时候，移除该 DOM 节点，就可以自动去掉子应用使用的 css。但这种模式可能会导致子应用内的样式影响到基座。（例如子应用内和基座对同一个 id 的 DOM 元素配置了样式）</p><h4 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a><strong>Shadow</strong> <strong>DOM</strong></h4><p>Shadow DOM允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 Shadow DOM 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样，隐藏的 DOM 样式和其余 DOM 是完全隔离的，类似于 iframe 的样式隔离效果。</p><p>qiankun2.0 之后，追加了一个新的选项，叫做<strong>严格样式隔离，</strong>其实严格样式隔离代表 Shadow DOM，qiankun采用shadowDOM的方式进行样式隔离，即为子应用的根节点创建一个 shadow root。最终整个应用的所有DOM将形成一棵 shadow tree，它内部所有节点的样式对树外面的节点无效，因此自然就实现了样式隔离。</p><p>但是这种方案是存在缺陷的。因为某些UI框架可能会生成一些弹出框直接挂载到document.body下，此时由于脱离了 shadow tree，所以它的样式仍然会对全局造成污染。另外如果子应用使用的是 React 技术栈，而 React 事件代理其实是挂在 document 上的，它也会出一些问题。所以实践里当你开启 Shadow DOM 之后，当你的子应用可能会遇到一些奇怪的错误，这些错误需要你一一的去手动修复，这是比较累的一个过程。</p><h4 id="Scoped-CSS"><a href="#Scoped-CSS" class="headerlink" title="Scoped CSS"></a><strong>Scoped</strong> <strong>CSS</strong></h4><p>思路类似于Vue中的 scoped属性，给每个子应用的根节点添加一个特殊属性，用作对所有css选择器的约束。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">  <span class="hljs-attr">data-qiankun-asiw732sde</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;__qiankun_microapp_wrapper__&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;module-app1&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app-main&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><br>.app-main &#123; <br>  字体大小：14 px ; <br>&#125;<br><br>div[data-qiankun-asiw732sde] .app-main &#123;  <br>  字体大小：14 px ; <br>&#125;<br></code></pre></td></tr></table></figure><p>经过上述替换，这个样式就只能在当前子应用内生效了。虽然该方案已经提出很久了，但仍然是实验性的，因为它不支持@ keyframes，@ font-face，@ import，@ page（即不会被重写）</p><h4 id="工程化手段-BEM、CSS-Modules、CSS-in-JS"><a href="#工程化手段-BEM、CSS-Modules、CSS-in-JS" class="headerlink" title="工程化手段-BEM、CSS Modules、CSS in JS"></a><strong>工程化手段-BEM、CSS Modules、CSS in</strong> <strong>JS</strong></h4><p>通过一系列<strong>约束</strong>和<strong>编译时生成不同类名</strong>、<strong>JS</strong> <strong>中处理</strong> <strong>CSS</strong> <strong>生成不同类名</strong>来解决隔离问题</p><p>当然动态样式表实现之后，我们还是没有解决主应用和主应用之间的样式冲突。实际上这个问题最好的手段还是通过一些工程化的手段来解，比如说 BEM，就是说大家约定一下，你应用 A 样式就统一加一个 a- 的前缀，应用 B 样式就统一加一个 b- 的前缀，你的框架应用也统一加个前缀。大家通过一些约定（比如约定大家都加上一个应用名的前缀）来避免冲突，这是非常有效的一个方案。尤其是主子应用之间的冲突，大部分情况下你只要保证主应用的样式做好改造，保证主应用的样式是很具象的规则，不会跟子应用冲突，那主子应用之间的冲突其实也解决了。不过这种方案终归是依赖约定，往往容易出纰漏。</p><p>当前 css module 其实非常成熟一种做法，就是通过编译生成不冲突的选择器名。你只要把你想要避免冲突的应用，通过 css module （在构建工具里加一些 css 预处理器即可实现）就能很简单的做到。 css module 构建打包之后，应用之间的选择器名就不同了，也就不会相互冲突了。</p><p>css-in-js 也是一种流行的方案，通过这种方式编码的样式也不会冲突，这几个方案实现起来都不复杂，而且都非常行之有效。所以绝大部分情况下，大家手动用工程化手段处理一下主子应用之间的样式冲突，就可以解决掉样式隔离的问题。</p><table><thead><tr><th></th><th><strong>说明</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>BEM</strong></td><td>不同项目用不同的前缀/命名规则避开冲突</td><td>简单</td><td>依赖约定，这也是耦合的一种容易出纰漏</td></tr><tr><td><strong>CSS****Modules</strong></td><td>通过编译生成不冲突的选择器名</td><td>可靠易用，避免人工约束</td><td>只能在构建期使用，依赖预处理器与打包工具</td></tr><tr><td><strong>CSS-in-JS</strong></td><td>CSS和JS编码在一起，最终生成不冲突的选择器</td><td>基本彻底避免冲突</td><td>运行时开销，略缺失完整css能力</td></tr></tbody></table><p>当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。</p><h3 id="JavaScript隔离"><a href="#JavaScript隔离" class="headerlink" title="JavaScript隔离"></a><strong>JavaScript隔离</strong></h3><p>qiankun实现js隔离的方式是实现js沙箱，沙箱是一种安全机制，为运行中的程序提供的隔离环境。</p><p>qiankun 做沙箱隔离主要分为三种：</p><ul><li><p> legacySandBox 传统沙箱 </p></li><li><p> proxySandBox  代理沙箱 </p></li><li><p> snapshotSandBox 快照沙箱 </p></li></ul><p>其中 legacySandBox、proxySandBox 是基于 Proxy API 来实现的，在不支持 Proxy API 的低版本浏览器中，会降级为 snapshotSandBox。在现版本中，legacySandBox 仅用于 singular 单实例模式，而多实例模式会使用 proxySandBox。</p><h4 id="SnapshotSandbox-快照-js-沙箱"><a href="#SnapshotSandbox-快照-js-沙箱" class="headerlink" title="SnapshotSandbox - 快照 js 沙箱"></a><strong>SnapshotSandbox - 快照</strong> <strong>js</strong> <strong>沙箱</strong></h4><p>快照沙箱是基于window diff来实现的，在不支持 Proxy 的场景下会默认使用此沙箱。此沙箱的原理是在激活沙箱时，将 window的快照信息存到一个windowSnapshot中， 如果modifyPropsMap有值，还需要还原上次的状态；激活期间，可能修改了window的数据；退出沙箱时，将修改过的信息存到modifyPropsMap里面，并且把window还原成初始进入的状态。子应用的 window 操作实质上是对这个变量操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25720495/1642476944215-309174bc-ae8b-4b9b-8de1-efe840a174fe.png" alt="img"></p><h4 id="LegacySandbox-传统-js-沙箱"><a href="#LegacySandbox-传统-js-沙箱" class="headerlink" title="LegacySandbox- 传统 js 沙箱"></a><strong>LegacySandbox- 传统</strong> <strong>js</strong> <strong>沙箱</strong></h4><p>此沙箱使用Proxy代理子应用对 window 的操作，将子应用对 window 的操作同步到全局 window 上，造成侵入。但同时会将期间对 window 的新增、删除、修改操作记录到三个状态池中，用于子应用卸载时还原主应用的状态和子应用加载时还原子应用的状态：</p><ul><li><p> <strong>addedPropsMapInSandbox</strong>： 存储在子应用运行时期间<strong>新增的全局变量</strong>，用于卸载子应用时<strong>还原主应用</strong>全局变量； </p></li><li><p> <strong>modifiedPropsOriginalValueMapInSandbox</strong>：存储在子应用运行期间<strong>更新的全局变量</strong>，用于卸载子应用时<strong>还原主应用</strong>全局变量； </p></li><li><p> <strong>currentUpdatedPropsValueMap</strong>：存储子应用全局变量的更新（新增和修改），用于运行时切换后还原子应用的状态； </p></li></ul><p>legacySandBox 的本质上还是操作 window 对象，但是他通过激活沙箱时还原子应用的状态，卸载时还原主应用的状态来实现沙箱隔离的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25720495/1642476982880-c73fea9d-f984-4a5c-bf60-593b46d36440.png" alt="img"></p><h4 id="ProxySandbox-代理-js-沙箱"><a href="#ProxySandbox-代理-js-沙箱" class="headerlink" title="ProxySandbox -代理 js 沙箱"></a><strong>ProxySandbox -代理</strong> <strong>js</strong> <strong>沙箱</strong></h4><p>在 qiankun 中，proxySandBox 用于多实例场景。和LegacySandbox同样基于 Proxy 代理子应用对 window 的操作，和LegacySandbox不同的是，proxySandBox 不会直接操作 window 对象。ProxySandbox会创建一个虚拟window对象fakeWindow提供给子应用使用。（fakeWindow通过 createFakeWindow方法得到的，这个方法是将 window的 document、 location、top、window等等属性拷贝一份，给到fakeWindow上）</p><p>激活沙箱后，每次对window取值的时候，先从自己沙箱环境的 fakeWindow里面找，如果不存在，就从 rawWindow(外部的 window)里去找；当对沙箱内部的window对象赋值的时候，会直接操作fakeWindow，而不会影响到rawWindow，实现完全的隔离主子应用的状态。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25720495/1642477018836-1f528778-8c73-41c2-bf08-674fffb1222e.png" alt="img"></p><p>注：样式隔离、JS 隔离都在会子应用 mount 前，bootstrap 时处理。</p><p>当然除了这些基本的隔离处理之外，qiankun 还提供了对 window 的各种监听和定时器的 Hook，保证子应用完整的销毁。综合来说，qiankun 的 js 隔离方式比较完善，足够满足在子应用内的隔离需求了。</p><p><strong>详细可阅读：</strong></p><ul><li><a href="https://juejin.cn/post/6920110573418086413">15分钟快速理解qiankun的</a><a href="https://juejin.cn/post/6920110573418086413">js</a><a href="https://juejin.cn/post/6920110573418086413">沙箱原理及其实现</a></li></ul><h2 id="4-应用路由"><a href="#4-应用路由" class="headerlink" title="4. 应用路由"></a><strong>4. 应用路由</strong></h2><p>qiankun 在应用路由的技术实现是直接基于 single-spa 的基础，做了一点简单的扩展。（qiankun 提供单实例和多实例模式。这里只讨论单实例模式，多实例模式目前还处于实验性阶段，多实例路由目前无法使用。）</p><p>基座应用<strong>加载执行</strong> qiankun <strong>时，会是通过监听</strong>hashChange<strong>和</strong>popState<strong>这两个原生事件来检测路由变化的，它会根据路由的变化来加载对应的应用。当</strong>基座应用<strong>通过</strong>执行pushState(replaceState)<strong>、</strong>修改 hash<strong>、</strong>使用浏览器前进后退(go、back、forward)功能<strong>的方式修改 url 时，</strong>popstate(hashchange) <strong>就会触发，相应的</strong>子应用的激活逻辑就会执行。</p><p>我们知道，在使用 <strong>window.history</strong> 时，如果执行 <strong>pushState(repalceState)</strong> 方法，是不会触发 <strong>popstate</strong> 事件的，而 <strong>qiankun</strong> 之所以能在执行 <strong>pushState</strong>、<strong>replaceState</strong> 方法时，触发 <strong>popstate</strong> 事件，是因为 <strong>qiankun</strong>（实际上是single-spa） 重写了 <strong>window.history</strong> 的 <strong>pushState</strong> 和 <strong>replaceState</strong> 方法。在执行 <strong>pushState</strong>、<strong>replaceState</strong> 方法时，会通过<strong>原生方法 - PopStateEvent</strong> 构建一个<strong>事件对象</strong>，然后调用 <strong>window.dispatchEvent</strong> 方法，<strong>手动触发 popState 事件</strong>。</p><p><strong>详细可阅读：</strong></p><ul><li> <a href="https://zhuanlan.zhihu.com/p/144537631">微前端</a><a href="https://zhuanlan.zhihu.com/p/144537631"> | 5. single-spa 的生命周期和事件管理</a> </li><li> <a href="https://juejin.cn/post/6862661545592111111#heading-67">微前端</a><a href="https://juejin.cn/post/6862661545592111111#heading-67">框架 之 single-spa 从入门到精通</a> </li></ul><h2 id="5-应用通信"><a href="#5-应用通信" class="headerlink" title="5. 应用通信"></a><strong>5. 应用通信</strong></h2><p>一般来说，微前端中各个应用之间的通信应该是尽量少的，而这依赖于应用的合理拆分。反过来说，如果你发现两个应用间存在极其频繁的通信，那么一般是拆分不合理造成的，这时往往需要将它们合并成一个应用。</p><p>然而，应用间存在少量的通信是难免的。qiankun官方提供了一个简要的方案，思路是基于一个全局的globalState对象。这个对象由基座应用负责创建。内部包含一组用于通信的变量，以及两个分别用于修改变量值和监听变量变化的方法：setGlobalState和onGlobalStateChange。</p><p>基座应用初始化globalState：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; initGlobalState, MicroAppStateActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qiankun&#x27;</span>;<br><span class="hljs-keyword">const</span> initialState = &#123;&#125;;<br><span class="hljs-keyword">const</span> actions: MicroAppStateActions = initGlobalState(initialState);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> actions;<br></code></pre></td></tr></table></figure><p>这里的actions对象就是我们说的globalState，即全局状态。基座应用可以在加载子应用时通过props将actions传递到子应用内，而子应用通过以下语句即可监听全局状态变化和修改全局状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions.onGlobalStateChange (globalState, oldGlobalState) &#123;<br>  ...<br>&#125;<br>actions.setGlobalState(...);<br></code></pre></td></tr></table></figure><p>此外，基座应用和其他子应用也可以进行这两个操作，从而实现对全局状态的共享，这样各个应用之间就可以通信了。这种方案与Redux和Vuex都有相似之处，只是由于微前端中的通信问题较为简单，所以官方只提供了这样一个精简方案。</p><p><strong>详细可阅读：</strong></p><ul><li><a href="https://juejin.cn/post/6844904151231496200">https://juejin.cn/post/6844904151231496200</a></li></ul><p><strong>代码实例：</strong></p><ul><li><a href="https://github.dev/a1029563229/micro-front-template/tree/feature-communication">https://github.dev/a1029563229/micro-front-template/tree/feature-communication</a></li></ul><h1 id="十-微前端解决方案整体架构"><a href="#十-微前端解决方案整体架构" class="headerlink" title="十. 微前端解决方案整体架构"></a><strong>十.</strong> <strong>微前端解决方案整体架构</strong></h1><p>微前端不是一个框架，而是一套架构体系。</p><p>可以看到 qiankun 帮我们做了很多事情，但是这个事情并没有帮我们一揽子全部做完，并不是用了 qiankun 之后，就完全地一劳永逸地解决了微前端的所有麻烦。克军 在 D2 的微前端的专场分享的时候，有提到过微前端的整个大图，他把整个微前端体系分成了非常多的模块，qiankun 所帮你解决的这一块实际上是<strong>微前端的运行时容器，</strong>这是整个微前端工程化里面的一个环节。</p><p>从这个角度来讲，qiankun 不算是一个完整的微前端解决方案，而是微前端运行时容器的一个完整解决方案，当你用了 qiankun 之后，你能解决几乎所有的微前端运行时容器的问题，但是更多的一些涉及工程和平台的问题，比如：版本管理、质量管控<strong>、</strong>配置下发、线上监控、灰度发布，安全检测等。这些怎么做，都不是 qiankun 作为一个库所能解答的。这些问题还是得看大家的具体情况，来选择自己适合的解决方案。这也需要在微前端这方面做一些基础设施建设的投入，才能比较好的解答工程问题与平台建设问题。</p><p><strong>详细可阅读：</strong></p><ul><li> <a href="https://github.com/d2forum/14th/blob/master/PPT/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB--%E5%85%8B%E5%86%9B.pdf">微前端</a><a href="https://github.com/d2forum/14th/blob/master/PPT/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB--%E5%85%8B%E5%86%9B.pdf">架构体系–克军</a> </li><li> <a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">拥抱云时代的</a><a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">前端</a><a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">开发架构——</a><a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">微前端</a> </li></ul><h1 id="十一-微前端的优缺点"><a href="#十一-微前端的优缺点" class="headerlink" title="十一. 微前端的优缺点"></a><strong>十一.</strong> <strong>微前端的优缺点</strong></h1><h2 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a><strong>1. 优点</strong></h2><ul><li><p> 技术兼容性好，各个子应用可以基于不同的技术架构 </p></li><li><p> 代码库更小、内聚性更强 </p></li><li><p> 便于独立编译、测试和部署，可靠性更高 </p></li><li><p> 耦合性更低，各个团队可以独立开发，互不干扰 </p></li><li><p> 可维护性和扩展性更好，便于局部升级和增量升级 </p></li></ul><p>关于技术兼容性，由于在被基座应用加载前， 所有子应用已经编译成原生代码输出，所以基座应用可以加载各类技术栈编写的应用；由于拆分后应用体积明显变小，并且每个应用只实现一个业务模块，因此其内聚性更强；另外子应用本身也是完整的应用，所以它可以独立编译、测试和部署；关于耦合性，由于各个子应用只负责各自的业务模块，所以耦合性很低，非常便于独立开发；关于可维护性和扩展性，由于拆分出的应用都是完整的应用，因此专门升级某个功能模块就成为了可能，并且当需要增加模块时，只需要创建一个新应用，并修改基座应用的路由规则即可。</p><h2 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a><strong>2. 缺点</strong></h2><ul><li><p> 子应用间的资源共享能力较差，使得项目总体积变大 </p></li><li><p> 需要对现有代码进行改造（指的是未按照微前端形式编写的旧工程） </p></li><li><p> 应用的拆分基础依赖于基础设施的构建，一旦大量应用依赖于同一基础设施，那么维护变成了一个挑战。 </p></li><li><p> 拆分的粒度越小，便意味着架构变得复杂、维护成本变高。 </p></li><li><p> 技术栈一旦多样化，便意味着技术栈混乱。 </p></li><li><p> 复杂度从代码转向基础设施 </p></li><li><p> 整个应用的稳定性和安全性变得更加不可控 </p></li><li><p> 具备一定的学习和了解成本 </p></li><li><p> 需要建立全面的微前端周边设施，才能充分发挥其架构的优势 </p></li><li><ul><li>调试工具</li><li>监控系统</li></ul></li><li><ul><li>上层 Web 框架</li><li>部署平台</li></ul></li><li><ul><li>…….</li></ul></li></ul><h1 id="十二-微前端的适用场景"><a href="#十二-微前端的适用场景" class="headerlink" title="十二.  微前端的适用场景"></a><strong>十二.</strong>  <strong>微前端的适用场景</strong></h1><p>微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：</p><ul><li><p> 微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。 </p></li><li><p> 整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括： </p></li><li><ul><li> 基座应用和微应用的自动部署能力。 </li><li> 微应用的配置管理能力。 </li></ul></li><li><ul><li> 本地开发调试能力。 </li><li>线上监控和统计能力等等。<br>只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。 </li></ul></li><li><p> 当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。 </p></li></ul><p><strong>适用场景:</strong></p><ul><li><p> 大规模企业级 Web 应用开发 </p></li><li><p> 跨团队及企业级应用协作开发 </p></li><li><p> 不同技术选型的项目 </p></li><li><p> 内聚的单个产品中部分需要独立发布、灰度等能力 </p></li><li><p> 长期收益高于短期收益 </p></li><li><p> 微前端的目标并非用于取代 Iframe </p></li><li><ul><li>应用的来源必须可信</li><li>用户体验要求更高</li></ul></li></ul><h1 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a><strong>学习文档</strong></h1><p><strong>以上内容均学习并搬运至如下某些文章中：</strong></p><h2 id="1-微前端概念"><a href="#1-微前端概念" class="headerlink" title="1. 微前端概念"></a><strong>1.</strong> <strong>微前端概念</strong></h2><ul><li><p> <a href="https://juejin.cn/post/6844904162509979662">微前端</a><a href="https://juejin.cn/post/6844904162509979662">-最容易看懂的微前端知识 - </a><a href="https://juejin.cn/post/6844904162509979662">掘金</a> </p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/41879781">微前端</a><a href="https://zhuanlan.zhihu.com/p/41879781">的设计理念与实践初探</a> </p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/39102712">实施</a><a href="https://zhuanlan.zhihu.com/p/39102712">前端</a><a href="https://zhuanlan.zhihu.com/p/39102712">微服务化的六七种方式</a> </p></li><li><p> <a href="https://www.jianshu.com/p/785c2ca5a886">微前端</a><a href="https://www.jianshu.com/p/785c2ca5a886">简介</a> </p></li><li><p> <a href="https://www.infoq.cn/article/xm_aaiotxmlppgwvx9y9">微前端</a><a href="https://www.infoq.cn/article/xm_aaiotxmlppgwvx9y9">如何落地-InfoQ</a> </p></li><li><p> <a href="https://juejin.cn/post/7016911648656982024">字节跳动是如何落地</a><a href="https://juejin.cn/post/7016911648656982024">微前端</a><a href="https://juejin.cn/post/7016911648656982024">的 - </a><a href="https://juejin.cn/post/7016911648656982024">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6844903953734336525">微前端</a><a href="https://juejin.cn/post/6844903953734336525">入门 - </a><a href="https://juejin.cn/post/6844903953734336525">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6844904023082926094">微前端</a><a href="https://juejin.cn/post/6844904023082926094">在解决什么问题? - </a><a href="https://juejin.cn/post/6844904023082926094">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6854573214430380039">微前端</a><a href="https://juejin.cn/post/6854573214430380039">框架设计 - </a><a href="https://juejin.cn/post/6854573214430380039">掘金</a> </p></li><li><p> <a href="https://cloud.tencent.com/developer/article/1828684">一文读懂</a><a href="https://cloud.tencent.com/developer/article/1828684">微前端</a><a href="https://cloud.tencent.com/developer/article/1828684">架构</a> </p></li><li><p> <a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">拥抱云时代的</a><a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">前端</a><a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">开发架构——</a><a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw?spm=a2c6h.12873639.0.0.67432312OS7TP9">微前端</a> </p></li><li><p> <a href="https://www.yuque.com/kuitos/gky7yw/rhduwc">微前端</a><a href="https://www.yuque.com/kuitos/gky7yw/rhduwc">的核心价值 · 语雀</a> </p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/78362028">可能是你见过最完善的</a><a href="https://zhuanlan.zhihu.com/p/78362028">微前端</a><a href="https://zhuanlan.zhihu.com/p/78362028">解决方案</a> </p></li><li><p> <a href="http://blog.jcr.pub/2021/04/28/the-architecture-of-micro-frontends-qiankun/">微前端</a><a href="http://blog.jcr.pub/2021/04/28/the-architecture-of-micro-frontends-qiankun/">架构详解 - 乾坤</a> </p></li><li><p> <a href="https://jonny-wei.github.io/blog/talk/micro-frontend.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%8F%8A-qinkun-%E6%A1%86%E6%9E%B6">微前端</a><a href="https://jonny-wei.github.io/blog/talk/micro-frontend.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%8F%8A-qinkun-%E6%A1%86%E6%9E%B6"> | 花帽子的博客</a> </p></li><li><p> <a href="https://juejin.cn/post/6911873800669757447">闲庭信步聊</a><a href="https://juejin.cn/post/6911873800669757447">前端</a><a href="https://juejin.cn/post/6911873800669757447"> - 见微知著</a><a href="https://juejin.cn/post/6911873800669757447">微前端</a><a href="https://juejin.cn/post/6911873800669757447"> - </a><a href="https://juejin.cn/post/6911873800669757447">掘金</a> </p></li><li><p> <a href="https://microfrontends.cn/">Thinking in Microjfrontend (</a><a href="https://microfrontends.cn/">微前端</a><a href="https://microfrontends.cn/">的那些事儿)</a> </p></li><li><p> <a href="https://segmentfault.com/a/1190000021535649">最简</a><a href="https://segmentfault.com/a/1190000021535649">微前端</a><a href="https://segmentfault.com/a/1190000021535649">解决方案之（MPA + 路由分发）</a> </p></li><li><p> <a href="https://juejin.cn/post/6844903943873675271#heading-0">每日优鲜供应链</a><a href="https://juejin.cn/post/6844903943873675271#heading-0">前端</a><a href="https://juejin.cn/post/6844903943873675271#heading-0">团队</a><a href="https://juejin.cn/post/6844903943873675271#heading-0">微前端</a><a href="https://juejin.cn/post/6844903943873675271#heading-0">改造 - </a><a href="https://juejin.cn/post/6844903943873675271#heading-0">掘金</a> </p></li><li><p> <a href="https://developer.aliyun.com/article/761446">阿里云开放平台</a><a href="https://developer.aliyun.com/article/761446">微前端</a><a href="https://developer.aliyun.com/article/761446">方案的沙箱实现-阿里云开发者社区</a> </p></li><li><p> <a href="https://segmentfault.com/a/1190000020832808">带你手写</a><a href="https://segmentfault.com/a/1190000020832808">微前端</a><a href="https://segmentfault.com/a/1190000020832808">框架</a> </p></li><li><p> <a href="https://www.infoq.cn/article/3azwpv801cuauhiskowb">网易严选企业级</a><a href="https://www.infoq.cn/article/3azwpv801cuauhiskowb">微前端</a><a href="https://www.infoq.cn/article/3azwpv801cuauhiskowb">解决方案与落地实践-InfoQ</a> </p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/79388540">架构设计：</a><a href="https://zhuanlan.zhihu.com/p/79388540">微前端</a><a href="https://zhuanlan.zhihu.com/p/79388540">架构</a> </p></li><li><p> <a href="https://segmentfault.com/a/1190000040275586">微前端</a><a href="https://segmentfault.com/a/1190000040275586">解决方案</a> </p></li></ul><h2 id="2-single-spa相关"><a href="#2-single-spa相关" class="headerlink" title="2. single-spa相关"></a>2. single-spa相关</h2><ul><li><p> <a href="https://zh-hans.single-spa.js.org/docs/getting-started-overview">single-spa</a> </p></li><li><p> <a href="https://juejin.cn/post/6862661545592111111#heading-72">微前端</a><a href="https://juejin.cn/post/6862661545592111111#heading-72">框架 之 single-spa 从入门到精通 - </a><a href="https://juejin.cn/post/6862661545592111111#heading-72">掘金</a> </p></li><li><p> <a href="https://www.cnblogs.com/synY/p/13958963.html">微前端</a><a href="https://www.cnblogs.com/synY/p/13958963.html">single-spa原理学习 - 余圣源 - 博客园</a> </p></li><li><p> <a href="https://juejin.cn/post/6992539016620933150">微前端</a><a href="https://juejin.cn/post/6992539016620933150">学习系列(二)：single-spa</a> </p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/144537631">微前端</a><a href="https://zhuanlan.zhihu.com/p/144537631"> | 5. single-spa 的生命周期和事件管理</a> </p></li><li><p> <a href="https://juejin.cn/post/7011767759432318984">前端</a><a href="https://juejin.cn/post/7011767759432318984">微服务：single-spa与qiankun的区别</a> </p></li><li><p> <a href="https://2heal1.github.io/work/single-spa.html#%E5%BE%AE%E5%BA%94%E7%94%A8%E6%8A%9B%E5%87%BA%E7%9B%B8%E5%85%B3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">single-spa浅析 | Heal Blog</a> </p></li></ul><h2 id="3-qiankun相关"><a href="#3-qiankun相关" class="headerlink" title="3. qiankun相关"></a>3. qiankun相关</h2><ul><li><p> <a href="https://2heal1.github.io/work/qiankun%E7%89%B9%E6%80%A7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#js-%E6%B2%99%E7%AE%B1">qiankun特性分析 | Heal Blog</a> </p></li><li><p> <a href="https://juejin.cn/post/6844904158085021704#heading-7">基于 qiankun 的</a><a href="https://juejin.cn/post/6844904158085021704#heading-7">微前端</a><a href="https://juejin.cn/post/6844904158085021704#heading-7">最佳实践(万字长文) - 从 0 到 1 篇 - </a><a href="https://juejin.cn/post/6844904158085021704#heading-7">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6844904151231496200">基于 qiankun 的</a><a href="https://juejin.cn/post/6844904151231496200">微前端</a><a href="https://juejin.cn/post/6844904151231496200">最佳实践(图文并茂) - 应用间通信篇 - </a><a href="https://juejin.cn/post/6844904151231496200">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6844904115999342600#heading-14">万字长文+图文并茂+全面解析</a><a href="https://juejin.cn/post/6844904115999342600#heading-14">微前端</a><a href="https://juejin.cn/post/6844904115999342600#heading-14">框架 qiankun 源码 - qiankun 篇 - </a><a href="https://juejin.cn/post/6844904115999342600#heading-14">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6885211340999229454">微前端</a><a href="https://juejin.cn/post/6885211340999229454">框架 之 qiankun 从入门到源码分析 - </a><a href="https://juejin.cn/post/6885211340999229454">掘金</a> </p></li><li><p> <a href="https://www.cnblogs.com/synY/p/13969785.html">微前端</a><a href="https://www.cnblogs.com/synY/p/13969785.html">qiankun原理学习 - 余圣源 - 博客园</a> </p></li><li><p> <a href="https://juejin.cn/post/6885212507837825038">HTML Entry 源码分析 - </a><a href="https://juejin.cn/post/6885212507837825038">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6896643767353212935">解密</a><a href="https://juejin.cn/post/6896643767353212935">微前端</a><a href="https://juejin.cn/post/6896643767353212935">:从qiankun看沙箱隔离 - </a><a href="https://juejin.cn/post/6896643767353212935">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6920110573418086413">15分钟快速理解qiankun的</a><a href="https://juejin.cn/post/6920110573418086413">js</a><a href="https://juejin.cn/post/6920110573418086413">沙箱原理及其实现</a> </p></li><li><p> <a href="https://juejin.cn/post/6891888458919641096">解密</a><a href="https://juejin.cn/post/6891888458919641096">微前端</a><a href="https://juejin.cn/post/6891888458919641096">:从qiankun看子应用加载 - </a><a href="https://juejin.cn/post/6891888458919641096">掘金</a> </p></li><li><p> <a href="https://blog.csdn.net/weixin_43825389/article/details/109313017">qiankun</a><a href="https://blog.csdn.net/weixin_43825389/article/details/109313017">微前端</a><a href="https://blog.csdn.net/weixin_43825389/article/details/109313017">路由模式<em>落梅抚雪的博客-CSDN博客</em>qiankun 路由</a> </p></li><li><p> <a href="https://juejin.cn/post/6847902217945481224">微前端</a><a href="https://juejin.cn/post/6847902217945481224">连载 5/7:微前端主子应用路由调度 - </a><a href="https://juejin.cn/post/6847902217945481224">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6846687602439897101">微前端</a><a href="https://juejin.cn/post/6846687602439897101">连载 6/7:微前端框架 - qiankun 大法好 - </a><a href="https://juejin.cn/post/6846687602439897101">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6844904185910018062">qiankun </a><a href="https://juejin.cn/post/6844904185910018062">微前端</a><a href="https://juejin.cn/post/6844904185910018062">方案实践及总结 - </a><a href="https://juejin.cn/post/6844904185910018062">掘金</a> </p></li><li><p> <a href="https://python.iitter.com/other/195355.html">微前端</a><a href="https://python.iitter.com/other/195355.html">（Micro-Frontends）qiankun框架原理与实现</a> </p></li><li><p> <a href="https://www.jianshu.com/p/9703726b4c9f">qiankun源码深挖</a> </p></li><li><p> <a href="https://blog.csdn.net/qq_41694291/article/details/113842872">微前端</a><a href="https://blog.csdn.net/qq_41694291/article/details/113842872">框架qiankun之原理与实战</a> </p></li><li><p> <a href="https://www.processon.com/view/link/5f3b53d57d9c0806d41e1a72#map">微前端</a><a href="https://www.processon.com/view/link/5f3b53d57d9c0806d41e1a72#map">框架 | ProcessOn免费在线作图,在线流程图,在线思维导图 </a> </p></li></ul><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a><strong>4. 其他</strong></h2><ul><li><p> <a href="https://juejin.cn/post/6917523941435113486">你好，谈谈你对</a><a href="https://juejin.cn/post/6917523941435113486">前端</a><a href="https://juejin.cn/post/6917523941435113486">路由的理解 - </a><a href="https://juejin.cn/post/6917523941435113486">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6886290490640039943#comment">「源码解析 」这一次彻底弄懂react-router路由原理 - </a><a href="https://juejin.cn/post/6886290490640039943#comment">掘金</a> </p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/270651966">深入了解 </a><a href="https://zhuanlan.zhihu.com/p/270651966">React</a><a href="https://zhuanlan.zhihu.com/p/270651966"> Router 原理</a> </p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/68136798">傻傻分不清的Manifest</a> </p></li><li><p> <a href="https://juejin.cn/post/6844903601060446221">Webpack</a><a href="https://juejin.cn/post/6844903601060446221">中publicPath详解 - </a><a href="https://juejin.cn/post/6844903601060446221">掘金</a> </p></li><li><p> <a href="https://juejin.cn/post/6844903853708541959">html-webpack-plugin 使用总结 - </a><a href="https://juejin.cn/post/6844903853708541959">掘金</a> </p></li><li><p> <a href="https://segmentfault.com/a/1190000022669224">webpack</a><a href="https://segmentfault.com/a/1190000022669224"> 打包的代码怎么在浏览器跑起来的？看不懂算我输</a> </p></li><li><p> <a href="https://juejin.cn/post/6844903624632434702">Webpack</a><a href="https://juejin.cn/post/6844903624632434702"> 4 配置最佳实践 - </a><a href="https://juejin.cn/post/6844903624632434702">掘金</a> </p></li><li><p> <a href="https://segmentfault.com/a/1190000038180453">webpack</a><a href="https://segmentfault.com/a/1190000038180453">的异步加载原理及分包策略</a> </p></li><li><p> <a href="https://juejin.cn/post/6844903618081095688">【深入理解</a><a href="https://juejin.cn/post/6844903618081095688">webpack</a><a href="https://juejin.cn/post/6844903618081095688">】library,libraryTarget,externals的区别及作用 - </a><a href="https://juejin.cn/post/6844903618081095688">掘金</a> </p></li><li><p> <a href="https://www.cxyzjd.com/article/weixin_43334673/107814210">代码分割、分块打包、动态导入、按需加载</a> </p></li><li><p> <a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">四种软件架构：单体架构、分布式架构、微服务架构、</a><a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">Serverless</a><a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">架构</a> </p></li><li><p> <a href="https://qinzhiqiang.cn/2020/09/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8Essr%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微前端</a><a href="https://qinzhiqiang.cn/2020/09/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8Essr%E5%BE%AE%E6%9C%8D%E5%8A%A1/">与</a><a href="https://qinzhiqiang.cn/2020/09/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8Essr%E5%BE%AE%E6%9C%8D%E5%8A%A1/">SSR</a><a href="https://qinzhiqiang.cn/2020/09/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8Essr%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a> </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术知识归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/07/06/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/"/>
    <url>/2021/07/06/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/</url>
    
    <content type="html"><![CDATA[<h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs js">git clone git@github.com:Lin-Tui/gitTest.git <span class="hljs-comment">//克隆远程版本库到本地（这个步骤前无需添加该远程仓库）</span><br>git clone -b remote_branchName git@github.com:Lin-Tui/gitTest.git <span class="hljs-comment">//克隆指定的远程分支到本地</span><br>git init <span class="hljs-comment">//初始化本地版本库</span><br></code></pre></td></tr></table></figure><h4 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">touch fileName <span class="hljs-comment">//创建文件</span><br>mkdir dirName <span class="hljs-comment">//在当前目录创建文件夹</span><br>rm fileName <span class="hljs-comment">//删除指定文件 </span><br>rm -r dirName  <span class="hljs-comment">//删除指定文件夹</span><br>cat fileName <span class="hljs-comment">//查看文件内容</span><br>cd dirName <span class="hljs-comment">//进入该文件夹</span><br>cd . <span class="hljs-comment">//返回上级目录</span><br>cd .. <span class="hljs-comment">//返回上上级目录</span><br>git status <span class="hljs-comment">// 查看状态</span><br>git diff <span class="hljs-comment">// 查看变更内容</span><br>git mv oldFileName newFileName  <span class="hljs-comment">//更改文件名</span><br>git * rm <span class="hljs-comment">//删除所有文件 </span><br>git * rm -r <span class="hljs-comment">//删除所有文件夹</span><br>git add . <span class="hljs-comment">//暂存所有文件</span><br>git add fileName <span class="hljs-comment">//暂存指定文件</span><br>git commit fileName -m <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment">//提交指定文件</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment">//提交所有更新过的文件</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span> -a <span class="hljs-comment">//暂存所有修改并提交</span><br></code></pre></td></tr></table></figure><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">git log <span class="hljs-comment">//查看历史</span><br>git log -p fileName <span class="hljs-comment">//查看指定文件的提交历史</span><br>git blame fileName <span class="hljs-comment">//修改最后一次提交</span><br></code></pre></td></tr></table></figure><h4 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">git branch <span class="hljs-comment">//列出所有本地分支 </span><br>git branch -r <span class="hljs-comment">//列出所有远程分支</span><br>git branch local_branchName <span class="hljs-comment">//创建本地分支</span><br>git branch -d local_branchName <span class="hljs-comment">//删除指定的本地分支</span><br>git checkout local_branchName <span class="hljs-comment">//切换到指定分支</span><br>git checkout -b local-branchName <span class="hljs-comment">//创建并切换到新的本地分支</span><br>git tag <span class="hljs-comment">//查看所有本地标签</span><br>git tag --list <span class="hljs-comment">//查看所有本地标签</span><br>git tag tagName <span class="hljs-comment">//给当前分支打标签</span><br>git push origin tagName  <span class="hljs-comment">//推送当前标签</span><br>git push --tag <span class="hljs-comment">//上传所有标签</span><br>git tag -d tagName <span class="hljs-comment">//删除当前分支标签</span><br>git push origin :tagName  <span class="hljs-comment">//删除当前分支标签</span><br></code></pre></td></tr></table></figure><h4 id="分支与合"><a href="#分支与合" class="headerlink" title="分支与合"></a>分支与合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">git merge branchName <span class="hljs-comment">//合并分支</span><br>git rebase branchName <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">git remote -v  <span class="hljs-comment">//查看远程版本库信息</span><br>git remote show &lt;remote&gt; <span class="hljs-comment">//查看指定远程版本库信息</span><br>git remote add origin git@github.com:Lin-Tui/gitTest.git<span class="hljs-comment">//添加指定远程版本库。新建一个本地仓库就要为该本地仓库添加远程版本库。</span><br>git fetch &lt;remote&gt; <span class="hljs-comment">//从远程版本库获取代码</span><br>git pull <span class="hljs-comment">//将当前分支推送到远程同名且关联的分支上</span><br>git pull origin master <span class="hljs-comment">//这个命令可以在本地任意分支上使用，拉取默认分支代码及快速合并</span><br>git pull origin remote_branchName <span class="hljs-comment">//拉取指定分支的代码并快速合并</span><br>git push --set-upstream origin remote_branchName <span class="hljs-comment">//将当前分支与指定远程分支建立关联</span><br>git push  <span class="hljs-comment">//在当前本地分支推送到远程同名的且关联的分支上，并快速合并</span><br>git push origin master (--force)<span class="hljs-comment">// 将本地master分支推送到默认远程仓库master上并快速合并，括号内容可选（不是强制提交）</span><br>git push origin local_branchName:remote_branchName <span class="hljs-comment">//推送任意指定本地分支上的代码到任意指定远程仓库分支上.local_branchName必须为你本地存在的分支，remote_branchName为远程分支，如果remote_branchName不存在则会自动创建分支。</span><br>git push origin remote_branchName<span class="hljs-comment">// 创建一个远程仓库的新分支</span><br>git push origin :remote_branchName <span class="hljs-comment">// 删除远程分支</span><br>下载和上传指定分支<br></code></pre></td></tr></table></figure><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">git checkout a.js <span class="hljs-comment">//撤销对指定的还未暂存(工作区)的文件的修改.(这个命令会用暂存区指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。)</span><br>git checkout . <span class="hljs-comment">//撤销对所有的还未暂存(工作区)的文件的修改.(这个命令会用暂存区全部文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。)</span><br>git checkout head a.js <span class="hljs-comment">// 撤销对暂存区和工作区中指定文件的修改，将上次提交的内容替换到暂存区和工作区中。</span><br>git checkout head . <span class="hljs-comment">// 撤销对暂存区和工作区中所有文件的修改，将上次提交的内容替换到暂存区和工作区中。</span><br>git reset HEAD a.js <span class="hljs-comment">// 撤销对暂存区的修改，但工作区仍和原来一样。(将咱暂存区和HEAD的提交保持一致)</span><br>git reset --hard HEAD <span class="hljs-comment">// 撤销对暂存区和工作区的修改。(将工作区、暂存取和HEAD保持一致)</span><br>git revert &lt;commit&gt; <span class="hljs-comment">//撤销指定的提交，回退到指定版本。&lt;commit&gt;为想回退的版本后一个版本</span><br>git reset --hard &lt;commit&gt; <span class="hljs-comment">//撤销指定的提交，回退到指定版本。并且在git push 后远程的相关提交历史会被清除。&lt;commit&gt;为想回退的版本。</span><br></code></pre></td></tr></table></figure><p><a href="https://juejin.im/entry/5b802f2f6fb9a019eb43bb42?tdsourcetag=s_pctim_aiomsg">Git常用命令速查表（收藏大全）</a></p><p>保存已修改的git stash</p><p>建立新分支之后，将原来的改动放到现在的新分支上</p><p>git stash pop</p><ol><li>上次提交后，hello.js 里面是空的。 </li><li>在工作区往 hello.js 里添加一行 111</li><li>git add hello.js</li><li>现在工作区和暂存区的hello.js都是只有一行 111。</li><li>将工作区的hello.js添加一行222</li><li>git checkout hello.js</li><li>现在工作区和暂存区的hello.js都是只有一行 111。</li><li>将工作区的hello.js添加一行222</li><li>git reset head hello.js</li><li>现在工作区有两行，不变。暂存区回到上次提交时的样子，是0行。</li><li>验证，用 git checkout hello.js</li><li>现在工作区和暂存区的hello.js都为空。</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目开发常用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令快查</title>
    <link href="/2021/07/06/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%9F%A5/"/>
    <url>/2021/07/06/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="Git常用命令备忘快查"><a href="#Git常用命令备忘快查" class="headerlink" title="Git常用命令备忘快查"></a>Git常用命令备忘快查</h2><h3 id="1-git-config"><a href="#1-git-config" class="headerlink" title="1. git config"></a>1. git config</h3><ul><li><p>配置个人的用户名称和电子邮件地址：</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;runoob&quot;</span><br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> test@runoob<span class="hljs-variable">.com</span><br></code></pre></td></tr></table></figure></li><li><p>查看配置信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git config --list<br><span class="hljs-variable">$ </span>git congig -l<br></code></pre></td></tr></table></figure></li><li><p>查阅某个环境变量的设定，只要把特定的名字跟在后面即可:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git config <span class="hljs-keyword">user</span>.name<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-git-init"><a href="#2-git-init" class="headerlink" title="2. git init"></a>2. git init</h3><ul><li><p>在当前目录中创建新的Git仓库，生成一个 .git 目录</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure></li><li><p>使用我们指定目录作为Git仓库</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">git <span class="hljs-function"><span class="hljs-keyword">init</span> &lt;directoryName&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-git-clone"><a href="#3-git-clone" class="headerlink" title="3. git clone"></a>3. git clone</h3><ul><li><p>拷贝一个Git仓库到本地，让自己能够查看该项目，或者进行修改。命令格式为：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;repo</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>克隆到指定的目录，可以使用以下命令格式：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;repo</span>&gt; <span class="hljs-tag">&lt;directoryName&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>repo:</strong> Git 仓库。</li><li><strong>directory:</strong> 本地目录。</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:schacon/simplegit.git<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-git-add"><a href="#4-git-add" class="headerlink" title="4. git add"></a>4. git add</h3><ul><li><p>将文件添加到缓存：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-builtin-name">add</span> README hello.php <br></code></pre></td></tr></table></figure></li></ul><h3 id="5-git-status"><a href="#5-git-status" class="headerlink" title="5. git status"></a>5. git status</h3><ul><li><p>用于查看项目的当前状态, 在你上次提交之后是否有修改.加了<code>-s</code>参数，以获得简短的结果输出。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git status<br><span class="hljs-variable">$ </span>git status -s<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-git-diff"><a href="#6-git-diff" class="headerlink" title="6. git diff"></a>6. git diff</h3><p>执行 <code>git diff </code>来查看执行 <code>git status</code> 的结果的详细信息。</p><p><code>git diff</code> 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。<code>git diff</code> 有两个主要的应用场景。</p><ul><li>尚未缓存的改动：**<code>git diff</code>**</li><li>查看已缓存的改动： <strong><code>git diff --cached</code></strong></li><li>查看已缓存的与未缓存的所有改动：**<code>git diff HEAD</code>**</li><li>显示摘要而非整个 diff：**<code>git diff --stat</code>**</li></ul><h3 id="7-git-commit"><a href="#7-git-commit" class="headerlink" title="7. git commit"></a>7. git commit</h3><p>使用 <code>git add</code> 命令将想要快照的内容写入缓存区， 而执行 <code>git commit</code> 将缓存区内容添加到仓库中。</p><p>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。(最上面两行代码)</p><ul><li><p>使用 <code>-m</code> 选项以在命令行中提供提交注释</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;第一次版本提交&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>如果你没有设置<code>-m</code>选项，Git 会尝试为你打开一个编辑器以填写提交信息。如果你觉得 <code>git add</code> 提交缓存的流程太过繁琐，Git 也允许你用<code> -a</code> 选项跳过<code>git add</code>这一步。命令格式如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git commit -am</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="8-git-reset-HEAD"><a href="#8-git-reset-HEAD" class="headerlink" title="8. git reset HEAD"></a>8. git reset HEAD</h3><ul><li><p><code>git reset HEAD</code> 命令用于取消已缓存的内容。</p><p>执行 <code>git reset HEAD</code> 以取消之前 <code>git add</code> 添加，但不希望包含在下一提交快照中的缓存。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-meta">reset</span> HEAD &lt;<span class="hljs-meta">fileName</span>&gt; <br></code></pre></td></tr></table></figure></li></ul><h3 id="9-git-rm"><a href="#9-git-rm" class="headerlink" title="9. git rm"></a>9. git rm</h3><ul><li><p>要从工作目录 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git rm <span class="hljs-tag">&lt;<span class="hljs-name">fileName</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> &lt;file&gt;<br></code></pre></td></tr></table></figure></li><li><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached</code> 选项即可:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">git <span class="hljs-keyword">rm</span> --cached &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> –<span class="hljs-built_in">r</span> * <br></code></pre></td></tr></table></figure></li></ul><h3 id="10-git-mv"><a href="#10-git-mv" class="headerlink" title="10. git mv"></a>10. git mv</h3><ul><li><p>git mv 命令用于移动或重命名一个文件、目录、软连接。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git <span class="hljs-built_in">mv</span> README  README.md<br></code></pre></td></tr></table></figure></li></ul><p>​      (把文件README 重命名为 README.md)</p><h3 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h3><ul><li><p>创建目录：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ mkdir runoob<br></code></pre></td></tr></table></figure></li><li><p>打开目录：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;directoryName&gt;/<br></code></pre></td></tr></table></figure></li><li><p>添加文件：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>touch README<br><span class="hljs-variable">$ </span>touch hello.php<br></code></pre></td></tr></table></figure></li><li><p>列举目录下的文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ul><li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li></ul></li></ul><ul><li><p><strong>暂存区</strong>：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</p><ul><li><strong>版本库</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br><img src="https://img-blog.csdnimg.cn/20200130223232160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图中：</li></ul><ol><li><p>左侧为工作区</p></li><li><p>右侧为版本库。其中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。</p></li><li><p>“HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</p></li><li><p>objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p></li></ol><ul><li><p>当对工作区修改（或新增）的文件执行 <code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作<code>git commit</code>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 <code>git reset HEAD&quot;</code>命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;&quot;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目开发常用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS学习笔记</title>
    <link href="/2020/11/06/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/06/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="琐碎笔记"><a href="#琐碎笔记" class="headerlink" title="琐碎笔记"></a>琐碎笔记</h1><h2 id="一-ES6-Modules-和-CommonJS"><a href="#一-ES6-Modules-和-CommonJS" class="headerlink" title="一. ES6 Modules 和 CommonJS"></a>一. ES6 Modules 和 CommonJS</h2><p><strong><a href="https://www.cnblogs.com/qixidi/p/10287679.html">深入 CommonJs 与 ES6 Module</a></strong></p><h2 id="二-Typescript-和-Javascript"><a href="#二-Typescript-和-Javascript" class="headerlink" title="二. Typescript 和 Javascript"></a>二. Typescript 和 Javascript</h2><p><a href="https://www.cnblogs.com/langzianan/p/8403332.html"><strong>Typescript 和 Javascript之间的区别</strong></a></p><h2 id="三"><a href="#三" class="headerlink" title="三."></a>三.</h2><h4 id="1-类型声明空间"><a href="#1-类型声明空间" class="headerlink" title="1. 类型声明空间"></a>1. 类型声明空间</h4><p>类型声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;;<br><span class="hljs-keyword">interface</span> Bar &#123;&#125;;<br><span class="hljs-keyword">type</span> Bas = &#123;&#125;;<br></code></pre></td></tr></table></figure><p>将上面作为类型注释：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> foo: Foo;<br><span class="hljs-keyword">let</span> bar: Bar;<br><span class="hljs-keyword">let</span> bas: Bas;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>： 尽管定义了interface Bar，却并不能把它作为一个变量来使用，因为他没有定义在变量空间中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Bar &#123;&#125;;<br><span class="hljs-keyword">const</span> bar = Bar; <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><h4 id="2-变量声明空间"><a href="#2-变量声明空间" class="headerlink" title="2. 变量声明空间"></a>2. 变量声明空间</h4><p>变量声明空间包含可用变量的内容，在上文中 class Foo提供了一个类型Foo到类型声明空间，此外它同样提供了一个变量Foo到变量声明空间。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;;<br><span class="hljs-keyword">const</span> someVar = Foo;<br><span class="hljs-keyword">const</span> someOtherVar = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>： 一些用var声明的变量，也只能在变量声明空间使用，不能用作类似注解。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> foo = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">let</span> bar: foo; <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><h4 id="3-类型注解"><a href="#3-类型注解" class="headerlink" title="3. 类型注解"></a>3. 类型注解</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-number">123</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>(<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>&#123;<br><span class="hljs-keyword">return</span> num<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript<strong>原始类型</strong>也同样适应于TypeScript的类型系统，因此string，number，boolean也可以被用作类型注解。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> str: <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">let</span> bool: <span class="hljs-built_in">boolean</span>;<br>num = <span class="hljs-number">123</span>;<br>num = <span class="hljs-number">123.456</span>;<br>num = <span class="hljs-string">&#x27;123&#x27;</span>; <span class="hljs-comment">//Error</span><br>str = <span class="hljs-string">&#x27;123&#x27;</span>;<br>str = <span class="hljs-number">123</span>; <span class="hljs-comment">//Error</span><br>bool = <span class="hljs-literal">true</span>;<br>bool = <span class="hljs-literal">false</span>;<br>bool = <span class="hljs-string">&#x27;false&#x27;</span>; <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><p><strong>数组</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> boolArray: <span class="hljs-built_in">boolean</span>[];<br>boolArray = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>];<br><span class="hljs-built_in">console</span>.log(boolArray[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">console</span>.log(boolArray.length);<br>boolArray[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>boolArray = [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>];<br>boolArray[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;false&#x27;</span>; <span class="hljs-comment">//Error</span><br>boolArray = <span class="hljs-string">&#x27;false&#x27;</span>; <span class="hljs-comment">//Error</span><br>boolArray = [<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;false&#x27;</span>]; <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><p><strong>接口</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Name &#123;<br>    <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>;<br>    second: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">let</span> name: Name;<br>name = &#123;<br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">second</span>: <span class="hljs-string">&#x27;Doe&#x27;</span><br>&#125;;<br>name = &#123;<br>    <span class="hljs-comment">// Error: &#x27;second is missing&#x27;</span><br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;John&#x27;</span><br>&#125;<br>name = &#123;<br>    <span class="hljs-comment">// Error: &#x27;second is the wrong type&#x27;</span><br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">second</span>: <span class="hljs-number">1337</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内联类型</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> name: &#123;<br>    <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>;<br>    second: <span class="hljs-built_in">string</span>;<br>&#125;;<br>name = &#123;<br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">second</span>: <span class="hljs-string">&#x27;Doe&#x27;</span><br>&#125;;<br>name = &#123;<br>     <span class="hljs-comment">// Error: &#x27;second is missing&#x27;</span><br>    <span class="hljs-attr">fisrt</span>: <span class="hljs-string">&#x27;John&#x27;</span><br>&#125;;<br>name = &#123;<br>    <span class="hljs-comment">// Error: &#x27;second is the wrong type&#x27;</span><br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">second</span>: <span class="hljs-number">1337</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特殊类型</strong>： any、null、undefined、void</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> power: <span class="hljs-built_in">any</span>;<br>power = <span class="hljs-string">&#x27;123&#x27;</span>;<br>power = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span>;<br>power = num;<br>num = power;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> str: <span class="hljs-built_in">string</span>;<br>num = <span class="hljs-literal">null</span>;<br>str = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(message);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">items: T[]</span>):<span class="hljs-title">T</span>[] </span>&#123;<br>    <span class="hljs-keyword">const</span> toreturn = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = items.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>        toreturn.push(items[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> toreturn<br>&#125;<br><span class="hljs-keyword">const</span> sample = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> reversed = reverse(sample);<br><span class="hljs-built_in">console</span>.log(reversed); <span class="hljs-comment">//3, 2, 1</span><br>reversed[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-comment">//Error</span><br>reversed = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]; <span class="hljs-comment">//Error</span><br>reversed[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//Ok</span><br>reversed = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">//Ok</span><br></code></pre></td></tr></table></figure><p><strong>联合类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatCommandline</span>(<span class="hljs-params">command: <span class="hljs-built_in">string</span>[] | <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> line = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> command === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        line = command.trim();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        line = command.join(<span class="hljs-string">&#x27; &#x27;</span>).trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>交叉类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">U</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt; (<span class="hljs-params">first: T, second: U</span>): <span class="hljs-title">T</span> &amp; <span class="hljs-title">U</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;<br>    for (let id in first) &#123;<br>        (&lt;T&gt;result)[id] = first[id];<br>    &#125;<br>    for (let id in second) &#123;<br>        if (!result.hasOwnProperty(id)) &#123;<br>            (&lt;U&gt;result[id] = second[id]);<br>        &#125;<br>    &#125;<br>    return result<br>&#125;<br>const x = extend(&#123;a: &#x27;hello&#x27;&#125;, &#123;b: 42&#125;);<br>const a = x.a;<br>const b = x.b;<br></code></pre></td></tr></table></figure><p><strong>元组类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> nameNumber: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br>nameNumber = [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">123</span>];<br>nameNumber = [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>]; <span class="hljs-comment">//Error</span><br><span class="hljs-keyword">const</span> [name, num] = nameNumber;<br></code></pre></td></tr></table></figure><p><strong>类型别名</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> StrOrNum = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">let</span> sample: StrOrNum;<br>sample = <span class="hljs-number">123</span>;<br>sample = <span class="hljs-string">&#x27;123&#x27;</span>;<br><br><span class="hljs-comment">// 会检查类型</span><br>sample = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">type</span> Text = <span class="hljs-built_in">string</span> | &#123; <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">type</span> Coordinates = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-keyword">type</span> Callback = <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><h4 id="4-减少错误"><a href="#4-减少错误" class="headerlink" title="4. 减少错误"></a>4. 减少错误</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> foo = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">let</span> bar = <span class="hljs-string">&#x27;hey&#x27;</span>;<br>bar = foo; <span class="hljs-comment">//Error</span><br>bar = foo <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>; <span class="hljs-comment">//Ok</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">let</span> bar = <span class="hljs-string">&#x27;hey&#x27;</span>;<br>bar = foo(); <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>): <span class="hljs-title">any</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">let</span> bar = <span class="hljs-string">&#x27;hey&#x27;</span>;<br>bar = foo();<br></code></pre></td></tr></table></figure><h4 id="5-接口"><a href="#5-接口" class="headerlink" title="5. 接口"></a>5. 接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//内联注释：</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> myPoint: &#123;<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>&#125;;<br><span class="hljs-comment">//等效于下面的接口形式：</span><br><span class="hljs-keyword">interface</span> Point &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    y: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> myPoint: Point;<br></code></pre></td></tr></table></figure><p><strong>类可以实现接口</strong>：</p><p>如果希望在类中使用必须被遵循的接口或别人定义的对象结构，可以使用 implements关键字来确保其兼容性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Point &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    y: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPoint</span> <span class="hljs-title">implements</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    y: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上，在implements存在的情况下，该外部Point接口的任何更改都将导致代码库中的编译错误，因此可以轻松地使其保持同步。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Point &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    y: <span class="hljs-built_in">number</span>;<br>    z: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPoint</span> <span class="hljs-title">implements</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-comment">//Error: missing member;</span><br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    y: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>： implements限制了类实例的结构，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> foo:Point = <span class="hljs-keyword">new</span> MyPoint();<br></code></pre></td></tr></table></figure><h4 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6. 枚举"></a>6. 枚举</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> CardSuit &#123;<br>    Clubs,<br>    Diamonds,<br>    Hearts,<br>    Spades<br>&#125;<br><span class="hljs-keyword">let</span> Card = CardSuit.Clubs;<br><span class="hljs-comment">// 类型安全</span><br>Card = <span class="hljs-string">&#x27;not a member of card suit&#x27;</span>; <span class="hljs-comment">// Error: string 不能赋值给 `CardSuit` 类型</span><br></code></pre></td></tr></table></figure><p>数字类型枚举与数字类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;<br>  Red,<br>  Green,<br>  Blue<br>&#125;<br><br><span class="hljs-keyword">let</span> col = Color.Red;<br>col = <span class="hljs-number">0</span>; <span class="hljs-comment">// 有效的，这也是 Color.Red</span><br></code></pre></td></tr></table></figure><p>默认情况下，第一个枚举值是 <code>0</code>，然后每个后续值依次递增 1：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;<br>  Red, <span class="hljs-comment">// 0</span><br>  Green, <span class="hljs-comment">// 1</span><br>  Blue <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>但是，你可以通过特定的赋值来改变给任何枚举成员关联的数字，如下例子，我们从 3 开始依次递增：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;<br>  DarkRed = <span class="hljs-number">3</span>, <span class="hljs-comment">// 3</span><br>  DarkGreen, <span class="hljs-comment">// 4</span><br>  DarkBlue <span class="hljs-comment">// 5</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h4><p><strong>参数注解</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sampleVariable: &#123;<span class="hljs-attr">bar</span>: number&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">sampleParameter: &#123;bar: number&#125;</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>返回类型注解</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Foo &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">sample:Foo</span>): <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sample;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常，不需要注解函数的返回类型，因为它可以由编译器推断：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Foo &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">sample: Foo</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> sample; <span class="hljs-comment">//inferred return type &#x27;Foo&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可选参数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">bar: <span class="hljs-built_in">number</span>, bas?:<span class="hljs-built_in">string</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-comment">//..</span><br>&#125;<br>foo(<span class="hljs-number">123</span>);<br>foo(<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>默认参数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">barL <span class="hljs-built_in">number</span>, bas:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;hello&#x27;</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(bar, bas)<br>&#125;<br>foo(<span class="hljs-number">123</span>); <span class="hljs-comment">//123, hello</span><br>foo(<span class="hljs-number">123</span>, ;world); <span class="hljs-comment">//123, world</span><br></code></pre></td></tr></table></figure><p><strong>函数声明</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//在没有提供函数实现的情况下，有两种函数类型的方式：</span><br><span class="hljs-keyword">type</span> longHand = &#123;<br>    (a: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> ShortHand = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><span class="hljs-comment">//当想使用函数重载时，只能用第一种方式：</span><br><span class="hljs-keyword">type</span> LongHandAllowsOverloadDeclarations = &#123;<br>    (a: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>(a: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="8-可调用的"><a href="#8-可调用的" class="headerlink" title="8. 可调用的"></a>8. 可调用的</h4><p>可以使用类型别名或者接口来表示一个可被调用的类型注解：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ReturnString &#123;<br>    (): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它可以表示一个返回值为string的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> foo: ReturnString;<br><span class="hljs-keyword">const</span> bar = foo(); <span class="hljs-comment">//bar 被推断为一个字符串</span><br></code></pre></td></tr></table></figure><h4 id="9-类型断言"><a href="#9-类型断言" class="headerlink" title="9. 类型断言"></a>9. 类型断言</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> foo = &#123;&#125;;<br>foo.bar = <span class="hljs-number">123</span>;<br>foo.bas = <span class="hljs-string">&#x27;hello&#x27;</span> <br><span class="hljs-comment">//Error  &#x27;bar&#x27;,&#x27;bas&#x27;属性不存在于&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>上面错误可通过类型断言来避免：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Foo &#123;<br>    <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;<br>    bas: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">const</span> foo = &#123;&#125; <span class="hljs-keyword">as</span> Foo;<br>foo.bar = <span class="hljs-number">123</span>;<br>foo.bas = <span class="hljs-string">&#x27;hello&#x27;</span>;<br></code></pre></td></tr></table></figure><p>类型断言可能存在害处，如果没有按照约定添加属性，typescript编译器并不会对此发出错误警告：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Foo &#123;<br>    <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;<br>    bas: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">const</span> foo = &#123;&#125; <span class="hljs-keyword">as</span> Foo;<br><span class="hljs-comment">// 忘记了什么</span><br></code></pre></td></tr></table></figure><h4 id="10-readonly"><a href="#10-readonly" class="headerlink" title="10. readonly"></a>10. readonly</h4><p>typescript类型系统允许你在一个接口使使用readonly来标记属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">config:&#123;<span class="hljs-keyword">readonly</span> bar: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">readonly</span> bas: <span class="hljs-built_in">number</span>&#125;</span>) </span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">const</span> config = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">bas</span>: <span class="hljs-number">123</span>&#125;;<br>foo(config);<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Foo = &#123;<br>    <span class="hljs-keyword">readonly</span> bar: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">readonly</span> bas: <span class="hljs-built_in">number</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> foo: Foo = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">bas</span>: <span class="hljs-number">456</span>&#125;;<br>foo.bar = <span class="hljs-number">456</span><span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//也能指定一个类的属性为只读，然后声明时或者构造函数中初始化它们。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">readonly</span> bar = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">readonly</span> baz: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.baz = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment">//ok</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有一个<strong>Readonly</strong>的映射类型，它接收一个泛型T，用来把它的所有属性标记为只读类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Foo = &#123;<br>    <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;<br>    bas: <span class="hljs-built_in">number</span>;<br>&#125;;<br><span class="hljs-keyword">type</span> FooReadonly = Readonly&lt;Foo&gt;;<br><span class="hljs-keyword">const</span> foo: Foo = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">bas</span>: <span class="hljs-number">456</span>&#125;;<br><span class="hljs-keyword">const</span> fooReadonly: FooReadonly = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">bas</span>: <span class="hljs-number">456</span>&#125;;<br>foo.bar = <span class="hljs-number">456</span>;<br>fooReadonly.bar = <span class="hljs-number">456</span>; <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><p>甚至可以把索引标记为只读：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Foo &#123;<br>    <span class="hljs-keyword">readonly</span> [X: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> foo: Foo = &#123;<span class="hljs-number">0</span>: <span class="hljs-number">123</span>, <span class="hljs-number">2</span>: <span class="hljs-number">345</span>&#125;;<br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-number">0</span>]);<br>foo[<span class="hljs-number">0</span>] = <span class="hljs-number">456</span>; <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> foo:ReadonlyArray&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-number">0</span>]);<br>foo.push(<span class="hljs-number">4</span>); <span class="hljs-comment">//Error</span><br>foo = foo.concat(<span class="hljs-number">4</span>); <span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><h4 id="11-泛型"><a href="#11-泛型" class="headerlink" title="11. 泛型"></a>11. 泛型</h4><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：</p><ul><li>类的实例成员</li><li>类的方法</li><li>函数参数</li><li>函数返回值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> data = [];<br>    push = <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">this</span>.data.push(item);<br>    pop = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.data.shift()<br>&#125;<br><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue();<br>queue.push(<span class="hljs-number">0</span>);<br>queue.push(<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueNumber</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> data = [];<br>    push = <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">this</span>.data.push(item);<br>    pop = (): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> <span class="hljs-built_in">this</span>.data.shift();<br>&#125;<br><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> QueueNumber();<br>queue.push(<span class="hljs-number">0</span>);<br>queue.push(<span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> data: T[] = [];<br>    push = <span class="hljs-function">(<span class="hljs-params">item: T</span>) =&gt;</span> <span class="hljs-built_in">this</span>.data.push(item);<br>    pop = (): T | <span class="hljs-function"><span class="hljs-params">undefined</span> =&gt;</span> <span class="hljs-built_in">this</span>.data.shift();<br>&#125;<br><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">number</span>&gt;();<br>queue.push(<span class="hljs-number">0</span>);<br>queue.push(<span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TypeScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记</title>
    <link href="/2020/11/06/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/06/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-TypeScript基础"><a href="#一-TypeScript基础" class="headerlink" title="一. TypeScript基础"></a>一. TypeScript基础</h1><h2 id="1-什么是TypeScript"><a href="#1-什么是TypeScript" class="headerlink" title="1. 什么是TypeScript"></a>1. 什么是TypeScript</h2><p>​    鉴于JavaScript目前在大规模、可扩展应用上的不足，微软公司设计了TypeScript语言。TypeScript语言具有静态类型检测和面向对象的特征，在编译阶段可以及时发现语法错误，同时支持分模块开发，编译后转换成原生的JavaScript代码，可以直接运行在各类浏览器上，而不需要额外的配置。</p><p>​    TypeScript本质上是在JavaScript语言中添加了可选的静态类型和基于类的面向对象编程等新特性。</p><p>Typescript是JavaScript的超集，专门为开发大规模可扩展的应用程序而设计的，且可编译为原生JavaScript的一种静态类型语言。</p><p><strong>Typescript语言特点</strong>：</p><ul><li>TYpeScript是以JavaScript为基础</li><li>TypeScript支持第三方JavaScript库</li><li>TypeScript是可移植的</li><li>TypeScript是静态类型语言</li></ul><h2 id="2-为什么要学习TypeScript"><a href="#2-为什么要学习TypeScript" class="headerlink" title="2. 为什么要学习TypeScript"></a>2. 为什么要学习TypeScript</h2><p>​    由于目前各主流浏览器中JavaScript引擎还没有完全实现ES6的特性，如JavaScript模块导入与导出和面向对象编程的类与接口等。另外，JavaScript是一种动态语言，很难做到静态类型检查。这将导致很多JavaScript语法问题在编码阶段无法暴露，而只能运行时暴露。</p><p>​    这种背景下，微软使用Apache授权协议推出开源语言TypeScript，增加了可选类型、与模块等特征，可编译成标准的JavaScript代码，并保证编译后的JavaScript代码兼容性。另外，TypeScript是一门静态类型语言，本身具有静态类型检查的功能，很好地弥补了JavaScript在静态类型检查上的不足。</p><p>​    TypeScript非常适合开发大规模可扩展的JavaScript应用程序。</p><ul><li>面向对象特征，支持类、接口、命名空间和模块等。</li><li>静态类型检查，可以在编码阶段检查代码有无语法错误。</li><li>胜任大规模可扩展应用开发，这是TypeScript诞生的初心。</li><li>更高的编码效率，通过IED可以实现代码补全、接口提示。跳转到定义和代码重构等操</li><li>兼容JavaScript语法，同时支持ES6特征，可以使用最先进JavaScript语法。</li></ul><p><strong>TypeScript相比JavaScript的优势</strong></p><ul><li><p>编译时检查：</p><p>TypeScript是静态类型的语言，静态类型可以让开发工具在编码阶段（编译阶段）即时检测各类语法错误。</p></li><li><p>面向对象特征：</p><p>面向对象程序可以更好地构建大规模应用程序，通过对现实问题合理地抽象，可以利用面向对象特征中的接口、类等来构建可复用、易扩展的大型应用程序。TypeScript支持面向对象功能，可以更好地构建大型JavaScript应用程序。</p></li><li><p>更好的协作：</p><p>TypeScript支持分模块开发，这样可以更好地进行分工协作，最后在合并的时候解决命名冲突等问题，这对于团队协作来说是至关重要的。</p></li><li><p>更强的生产力：</p><p>TypeScript遵循ES6规范，可以让代码编辑器IDE实现代码智能提示，代码自动完成和diamante重构等操作，这些功能有助于提高开发人员的工作效率。</p></li></ul><p><strong>TypeScript给前端开发带来的好处</strong></p><ul><li><p>提高编码效率和代码质量</p><p>传统的JavaScript在编写代码时，往往比较痛苦的是没有一个很好的编辑器IDE，可以像C#或者java那样，IDE对代码进行智能提示和语法错误检查，从而导致JavaScript代码在编码阶段很难发生潜在发错误。</p><p>TypeScript是一种静态类型语言，可以让编辑器实现包括代码补全、接口提示、跳转到定义和代码重构等操作。借助编辑器，可以在编译阶段就发现大部分语法错误，这总比JavaScript在运行时发现错误要好得多。</p></li><li><p>增加了代码的可读性和可维护性</p></li><li><p>胜任大规模应用开发</p><p>TypeScript是具有面向对象特征的编程语言，在大规模应用开发中，可以利用模块和类等特征对代码进行合理规划，达到高内聚低耦合的目的。TypeScript可以让复杂的代码结构更加清晰、一致和简单，降低了代码后续维护和升级的难度。因此，在面对大型应用开发时，使用TypeScript往往更加合适。</p></li><li><p>使用最先进的JavaScript语法</p></li></ul><h2 id="3-TypeScript的组成部分"><a href="#3-TypeScript的组成部分" class="headerlink" title="3. TypeScript的组成部分"></a>3. TypeScript的组成部分</h2><p>TypeScript整个体系组成比较复杂，从本质上讲它主要由以下3个部分构成。</p><ul><li>TypeScript编译器核心：包括语法、关键字和类型注释等。</li><li>独立的TypeScript编译器：将TypeScript编写的代码转换成等效的JavaScript代码，可以通过参数动态生成ES5 或者ES3等目标代码。</li><li>TypeScript语言服务：在TypeScript编译器核心层上公开一个额外的层，是类似编辑器的应用程序。语言服务支持常用的代码编辑器中需要的操作，如代码智能提示，代码重构、代码格式化、代码折叠和着色等。</li></ul><h1 id="二-TypeScript基本语法"><a href="#二-TypeScript基本语法" class="headerlink" title="二. TypeScript基本语法"></a>二. TypeScript基本语法</h1><h2 id="1-简单语法"><a href="#1-简单语法" class="headerlink" title="1. 简单语法"></a>1. 简单语法</h2><h4 id="（1）变量声明："><a href="#（1）变量声明：" class="headerlink" title="（1）变量声明："></a>（1）变量声明：</h4><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> 或 <span class="hljs-keyword">var</span> 变量名： 数据类型 = 初始化值<br><span class="hljs-comment">//例如：</span><br><span class="hljs-keyword">let</span> varName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h2><h4 id="（2）基础类型"><a href="#（2）基础类型" class="headerlink" title="（2）基础类型"></a>（2）基础类型</h4><ul><li>数值型 number</li><li>布尔型 boolean</li><li>字符型 string</li></ul><p>字符串和数字用+字符连接，那么结果将成为字符串。</p><p>字符串和布尔值用+拼接，也会生成字符串。</p><p>字符串和数组用字符串连接，那么结果将成为字符串，因此可以将空字符串和数组相加用于将数值的值转成用（，）分隔的一个字符串。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> res1 = <span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-number">5</span>; <span class="hljs-comment">// &#x27;5&#x27;</span><br><span class="hljs-keyword">let</span> res2 = <span class="hljs-literal">true</span> + <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// &#x27;true&#x27;</span><br><span class="hljs-keyword">let</span> res3 = <span class="hljs-string">&#x27;&#x27;</span> + [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// &#x27;1, 2, 3&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="（3）枚举"><a href="#（3）枚举" class="headerlink" title="（3）枚举"></a>（3）枚举</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 用enum关键词声明了一个名为Days的枚举类型，一般枚举类型的标识符首字母大写。</span><br><span class="hljs-built_in">enum</span> Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;<br><span class="hljs-comment">// 用自定义的枚举类型来声明一个新的变量today，并赋值为Days.Sun</span><br><span class="hljs-keyword">let</span> today: Days = Days.Sun;<br></code></pre></td></tr></table></figure><p>使用枚举可以限定我们的赋值范围，防止赋值错误，例如不能为today变量赋值为Days.OneDays。</p><p>一般情况下，枚举中的元素从0开始编码。同时也会对枚举值到枚举名进行反向映射。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;<br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Sun&#x27;</span>&#125; === <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Mon&#x27;</span>&#125; === <span class="hljs-number">1</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Tue&#x27;</span>&#125; === <span class="hljs-number">2</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Wed&#x27;</span>&#125; === <span class="hljs-number">3</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Sat&#x27;</span>&#125; === <span class="hljs-number">6</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;Sun&#x27;</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;Mon&#x27;</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days[<span class="hljs-number">2</span>] === <span class="hljs-string">&#x27;Tue&#x27;</span>); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Days[<span class="hljs-number">6</span>] === <span class="hljs-string">&#x27;Sat&#x27;</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>枚举支持连续编号和不连续编号，也支持部分编号和部分不编号。</p><p>给枚举类型进行手动赋值时，一定要注意手动编号和自动编号不要重复，否则会相互覆盖。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Days &#123;Sun = <span class="hljs-number">1</span>, Mon = <span class="hljs-number">2</span>, Tue = <span class="hljs-number">4</span>, Wed = <span class="hljs-number">3</span>, Thu = <span class="hljs-number">5</span>, Fri, Sat&#125;;<br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Sun&#x27;</span>&#125; === <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Mon&#x27;</span>&#125; === <span class="hljs-number">2</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Tue&#x27;</span>&#125; === <span class="hljs-number">4</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Wed&#x27;</span>&#125; === <span class="hljs-number">3</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Thu&#x27;</span>&#125; === <span class="hljs-number">5</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Fri&#x27;</span>&#125; === <span class="hljs-number">6</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Sat&#x27;</span>&#125; === <span class="hljs-number">7</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>枚举手动编号和自动编号如果出现重复，那么重复的枚举名会指向同一个值，而这个数值只会返回最后一个赋值的枚举名。TypeScript编辑器并不会提示错误或警告。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Days &#123;Sun = <span class="hljs-number">1</span>, Mon = <span class="hljs-number">2</span>, Tue = <span class="hljs-number">4</span>, Wed = <span class="hljs-number">3</span>, Thu, Fri, Sat&#125;;<br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Sun&#x27;</span>&#125; === <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Mon&#x27;</span>&#125; === <span class="hljs-number">2</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days&#123;<span class="hljs-string">&#x27;Tue&#x27;</span>&#125; === <span class="hljs-number">4</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(Days.Tue); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">console</span>.log(Days.Thu); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">console</span>.log(Days.Fri); <span class="hljs-comment">// 5</span><br><span class="hljs-built_in">console</span>.log(Days.Sat); <span class="hljs-comment">// 6</span><br><span class="hljs-built_in">console</span>.log(Days[<span class="hljs-number">4</span>]); <span class="hljs-comment">// Thu</span><br></code></pre></td></tr></table></figure><h4 id="（4）任意值"><a href="#（4）任意值" class="headerlink" title="（4）任意值"></a>（4）任意值</h4><p>​    TypeScript语言是一种静态类型的JavaScript，可以更好地进行编译检查和代码分析等，但有些时候TypeScript需要和JavaScript进行交互，这时就需要任意值（any）类型。</p><p>​    在某些情况下，编程阶段还不清楚要声明的变量是什么类型，这些值可能来自动态的内容，比如来自用户输入或第三方代码库。这种情况下，我们不希望类型检查器对这些值进行检查，此时可以声明一个任意值类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> myVar: <span class="hljs-built_in">any</span> = <span class="hljs-number">7</span>;<br>myVar = <span class="hljs-string">&#x27;maybe a string instead&#x27;</span>;<br>myVar = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>any类型上没有任何内置的属性和方法可以被调用，它只能在运行时检测该属性或方法是否存在。因此声明一个变量为任意值之后，编译器无法帮助你继续类型检测和代码提示。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br>notSure.ifItExits(); <span class="hljs-comment">//ifItExits方法在运行时可能存在</span><br>notSure.toFixed(); <span class="hljs-comment">//toFixed是数值4的方法</span><br><span class="hljs-keyword">let</span> prettySure: <span class="hljs-built_in">Object</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// 此处是大写的Object，不是小写的object</span><br>prettySure.toFixed(); <span class="hljs-comment">//错误object类型没有toFixed方法</span><br></code></pre></td></tr></table></figure><p>可以看出，any类型的变量可以调用任何方法和属性，但是Object类型的变量却不允许调用次类型之外的任何属性和方法，即使Object对象有这个属性和方法也不允许。</p><p>变量如果在声明的时候未明确指定其类型且未赋值，那么它会被识别到任意值类型。</p><p>TypeScript会在没有明确地指定类型的时候推测出一个类型，这就是类型推论。通过定义的时候没有赋值，不管之后有没有赋值，都会被推断成any类型而完全不被编译器进行类型检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> some; <span class="hljs-comment">//any类型</span><br>some = <span class="hljs-string">&#x27;Seven&#x27;</span>;<br>some = <span class="hljs-number">7</span>;<br>some.getName();<br></code></pre></td></tr></table></figure><h4 id="（5）空值、Null与Undefined"><a href="#（5）空值、Null与Undefined" class="headerlink" title="（5）空值、Null与Undefined"></a>（5）空值、Null与Undefined</h4><h4 id="（6）Never"><a href="#（6）Never" class="headerlink" title="（6）Never"></a>（6）Never</h4><h4 id="（7）Symbols"><a href="#（7）Symbols" class="headerlink" title="（7）Symbols"></a>（7）Symbols</h4><h4 id="（8）交叉类型"><a href="#（8）交叉类型" class="headerlink" title="（8）交叉类型"></a>（8）交叉类型</h4><p>交叉类型可以将多个类型合并成为一个类型，合并后的交叉类型包含了其中使用类型的特性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">dirverOnRoad</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;can driver on road&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">driverInWater</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;can driver in water&#x27;</span>)<br>    &#125;<br>&#125; <br><br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> Car();<br><span class="hljs-keyword">let</span> ship = <span class="hljs-keyword">new</span> Ship();<br><span class="hljs-keyword">let</span> carShip: Car &amp; Ship = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Car</span> &amp; <span class="hljs-attr">Ship</span>&gt;</span>; //Car &amp; Ship是Car和Ship的交叉类型</span><br><span class="xml">carShip[&#x27;driverOnRoad&#x27;] = car[&#x27;driverOnRoad&#x27;];</span><br><span class="xml">carShip[&#x27;driverInWater&#x27;] = ship[&#x27;driverWater&#x27;];</span><br><span class="xml">carShip.driverInWater();</span><br><span class="xml">carShip.driverOnRoad();</span><br></code></pre></td></tr></table></figure><h4 id="（9）Union类型"><a href="#（9）Union类型" class="headerlink" title="（9）Union类型"></a>（9）Union类型</h4><p>联合类型表示取值可以为多种类型中的一种。联合类型与交叉类型在用法上完全不一样。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padLeft</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, padding: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(padding + <span class="hljs-number">1</span>).join(<span class="hljs-string">&quot; &quot;</span>) +value;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> padding + value;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`参数为string或number，但传入<span class="hljs-subst">$&#123;padding&#125;</span>.`</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(padLeft(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">console</span>.log(padLeft(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-string">&#x27;_ &#x27;</span>))<br></code></pre></td></tr></table></figure><h4 id="（10）类型别名"><a href="#（10）类型别名" class="headerlink" title="（10）类型别名"></a>（10）类型别名</h4><p>联合类型往往比较长，也不容易记忆和书写，我们可以用类型别名来解决这个问题。类型别名可以用来给一个类型起一个新名字没。</p><p>类型别名的语法是：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">类型别名 </span>= 类型或表达式<br></code></pre></td></tr></table></figure><p>类别别名可以用于简单了下和自定义类型，也可以用于表达式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//用type给表达式() =&gt; string起一个别名myfunc；</span><br><span class="hljs-keyword">type</span> myfunc = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>;<br><span class="hljs-comment">// 用type 给联合类型string|number|myfunc起一个别名NameOrStringOrMyFunc。</span><br><span class="hljs-keyword">type</span> NameOrStringOrMyFunc = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | myFunc;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrStringOrMyFunc</span>): <span class="hljs-title">string</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（11）类型断言"><a href="#（11）类型断言" class="headerlink" title="（11）类型断言"></a>（11）类型断言</h4><p>类型断言可以用来手动指定一个值的类型。</p><p>类型断言的语法是:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-number">1.</span> &lt;类型&gt;值或者对象<br><span class="hljs-number">2.</span> 值或者对象 <span class="hljs-keyword">as</span> 类型<br><span class="hljs-comment">// 在tsx语法中必须使用后一种，因此&lt;&gt;有特殊意义。</span><br></code></pre></td></tr></table></figure><p>类型断言一般和联合类型一起使用，可以将一个联合类型的变量指定为一个更具体的类型进行操作，从而可以使用特定类型的属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-comment">//if (a as string).length &#123;</span><br>    <span class="hljs-keyword">if</span> ((&lt;<span class="hljs-built_in">string</span>&gt;a).length) &#123;<br>        <span class="hljs-keyword">return</span> (&lt;<span class="hljs-built_in">string</span>&gt;a).length;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a.toString().length;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(getLength(<span class="hljs-number">6</span>)); <span class="hljs-comment">//1</span><br><span class="hljs-built_in">console</span>.log(getLength(<span class="hljs-string">&#x27;hello&#x27;</span>)) <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p>联合类型string|number限定参数a的类型，可以用类型断言<code>&lt;string&gt;a</code>指定类型为string，从而可以调用字符的length属性，如果传入的是数值，那么会返回a.toString().length的值。类型断言成一个联合类型string|number 中不存在的类型是不允许的。</p><p>类型断言不是类型转换，且类型推断不能直接进行调用，需要放于条件判断中或者先将其转化成unknown在进行类型断言。</p><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>类型分为值类型和引用类型，所以变量可分为值类型变量和引用类型变量。</p><p>JavaScript中的数据主要包含两种：一种是基本类型（值类型），另一种是引用类型（引用类型）。</p><p>内存分为两个部分：栈内存和堆内存。</p><p>基本类型保存在栈内存中，引用类型值在堆内存中保存着对象，在栈内存中保存着指向堆内存的指针。</p><p>JavaScript中，基本类型值包括： undefined、null、number、string、boolean，在内存中分别占固定大小的空间。引用类型只有object，这种值的大小不固定，可以动态添加属性和方法，而基本类型则不可以。</p><p>对基本类型值进行复制，复制的是指本身，相当于复制了一个副本，修改一个变量不会影响另一个变量的值。而对引用类型值进行复制，复制的是对象所在的内存地址。所以两者指向的都是栈内存的同一个数据，修改一个变量导致另一个变量的值也进行修改。</p><h4 id="（1）声明变量"><a href="#（1）声明变量" class="headerlink" title="（1）声明变量"></a>（1）声明变量</h4><p>在TypeScript编码规范中，建议使用变量前一定要先声明。变量声明可以使用以下4中方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [var 或 let 或 const][变量名]:[类型]=值;</span><br><span class="hljs-keyword">var</span> uname:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><span class="hljs-keyword">let</span> uname2: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">const</span> version: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;1.0&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [var 或 let][变量名]: [类型];</span><br><span class="hljs-keyword">var</span> uname: <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">let</span> uname2: <span class="hljs-built_in">string</span>;<br><span class="hljs-comment">// 此范式进行变量声明，只指定了声明变量的类型，初始值默认为undefined。</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [var 或 let][变量名];</span><br><span class="hljs-keyword">var</span> uname;<br><span class="hljs-keyword">let</span> uname2;<br><span class="hljs-comment">// 此范式进行变量声明，值提供了变量名，声明变量的类型和初始值都未提供。变量类型默认为any，变量值默认为undefined。</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [var 或 let 或 const][变量名] = 值;</span><br><span class="hljs-keyword">var</span> uname = <span class="hljs-string">&#x27;Rom&#x27;</span>; <span class="hljs-comment">//string</span><br><span class="hljs-keyword">let</span> uname2 = <span class="hljs-number">100</span>; <span class="hljs-comment">//number</span><br><span class="hljs-keyword">const</span> version = <span class="hljs-string">&#x27;1.0&#x27;</span> <span class="hljs-comment">//string</span><br><span class="hljs-comment">// 此范式进行变量声明，未指定声明变量的类型，但是给出了初始值，这时会用类型推断来确定变量的类型。</span><br></code></pre></td></tr></table></figure><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><h4 id="（1）类型运算符-typeof"><a href="#（1）类型运算符-typeof" class="headerlink" title="（1）类型运算符 typeof"></a>（1）类型运算符 typeof</h4><p>typeof操作符返回一个字符串，用以获取一个变量或表达式的类型。</p><p>typeof运算符一般只能返回如下几个结果：number、boolean、string、symbol、function、object、undefined。</p><table><thead><tr><th align="center">变量类型</th><th align="center">示例</th><th align="center">typeof 返回值</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">typeof 2</td><td align="center">‘number’</td></tr><tr><td align="center">boolean</td><td align="center">typeof true</td><td align="center">‘boolean’</td></tr><tr><td align="center">string</td><td align="center">typeof  ‘hello’</td><td align="center">‘string’</td></tr><tr><td align="center">null</td><td align="center">typeof null</td><td align="center">‘object’</td></tr><tr><td align="center">undefined</td><td align="center">typeof undefined</td><td align="center">‘undefined’</td></tr><tr><td align="center">function</td><td align="center">typeof JSON.stringfy</td><td align="center">‘function’</td></tr><tr><td align="center">array</td><td align="center">typeof [1, 2]</td><td align="center">‘object’</td></tr><tr><td align="center">object</td><td align="center">typeof {}</td><td align="center">‘object’</td></tr><tr><td align="center">enum</td><td align="center">typeof Colors</td><td align="center">‘object’</td></tr><tr><td align="center">enum</td><td align="center">typeof Colors.Red</td><td align="center">‘number’</td></tr><tr><td align="center">class</td><td align="center">typeof Person</td><td align="center">‘function’</td></tr><tr><td align="center">tuple</td><td align="center">typeof [2, ‘hello’]</td><td align="center">‘object’</td></tr></tbody></table><h4 id="（2）instanceof-运算符"><a href="#（2）instanceof-运算符" class="headerlink" title="（2）instanceof 运算符"></a>（2）instanceof 运算符</h4><p>instanceof运算符可用于测试对象是否为指定类型的实例。如果是，那么返回的值为true，否则返回false。instanceof运算符的基本语法为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">类实例 <span class="hljs-keyword">instanceof</span> 类<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">private</span> age: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> man: People = <span class="hljs-keyword">new</span> People();<br>alert (man <span class="hljs-keyword">instanceof</span> People); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>instanceof 左边的只能是any类型或者对象类型或者类型参数。其他不能用，如<code>&quot;hello&quot; instanceof string</code>报错。</p><h1 id="三-数组、元组"><a href="#三-数组、元组" class="headerlink" title="三. 数组、元组"></a>三. 数组、元组</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>数组即一组数据，它把一系列具有相同类型的数据组织在一起，成为一个可操作的对象。</p><p><strong>声明和初始化数组</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// let 或 var 数组名: 元素类型[] = [值1, 值2, ..., 值N];</span><br><span class="hljs-comment">// 其中，元素类型可以是字符类型、数值类型、布尔类型，也可以是联合类型和用户自定义的类型。</span><br><span class="hljs-keyword">let</span> arr1: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">let</span> arr2: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> arr3: <span class="hljs-built_in">boolean</span>[] = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>];<br><span class="hljs-keyword">let</span> arr4: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-literal">true</span>];<br><span class="hljs-keyword">let</span> arr5: <span class="hljs-built_in">object</span>[] = [<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;jack&#x27;</span>]; <span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">let</span> arr6: <span class="hljs-built_in">object</span>[] = [&#123;<span class="hljs-attr">age</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;];<br><span class="hljs-keyword">let</span> arr7: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;true&#x27;</span>];<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// let 或 var 数组名: Array&lt;元素类型&gt; = [值1, 值2, ..., 值N];</span><br><span class="hljs-keyword">let</span> arr1: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">let</span> arr2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> arr3: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">boolean</span>&gt; = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>];<br><span class="hljs-keyword">let</span> arr4: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt; = [<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;jack&#x27;</span>];<br><span class="hljs-keyword">let</span> arr5: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">object</span>&gt; = [<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;jack&#x27;</span>]; <span class="hljs-comment">//错误</span><br><span class="hljs-keyword">let</span> arr6: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">object</span>&gt; = [&#123;<span class="hljs-attr">age</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;];<br><span class="hljs-keyword">let</span> arr7: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;true&#x27;</span>]<br><span class="hljs-comment">// 这种方式声明数组的时候，元素类型不能省略，即不允许Array&lt;&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用数组字面量，数组声明和初始化的基本语法如下：</span><br><span class="hljs-comment">//let 或 var 数组名 = [值1, 值2, ..., 值N];</span><br><span class="hljs-comment">// 使用数组字面量的方式构建数组，则数组的元素类型会根据初始化的值来确定。如果数组在声明时未设置元素类型且只初始化为空数组，就会被认为是any类型，可以存储任何类型的数据。如果未设置元素类型，且初始化了非空的值，那么编译器会根据初始化的值来自动推断数组的类型。</span><br><span class="hljs-keyword">let</span> arr1 = []; <span class="hljs-comment">//any[]</span><br>arr1.push(<span class="hljs-number">3</span>);<br>arr1 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-literal">true</span>, &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">2</span>&#125;];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// number[];</span><br><span class="hljs-keyword">let</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;true&#x27;</span>]; <span class="hljs-comment">//(string | number)[];</span><br>arr3.push(<span class="hljs-number">2</span>);<br>arr3.push(<span class="hljs-literal">true</span>); <span class="hljs-comment">//错误，布尔类型不能存储</span><br></code></pre></td></tr></table></figure><h2 id="2-元组"><a href="#2-元组" class="headerlink" title="2. 元组"></a>2. 元组</h2><p>元组是关系数据库中的基本概念，关系是一张表，表中的每行就是一个元组，每列就是一个属性。在二维表里，元组也称为行。</p><p>元组可以是不同类型的对象集合。</p><p><strong>元组特点</strong>：</p><ul><li>元组的数据类型可以是任何类型</li><li>在元组中，可以包含其他元组</li><li>元组可以是空元组</li><li>元素的取值同数组的取值，元组的标号从0开始</li><li>元组可以作为参数传递给函数</li></ul><p>元组的声明和初始化与数组比较类似，只是元组中的各个元素类型可以不同。</p><p>需要注意元组和数组在语法上的区别：数组是datatype[]， 而元组是[datatype1, datatype2,…]。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> row: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">99</span>]<br><span class="hljs-comment">// 元组声明的时候[]中的类型不能省略，且初始化的个数必须和声明中的类型个数一致，否则报错。</span><br></code></pre></td></tr></table></figure><p>上面用let声明了一个类型为[number, string, number]的元组row。将上面的代码稍微做修改后则不是元组，而是一个联合类型的数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> row = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">2</span>] <span class="hljs-comment">// (string | number)[]</span><br></code></pre></td></tr></table></figure><p>可以将any类型的变量赋值给元组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">any</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> row: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, a];<br></code></pre></td></tr></table></figure><h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四. 函数"></a>四. 函数</h1><h2 id="1-定义函数"><a href="#1-定义函数" class="headerlink" title="1. 定义函数"></a>1. 定义函数</h2><h4 id="（1）函数声明"><a href="#（1）函数声明" class="headerlink" title="（1）函数声明"></a>（1）函数声明</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">参数<span class="hljs-number">1</span>: 类型, 参数<span class="hljs-number">2</span>: 类型, ..., 参数n: 类型</span>): 类型 </span>&#123;<br>    <span class="hljs-comment">//执行代码</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数返回类型会自动进行类型推断，一般可以省略。</p><p>函数声明定义的函数可以称为普通函数，也叫命名函数。</p><h4 id="（2）函数表达式"><a href="#（2）函数表达式" class="headerlink" title="（2）函数表达式"></a>（2）函数表达式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> 或 <span class="hljs-keyword">var</span> 函数表达式名 = <span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">参数<span class="hljs-number">1</span>: 类型, 参数<span class="hljs-number">2</span>: 类型, ..., 参数n: 类型</span>): 类型 </span>&#123;<br>    <span class="hljs-comment">// 执行代码</span><br>&#125;<br><span class="hljs-comment">// 在函数表达式中，函数名可以省略，此时函数就是匿名函数，即function关键字后直接就是小括号。 </span><br><span class="hljs-keyword">let</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-comment">// 在函数表达式中，函数名只是函数体中的一个本地变量。外部并不能通过函数名来调用函数。</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-built_in">console</span>.log(a(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">//5</span><br><span class="hljs-built_in">console</span>.log(add2(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>函数表达式一般都是匿名的，如果给出函数名，那么这个函数表达式则称为命名函数表达式。如果函数表达式中有递归这种场景，也就是自己需要调用自己，那么必须用命名函数表达式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>); <span class="hljs-comment">//需要函数名factorial</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(func(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h4 id="（3）箭头函数表达式"><a href="#（3）箭头函数表达式" class="headerlink" title="（3）箭头函数表达式"></a>（3）箭头函数表达式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> 或 <span class="hljs-keyword">var</span> 箭头表达式名 = <span class="hljs-function">(<span class="hljs-params">参数<span class="hljs-number">1</span>: 类型, 参数<span class="hljs-number">2</span>: 类型, ..., 参数n: 类型</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//执行代码</span><br>&#125;<br><span class="hljs-comment">// 箭头函数表达式也是一个匿名函数</span><br><span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-keyword">let</span> add = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a +<span class="hljs-number">3</span>;<br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h4 id="（4）Function-对象"><a href="#（4）Function-对象" class="headerlink" title="（4）Function 对象"></a>（4）Function 对象</h4><p>Function对象可以定义任何函数，用Function类直接创建函数的语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> 或 <span class="hljs-keyword">var</span> 函数名 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, ..., 参数N, 函数体)<br><span class="hljs-keyword">let</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;msg&#x27;</span>, <span class="hljs-string">&#x27;console.log(&quot;hello &quot; + msg)&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2. 函数的参数"></a>2. 函数的参数</h2><p>在Typescript中，参数可以用”参数名：数据类型”来定义一个函数的参数，其中数据类型省略时，默认为any类型，可以传入任意值。</p><p>虽然参数类型可以省略，但是不建议省略，any类型将失去静态检测的功能。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 错误代码示例：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-string">&#x27;&#x27;</span> + b;<br>&#125;<br><span class="hljs-keyword">let</span> result1 = func(<span class="hljs-string">&#x27;tom&#x27;</span>) <span class="hljs-comment">// 错误，少一个参数</span><br><span class="hljs-keyword">let</span> result2 = func(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 错误， 多一个参数</span><br><span class="hljs-keyword">let</span> result3 = fucn(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;tom&#x27;</span>) <span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">let</span> result4 = func(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 错误，第二个参数类型不对</span><br></code></pre></td></tr></table></figure><p>在TypeScript中，函数参数有以下几类：</p><ul><li>可选参数</li><li>Rest参数（剩余参数）</li><li>默认参数</li></ul><h4 id="（1）可选参数"><a href="#（1）可选参数" class="headerlink" title="（1）可选参数"></a>（1）可选参数</h4><p>可选参数使用问号标识(?)来定义，参数一旦声明为可选的，那么在函数调用的时候可以传值也可以不传值。</p><p>函数的参数可以全部设为可选，但是可选的必须位于非可选参数之后，否则报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b?:<span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (b === <span class="hljs-literal">undefined</span>) &#123;<br>        b = <span class="hljs-string">&#x27;&#x27;</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> a +<span class="hljs-string">&#x27; &#x27;</span> + b;<br>&#125;<br><span class="hljs-keyword">let</span> res1 = func(<span class="hljs-string">&#x27;tom&#x27;</span>) <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">let</span> res2 = func(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;jane&#x27;</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//错误，多一个参数</span><br><span class="hljs-keyword">let</span> res3 = func(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;jane&#x27;</span>); <span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">let</span> res4 = func(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//错误，第二个参数类型不对</span><br></code></pre></td></tr></table></figure><h4 id="（2）Rest参数（剩余参数）"><a href="#（2）Rest参数（剩余参数）" class="headerlink" title="（2）Rest参数（剩余参数）"></a>（2）Rest参数（剩余参数）</h4><p>Rest参数可以接受函数的多余参数，组成一个数组，但必须放在形参的最后面。Rest参数名前用…表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">a: 类型, b: 类型, ...restArgs: 类型[]</span>) </span>&#123;<br>    <span class="hljs-comment">//函数逻辑</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, ...b: <span class="hljs-built_in">string</span>[]</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (b === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-comment">// 避免b = undefined</span><br>        b = []<br>    &#125;<br>    <span class="hljs-keyword">return</span> a +<span class="hljs-string">&#x27; &#x27;</span> + b<br>&#125;<br><span class="hljs-keyword">let</span> res1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-string">&#x27;jack&#x27;</span></span>) //正确，&#x27;<span class="hljs-title">jack</span> &#x27;</span><br><span class="hljs-function"><span class="hljs-title">let</span> <span class="hljs-title">res2</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;adams&#x27;</span>, <span class="hljs-literal">undefined</span></span>)</span>; //正确， &#x27;<span class="hljs-title">jack</span> <span class="hljs-title">admas</span>&#x27;</span><br><span class="hljs-function"><span class="hljs-title">let</span> <span class="hljs-title">res3</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;adams&#x27;</span>, <span class="hljs-string">&#x27;smith&#x27;</span></span>)</span>; //正确，&#x27;<span class="hljs-title">jack</span> <span class="hljs-title">admas</span>,<span class="hljs-title">smith</span>&#x27;</span><br><span class="hljs-function"><span class="hljs-title">let</span> <span class="hljs-title">res4</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">2</span></span>)</span>; //错误，第二个参数类型不对</span><br></code></pre></td></tr></table></figure><h4 id="（3）默认参数"><a href="#（3）默认参数" class="headerlink" title="（3）默认参数"></a>（3）默认参数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">a: 类型, ..., b: 类型 = 默认值</span>) </span>&#123;<br>    <span class="hljs-comment">//函数逻辑</span><br>&#125;<br><span class="hljs-comment">// 函数参数不能同时设置可选和默认</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDiscount</span>(<span class="hljs-params">price: <span class="hljs-built_in">number</span>, rate: <span class="hljs-built_in">number</span> = <span class="hljs-number">0.50</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> discount = price * rate;<br>    <span class="hljs-keyword">return</span> discount;<br>&#125;<br><span class="hljs-keyword">let</span> a = getDiscount(<span class="hljs-number">1000</span>); <span class="hljs-comment">//500</span><br><span class="hljs-keyword">let</span> b = getDiscount(<span class="hljs-number">1000</span>, <span class="hljs-number">0.6</span>) <span class="hljs-comment">//600</span><br></code></pre></td></tr></table></figure><h4 id="（4）类型注解"><a href="#（4）类型注解" class="headerlink" title="（4）类型注解"></a>（4）类型注解</h4><p>​    JavaScript不是一种静态类型语言。这意味着我们不能指定变量和函数参数的类型。但是TypeScript是一种静态类型语言，这让我们可以对变量和函数进行类型注解。类型注解也就是对参数或变量类型进行注释，比如限定参数为数值类型或者字符串类型等。</p><p>​    类型注解用于强制执行类型检查。TypeScript中不一定要使用类型注释。但是，类型注解有助于编译器检查类型，并有助于避免处理数据类型时报错在TypeScript编程中，类型注解也是一种编写代码的好习惯，一方面开启静态类型检测功能，将很多潜在的类型错误及时排查出来，另一方面也让后续的维护更容易。</p><p>​    可以用冒号（：）在函数的参数名后面指定类型，冒号和参数名之间可以有一个空格。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> stu: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">student: &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    id: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    age: <span class="hljs-built_in">number</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    name: <span class="hljs-built_in">string</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;name&#x27;</span> + student.name);<br>&#125;<br>stu = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;001&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">31</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span><br>&#125;<br>print(stu);<br>print(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;001&#x27;</span>&#125;); <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><h2 id="3-特殊函数"><a href="#3-特殊函数" class="headerlink" title="3. 特殊函数"></a>3. 特殊函数</h2><h4 id="（1）函数重载"><a href="#（1）函数重载" class="headerlink" title="（1）函数重载"></a>（1）函数重载</h4><p>函数重载常用来实现功能类似但所处理的数据类型不同的问题。</p><p>函数重载是函数名字相同，而参数不同，返回类型可以相同也可以不相同，但不能只有函数返回值类型不同。这些同名函数的参数要么不同，要么类型不同，那么顺序不同。</p><p>每个函数重载都必须有一个独一无二的参数类型列表。函数重载是多态的一种实现方式。</p><p>重载函数一般有以下几种方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 参数类型不同</span><br><span class="hljs-comment">//1. 声明定义：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>)</span>;<br><span class="hljs-comment">//2. 实现：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;string =&#x27;</span> +x)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;number =&#x27;</span> + x)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;未实现&#x27;</span>)<br>    &#125;<br>&#125;<br>disp(<span class="hljs-number">2</span>);<br>disp(<span class="hljs-string">&#x27;2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>函数重载声明定义必须放在实现函数之前，否则报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 参数数量不同</span><br><span class="hljs-comment">// 1. 声明定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>)</span>;<br><span class="hljs-comment">//2. 实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span>, y?:<span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (y === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(x)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(x + y)<br>    &#125;<br>&#125;<br>disp(<span class="hljs-number">2</span>);<br>disp(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>函数重载中如果参数个数不同，那么函数实现中对应的参数必须为可选参数，否则报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 参数类型顺序不同</span><br><span class="hljs-comment">// 1. 声明定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">string</span></span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span>, y: <span class="hljs-built_in">number</span></span>)</span>;<br><span class="hljs-comment">//2. 实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span>, y: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> y === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(x*<span class="hljs-number">10</span> + y)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> y === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(x + y*<span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(‘未实现)<br>    &#125;<br>&#125;<br>disp(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//&#x27;230&#x27;</span><br>disp(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-comment">//&#x27;203&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 参数默认值不同</span><br><span class="hljs-comment">// 1. 声明定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-string">&#x27;jack&#x27;</span>, y: numeber</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-string">&#x27;tom&#x27;</span>, y: <span class="hljs-built_in">number</span></span>)</span>;<br><span class="hljs-comment">// 2. 实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disp</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span>, y: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (x === <span class="hljs-string">&#x27;jack&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;jack =&#x27;</span> + y)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x === <span class="hljs-string">&#x27;tom&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;tom =&#x27;</span> + y)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;未实现&#x27;</span>)<br>    &#125;<br>&#125;<br>disp(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">3</span>);<br>disp(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>在参数默认值重载函数中，除了默认值外不允许传入其他值。</p><h1 id="五-面向对象编程"><a href="#五-面向对象编程" class="headerlink" title="五. 面向对象编程"></a>五. 面向对象编程</h1><p>面向对象编程的本质是以建立模型来抽象表达实现事物。模型是用来反映实现世界中事物特征的一种抽象载体。一般情况下，任何一个模型都不可能完全反映客观事物的一切具体特征，但是可以根据需求抓住待解决问题的主要矛盾，即主要的特征和行为。面向对象是以功能来划分问题，而不是步骤。</p><p>面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。</p><p>抽象、封装、继承和多态是面向对象的基础，是面向对象的四大基础特征。</p><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1. 对象"></a>1. 对象</h2><p>对象指的是具体的某个事物，具有唯一性标识。状态和行为的三大特性。</p><h2 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-attr">engine</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;V8&#x27;</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">engine: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.engine = engine;<br>    &#125;<br>    getEngine(): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.engine;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> aodiCar = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">&#x27;奥迪 V8&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(aodiCar.engine);<br><span class="hljs-built_in">console</span>.log(aodiCar.getEngine());<br><span class="hljs-comment">// 访问类的实例对象的属性和方法除了用符号外，还可以用[]， 如aodiCar[&#x27;engine&#x27;]和aodiCar[&#x27;getEngine&#x27;]()</span><br></code></pre></td></tr></table></figure><h4 id="（1）类的继承"><a href="#（1）类的继承" class="headerlink" title="（1）类的继承"></a>（1）类的继承</h4><p>在类的继承中，子类的构造函数必须包含父类的构造函数，调用父类构造函数用super。而且在构造函数里访问this的属性之前一定要调用super()，否则编译器也会提示错误。</p><p>TypeScript中的类只能继承一个父类，不支持继承多个类，但支持多重继承。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; walk&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; eating&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-attr">clazz</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, clazz: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age);<br>        <span class="hljs-built_in">this</span>.clazz = clazz;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">learn</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; learning&#x27;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringfy(<span class="hljs-built_in">this</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HighSchoolStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-attr">clazz</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, clazz: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, clazz);<br>        <span class="hljs-built_in">this</span>.clazz = clazz;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">goNCEE</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; take NCEE&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> studentA = <span class="hljs-keyword">new</span> HighSchoolStudent(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;高三一班&#x27;</span>);<br>studentA.walk();<br>studentA.learn();<br>studentA.goNCEE();<br>student.display()<br><br><span class="hljs-comment">// 可以对实例对象进行类型断言，让子类转成父类的类型。</span><br><span class="hljs-keyword">let</span> studentB = studentA <span class="hljs-keyword">as</span> Student;<br>sudentB.display();<br><span class="hljs-keyword">let</span> people = studentA <span class="hljs-keyword">as</span> People;<br>people.walk();<br></code></pre></td></tr></table></figure><h4 id="（2）方法重载"><a href="#（2）方法重载" class="headerlink" title="（2）方法重载"></a>（2）方法重载</h4><p>重载是在一个类里面方法名字相同但参数不同，返回类型可以相同也可以不同。每个重载的方法都必须有一个独一无二的参数类型列表。</p><p>重写是子类对父类允许访问的方法的实现共产进行重新编写，返回值和形参都不能改变，即方法签名不变，方法体重写。重写的好处在于子类可以根据需要定义特定于自己的行为，从而覆盖父类的方法。</p><h2 id="3-接口"><a href="#3-接口" class="headerlink" title="3. 接口"></a>3. 接口</h2><p>接口是一系列抽象属性或方法的声明，接口只给出属性或方法的约定，并不给出具体实现。</p><p>具体的实现逻辑可以交由接口的实现类来完成。借助接口，我们无须关心实现类的内部实现细节就可以用接口定义的属性或方法对某个类进行属性或方法调用。</p><h4 id="（1）声明接口"><a href="#（1）声明接口" class="headerlink" title="（1）声明接口"></a>（1）声明接口</h4><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名或定义契约。TypeScript中接口定义的基本语法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> 接口名 &#123;<br>    <span class="hljs-comment">//属性或方法定义</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> inPeople &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age:  <span class="hljs-built_in">number</span>;<br>    walk();<br>    eat(a: <span class="hljs-built_in">string</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中的属性和方法可以定义为可选的，如果将该接口中的属性和方法用可选符号？限定为可选的情况下，接口的实现中可选属性或方法就可以不实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IConfigs &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    height?:<span class="hljs-built_in">number</span>, <span class="hljs-comment">//接口中的属性和方法既可以用分号;分隔，也可以逗号,分隔</span><br>    width?:<span class="hljs-built_in">number</span>;<br>    learn?(); <span class="hljs-comment">//可选方法</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params">config: IConfigs</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(config.name)<br>&#125;<br>load(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">180</span>&#125;)<br>load(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;svg&#x27;</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">180</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>&#125;)<br>load(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;html&#x27;</span>,<br>    <span class="hljs-attr">heigth</span>: <span class="hljs-number">180</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">learn</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;learning&#x27;</span>)&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>接口还可以继承自类：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rect</span> </span>&#123;<br>    <span class="hljs-attr">heigth</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>;<br>    width: <span class="hljs-built_in">number</span> = <span class="hljs-number">200</span>;<br>    learn?() &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;learning&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Iconfig <span class="hljs-keyword">extends</span> Rect &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params">config: Iconfig</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(config.name);<br>    <span class="hljs-comment">//console.log(config.learn()) // config.learn is not a function</span><br>&#125;<br><span class="hljs-comment">// load(&#123;name: &#x27;div&#x27;, heigth: 180&#125;); //错误缺少width</span><br>load(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;svg&#x27;</span>, <span class="hljs-attr">heigth</span>: <span class="hljs-number">180</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>&#125;)<br></code></pre></td></tr></table></figure><p>TypeScript中不允许一次继承多个类，但可以实现多个接口。类实现接口用关键字implements来表示。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Iconfigs &#123;<br>    <span class="hljs-attr">heigth</span>: <span class="hljs-built_in">number</span>;<br>    width: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Ibase &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>    name: <span class="hljs-built_in">string</span>;<br>    toString(): <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyElement</span> <span class="hljs-title">implements</span> <span class="hljs-title">Iconfigs</span>, <span class="hljs-title">Ibase</span> </span>&#123;<br>    <span class="hljs-attr">heigth</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">200</span>;<br>    width: <span class="hljs-built_in">number</span> = <span class="hljs-number">300</span>;<br>    id: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;myele&#x27;</span>;<br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringfy(<span class="hljs-built_in">this</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> MyElement();<br><span class="hljs-built_in">console</span>.log(e.tostring)<br></code></pre></td></tr></table></figure><p>接口中还可以限定一个属性为只读的，只读属性用关键字readonly来指定。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Ibase &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">readonly</span> outhor: <span class="hljs-built_in">string</span>;<br>    tostring(): <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyElement</span> <span class="hljs-title">implements</span> <span class="hljs-title">Ibase</span> </span>&#123;<br>    <span class="hljs-keyword">readonly</span> author: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;tom&#x27;</span>;<br>    name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;myele&#x27;</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">author:<span class="hljs-built_in">string</span>, name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.author = author;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">tostring</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> MyElement(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>) <span class="hljs-comment">//只读属性，但生成的js文件可以修改</span><br></code></pre></td></tr></table></figure><p>类中只读属性除了在构造函数中可以进行赋值外，其他方法不允许修改只读属性的值。</p><p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法进行了移除，因此可以确保数组创建后不能被修改。另外，只读属性不能用const，而只能用readonly。最简单判断该用readonly还是const的方法是，需要限定的是变量还是属性。如果要限定一个变量则用const，若要限定属性则使用readonly。</p><p>​    接口描述了类的公共部分，而不是公共和私有两部分。接口不会帮我们检查类是否具有某些私有成员。我们要知道类具有两个类型的：静态部分的类型和实例的类型。</p><h4 id="（2）Union-Type-和-接口"><a href="#（2）Union-Type-和-接口" class="headerlink" title="（2）Union Type 和 接口"></a>（2）Union Type 和 接口</h4><p>接口中的属性可以是简单的数据类型，也可以使用复杂的数据类型，如联合类型（Union Type）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Ibase &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    width: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>    height: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyElement</span> <span class="hljs-title">implements</span> <span class="hljs-title">Ibase</span> </span>&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = <span class="hljs-string">&#x27;200px&#x27;</span>;<br>    heigth: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = <span class="hljs-string">&#x27;300px&#x27;</span>;<br>    name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;tom&#x27;</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name : <span class="hljs-built_in">string</span>, width: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, height: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = heigth;<br>    &#125; <br>&#125;<br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> MyElement(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;300px&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IFunc &#123;<br>    (width: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, <span class="hljs-attr">heigth</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyElement</span> </span>&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = <span class="hljs-string">&#x27;200px&#x27;</span>;<br>    height: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = <span class="hljs-string">&#x27;300px&#x27;</span>;<br>    name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;tom&#x27;</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, width: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, height: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br>    setLocation(func: IFunc): <span class="hljs-built_in">boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> func(<span class="hljs-built_in">this</span>.width, <span class="hljs-built_in">this</span>.height);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> MyElement(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;300px&#x27;</span>)<br>e.setLocation(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w, h</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(w);<br>    <span class="hljs-built_in">console</span>.log(h);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;)<br>    <br></code></pre></td></tr></table></figure><h4 id="（3）接口和数组"><a href="#（3）接口和数组" class="headerlink" title="（3）接口和数组"></a>（3）接口和数组</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IMath &#123;<br>    <span class="hljs-attr">data</span>: <span class="hljs-built_in">number</span>[];<br>    sum(data: <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMath</span> <span class="hljs-title">implements</span> <span class="hljs-title">IMath</span> </span>&#123;<br>    <span class="hljs-attr">data</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">data: <span class="hljs-built_in">number</span>[]</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>    sum(_data?: <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span> &#123;<br>        <span class="hljs-keyword">let</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (_data === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.data) &#123;<br>                ret += i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> _data) &#123;<br>                ret += i<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> MyMath([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-built_in">console</span>.log(e.sum()); <span class="hljs-comment">//6</span><br><span class="hljs-built_in">console</span>.log(e.sum([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])) <span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><h4 id="（4）接口的继承"><a href="#（4）接口的继承" class="headerlink" title="（4）接口的继承"></a>（4）接口的继承</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IBase &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>    name: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> IShape &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    y: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> ICircle <span class="hljs-keyword">extends</span> Ishape, Ibase &#123;<br>    <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> circle = &lt;ICircle&gt;&#123;&#125;;<br>circle.color = <span class="hljs-string">&#x27;blue&#x27;</span>;<br>circle.radius = <span class="hljs-number">10</span>;<br>circle.x = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// ICircle接口继承了接口Ishape和IBase，因此接口ICircle中将自动创建接口IShape和IBase中所有的属性和方法定义。</span><br></code></pre></td></tr></table></figure><p>如果接口继承自多个接口，且多个接口中有同名的属性，但是属性的数据类型不同，就无法同时继承。</p><p>接口除了可以继承接口外，还可以继承自类。当接口继承了一个类时，它会继承类的成员但不包括其实现。接口同样会继承到类的private和protected成员。这意味着当我们创建一个接口并继承一个拥有私有或受保护的成员类时，这个接口只能被该类或其子类所实现。</p><p>接口的属性和方法不能限定访问控制符，但是通过继承类可以限定接口中属性的访问权限。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> state: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">protected</span> innerValue: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> IClickableControl <span class="hljs-keyword">extends</span> Control &#123;<br>    click(): <span class="hljs-built_in">void</span>;<br>    <span class="hljs-comment">//state: string //错误 不能访问私有属性state</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Control</span> <span class="hljs-title">implements</span> <span class="hljs-title">IClickableControl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">click</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Button&#x27;</span>;<br>        <span class="hljs-built_in">this</span>.innerValue = <span class="hljs-string">&#x27;@001&#x27;</span>;<br>        <span class="hljs-comment">//this.state = &#x27;0&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 错误：MyImage 只是实现了接口IClickableControl，但不是Control的子类，则会报错。Image类型缺少state私有属性</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImage</span> <span class="hljs-title">implements</span> <span class="hljs-title">IclickableControl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">click</span>(<span class="hljs-params"></span>)</span> &#123;<br>       <span class="hljs-comment">// this.name = &#x27;MyImage&#x27;</span><br>       <span class="hljs-comment">// this.innerValue = &#x27;@001&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类可以同时继承类和实现接口，但是注意继承必须置于实现接口之前，即extends要放在implements之前，否则报错。</p><h4 id="（5）类也可以实现接口"><a href="#（5）类也可以实现接口" class="headerlink" title="（5）类也可以实现接口"></a>（5）类也可以实现接口</h4><p>抽象类是一种特殊的类，可以被其他类继承。抽象类一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。abstract关键字用于定义抽象类和抽象类内部定义抽象方法，因此可以用抽象类来实现接口的功能。</p><p>抽象类中的抽象方法不包含具体实现，并且必须在子类中实现。抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。抽象方法必须包含abstract关键字并且可以包含访问修饰符。</p><h2 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4. 命名空间"></a>4. 命名空间</h2><p>命名空间是用来组织和重用代码的，防止重名的情况。</p><h4 id="（1）定义命名空间"><a href="#（1）定义命名空间" class="headerlink" title="（1）定义命名空间"></a>（1）定义命名空间</h4><p>命名空间的目的就是为了解决命名冲突的问题。</p><p>TypeScript中命名空间使用namespace关键字来定义，基本语法格式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">namespace</span> 命名空间名 &#123;<br>    <span class="hljs-comment">// 内部类和成员</span><br>&#125;<br><span class="hljs-comment">// 命名空间名一般符合一般标识符的命名规则。命名空间可以用.分隔的几个单词构成。</span><br>    <br><span class="hljs-keyword">namespace</span> com.wyd.demo &#123;<br>    <span class="hljs-keyword">interface</span> IPeople &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>        name: <span class="hljs-built_in">string</span>;<br>        learn();<br>    &#125;<br>    <span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-title">implements</span> <span class="hljs-title">IPeople</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> id: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">learn</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; learning&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> man = <span class="hljs-keyword">new</span> com.wyd.demo.Man(<span class="hljs-string">&#x27;001&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>);<br>man.learn();<br></code></pre></td></tr></table></figure><h4 id="（2）嵌套命名空间"><a href="#（2）嵌套命名空间" class="headerlink" title="（2）嵌套命名空间"></a>（2）嵌套命名空间</h4><p>命名空间支持嵌套，即我们可以将命名空间定义在另一个命名空间中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">namespace</span> com.wyd &#123;<br>    <span class="hljs-comment">// 嵌套时， 里层的namespace必须用export，否则无法访问。</span><br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> nested &#123;<br>        <span class="hljs-keyword">export</span> fucntion <span class="hljs-function"><span class="hljs-title">callNS</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-comment">// com.wyd.demo.Man</span><br>            <span class="hljs-keyword">let</span> man = <span class="hljs-keyword">new</span> demo.Man(<span class="hljs-string">&#x27;001&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>);<br>            man.learn();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 命名空间别名</span><br><span class="hljs-keyword">import</span> myNs = com.wydnested;<br>com.wyd.nested.callNS();<br>myNS.callNS()<br></code></pre></td></tr></table></figure><h2 id="5-外部模块"><a href="#5-外部模块" class="headerlink" title="5. 外部模块"></a>5. 外部模块</h2><h4 id="（1）模块加载器"><a href="#（1）模块加载器" class="headerlink" title="（1）模块加载器"></a>（1）模块加载器</h4><p>模块使用模块加载器去导入其他模块。在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。</p><p>模块加载器一般分为供浏览器端使用的AMD规范和CMD规范、供服务器端使用的CommonJs规范、跨浏览器和服务器的UMD规范。</p><h4 id="（2）AMD："><a href="#（2）AMD：" class="headerlink" title="（2）AMD："></a>（2）AMD：</h4><p>AMD（异步模块加载机制）规范的描述比较简单，完整描述了模块的定义、依赖关系、引用关系以及异步加载机制。requestJS库采用AMD规范进行模块加载。AMD规范特别适用于浏览器环境。</p><p>AMD规范用一个全局函数define来定义模块。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 第一步，新建一个moduleA.js文件，按照约定，其模块名为文件名moduleA。函数define中用一个匿名函数返回一个对象。</span><br>define (<br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>,<br>            <span class="hljs-attr">age</span>: <span class="hljs-number">31</span><br>        &#125;<br>    &#125;<br>);<br><span class="hljs-comment">// 第二步： 新建一个moduleB.js文件，按照约定，其模块名为文件名moduleB。模块moduleB依赖模块moduleA。</span><br><span class="hljs-comment">// 第一个参数需要用一个数组来描述依赖项；第二个参数是一个匿名的工厂函数，返回一个对象，其中匿名函数的参数列表和依赖项时一一对应的关系。</span><br>define([<span class="hljs-string">&#x27;moduleA&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">moduleA</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">showName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(moduleA.name)<br>        &#125;,<br>        <span class="hljs-attr">getAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> moduleA.age<br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//第三步， 新建一个入口文件man.js。在这个文件中，首先用require.config方法来加载jquery库，然后用require函数来调用moduleB和jquery库中的方法。</span><br><span class="hljs-comment">// require函数有两个参数时，第一个参数时一个数组，可以用来描述需要引入的依赖项，也就是要加载的模块；第二个是一个匿名的工厂函数，其中匿名函数的参数列表和引入的依赖项是一一对应的关系。</span><br><span class="hljs-built_in">require</span>.config(&#123;<br>    <span class="hljs-attr">paths</span>: &#123;<br>        <span class="hljs-attr">jquery</span>: <span class="hljs-string">&#x27;http://code.jquery.com/jquery-1.11.1.min&#x27;</span><br>    &#125;<br>&#125;)<br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-string">&#x27;moduleB&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$, moduleB</span>) </span>&#123;<br>    moduleB.showName();<br>    $(<span class="hljs-string">&#x27;#mydiv&#x27;</span>).html(<span class="hljs-string">&#x27;age=&#x27;</span>+moduleB.getAge());<br>&#125;)<br><span class="hljs-comment">// 第四步， 新建一个index.html文件，用来将main.js文件引入到HTML页面中运行。require.js可以在引入自身JS文件时根据script脚本中的data-main属性的配置来加载入口文件。</span><br>&lt;!DOCTYPE html&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">    ...</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;mydiv&#x27;</span>&gt;</span>body<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;require.js&#x27;</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">&#x27;main.js&#x27;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="（3）CMD"><a href="#（3）CMD" class="headerlink" title="（3）CMD"></a>（3）CMD</h4><p>CMD（通用模块定义）规范是国内发展出来的。在AMD规范中有一个浏览器的实现库require.js，CMD规范也有一个浏览器的实现库SeaJS。SeaJS功能和requireJS基本相同，只不过模块定义方式和模块加载时机上有所不同。</p><p>在CMD规范中，一个模块就是一个JS文件。</p><p>代码书写格式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">define(id?,d?.factory)<br></code></pre></td></tr></table></figure><p>因为CMD推崇一个文件就是一个模块，所以经常用文件名作为模块id。CMD推崇依赖就近，所以一般不在define函数的参数中写依赖。define函数的第三个参数factory是一个工厂函数，格式为function(require, export, module)。其中有三个参数：require是一个方法，用来获取其他模块提供的接口；exports是一个对象，用来向外提供模块接口；module是一个对象，上面存储了当前模块相关联的一些属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//第一步： 新建一个moduleA.js文件，按照约定，其模块名为文件名moduleA。函数define中用一个匿名函数返回一个对象。</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">requrie, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>    <span class="hljs-built_in">module</span>.exports = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">31</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">//第二步： 新建一个moduleB.js文件。按照约定，其模块名为文件名muduleB。模块moduleB依赖模块moduleA。define函数前两个参数是可选参数，可以省略。一般都直接用第三个参数factory来构建模块信息，factory工厂函数中可以通过require函数加载模块moduleA，并通过module.exports对外导出模块。</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> moduleA = requrie(<span class="hljs-string">&#x27;moduleA&#x27;</span>);<br>    <span class="hljs-built_in">module</span>.exports = &#123;<br>        <span class="hljs-attr">showName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(moduleA.name);<br>        &#125;,<br>        <span class="hljs-attr">getAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> moduleA.age;<br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">// exports仅仅是module.exports的一个引用。在factory工厂函数内部exports重新赋值时并不会改变module.exports的值。因此给exports赋值时无效的，不能用来更改模块接口。</span><br><br><span class="hljs-comment">// 第三步：新建一个入口man.js，这个文件中仍然用define函数来定义一个模块main。模块main中用require(&#x27;moduleB&#x27;)语句引入模块moduleB，并赋值给内部变量moduleB，这样就可以利用moduleB来访问模块moduleB中的shoeName方法。</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">requrie, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> moduleB = requrie(<span class="hljs-string">&#x27;moduleB&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(moduleB);<br>    moduleB.showName();<br>    $(<span class="hljs-string">&#x27;#mydiv&#x27;</span>).html(<span class="hljs-string">&#x27;age = &#x27;</span> + moduleB.getAge())<br>&#125;)<br><br><span class="hljs-comment">//第四步：新建一个index.html文件来加载main.js文件，由于浏览器中并不能直接运行CMD模块代码，这里用sea.js库来加载CMD模块main.js</span><br>&lt;!DOCTYPE html&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">    ...</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;mydiv&#x27;</span>&gt;</span>body<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;sea.js&#x27;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">        seajs.use([<span class="hljs-string">&#x27;main.js&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">main</span>) </span>&#123;&#125;)</span></span><br><span class="javascript"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="（4）CommonJS规范"><a href="#（4）CommonJS规范" class="headerlink" title="（4）CommonJS规范"></a>（4）CommonJS规范</h4><p>CommonJS规范规定，每一个文件就是一个模块，拥有自己独立的作用域，每个模块内部的module变量代码当前模块。module变量是一个对象，它的exports属性（module.exports）是对外的接口。当需要用require方法加载某个模块时，本质上是加载该模块的module.exports属性。</p><p>CommonJs API定义很多普通应用程序（主要是指非浏览器的应用）使用的API。这样的话，开发者可以使用CommonJs API编写各种类型的应用程序，且这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。CommonJs的核心思想就是通过require方法来同步加载依赖的模块，通过exports或者module.exports来导出需要暴露的接口。</p><p>NodeJs是CommonJs规范的实现，而webpack打包工具也是原生支持CommonJs规范的。在兼容CommonJs的系统中，我们不但可以开发服务器端的JavaScript应用程序，而且可以开发图形界面应用程序等。</p><p>由于CommonJs是同步加载模块的，对于浏览器而言，需要将文件从服务器端请求过来加载就不太适用了，同步等待会出现浏览器“假死”的情况，因此CommonJs是不适用于浏览器端的。</p><p>虽然CommonJs编写的模块不适用于浏览器端，但是可以借助工具进行格式转换，从而适用浏览器端。</p><p>浏览器不兼容CommonJs的根本原因在于缺少Node.js环境的变量：module，exports、require和global。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 第一步：新建一个moduleA.js文件，在moduleA.js文件中定义一个obj对象，并通过module.exports=obj导出模块信息。</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">13</span><br>&#125;<br><span class="hljs-built_in">module</span>.exports = obj;<br><br><span class="hljs-comment">// 第二步： 新建一个moduleB.js文件，首先用require(&#x27;./moduleA.js&#x27;)来表示当前模块依赖于模块文件moduleA.js,然后声明一个func的对象，里面包含showName和getAge方法，这两个方法都可以使用导入的moduleA.js文件中导出的对象obj。最后用module.exports = func导出模块信息。</span><br><span class="hljs-keyword">var</span> moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./moduleA.js&#x27;</span>);<br><span class="hljs-keyword">var</span> func = &#123;<br>    <span class="hljs-attr">showName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(moduleA.name);<br>    &#125;,<br>    <span class="hljs-attr">gerAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> moduleA.age<br>    &#125;<br>&#125;;<br><span class="hljs-built_in">module</span>.exports = func;<br><br><span class="hljs-comment">// 第三步： 新建一个入口文件man.js。这个文件中首先用require(&#x27;./moduleB.js&#x27;)方法来加载moduleB.js库并将模块导出信息赋值给变量moduleB。然后可以通过变量moduleB来调用moduleB.js中的方法。</span><br><span class="hljs-keyword">var</span> moduleB = requrie(<span class="hljs-string">&#x27;./moduleB.js&#x27;</span>);<br><span class="hljs-comment">// console.log(moduleB);</span><br>moduleB.showName();<br><br><span class="hljs-comment">//第四步：在vscode中配置启动项launch.json。CommonJs规范可以在NodeJS中运行，这里配置一个类型为node、启动文件为commonjs文件夹下的main.js。</span><br>&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>:<span class="hljs-string">&quot;0.2.0&quot;</span>,<br>        <span class="hljs-string">&quot;configuration&quot;</span>: [&#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;debug common.js&quot;</span>,<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolfer&#125;/commonjs\\main.js&quot;</span><br>        &#125;]<br>&#125;<br><span class="hljs-comment">// 在vscode中直接调试。</span><br></code></pre></td></tr></table></figure><h4 id="（5）UMD"><a href="#（5）UMD" class="headerlink" title="（5）UMD"></a>（5）UMD</h4><p>UMD（通用模块规范）是由社区想出来的一种整合了CommonJs和AMD两个模块定义规范的方法。UMD用一个工厂函数来统一不同模块定义规范。</p><p>UMD有两个基本原则： 所有定义的模块的方法需要单独传入依赖： 所有定义模块的方法都需要返回一个对象，供其他模块使用。UMD实现思路比较简单，先判断当前环境是否支持CommonJs模块机制（判断module和module.exports是否为object类型），如果存在就使用CommonJs规范进行模块加载；如果不存在就判断是否支持AMD（判断define和define.cdm是否存在），若存在则使用AMD规范加载模块，若前两个都不存在，则将模块暴露到全局变量window或global。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 第一步：新建一个moduleA.js文件。安装UMD规范，首先判断当前环境是否支持CommonJs模块机制，如果不支持就判断是否支持AMD模块机制。</span><br><span class="hljs-comment">// moduleA.js中定义的是一个立即执行函数传入模块定义的工厂函数factory。在工厂函数factory中通过exports.obj=obj对外暴露接口。</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">factory</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>.exports === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">var</span> v = factory(<span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>);<br>        <span class="hljs-keyword">if</span> (v !== <span class="hljs-literal">undefined</span>) <span class="hljs-built_in">module</span>.exports = v<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;<br>        define([<span class="hljs-string">&#x27;require&#x27;</span>, <span class="hljs-string">&#x27;exports&#x27;</span>], factory);<br>    &#125;<br>&#125;)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-built_in">exports</span>._esModule = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">var</span> obj = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">31</span><br>    &#125;;<br>    <span class="hljs-built_in">exports</span>.obj = obj;<br>&#125;)<br><br><span class="hljs-comment">//第二步： 新建一个moduleB.js文件。按照UMD规范，首先判断当前环境是否支持CommonJs模块机制，如果不支持就判断一下是否支持AMD模块机制。moduleB.js中定义的是一个立即执行函数传入模块定义的工厂函数factory。在工厂函数factory中通过exports.func = func对外暴露接口。</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">factory</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>.exports === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">var</span> v = factory(<span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>);<br>        <span class="hljs-keyword">if</span> (v !== <span class="hljs-literal">undefined</span>) <span class="hljs-built_in">module</span>.exports = v<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;fucntion&#x27;</span> &amp;&amp; define.amd) &#123;<br>        define([<span class="hljs-string">&#x27;require&#x27;</span>, <span class="hljs-string">&#x27;exports&#x27;</span>, <span class="hljs-string">&#x27;./moduleA&#x27;</span>], factory);<br>    &#125;<br>&#125;)(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-built_in">exports</span>._esModule = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">var</span> moduleA_1 = requrie(<span class="hljs-string">&#x27;./moduleA&#x27;</span>);<br>    <span class="hljs-keyword">var</span> func = &#123;<br>        <span class="hljs-attr">showName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(moduleA_1.obj.name);<br>        &#125;,<br>        <span class="hljs-attr">getAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> moduleA_1.obj.age;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">exports</span>.func = func;<br>&#125;)<br><br><span class="hljs-comment">// 第三步： 新建一个入口文件man.js，该文件用define([&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;./moduleB&#x27;], factory)和require(&#x27;./moduleB&#x27;)定义了在两种模块机制下该模块对moduleB的依赖关系。</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">factory</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>.exports === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">var</span> v = factory(<span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>);<br>        <span class="hljs-keyword">if</span> (v !== undefine) <span class="hljs-built_in">module</span>.exports = v;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;<br>        define([<span class="hljs-string">&#x27;require&#x27;</span>, <span class="hljs-string">&#x27;exports&#x27;</span>, <span class="hljs-string">&#x27;./moduleB&#x27;</span>], factory);<br>    &#125;<br>&#125;)(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-keyword">export</span></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-built_in">exports</span>._esModule = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">console</span>.log(requrie);<br>    <span class="hljs-keyword">var</span> moduleB_1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./moduleB&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(moduleB_1.func);<br>    moduleB_1.func.showName();<br>    $(<span class="hljs-string">&#x27;#mydiv&#x27;</span>).html(<span class="hljs-string">&#x27;age=&#x27;</span> + moduleB_1.func.getAge())<br>&#125;)<br><br><span class="hljs-comment">// 第四步：新建一个index.html页面，用AMD方式来加载main.js文件。</span><br>&lt;!DOCTYPE html&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">    ...</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;mydiv&#x27;</span>&gt;</span>body<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;jquery.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;require.js&#x27;</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">&#x27;main.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="（6）ES6规范"><a href="#（6）ES6规范" class="headerlink" title="（6）ES6规范"></a>（6）ES6规范</h4><p>现在ES6规范支持模块化，根据规范可以直接用import和export在浏览器中导入和导出模块。一个js文件代表一个js模块。目前浏览器对ES6模块支持程度不同，一般都要借助工具进行转换，如使用babelJS把ES6代码转化为兼容ES5版本的代码。</p><p>ES6模块的基本特点：每一个模块织加载一次；每一个模块内声明的变量都是局部变量，不会污染全局作用域；模块内部的变量或者函数可以通过export导出；一个模块可以用inport导入其他模块。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 第一步： 新建一个moduleA.js文件，首先定义一个obj对象，并用export导出obj</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">31</span><br>&#125;<br><span class="hljs-keyword">export</span> &#123;obj&#125;<br><br><span class="hljs-comment">// 第二步：新建一个moduleB.js文件。首先用import &#123;obj&#125; from &#x27;./moduleA&#x27;导出模块中obj对象。然后就在moduleB中直接进行调用，最后用export &#123;func&#125;导出本模块定义的对象func</span><br><span class="hljs-keyword">import</span> &#123;obj&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./moduleA&#x27;</span>;<br><span class="hljs-keyword">var</span> func = &#123;<br>    <span class="hljs-attr">showName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(obj.name);<br>    &#125;,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> obj.age<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第三步： 新建一个入口文件man.js。使用import &#123;func&#125; from &#x27;./moduleB&#x27;导入模块中的func对象，就可以调用func.showName方法了。</span><br><span class="hljs-keyword">import</span> &#123;func&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./moduleB&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(func);<br>func.showName()<br><br><span class="hljs-comment">// 第四步： 目前浏览器对ES6模块支持还不太好，不能直接在浏览器运行，可利用babel-node工具来运行。bable-node提供了在命令行直接运行ES6模块文件的便捷方式。</span><br><span class="hljs-comment">// 在vscode中配置启动项package.json</span><br>&#123;<br>   ....<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript会根据编译时指定的模块目标参数生成相应的供CommonJs、AMD、UMD或ES6模块加载系统使用的代码。</p><p>tsconfig.json中compilerOptions对象有一个module属性，可以用来指定模块目标，支持的值有’node’、’commonjs’、 ‘amd’、’system’、’umd’、’es2015’、’esnext’。因此，可以用如下命令生成CommonJs的模块系统：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">tsc --<span class="hljs-built_in">module</span> commonjs.<span class="hljs-string">\ts\main.js</span><br></code></pre></td></tr></table></figure><h2 id="6-TypeScript如何解析模块"><a href="#6-TypeScript如何解析模块" class="headerlink" title="6. TypeScript如何解析模块"></a>6. TypeScript如何解析模块</h2><p>模块解析是指编译器在查找导入模块内容时所遵循的流程。</p><p>假设有一个导入语句<code>import &#123;m&#125; from &#39;moduleA&#39;</code>；为了检查导入的m模块是如何使用的，编译器需要准确地知道它表示什么，并且需要经常它的定义moduleA。</p><h4 id="（1）模块导入路径解析"><a href="#（1）模块导入路径解析" class="headerlink" title="（1）模块导入路径解析"></a>（1）模块导入路径解析</h4><p>模块导入时的路径分为相对路径和非相对路径，不同类型的路径会以不同的方式进行解析。</p><p>相对路径导入模式是以”/“，”./“或”../“开头的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> models <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/components/models&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;config&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./config&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../database/db&#x27;</span>;<br></code></pre></td></tr></table></figure><p>所有其他形式的导入被当作是非相对的，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;JQuery&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span><br></code></pre></td></tr></table></figure><p>相对导入在解析是相对导入它的文件而已的，并且不能解析为一个外部模块声明。我们自己写的模块使用相对导入，这样能确保它们在运行时相对位置。</p><p>非相对模块的导入可以相对于baseUrl或通过路径映射来进行解析，使用非相对路径来导入你的外部依赖。</p><h4 id="（2）模块解析策略"><a href="#（2）模块解析策略" class="headerlink" title="（2）模块解析策略"></a>（2）模块解析策略</h4><p>共有两种可用的模块解析策略：Node和Classic。可以使用 –moduleResolution标记来指定使用哪种模块解析策略。若未指定，则在使用了–module AMD|System|ES2015时的默认值为Classic，其他情况时则为Node。</p><p>Classic这种策略在以前是TypeScript默认的模块解析。现在它存在的理由主要是为了向后兼容。相对导入的模块是相对于它的文件进行解析。因此,/root/src/moduleA.ts文件里的import {b} from ‘./moduleB’导入语句会使用下面的查找顺序：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/</span>src/moduleB.ts<br><span class="hljs-regexp">/root/</span>src/moduleB.d.ts<br></code></pre></td></tr></table></figure><p>对于非相对模块的导入，编译器会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。假设在/root/src/moduleA.ts文件里有一个对moduleB模块的非相对导入，那么Import {b} from ‘moduleB’导入语句会使用下面的查找顺序：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/</span>src/moduleB.ts<br><span class="hljs-regexp">/root/</span>src/moduleB.d.ts<br><span class="hljs-regexp">/root/m</span>oduleB.ts<br><span class="hljs-regexp">/root/m</span>oduleB.d.ts<br>/moduleB.ts<br>/moduleB.d.ts<br></code></pre></td></tr></table></figure><p>Node这个解析策略在运行时按照Node.js模块的解析机制来解析模块。通常，在Node.js里导入时通过require函数调用进行的。node.js会根据require的是相对路径还是非相对路径做出不同的行为：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sas">(1)如果<span class="hljs-meta">X</span>是内置模块（如requrie(<span class="hljs-string">&#x27;http&#x27;</span>)）<br>a. 返回该模块<br>b. 不再继续执行<br>(2)如果<span class="hljs-meta">X</span>以<span class="hljs-string">&#x27;./&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-string">&#x27;../&#x27;</span>开头<br>a. 根据<span class="hljs-meta">X</span>所在的父模块，确定<span class="hljs-meta">X</span>的绝对路径<br>b. 将<span class="hljs-meta">X</span>当成文件，依次查找下面的文件，只要其中有一个存在，就返回该文件，不再继续执行。<br><span class="hljs-meta">X</span><br><span class="hljs-meta">X</span>.js<br><span class="hljs-meta">X</span>.json<br><span class="hljs-meta">X</span>.node<br>c. 将<span class="hljs-meta">X</span>当成目录，依次查找下面的文件，只要其中有一个存在，就返回该文件，不再继续执行。<br><span class="hljs-meta">X</span>/package.js<span class="hljs-meta">on(</span>main字段)<br><span class="hljs-meta">X</span>/<span class="hljs-meta">index</span>.js<br><span class="hljs-meta">X</span>/<span class="hljs-meta">index</span>.json<br><span class="hljs-meta">X</span>/<span class="hljs-meta">index</span>.node<br>(3)如果<span class="hljs-meta">X</span>不带路径<br>a. 根据<span class="hljs-meta">X</span>所在父模块，确定<span class="hljs-meta">X</span>可能的安装目录<br>b. 依次在每个目录中，将<span class="hljs-meta">X</span>当成文件名或目录名加载<br>(4)抛出<span class="hljs-string">&#x27;not found&#x27;</span><br></code></pre></td></tr></table></figure><p>假设是相对路径，为/root/src/moduleA.js，包含一个导入requrie(‘./moduleB’)语句，那么Nodejs以下面的顺序解析这个模块moduleB：</p><p>首先检查/root/src/moduleB.js文件是否存在，存在则导入；不存在则检查/root/src/moduleB目录中是否包含一个package.json文件，如果包含package.json且package.json文件指定了一个”main”模块（假设为”mian“： ”libs/moduleB.js“）， 那么Node.js会引用/root/src/moduleB/libs/moduleB.js</p><p>如果没有package.json文件，就检查/root/src/moduleB目录是否包含一个index.js文件。如果没有找到就报错。</p><p>如果是非相对模块名的解析，NodeJs会在文件夹node_module里查找模块。node_modules可能与当前文件在同一级目录或者在上层目录里。NodeJs会向上级目录遍历，查找每个node_modules直到它找到要加载的模块。</p><p>TypeScript模仿NodeJs运行时的解析策略在编译阶段单位模块定义文件。但是TypeScript在Node.js解析逻辑基础上增加了TypeScript源文件的扩展名（.ts  .tsx  .d.ts）。同时，TypeScript在package.json里使用字段’types’属性来表示类似’mian‘的意义。编译器会使用它来找到要使用的’main‘定义文件。</p><h4 id="（3）BaseUrl"><a href="#（3）BaseUrl" class="headerlink" title="（3）BaseUrl"></a>（3）BaseUrl</h4><p>在利用AMD模块加载器的应用里使用BaseUrl是常用的做法，要求在运行时模块都被放到一个文件夹里。这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。设置BaseUrl来告诉编译器到哪里去查找模块。所有非相对模块导入都会被当作相对于BaseUrl。TypeScript编译器通过tsconfigjson中的BaseUrl来设置。</p><p>相对模块的导入不会被设置的BaseUrl所影响，因为它们总是相对于导入它们的文件。</p><h4 id="（4）路径映射"><a href="#（4）路径映射" class="headerlink" title="（4）路径映射"></a>（4）路径映射</h4><p>有时模块不是直接放在BaseUrl下面。比如jquery模块的导入，在运行时可能被解释为“node_modules/jquery/dist/jquery.slim.min.js”。加载器使用映射配置来将模块名映射到运行时的文件。TypeScript编译器通过使用tsconfig.json文件里的“paths”来支持这样的声明映射。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-comment">//paths提供的话，必须提供该属性</span><br>        <span class="hljs-attr">&quot;paths&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;jquery&quot;</span>: [&#x27;node_modules/jquery/dist/jquery&#x27;] <span class="hljs-comment">// 此处映射是相对于“BaseUrl”的</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>“paths”是相对于“BaseUrl”进行解析的。</p><p>通过paths属性，还可以指定复杂的映射，包括指定多个位置。假设在一个项目中一些模块位于目录A中，而其他的模块位于目录B中，在项目构建过程中，可以用工具将模块集中到一处。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">root<br>|<span class="hljs-string">---folder1</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---file1.ts  (imports &#x27;folder1/file2&#x27; and &#x27;folder2/file3&#x27;)</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---file2.ts</span><br><span class="hljs-string"></span>|<span class="hljs-string">---generated</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---folder1</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---folder2</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---file3.ts</span><br><span class="hljs-string"></span>|<span class="hljs-string">---tsconfig.json</span><br></code></pre></td></tr></table></figure><p>那么对应的tsconfig.json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>,<br>        <span class="hljs-attr">&quot;paths&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;*&quot;</span>: [<br>                <span class="hljs-string">&quot;*&quot;</span>,<br>                <span class="hljs-string">&quot;generated/*&quot;</span><br>            ]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个tsconfig.json告诉编译器匹配所有“*”模式的模块导入会在以下两个位置查找：</p><ul><li>“*”表示模块名字不变。映射为&lt;模块名&gt;的路径将转换成<code>&lt;baseUrl&gt;/&lt;模块名&gt;</code></li><li>“generated”表示模块名前添加路径generated作为前缀，映射为&lt;模块名&gt;的路径将转换成<code>&lt;baseUrl&gt;/generated/&lt;模块名&gt;</code></li></ul><p>在对file.ts中的导入模块语句import ‘folder1/file2’进行解析时，首先匹配“*”模式且通配符捕抓到整个文件名。folder1/file2为非相对路口，需要结合BaseUrl属性值来进行合并，也就是root/folder1/file2.ts。由于此文件存在，因此导入完成。</p><p>在对file.ts中的导入模块语句import ‘folder2/file3’进行解析时，首先匹配“<code>*</code>”模式且通配符捕获到整个文件名。folder/file3为非相对路径，需要与baseUrl进行合并，也就是root/folder2/file3.由于次文件不存在，因此用第二个”<code>generated/*</code>“进行匹配。可以匹配到generated/folder2/file3。此路径为非相对路径，需要与baseUrl进行合并，也就是root/generated/folder2/file3，此文件存在，导入完成。</p><p>另外，可以利用rootDirs指定虚拟目录。有时多个目录下的项目源文件在编译时会进行合并，放在某一个输出目录中。这个输出目录可以看作是一些源目录的一个虚拟目录。利用rootDirs属性可以告诉编译器生成这个虚拟目录，此时编译器就可以在虚拟目录中解析相对模块导入，就好像不同的目录被合并到一个输出目录中一样。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">root<br>|<span class="hljs-string">---src</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---views</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---view1.ts  (imports &#x27;./template1&#x27;)</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---view2.ts</span><br><span class="hljs-string"></span>|<span class="hljs-string">---generated</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---templates</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---views</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">---template1.ts (imports &#x27;./view2&#x27;)</span><br><span class="hljs-string"></span>|<span class="hljs-string">---tsconfig.json</span><br></code></pre></td></tr></table></figure><p>rootDirs属性是一个数组，可以指定一个roots虚拟目录数组列表，列表里的内容会在运行时合并，这个tsconfig.json内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;rootDirs&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;src/views&quot;</span>,<br>            <span class="hljs-attr">&quot;generated/templates/views&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每当编译器在rootDirs的子目录下发现了相对模块导入，就会尝试从每一个rootDirs中导入。rootDirs的灵活性不仅仅在于其指定了要在逻辑上合并的物理目录列表，还体现在它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。</p><h2 id="7-声明合并"><a href="#7-声明合并" class="headerlink" title="7. 声明合并"></a>7. 声明合并</h2><p>在TypeScript中，声明合并是指编译器针对同一个名字的两个独立声明合并为单一声明，合并后的声明同时拥有原先两个声明的特性。任何数量的声明都可以被合并。</p><p>TypeScript中声明合并支持命名空间、接口和类。下面对接口。命名空间和类的声明合并进行说明。</p><h4 id="（1）合并接口"><a href="#（1）合并接口" class="headerlink" title="（1）合并接口"></a>（1）合并接口</h4><p>最简单也最常见的声明合并类型就是接口合并。从根本上说，合并的机制是把双方的成员放到一个同名的接口里。接口的非函数成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。</p><p>对应函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口A与后来的接口A合并时，后面的接口具有更高的优先级。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Ishape &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>    width: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Ishape &#123;<br>    <span class="hljs-attr">scale</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">let</span> rect: IShape = &#123;<span class="hljs-attr">heigth</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">10</span>&#125;<br><br><span class="hljs-comment">// 上面声明了两个同名的接口Ishape，但是其内部定义的属性不同，接口进行合并后就等同于：</span><br><span class="hljs-keyword">interface</span> Ishape &#123;<br>    <span class="hljs-attr">scale</span>: <span class="hljs-built_in">number</span>;<br>    heigth: <span class="hljs-built_in">number</span>;<br>    width: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> rect: IShape = &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每组接口里的声明顺序保持不变，但各组接口之间顺序是后来的接口重载出现在考前位置。</p><h1 id="六-泛型"><a href="#六-泛型" class="headerlink" title="六. 泛型"></a>六. 泛型</h1><p>泛型是TypeScript语言中的一种特性。TypeScript是一种静态类型语言，函数或方法中参数往往都是有类型限定的。我们在编写程序时，经常会遇到两个方法的功能非常相似、参数个数也一样，只是处理的参数类型不同。例如，一个是处理number类型的数据，另一个是处理string类型的数据。如果不借助泛型，那么一般需要写多个方法，分别用来处理不同的数据类型。</p><p>泛型能够在方法中传入通用的数据类型，使多个方法合并成一个，它可将类型参数化，以达到代码复用、提高代码通用性的目的。</p><h2 id="1-泛型的定义"><a href="#1-泛型的定义" class="headerlink" title="1. 泛型的定义"></a>1. 泛型的定义</h2><p>泛型是程序设计语言的一种特性。泛型是一种参数化类型。定义函数或方法时参数是形参，调用此函数或方法时传递的参数值是实参。那么参数化类型就是将类型由原来具体的类型变成一种类型参数，然后在调用时才传入具体的类型作为参数，调用时传入的类型称为类型实参。</p><p>在使用过程中，泛型操作的数据类型会根据传入的类型实参来确定。泛型可以用在类、接口和方法中分别被称为泛型类、泛型接口和泛型方法。泛型类和泛型方法同时具备通用性、类型安全和性能，是非泛型类和非泛型方法无法具备的。</p><p>泛型为TypeScript语言编写面向对象程序带来极大的便利和灵活性。泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行强制类型转换，所以性能得到提高。泛型为开发者提供了一种高性能的编程方式，能够提高代码的重用性，并允许开发者编写非常优雅的代码。</p><h4 id="（1）泛型函数的定义"><a href="#（1）泛型函数的定义" class="headerlink" title="（1）泛型函数的定义"></a>（1）泛型函数的定义</h4><p>泛型函数必须使用&lt;&gt;括起泛型类型参数T，跟在函数名后面，后续就可以用T来表示此类型。</p><p>泛型函数的基本语法为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">参数<span class="hljs-number">1</span>:T, ..., 参数n: 类型</span>): 返回类型 </span>&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，泛型函数中必须在函数名后用类型参数<code>&lt;T&gt;</code>，参数既可以没有也也是多个。一般情况下，泛型函数参数中都有一个用T定义的形参。泛型函数返回类型既可以用T来定义，也可以是其他类型。</p><h4 id="（2）泛型类的定义"><a href="#（2）泛型类的定义" class="headerlink" title="（2）泛型类的定义"></a>（2）泛型类的定义</h4><p>泛型类必须使用&lt;&gt;括起来参数T，跟在类名后面，后续就可以用T来表示此类型。泛型类的基本语法为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//属性和方法签名</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，类中的属性或方法都需要用类型参数T来约定类型，否则声明一个父类也就失去了实际意义。</p><p>方法签名是由方法名和形参列表共同组成的方法头。</p><h4 id="（3）泛型接口的定义"><a href="#（3）泛型接口的定义" class="headerlink" title="（3）泛型接口的定义"></a>（3）泛型接口的定义</h4><p>泛型接口可以使用&lt;&gt;括起泛型类型参数T，跟着接口后面，后续就可以用T来表示此类型。泛型接口的基本语法为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> 接口名&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 属性和方法签名</span><br>&#125;<br></code></pre></td></tr></table></figure><p>无法参加泛型枚举和泛型命名空间。</p><h2 id="2-详解泛型变量"><a href="#2-详解泛型变量" class="headerlink" title="2. 详解泛型变量"></a>2. 详解泛型变量</h2><p>泛型变量一般用大写字母T表示，如果有多个不同的泛型变量，可以同时用T、U和K表示。泛型变量T必须放于&lt;&gt;符号中才能告诉编译器是一个泛型变量，而不是一个普通的字母。</p><p>泛型变量T一般不能单独出现，会出现在函数、接口和类中。在函数体内，由于编译器并不知道泛型变量T定义的参数的具体数据类型，因此只能认为其为任意值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">entitySave</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">entity: T</span>): <span class="hljs-title">boolean</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;save entity to db&quot;</span>);<br>        <span class="hljs-comment">// save (entity);</span><br>        ret = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        ret = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">console</span>.log(e)<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-详解泛型函数"><a href="#3-详解泛型函数" class="headerlink" title="3. 详解泛型函数"></a>3. 详解泛型函数</h2><p>泛型函数必须使用&lt;&gt;括起泛型参数T，跟在函数名后面。泛型函数可以用一个通用的函数来处理不同的数据类型，从而提高代码的重用性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">msg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(msg);<br>    <span class="hljs-keyword">return</span> msg;<br>&#125;<br><span class="hljs-comment">// 上面定义了一个泛型函数，它的类型参数是T，可以代表任意类型，函数中有一个形参msg为T类型，返回值类型也是T类型。</span><br><span class="hljs-comment">// 调用泛型函数：</span><br><span class="hljs-keyword">let</span> g = echo&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> g); <span class="hljs-comment">//&#x27;string&#x27;</span><br><span class="hljs-comment">// 由于T的类型和参数msg的类型是一致的，因此，使用类型推断，编译器可以根据传入的参数自动为T指定类型：</span><br><span class="hljs-keyword">let</span> g = echo(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> g) <span class="hljs-comment">// &#x27;string&#x27;</span><br></code></pre></td></tr></table></figure><p>泛型函数内部泛型参数T只能当作一个any类型值来使用，并不能调用可能存在的方法或属性。如果通过类型断言，就可以打破这个限制：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">msg:T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> msg === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log((&lt;<span class="hljs-built_in">string</span>&gt;&lt;unknow&gt;msg).length)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> msg === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log((&lt;<span class="hljs-built_in">number</span>&gt;&lt;unknown&gt;msg).toFixed(<span class="hljs-number">2</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> msg)<br>    &#125; <br>    <span class="hljs-keyword">return</span> msg;<br>&#125;<br>echo(<span class="hljs-string">&#x27;222&#x27;</span>);<br>echo(<span class="hljs-number">222</span>)<br><br><span class="hljs-comment">// 用typeof判断参数msg的类型是否为string，如果是，就用类型断言(&lt;string&gt;&lt;unknown&gt;msg)将其转为字符串类型，并调用length属性；如果不是字符串类型，判断是否为数值类对象，如果是就用类型断言(&lt;number&gt;&lt;unkown&gt;msg)将其转为数值类型，并调用toFixed方法。</span><br></code></pre></td></tr></table></figure><p><code>&lt;string&gt;&lt;unkown&gt;msg</code>也可以写成<code>&lt;string&gt;msg</code></p><p>假设有一个学生管理信息系统，其中需要对学生和老师对象进行数据处理（增、删、改、查）。如果没有泛型，那么需要写两个数据处理的类来分别对学生实体和老师实体进行处理，借助泛型，可以对应该通用的数据处理方法对不同实体进行数据处理。</p><h2 id="4-详解泛型类"><a href="#4-详解泛型类" class="headerlink" title="4. 详解泛型类"></a>4. 详解泛型类</h2><p>泛型类必须使用&lt;&gt;括起泛型类型参数T，跟在类名后面。</p><p>类是面向对象编程中一个非常重要的概念。类是现实问题的抽象，包括实现事物的主要属性和行为。</p><p>假设现在有一个简单的学生管理信息系统需要开发，通过做需求分析，我们梳理出这个系统主要有几个实体：学生、老师和课程。通过分析，我们明确了学生、老师和课程这几个实体的属性，并将其转成类。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 学生实体有学号（XH,字符型）、姓名（name, 字符型）和班级名称（clazz,字符型）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-attr">XH</span>: <span class="hljs-built_in">string</span>;<br>    name: <span class="hljs-built_in">string</span>;<br>    clazz: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">XH: <span class="hljs-built_in">string</span>, name: <span class="hljs-built_in">string</span>, clazz: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.XH = XH;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.clazz = clazz;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 老师实体有工号（GH，字符型）和姓名（name， 字符型）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-attr">GH</span>: <span class="hljs-built_in">string</span>;<br>    name: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">GH: <span class="hljs-built_in">string</span>, name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.GH = GH;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作为一个管理系统，必须对学生和老师相关数据进行处理，一般来说就是增删改查。如果没有泛型，那么需要写多个非常类似的数据处理类，分别对学生实例和老师类实例进行处理。</p><p>基于泛型类和泛型接口，可以构建一个通用的后台数据操作类，GenericDAOI。该类是泛型类：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IGeneric&lt;T&gt; &#123;<br>    <span class="hljs-attr">arg</span>: T;<br>    save(arg: T): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDAO</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">IGeneric</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-attr">arg</span>: T;<br>    save(arg: T): <span class="hljs-built_in">boolean</span> &#123;<br>        <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123; <br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;svae to do&quot;</span>);<br>            <span class="hljs-comment">//save(arg);</span><br>            ret = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>            <span class="hljs-built_in">console</span>.log(e);<br>            ret = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">// 对学生和老师等不同的数据进行操作：</span><br><span class="hljs-keyword">let</span> student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;0906&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>m <span class="hljs-string">&#x27;高三一班&#x27;</span>);<br><span class="hljs-keyword">let</span> teacher = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&#x27;T1008&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>);<br><span class="hljs-keyword">let</span> geDao = <span class="hljs-keyword">new</span> GenericDAO&lt;Student&gt;();<br><span class="hljs-keyword">let</span> ret = getDao.save(student);<br><span class="hljs-keyword">let</span> geDao2 = <span class="hljs-keyword">new</span> GenericDAO&lt;Teacher&gt;();<br>ret = geDao2.save(teacher);<br><span class="hljs-built_in">console</span>.log(ret)<br></code></pre></td></tr></table></figure><h2 id="5-详解泛型约束"><a href="#5-详解泛型约束" class="headerlink" title="5. 详解泛型约束"></a>5. 详解泛型约束</h2><p>泛型参数T类似于any类型，可以表示任意值。但是有些情况下，函数需要处理的数据有一定的约束，比如有一个分泛型函数需要访问参数T的length属性，并加1.基于这种需求，必须对泛型参数T进行约束，也就是泛型约束。</p><p>泛型约束的语法为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">T <span class="hljs-keyword">extends</span> 接口或类<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 为了直观地理解泛型约束的相关内涵，首先定义一个接口来明确约束条件，给出一个用于约束泛型的接口IGeneric，其中有一个属性length：</span><br><span class="hljs-keyword">interface</span> IGeneric &#123;<br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// 创建一个泛型类GenericAdd,此泛型类的T需要继承这个接口以实现泛型约束。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericAdd</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IGeneric</span>&gt; </span>&#123;<br>    <span class="hljs-attr">arg</span>: T;<br>    add(arg: T): <span class="hljs-built_in">boolean</span> &#123;<br>        <span class="hljs-built_in">this</span>.arg = arg;<br>        arg.length ++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">getLength</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.arg.length<br>    &#125;<br>&#125;<br><span class="hljs-comment">// &lt;T extends IGeneric&gt;创建了一个带约束的泛型类。泛型类型T必须有一个length属性，否则无法作为泛型类GenericAdd的参数。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjLen</span> </span>&#123;<br>    length = <span class="hljs-number">2</span>;<br>    name = <span class="hljs-string">&#x27;obj&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> ObjLen();<br><span class="hljs-keyword">let</span> geDao = <span class="hljs-keyword">new</span> GenericAdd&lt;ObjLen&gt;().add(obj);<br><span class="hljs-keyword">let</span> geDao2 = <span class="hljs-keyword">new</span> GenericAdd&lt;<span class="hljs-built_in">string</span>&gt;().add(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-comment">// let geDao3 = new GenericAdd&lt;number&gt;(); //报错，没有name属性</span><br></code></pre></td></tr></table></figure><p>除了用接口作为泛型约束外，还可以用一个类型参数约束另一个类型参数。比如，现在想要用属性名从对象obj中获取属性，并且要确保这个属性存在于对象obj中，那么需要在这两个类型参数之间使用约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 索引类型（Index types）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>, <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: K</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">let</span> x = getProperty(obj, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">//1</span><br><span class="hljs-keyword">let</span> m = getProperty(obj, <span class="hljs-string">&#x27;m&#x27;</span>); <span class="hljs-comment">//报错</span><br><span class="hljs-comment">// keyof T 是索引类型查询操作符，索引类型属于TypeScript中的高级类型。</span><br></code></pre></td></tr></table></figure><p>.</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sass学习笔记</title>
    <link href="/2020/09/28/HTML&amp;CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Sass%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/09/28/HTML&amp;CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Sass%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-CSS-预处理器？"><a href="#什么是-CSS-预处理器？" class="headerlink" title="什么是 CSS 预处理器？"></a>什么是 CSS 预处理器？</h2><p><strong>定义：</strong></p><p>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。</p><p>通俗的说，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，例如你可以在 CSS 中使用<strong>变量</strong>、<strong>简单的逻辑程序</strong>、<strong>函数（</strong>如右侧代码编辑器中就使用了变量**$color）<strong>等等在编程语言中的一些基本特性，可以让你的 CSS <strong>更加简洁</strong>、</strong>适应性更强<strong>、</strong>可读性更佳<strong>，</strong>更易于代码的维护**等诸多好处。</p><p><strong>其它 CSS 预处理器语言：</strong></p><p>CSS 预处理器技术已经非常的成熟，而且也涌现出了很多种不同的 <strong>CSS 预处理器语言</strong>，比如说：</p><ul><li>Sass（SCSS）</li><li>LESS</li><li>Stylus</li><li>Turbine</li><li>Swithch CSS</li><li>CSS Cacheer</li><li>DT CSS</li></ul><p>如此之多的 CSS 预处理器，那么“我应该选择哪种 CSS 预处理器？”也相应成了最近网上的一大热门话题，在 <strong>Linkedin</strong>、<strong>Twitter</strong>、<strong>CSS-Trick</strong>、<strong>知乎</strong>以及各大技术论坛上，很多人为此争论不休。相比过去我们对是否应该使用 CSS 预处理器的话题而言，这已经是很大的进步了。</p><p>到目前为止，在众多优秀的 CSS 预处理器语言中就属 <strong>Sass</strong>、<strong>LESS</strong> 和 <strong>Stylus</strong> 最优秀，讨论的也多，对比的也多。本教程将着重向大家介绍 CSS 预处理器中的 Sass。相信前端开发工程师会喜欢的。</p><h2 id="什么是-Sass？"><a href="#什么是-Sass？" class="headerlink" title="什么是 Sass？"></a>什么是 Sass？</h2><p><a href="http://sass-lang.com/">Sass 官网</a>上是这样描述 Sass 的：</p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Sass</span> 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。<br>Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。<br></code></pre></td></tr></table></figure><p><strong>Sass 前世今生：</strong></p><p>Sass 是最早的 CSS 预处理语言，有比 LESS 更为强大的功能，不过其一开始的缩进式语法（Sass 老版本语法，后面课程会详细介绍 ）并不能被大众接受，不过由于其强大的功能和 Ruby on Rails 的大力推动，还是有很多开发者选择了 Sass。</p><p>Sass 是采用 <strong>Ruby</strong> 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和 HTML 一样的缩进式风格。</p><p><strong>为什么早期不如 LESS 普及？</strong></p><p>虽然缩进式风格可以有效缩减代码量，强制规范编码风格，但它一方面并不为大多数程序接受，另一方面无法兼容已有的 CSS 代码。这也是 Sass 虽然出现得最早，但远不如 LESS 普及的原因。</p><h2 id="Sass-和-SCSS-有什么区别？"><a href="#Sass-和-SCSS-有什么区别？" class="headerlink" title="Sass 和 SCSS 有什么区别？"></a>Sass 和 SCSS 有什么区别？</h2><p>Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：</p><ol><li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li><li>语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。</li></ol><p>先来看一个示例：</p><p><strong>Sass 语法</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$font</span>-stack: Helvetica, sans-serif  <span class="hljs-comment">//定义变量</span><br><span class="hljs-variable">$primary</span>-<span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span> //定义变量<br><br><span class="hljs-selector-tag">body</span><br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> <span class="hljs-variable">$font</span>-stack<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary</span>-color<br></code></pre></td></tr></table></figure><p><strong>SCSS 语法</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<br><span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#333</span>;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> <span class="hljs-variable">$font-stack</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编译出来的 CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> Helvetica, sans-serif;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>提示：</strong>小伙伴们可以看出来，我们的右侧代码使用的是 <strong>SCSS 语法</strong>方式（我们的代码编辑器<strong>不支持</strong> <strong>Sass 语法</strong>方式噢！）。</p><h2 id="Sass-SCSS-和纯-CSS-写法差很多吗？"><a href="#Sass-SCSS-和纯-CSS-写法差很多吗？" class="headerlink" title="Sass/SCSS 和纯 CSS 写法差很多吗？"></a>Sass/SCSS 和纯 CSS 写法差很多吗？</h2><p>写法差很多吗？这是很多初学者会问的一个问题。那么借此机会简单了解一下。</p><p><strong>Sass 和 CSS 写法有差别：</strong></p><p>Sass 和 CSS 写法的确存在一定的差异，由于 Sass 是基于 Ruby 写出来，所以其延续了 Ruby 的书写规范。在书写 Sass 时不带有大括号和分号，其主要是依靠严格的缩进方式来控制的。如：</p><p>Sass写法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">body</span><br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span><br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f36</span><br></code></pre></td></tr></table></figure><p>而在 CSS 我们是这样书写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">background</span>:<span class="hljs-number">#f36</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SCSS 和 CSS 写法无差别：</strong></p><p>SCSS 和 CSS 写法无差别，这也是 Sass 后来越来越受大众喜欢原因之一。简单点说，把你现有的“.css”文件直接修改成“.scss”即可使用。</p>]]></content>
    
    
    <categories>
      
      <category>HTML&amp;CSS学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 和 React 区别</title>
    <link href="/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%20%E5%92%8C%20React%20%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%20%E5%92%8C%20React%20%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-区别点："><a href="#一-区别点：" class="headerlink" title="一. 区别点："></a>一. 区别点：</h2><ul><li><strong>Templating vs JSX</strong></li></ul><p>react的思路是all in js，通过js来生成html， 所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等</p><p>vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件， 可以把html、css、js写到一个文件中，html提供了模板引擎来处理</p><p>react渲染是使用jsx，用js来操作html，列表渲染、条件判断等都通过js来控制，而vue提供了模板的语法，支持指令、过滤器等模板功能，简化了渲染逻辑。在react组件里需要写大段js才能描述清楚的逻辑，使用vue的模板可以很简洁紧凑的表明。</p><ul><li> <strong>单向绑定 vs 双向绑定</strong></li></ul><p>单双向绑定，指的是View层和Model层之间的映射关系。</p><p>双向绑定是在同一个组件内，将数据和视图绑定起来，和父子组件之间的通信并无什么关联；</p><p>React采用单向绑定，如图所示：<br>       <img src="https://img-blog.csdnimg.cn/20200820105639128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>用户访问View，用户发出交互到Actions中进行处理，Actions中通过setState对State进行更新，可以看出，View层不能直接修改State，必须要通过Actions来进行操作，这样更加清晰可控。</p><p>而Vue支持单向绑定和双向绑定：</p><p>单向绑定：插值形式， v-bind也是单向绑定。</p><p>双向绑定：表单v-model，用户对view层的更改会直接同步到model层。（实际上v-model只是v-bind:value 和 v-on:input的语法糖）</p><ul><li><strong>框架本质不同</strong></li></ul><p>Vue是MVVM模式的一种方式实现。但没有完全遵循 MVVM 模型。</p><p>React是前端组件化框架，是严格的view层，MVC模式。由后端组件化发展而来。</p><ul><li> <strong>状态管理</strong></li></ul><p>应用中的状态是React关键的概念，也有一些配套框架被设计为管理一个大的state对象，如Redux。state对象在react应用中是不可变的，需要使用setState()方法更新状态。在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。</p><p>而在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理，也无需使用如setState()之类的方法去改变它的状态，在Vue对象中，data参数就是应用中数据的保存者。</p><ul><li> <strong>性能优化</strong></li></ul><p>在react中，当组件状态改变时（setState后），它会触发整个子组件数重新渲染，以根组件作为渲染基点。为了避免不必要的子组件重新渲染，你需要使用PureComponent或者实现 shouldComponentUpdate。<br>  在Vue中，vue组件在初始化时会通过Object.defineProperty对每一个data属性建立对应的Wather，然后在模板编译时收集依赖。以后只要修改data的任何一个属性，就会触发视图的重新渲染，而且是精确的修改对应的vdom。这就不需要开发人员对整个性能进行优化，允许他们更专注于构建应用程序本身。   </p><p>总之，react的性能优化需要手动去做，而vue的性能优化是自动的，但是vue的响应式机制也有问题，就是当state特别多的时候，Watcher也会很多，会导致卡顿，所以大型应用（状态特别多的）一般用react，更加可控。</p><ul><li><strong>Hoc和minxins</strong></li></ul><h2 id="二-共同点："><a href="#二-共同点：" class="headerlink" title="二. 共同点："></a><strong>二. 共同点：</strong></h2><ul><li><strong>单向数据流</strong></li></ul><p>数据流指的是组件之间的数据流动。</p><p>虽然vue有双向绑定v-model，但是vue和react父子组件之间数据传递，仍然还是遵循单向数据流的，父组件可以向子组件传递props，但是子组件不能修改父组件传递来的props，子组件只能通过事件通知父组件进行数据更改。如图：</p><p><img src="https://img-blog.csdnimg.cn/2020081916312479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>这样做的优点是所有状态的改变可记录、可跟踪、源头易追溯，所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性。</p><ul><li> <strong>都使用Virtual DOM</strong></li></ul><p>Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。</p><ul><li> <strong>组件化</strong></li></ul><p>React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。</p><p><strong>学习于</strong>：</p><p><a href="https://segmentfault.com/q/1010000019491720">单向数据流和双向数据</a></p><p> <a href="https://www.cnblogs.com/Jomsou/p/10342466.html">Vue与React的异同</a></p><p><a href="https://www.cnblogs.com/suihang/p/10098860.html">Vue和React的对比</a></p><p><a href="https://zhuanlan.zhihu.com/p/33051365">React与Vue有什么不同？</a></p><p><a href="https://blog.csdn.net/a1943206465/article/details/60570567?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-60570567.nonecase">react的工作原理</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redux使用</title>
    <link href="/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redux%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redux%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p> </p>]]></content>
    
    
    <categories>
      
      <category>React学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 组件通信方式</title>
    <link href="/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>需要组件之间进行通信的几种情况</p><ul><li>父组件向子组件通信</li><li>子组件向父组件通信</li><li>跨级组件通信</li><li>没有嵌套关系组件之间的通信</li></ul><h3 id="1-父组件向子组件通信"><a href="#1-父组件向子组件通信" class="headerlink" title="1. 父组件向子组件通信"></a>1. 父组件向子组件通信</h3><p>React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息。<br><img src="https://img-blog.csdnimg.cn/2020081916071520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>父组件PageA</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ChildA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/ChildA&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pageA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                pageA</span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tom&quot;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><span class="hljs-comment">//函数组件：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pageA</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            pageA</span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Eve&quot;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> pageA;<br></code></pre></td></tr></table></figure><p><strong>子组件ChildA</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                ChildA: my name is &#123;this.props.name&#125;</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><span class="hljs-comment">//函数组件：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildA</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            ChildA: my name is &#123;props.name&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ChildA;<br></code></pre></td></tr></table></figure><h3 id="2-子组件向父组件通信"><a href="#2-子组件向父组件通信" class="headerlink" title="2. 子组件向父组件通信"></a>2. 子组件向父组件通信</h3><p>利用自定义事件，触发回调</p><p><strong>子组件ChildA</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">data</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;<br>    &#125;<br>    valueChange = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            <span class="hljs-attr">data</span>: data.target.value<br>        &#125;)<br>        <span class="hljs-built_in">this</span>.props.transferValue(data.target.value)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                ChildA</span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.data&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.valueChange&#125;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><span class="hljs-comment">//函数组件的方式：</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ChildA;<br></code></pre></td></tr></table></figure><p><strong>父组件</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ChildA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/ChildA&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pageA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>    &#125;<br>    childValue = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;data&#125;)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                pageA: 子组件ChildA传递过来的值：&#123;this.state.data&#125;</span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">transferValue</span>=<span class="hljs-string">&#123;this.childValue&#125;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> pageA;<br></code></pre></td></tr></table></figure><h3 id="3-跨级组件通信"><a href="#3-跨级组件通信" class="headerlink" title="3. 跨级组件通信"></a>3. 跨级组件通信</h3><p><a href="https://www.jianshu.com/p/eba2b76b290b?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">聊一聊我对 React Context 的理解以及应用</a></p><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法，它设计目的就是为了共享那些对于一个组件树而言是“全局”的数据</p><p>Context API的使用基于生产者消费者模式。生产者一方，通过组件静态属性childContextTypes声明，然后通过实例方法getChildContext()创建Context对象。消费者一方，通过组件静态属性contextTypes申请要用到的Context属性，然后通过实例的context访问Context的属性。</p><p><strong>旧版本context使用方法：</strong></p><p><strong>父组件PageB</strong>：（生产者）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><span class="hljs-keyword">import</span> ChildB <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/ChildB&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> childContextTypes = &#123;<br>        <span class="hljs-attr">propsB</span>: PropTypes.string,<br>        <span class="hljs-attr">methodB</span>: PropTypes.func<br>    &#125;<br>    <span class="hljs-comment">// 声明Context对象属性</span><br>    <span class="hljs-function"><span class="hljs-title">getChildContext</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">propsB</span>: <span class="hljs-string">&#x27;propsB&#x27;</span>,<br>            <span class="hljs-attr">methodB</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;methodB&#x27;</span><br>        &#125;<br>    &#125;<br>     <span class="hljs-comment">// 返回Context对象，方法名是约定好的</span><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> /&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PageB;<br></code></pre></td></tr></table></figure><p><strong>子组件ChildB</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ChildC <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildC&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildC</span> /&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ChildB;<br></code></pre></td></tr></table></figure><p><strong>子组件ChildC</strong>：（消费者）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>     <span class="hljs-comment">// 声明需要使用的Context属性</span><br>    <span class="hljs-keyword">static</span> contextTypes = &#123;<br>        <span class="hljs-attr">propsB</span>: PropTypes.string,<br>        <span class="hljs-attr">methodB</span>: PropTypes.func<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;propsB, methodB&#125; = <span class="hljs-built_in">this</span>.context;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;!111111&quot;</span>)<br>        <span class="hljs-built_in">console</span>.log(propsB)<br>        <span class="hljs-keyword">let</span> res = methodB()<br>        <span class="hljs-built_in">console</span>.log(res)<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                ChildC</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ChildC;<br></code></pre></td></tr></table></figure><p><strong>react升级后：</strong></p><p><a href="https://blog.csdn.net/weixin_46124214/article/details/108102826">React：Context 使用</a></p><h3 id="4-非嵌套组件间通信"><a href="#4-非嵌套组件间通信" class="headerlink" title="4. 非嵌套组件间通信"></a>4. 非嵌套组件间通信</h3><p>发布者通过emit事件触发方法，发布订阅消息给订阅者。</p><p>订阅者通过emitter.<strong>addListener</strong>(事件名称,函数名)方法，进行事件监听(订阅)。<br>订阅者通过emitter.<strong>removeListener</strong>(事件名称,函数名)方法 ，进行事件销毁(取消订阅)</p><p><strong>父组件pageC</strong>（发布者）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> Custom1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Custom1&#x27;</span>;<br><span class="hljs-keyword">import</span> Custom2 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Custom2&#x27;</span>;<br><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Evt&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>()<br>        <span class="hljs-built_in">this</span>.handleClick = <span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>        emitter.emit(<span class="hljs-string">&#x27;callCustom&#x27;</span>, <span class="hljs-string">&#x27;Hello 我来发信息啦&#x27;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                PageC</span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>点击发布事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Custom1</span> /&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Custom2</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PageC;<br></code></pre></td></tr></table></figure><p><strong>子组件Custom1（订阅者）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Evt.js&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Custom1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        emitter.addListener(<span class="hljs-string">&#x27;callCustom&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Custom1收到信息--&#x27;</span> + msg<br>            &#125;)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        emitter.removeListenner(<span class="hljs-string">&#x27;callCustom&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Custom1即将销毁此信息&#x27;</span> + msg<br>            &#125;)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&#x27;<span class="hljs-attr">red</span>&#x27;&#125;&#125;&gt;</span></span><br><span class="xml">                &#123;this.state.msg&#125;</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Custom1;<br></code></pre></td></tr></table></figure><p><strong>子组件Custom2（订阅者）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Evt&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Custom2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">super</span>();<br>      <span class="hljs-built_in">this</span>.state= &#123;<br>        <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;<br>  <br>    componentDidMount () &#123; <span class="hljs-comment">//在组件挂载完成后声明一个自定义事件</span><br>      emitter.addListener(<span class="hljs-string">&#x27;callCustom&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Custom2收到消息--&#x27;</span>+msg<br>        &#125;)<br>      &#125;)<br>    &#125;<br>  <br>    componentWillUnmount () &#123; <span class="hljs-comment">//组件销毁前移除事件监听</span><br>      emitter.removeListener(<span class="hljs-string">&#x27;callCustom&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Custom2即将销毁此消息--&#x27;</span>+ msg<br>        &#125;)<br>      &#125;)<br>    &#125;<br>  <br>    <span class="hljs-comment">//订阅者2消息显示</span><br>    render () &#123;<br>      <span class="hljs-keyword">return</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&#x27;<span class="hljs-attr">blue</span>&#x27;&#125;&#125;&gt;</span>&#123;this.state.msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>) <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Custom2;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 生命周期</title>
    <link href="/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一-React-v16-3前的生命周期"><a href="#一-React-v16-3前的生命周期" class="headerlink" title="一. React v16.3前的生命周期"></a>一. React v16.3前的生命周期</h2><p><img src="https://img-blog.csdnimg.cn/20200819161542855.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="1-组件初始化initialization阶段"><a href="#1-组件初始化initialization阶段" class="headerlink" title="1. 组件初始化initialization阶段"></a>1. 组件初始化initialization阶段</h3><figure class="highlight delphi"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span>：初始化<span class="hljs-title">state</span></span><br><span class="hljs-function"><span class="hljs-title">getDefaultProps</span><span class="hljs-params">()</span>:</span>设置默认的props，也可以用defaultProps设置组件的默认属性<br>getInitialState():初始化state，可以直接在<span class="hljs-function"><span class="hljs-keyword">constructor</span>中定义<span class="hljs-title">this</span>.<span class="hljs-title">state</span></span><br></code></pre></td></tr></table></figure><h3 id="2-组件挂载Mounting阶段"><a href="#2-组件挂载Mounting阶段" class="headerlink" title="2. 组件挂载Mounting阶段"></a>2. 组件挂载Mounting阶段</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentWillMount</span><span class="hljs-params">()</span></span>：在组件挂载到DOM前调用，整个生命周期只会被调用一次，以后组件更新不会调用，此时可以修改state<br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span>：创建虚拟dom，进行diff算法，更新dom树都在此进行。<br><span class="hljs-function"><span class="hljs-title">componentDidsMount</span><span class="hljs-params">()</span></span>：组件挂载到DOM后调用，只会被调用一次。<br></code></pre></td></tr></table></figure><h3 id="3-组件更新Updation阶段"><a href="#3-组件更新Updation阶段" class="headerlink" title="3. 组件更新Updation阶段"></a>3. 组件更新Updation阶段</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentWillReceiveProps</span><span class="hljs-params">(nextProps)</span></span>：组件挂载时不调用，组件接受新的props时调用<br><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span><span class="hljs-params">(nextProps, nextState)</span></span>：组件接收到新的props或者state时调用，return true就会更新dom(使用diff算法更新)，return false能阻止更新(不调用render)。<br><span class="hljs-function"><span class="hljs-title">componentWillUpdate</span><span class="hljs-params">(nextProps, nextState)</span></span>：在组件更新前调用，此时可以修改state<br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span>：创建虚拟dom，进行diff算法，更新dom树都在此进行。<br><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span><span class="hljs-params">()</span></span>:组件更新完成后调用<br></code></pre></td></tr></table></figure><p><strong>造成组件更新的两类（三种）情况：</strong></p><h4 id="（1）父组件重新render"><a href="#（1）父组件重新render" class="headerlink" title="（1）父组件重新render"></a><strong>（1）父组件重新render</strong></h4><p>父组件重新render引起子组件重新render的情况有两种：</p><ul><li><p>子组件直接使用父组件传过来的props, 每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextProps</span>)</span>&#123; <span class="hljs-comment">// 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染</span><br>        <span class="hljs-keyword">if</span>(nextProps.someThings === <span class="hljs-built_in">this</span>.props.someThings)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.props.someThings&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>子组件在componentWillReceiveProps方法中，将props转换成自己的state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            <span class="hljs-attr">someThings</span>: props.someThings<br>        &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentWillReceiveProps</span>(<span class="hljs-params">nextProps</span>)</span> &#123; <span class="hljs-comment">// 父组件重传props时就会调用这个方法</span><br>        <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">someThings</span>: nextProps.someThings&#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.state.someThings&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有个问题，每次组件接收到新的props或者使用setState更新state时，子组件都会重新渲染，除非用shouldComponentUpdate做了处理来阻止。那上面代码中根据新的props更新state，子组件是不是要进行两次渲染？回答否！</p><p>在该函数(componentWillReceiveProps)中调用 this.setState() 将不会引起第二次渲染。</p><p>是因为componentWillReceiveProps中判断props是否变化了，若变化了，this.setState将引起state变化，从而引起render，此时就没必要再做第二次因重传props引起的render了，不然重复做一样的渲染了。</p></li></ul><h4 id="（2）组件本身调用setState"><a href="#（2）组件本身调用setState" class="headerlink" title="（2）组件本身调用setState"></a>（2）组件本身调用setState</h4><p>没有导致state的值发生变化的setState也会导致重渲染。可通过shouldComponentUpdate方法优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>          <span class="hljs-attr">someThings</span>:<span class="hljs-number">1</span><br>        &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextStates</span>)</span>&#123; <span class="hljs-comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span><br>        <span class="hljs-keyword">if</span>(nextStates.someThings === <span class="hljs-built_in">this</span>.state.someThings)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>   handleClick = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 虽然调用了setState ，但state并无变化</span><br>        <span class="hljs-keyword">const</span> preSomeThings = <span class="hljs-built_in">this</span>.state.someThings<br>         <span class="hljs-built_in">this</span>.setState(&#123;<br>            <span class="hljs-attr">someThings</span>: preSomeThings<br>         &#125;)<br>   &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.someThings&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/penghuwan/p/6707254.html">【react】利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性</a></p><h3 id="4-组件卸载Unmounting阶段"><a href="#4-组件卸载Unmounting阶段" class="headerlink" title="4. 组件卸载Unmounting阶段"></a>4. 组件卸载Unmounting阶段</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span>：组件卸载前调用，只调用一次<br></code></pre></td></tr></table></figure><h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">component<span class="hljs-constructor">DidCatch(<span class="hljs-params">error</span>, <span class="hljs-params">info</span>)</span>：任何一处的javascript报错会触发<br></code></pre></td></tr></table></figure><h2 id="二-React-v16-3"><a href="#二-React-v16-3" class="headerlink" title="二. React v16.3"></a>二. React v16.3</h2><p><img src="https://img-blog.csdnimg.cn/20200819161606424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p>React16 新的生命周期弃用了componentWillMount、componentWillReceiveProps、componentWillUpdate</p></li><li><p>新增了getDerivedStateFromProps、getSnapshotBeforeUpdate代替弃用的三个钩子函数</p></li><li><p>React16并没有删除那三个钩子函数，但是不能和新增两个钩子函数混用</p></li></ul><h2 id="三-React-v16-4"><a href="#三-React-v16-4" class="headerlink" title="三. React v16.4+"></a>三. React v16.4+</h2><p><img src="https://img-blog.csdnimg.cn/2020081916162119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>)</span> &#123;<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">return</span> newState;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">注意是静态函数，实例无关。用来更新state，return null表示不需要更新，调用时机有2个：</span><br><span class="hljs-comment">(1)组件实例化完成之后</span><br><span class="hljs-comment">(2)re-render之前（类似于componentWillReceiveProps的时机）</span><br><span class="hljs-comment">配合componentDidUpdate使用，用来解决之前需要在componentWillReceiveProps里setState的场景，比如state依赖更新前后的props的场景</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>)</span> &#123;<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">return</span> snapshot;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">这个不是静态函数，调用时机是应用DOM更新之前，返回值会作为第3个参数传递给componentDidUpdate():</span><br><span class="hljs-comment">componentDidUpdate(prevProps, prevState, snapshot)</span><br><span class="hljs-comment">用来解决需要在DOM更新之前保留当前状态的场景，比如滚动条位置。类似的需求之前会通过`componentWillUpdate`来实现，现在通过`getSnapshotBeforeUpdate + componentDidUpdate`实现</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><p><strong>学习于</strong>:</p><p><a href="https://segmentfault.com/a/1190000016617400">React-新的生命周期（React16版本）</a></p><p><a href="https://www.jianshu.com/p/514fe21b9914">详解React生命周期(包括react16最新版)</a></p><p><a href="https://www.debug8.com/javascript/t_27291.html">react-v16.3新生命周期总结</a></p><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React 生命周期</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react 路由</title>
    <link href="/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react%20%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react%20%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-react-router-与-react-router-dom区别"><a href="#1-react-router-与-react-router-dom区别" class="headerlink" title="1. react-router 与 react-router-dom区别"></a>1. react-router 与 react-router-dom区别</h2><p><a href="https://www.cnblogs.com/menggirl23/p/10288477.html">react-router与react-router-dom使用时的区别</a></p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><p>首先进入项目目录，使用npm安装react-router-dom：</p><figure class="highlight q"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs q">npm install react-router-dom --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><h4 id="基础使用："><a href="#基础使用：" class="headerlink" title="基础使用："></a>基础使用：</h4><p><img src="https://img-blog.csdnimg.cn/20200819160211480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>Class1.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Class1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Class1;<br></code></pre></td></tr></table></figure><p><strong>Class2.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Class2<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Class2;<br></code></pre></td></tr></table></figure><p><strong>App.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> Class1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Class1&#x27;</span>;<br><span class="hljs-keyword">import</span> Class2 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Class2&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/class1&quot;</span>&gt;</span>class1<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/class2&quot;</span>&gt;</span>class2<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/class1&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Class1&#125;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;class2&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Class2&#125;</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p><strong>入口文件 index.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br><br>ReactDOM.render(<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="3-路由基本组件"><a href="#3-路由基本组件" class="headerlink" title="3. 路由基本组件"></a>3. 路由基本组件</h2><ul><li><code>&lt;BrowserRouter&gt;</code>：使用Html5提供的history API来保持UI和URL的同步</li><li><code>&lt;HashRouter&gt;</code>：使用URL和hash来保持UI和URL的同步</li><li><code>&lt;Link&gt;</code>：是react路由中点击切换到哪一个组件的链接</li><li><code>&lt;Route&gt;</code>：代表了你的路由界面，path代表路径，component代表路径对应的界面。</li><li><code>&lt;Switch&gt;</code>：仅渲染与当前位置匹配的第一个子元素。</li><li>exact：路由严格匹配模式，例：‘ink’ 与 ‘/‘正常情况下他们是匹配的，严格模式下他们是不匹配的。</li></ul><h2 id="4-嵌套路由"><a href="#4-嵌套路由" class="headerlink" title="4. 嵌套路由"></a>4. 嵌套路由</h2><p><strong>Class1.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link, Switch&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> Home = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><span class="hljs-keyword">const</span> About = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Class1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/class1/&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/class1/about&quot;</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/class1/&quot;</span> <span class="hljs-attr">component</span> = <span class="hljs-string">&#123;Home&#125;/</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/class1/about&quot;</span> <span class="hljs-attr">component</span> = <span class="hljs-string">&#123;About&#125;</span> /&gt;</span> </span><br><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Class1;<br></code></pre></td></tr></table></figure><h2 id="5-路由传参"><a href="#5-路由传参" class="headerlink" title="5. 路由传参"></a>5. 路由传参</h2><p><strong>Class1.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link, Switch&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> Home = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><span class="hljs-comment">// const About = (res) =&gt; &#123;</span><br><span class="hljs-comment">//         console.log(res);</span><br><span class="hljs-comment">//         return &lt;h1&gt;about&lt;/h1&gt;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-keyword">const</span> About = <span class="hljs-function">(<span class="hljs-params">&#123;location, history,match&#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(match.params.title);<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Class1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/class1/&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/class1/about/i-am-title&quot;</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/class1/&quot;</span> <span class="hljs-attr">component</span> = <span class="hljs-string">&#123;Home&#125;/</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/class1/about/:title&quot;</span> <span class="hljs-attr">component</span> = <span class="hljs-string">&#123;About&#125;</span> /&gt;</span> </span><br><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Class1;<br></code></pre></td></tr></table></figure><h2 id="6-lt-Route-gt-的渲染方式"><a href="#6-lt-Route-gt-的渲染方式" class="headerlink" title="6. &lt;Route&gt;的渲染方式"></a>6. <code>&lt;Route&gt;</code>的渲染方式</h2><ul><li><p><strong>component</strong>：一个React组件。当带有component参数的route匹配成功后，route会返回一个新的元素，其为component参数所对应的React组件。</p></li><li><p><strong>render</strong>：一个返回React element的函数。当匹配成功后调用该函数。该过程与传入component参数类似。</p></li><li><p><strong>children</strong>：一个返回React element的函数。与上述两个参数不同，无论route是否匹配当前location，其都会被渲染。</p></li></ul><p><strong>重定向 Redirect</strong>：</p><p>Redirect重定向是路由的重定向，应该写在组件Route中，一般使用render来实现它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<br>    BroserRouter <span class="hljs-keyword">as</span> Router,<br>    Route,<br>    Link,<br>    Redirect<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br>...<br>&lt;p&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/class1/redirect&#x27;</span>&gt;</span>redirect<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span>&lt;/p&gt;<br>...<br>&lt;Route path=<span class="hljs-string">&#x27;/class1/redirect&#x27;</span> render=&#123;<span class="hljs-function">() =&gt;</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/class/&#x27;</span> /&gt;</span></span><br>    )&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义链接</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> OldSchoolMenuLink = <span class="hljs-function">(<span class="hljs-params">&#123;label, to, activeOnlyWhenExact&#125;</span>) =&gt;</span> (<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> </span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;to&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">children</span> = <span class="hljs-string">&#123;(&#123;match&#125;)</span> =&gt;</span> (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;match</span> ? &quot;<span class="hljs-attr">active</span>&quot; <span class="hljs-attr">:</span> &quot;&quot;&#125; &gt;</span></span><br><span class="xml">            &#123;match ? &quot;&gt;&quot; :&quot;&quot;&#125;</span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#123;to&#125;</span>&gt;</span>&#123;label&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        )&#125;</span><br><span class="xml">)</span><br><span class="xml">//使用</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">OldSchoolMenuLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;About&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="7-编程式导航"><a href="#7-编程式导航" class="headerlink" title="7.  编程式导航"></a>7.  编程式导航</h2><p>react-router提供了一个withRouter组件，withRouter可以包装如何自定义组件，将react-router的history，location，match三个对象传入。无需一级传递react-router的属性，当需要用的router属性的时候，将组件包一层withRouter，就可以拿到需要的路由信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> RouterChange = withRouther(<span class="hljs-function">(<span class="hljs-params">&#123;history&#125;</span>) =&gt;</span> (<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> history.push(&#x27;/class1/&#x27;)&#125;&gt;跳转<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>))<br></code></pre></td></tr></table></figure><h2 id="8-阻止跳转"><a href="#8-阻止跳转" class="headerlink" title="8. 阻止跳转"></a>8. 阻止跳转</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link, Prompt&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Prompt</span> </span></span><br><span class="hljs-tag"><span class="xml">    <span class="hljs-attr">when</span>=<span class="hljs-string">&#123;this.state.isBlocking&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">    <span class="hljs-attr">message</span>=<span class="hljs-string">&#123;location</span> =&gt;</span> `你确定要离开当前页面跳转至$&#123;location.pathname&#125;`&#125;</span><br><span class="xml">/&gt;</span><br></code></pre></td></tr></table></figure><p>使用Prompt组件：when为布尔值是否开启验证</p><p>message: string 当用户离开当前页面时，设置的提示信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;Prompt message=<span class="hljs-string">&#x27;确定要离开？&#x27;</span>/&gt;<br></code></pre></td></tr></table></figure><p>message:func 当用户离开当前页面时，设置的回调函数</p><h2 id="9-NavLink"><a href="#9-NavLink" class="headerlink" title="9. NavLink"></a>9. NavLink</h2><p><code>&lt;NavLink&gt;</code>是<code>&lt;Link&gt;</code>的一个特定的版本，会在匹配上当前的URL的时候给已经渲染的元素添加上参数。</p><ul><li>activeClassName（string）：设置选中的样式，默认值为active</li><li>activeStyle（object）：当前元素被选中时，为此元素添加样式</li><li>isActive（func）：判断链接是否激活的额外逻辑的功能</li></ul><p><strong>学习于</strong>：</p><p><a href="https://www.bilibili.com/video/BV1YC4y1p7LG?from=search&seid=7930184209219319256">React全家桶之Router学习（一）</a></p><p><a href="https://www.bilibili.com/video/BV1eC4y1p74u?from=search&seid=7930184209219319256">React全家桶之Router学习（二）</a></p><p><a href="https://www.bilibili.com/video/BV1MQ4y1P74J?from=search&seid=7930184209219319256">React全家桶之Router学习（三）</a></p><p><strong>文档</strong>：</p><p><a href="http://react-guide.github.io/react-router-cn/docs/Introduction.html">React Router 中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react context使用</title>
    <link href="/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react%20context%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react%20context%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行跨层级数据传递的方法，它设计目的就是为了共享那些对于一个组件树而言是“全局”的数据</p><h2 id="一-式例1"><a href="#一-式例1" class="headerlink" title="一. 式例1"></a>一. 式例1</h2><h4 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h4><p><img src="https://img-blog.csdnimg.cn/20200819155135853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h4><p><strong>global.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> globalData = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> globalContext = React.createContext(globalData);<br></code></pre></td></tr></table></figure><p><strong>/public/index.html</strong>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;%PUBLIC_URL%/favicon.ico&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;theme-color&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><br><span class="hljs-tag">      <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Web site created using create-react-app&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;apple-touch-icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;%PUBLIC_URL%/logo192.png&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;manifest&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;%PUBLIC_URL%/manifest.json&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>React App<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">      <span class="hljs-selector-class">.app</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span></span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-selector-class">.father</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span></span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-selector-class">.son</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid pink;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span>   </span><br><span class="css">      &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>App.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; globalContext, globalData &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../global&#x27;</span>;<br><span class="hljs-keyword">import</span> Father <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Father&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; Provider &#125; = globalContext;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props)<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      ...globalData<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state&#125;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是App组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p><strong>Father.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> Son <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Son&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是Father组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Father;<br></code></pre></td></tr></table></figure><p><strong>Son.js</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：</span><br><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; globalContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../global&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是Son组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">                &#123;this.context.a&#125;</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br>Son.contextType = globalContext;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Son;<br><span class="hljs-comment">//方式二：</span><br><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; globalContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../global&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; Consumer &#125; = globalContext;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是Son组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span>&gt;</span></span><br><span class="xml">                    &#123;</span><br><span class="xml">                        value =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;value.a&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">                    &#125;</span><br><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">Consumer</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Son;<br></code></pre></td></tr></table></figure><h4 id="3-修改状态"><a href="#3-修改状态" class="headerlink" title="3. 修改状态"></a>3. 修改状态</h4><p><strong>global.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> globalData = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> globalActions = <span class="hljs-function"><span class="hljs-params">self</span> =&gt;</span> (&#123;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>        self.setState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123;<br>            <span class="hljs-attr">a</span>: state.a + <span class="hljs-number">1</span><br>        &#125;))<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">minus</span>(<span class="hljs-params"></span>)</span> &#123;<br>        self.setState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123;<br>            <span class="hljs-attr">a</span>: state.a -<span class="hljs-number">1</span><br>        &#125;))<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> globalContext = React.createContext(globalData);<br></code></pre></td></tr></table></figure><p><strong>App.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; globalContext, globalData, globalActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../global&#x27;</span>;<br><span class="hljs-keyword">import</span> Father <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Father&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; Provider &#125; = globalContext;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props)<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      ...globalData,<br>      ...globalActions(<span class="hljs-built_in">this</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state&#125;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是App组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p><strong>Son.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; globalContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../global&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">add1</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context.add()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">minus1</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context.minus()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是Son组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">                &#123;this.context.a&#125; </span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add1.bind(this)&#125;</span>&gt;</span>点我 +1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.minus1.bind(this)&#125;</span>&gt;</span>点我 -1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br>Son.contextType = globalContext;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Son;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200819155228131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="二-示例2"><a href="#二-示例2" class="headerlink" title="二. 示例2"></a>二. 示例2</h2><h4 id="1-目录结构-1"><a href="#1-目录结构-1" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h4><p><img src="https://img-blog.csdnimg.cn/20200819155257816.png#pic_center" alt="在这里插入图片描述"></p><h4 id="2-基本使用-方法一"><a href="#2-基本使用-方法一" class="headerlink" title="2. 基本使用-方法一"></a>2. 基本使用-方法一</h4><p><strong>someData.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">const</span> Context = React.createContext();<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>()<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            <span class="hljs-attr">people</span>: [<br>                &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,<br>                    <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>                    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;male&quot;</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaohong&quot;</span>,<br>                    <span class="hljs-attr">age</span>: <span class="hljs-number">11</span>,<br>                    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;female&quot;</span><br>                &#125;<br>            ]<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.people&#125;</span>&gt;</span></span><br><span class="xml">                &#123;this.props.children&#125;</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Provider</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>App.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; SomeData &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./SomeData&#x27;</span>;<br><span class="hljs-keyword">import</span> Display <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Display&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">SomeData</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Display</span> /&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">SomeData</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p><strong>Display.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Context &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./SomeData&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Display</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> val = React.useContext(Context);<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>name: &#123;val[0].name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>name: &#123;val[0].age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-基本使用-方法二"><a href="#3-基本使用-方法二" class="headerlink" title="3. 基本使用-方法二"></a>3. 基本使用-方法二</h4><p><strong>someData.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Context = React.createContext();<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>()<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            <span class="hljs-attr">people</span>: [<br>                &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,<br>                    <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>                    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;male&quot;</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaohong&quot;</span>,<br>                    <span class="hljs-attr">age</span>: <span class="hljs-number">11</span>,<br>                    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;female&quot;</span><br>                &#125;<br>            ]<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.people&#125;</span>&gt;</span></span><br><span class="xml">                &#123;this.props.children&#125;</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Provider</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ContextConsumer = Context.Consumer<br></code></pre></td></tr></table></figure><p><strong>Display.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; ContextConsumer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./SomeData&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Display</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ContextConsumer</span>&gt;</span></span><br><span class="xml">            &#123;value =&gt; value.map(val =&gt; &#123;</span><br><span class="xml">                return (</span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;val.name&#125;</span>&gt;</span></span><br><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>name: &#123;val.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>age: &#123;val.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                )</span><br><span class="xml">            &#125;)&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ContextConsumer</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://reactjs.bootcss.com/docs/context.html">React 中文文档 context</a></p>]]></content>
    
    
    <categories>
      
      <category>React学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>params与query</title>
    <link href="/2020/08/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/params%E4%B8%8Equery/"/>
    <url>/2020/08/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/params%E4%B8%8Equery/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Vue中路由的传参"><a href="#一-Vue中路由的传参" class="headerlink" title="一. Vue中路由的传参"></a>一. Vue中路由的传参</h1><p>假设需要实现一个路由切换，点击之切换到<code>W组件</code>。并传递一个<code>id</code>值和一个<code>age</code>值。</p><p>运用<code>router-link</code>来写：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;A: &#x27;xxx&#x27;, query: &#123;xx: &#x27;xxx&#x27;&#125;&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;A: &#x27;xxx&#x27;, params: &#123;xx: &#x27;xxx&#x27;&#125;&#125;&quot;</span> /&gt;</span><br>routers:&#123;???&#125;<br></code></pre></td></tr></table></figure><p>对于query 和 params来说：</p><ul><li>A是那么还是path</li><li>routers要怎么写</li><li>url长什么样子</li><li>会有什么隐藏的坑吗</li></ul><h2 id="1-query："><a href="#1-query：" class="headerlink" title="1. query："></a>1. <code>query</code>：</h2><p><code>name</code>和<code>path</code>都可以用。</p><ul><li><strong>name</strong>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;W&#x27;, query: &#123; id:&#x27;1234&#x27;，age:&#x27;12&#x27; &#125;&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">`routes`基于`name`设置：</code></pre></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hhhhhhh&#x27;</span>, <span class="hljs-comment">//这里可以任意</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;W&#x27;</span>,  <span class="hljs-comment">//这里必须是W</span><br>  <span class="hljs-attr">component</span>: W<br>&#125;<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">然后就把`path`匹配添加到`url`上去：</code></pre></div><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/#/</span>hhhhhhh?id=<span class="hljs-number">1234</span>&amp;age=<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><ul><li><strong>path</strong>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/W&#x27;, query: &#123; id:&#x27;1234&#x27;,age:&#x27;12&#x27; &#125;&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">基于`path`来设置`routes`：</code></pre></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/W&#x27;</span>, <span class="hljs-comment">//这里必须是W</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hhhhhhhh&#x27;</span>,  <span class="hljs-comment">//这里任意</span><br>  <span class="hljs-attr">component</span>: W<br>&#125;<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">`url`:</code></pre></div><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/#/</span>W?id=<span class="hljs-number">1234</span>&amp;age=<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">这两种方法，都可以自定义`path`的样式，不过一个是在`router-link to`里面定义，一个则是在`routes`里面定义</code></pre></div><ul><li><p><strong>接收参数</strong>:</p><p>在接收参数的时候都是使用<code>this.$route.query.id</code></p></li></ul><h2 id="2-parmas"><a href="#2-parmas" class="headerlink" title="2. parmas"></a>2. <code>parmas</code></h2><p>这里只能用<code>name</code>不能用<code>path</code>，不然会直接无视掉<code>params</code>中的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;W&#x27;, params: &#123; id:&#x27;1234&#x27;,age:&#x27;12&#x27; &#125;&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>然后在<code>routes</code>中添加:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>      <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/W/:id/:age&#x27;</span>,<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;W&#x27;</span>,<br>      <span class="hljs-attr">component</span>:W<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>name</code>与上面<code>router-link</code>中的<code>name</code>保持一致</p><p><code>url</code>就取决于这个<code>path</code>的写法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/#/</span>W<span class="hljs-regexp">/1234/</span><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>注意，<code>path</code>里面的<code>/w</code>可以任意写，写成<code>/hhhhh</code>也可以。<br>但是！<code>/:id</code>和<code>/:age</code>不能省略，且不能改名字</p><p>不写的话，第一次点击可以实现组件跳转，且可以通过<code>this.$route.parmas.id</code>获取到传过来的<code>id</code>值，但如果刷新页面，传过来的<code>id</code>值和<code>age</code>值就会丢失。从这也能看出params比query严格。</p><h1 id="二-Node中的req-query和req-params"><a href="#二-Node中的req-query和req-params" class="headerlink" title="二. Node中的req.query和req.params"></a>二. Node中的req.query和req.params</h1><p>在后端中，要接受前端的<code>axios</code>请求，于是我们又会接触到了query、params。</p><p>什么样的<code>axios</code>请求对应什么样的接受方式？<br>还有不止是<code>req.query</code>,<code>req.params</code>,还多了<code>req.body</code></p><p>假设前端现在用axios向后端发送一个请求，发送id值请求后端的数据。</p><h2 id="1-req-query"><a href="#1-req-query" class="headerlink" title="1. req.query"></a>1. <code>req.query</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">`/api/?id=1234`</span>)<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">`/api`</span>，&#123; <span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1234&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure><p>在前端里面，<code>router</code>怎么发送的就怎么收</p><ul><li><code>query</code>发送的就用<code>this.$route.query</code>接收</li><li><code>params</code>发送的就用<code>this.$route.params</code>接收</li></ul><p>但在这里，虽然第二种方式里面有<code>params</code>，但这两种我们都要用<code>req.query.id</code>来获取里面的<code>id</code>值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">router.get(<span class="hljs-string">&#x27;/api&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(req.query.id)<br>.......<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-req-params"><a href="#2-req-params" class="headerlink" title="2. req.params"></a>2. <code>req.params</code></h2><p>那如果直接把<code>id</code>值写进发送的<code>url</code>里面呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">`/api/1234`</span>)<br></code></pre></td></tr></table></figure><p>看这个形式有没有觉得很眼熟<br>它跟上面<code>params</code>的<code>url</code>非常像<br>我们就反向操作一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">router.get(<span class="hljs-string">&#x27;/api/:id&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(req.params.id)<br>    .......<br>    &#125;)<br></code></pre></td></tr></table></figure><p>如果它是这么请求的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">`/api/1234-12`</span>)<br></code></pre></td></tr></table></figure><p>中间用<code>-</code>或者<code>&amp;</code>隔开</p><p>那我们也可以在获取时的路径上这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">router.get(<span class="hljs-string">&#x27;/api/:id-:age&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(req.params.id)<br>    <span class="hljs-built_in">console</span>.log(req.params.age)<br>    .......<br>    &#125;)<br></code></pre></td></tr></table></figure><h2 id="3-req-body"><a href="#3-req-body" class="headerlink" title="3. req.body"></a>3. <code>req.body</code></h2><p>上面两个都是处理<code>get</code>请求的，而<code>req.body</code>就是用来处理<code>post</code>请求的。(需要安装<code>body-parser</code>中间件）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.post(<span class="hljs-string">`/api`</span>,&#123; <span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1234&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure><p>我们就用<code>req.body</code>来接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">router.get(<span class="hljs-string">&#x27;/api&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(req.body.id)<br>.......<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>转载于</strong>：</p><p><a href="https://segmentfault.com/a/1190000018940855">容易混淆-论query和params在前后端中的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器.组成与渲染原理</title>
    <link href="/2020/06/01/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E6%B5%8F%E8%A7%88%E5%99%A8.%E7%BB%84%E6%88%90%E4%B8%8E%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <url>/2020/06/01/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E6%B5%8F%E8%A7%88%E5%99%A8.%E7%BB%84%E6%88%90%E4%B8%8E%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="（一）浏览器组成结构"><a href="#（一）浏览器组成结构" class="headerlink" title="（一）浏览器组成结构"></a>（一）浏览器组成结构</h1><h3 id="1-从打开浏览器输入一个网址到页面展示网页内容的这段时间内，浏览器和服务器都发生了什么事情？"><a href="#1-从打开浏览器输入一个网址到页面展示网页内容的这段时间内，浏览器和服务器都发生了什么事情？" class="headerlink" title="1. 从打开浏览器输入一个网址到页面展示网页内容的这段时间内，浏览器和服务器都发生了什么事情？"></a>1. 从打开浏览器输入一个网址到页面展示网页内容的这段时间内，浏览器和服务器都发生了什么事情？</h3><ul><li>在接收到用户输入的网址后，浏览器会开启一个线程来处理这个请求，对用户输入的URL地址进行分析判断，如果是HTTP协议就按照HTTP方式来处理。</li><li>调用浏览器引擎中对应方法，比如WebView中的loadUrl方法，分析并加载这个URL地址。</li><li>通过DNS解析获取网站地址对应的IP地址，查询完成后连同浏览器的Cookie、userAgent等信息向网站目的IP发财GET请求。</li><li>进行HTTP协议会话，浏览器客户端向Web服务器发送报文。</li><li>进入网站后台上的Web服务器处理请求，如Apache、Tomcat、Node.js等服务器。</li><li>进入部署好的后端应用，如 PHP、Java、JavaScript、Python等后端程序，找到对应的请求处理逻辑，这期间会读取服务器缓存或查询数据库等。</li><li>服务器处理请求并返回响应报文，此时如果浏览器访问过该页面，缓存上有对应资源，会与服务器最后修改记录对比，一致则返回304，否则返回200和对应的内容。</li><li>浏览器开始下载HTML文档（响应报文状态码为200时）或者从本地缓存读取文件内容（浏览器缓存有效或响应报文状态码为304时）</li><li>浏览器根据下载收到的HTML文件解析结构建立DOM文档树，并根据HTML中的标记请求下载指定的MIME类型文件（如CSS、JavaScript脚本等），同时设置缓存等内容。</li><li>页面开始解析渲染DOM，CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染，JavaScript根据DOM API操作DOM，并读取浏览器缓存，执行事件绑定等，页面整个展示过程完成。</li></ul><p>整个过程中使用到了较多的浏览器功能，如用户地址输入框、网络请求、浏览器文档解析、渲染引擎、JavaScript执行引擎、客户端存储等。</p><h3 id="2-浏览器主要结构："><a href="#2-浏览器主要结构：" class="headerlink" title="2. 浏览器主要结构："></a><strong>2. 浏览器主要结构</strong>：</h3><ul><li><p><strong>用户界面</strong></p><p>用户界面包括浏览器中可见的地址输入框、浏览器前进返回按钮、打开书签、打开历史记录等用户可操作的功能选项。</p></li><li><p><strong>浏览器引擎</strong></p><p>浏览器引擎可以在用户界面和渲染引擎之间传递指令和在客户端本地缓存中读写数据等，是浏览器中各个部分之间互相通信的核心。</p></li><li><p><strong>渲染引擎</strong></p><p>浏览器渲染引擎的功能是解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面。浏览器内核主要指 渲染引擎。</p></li><li><p><strong>网络</strong></p><p>网络功能模块是浏览器开启网络线程发送请求或下载资源文件的模块，例如DOM树解析过程中请求静态资源首先是通过浏览器中网络模块发起的。</p></li><li><p><strong>JavaScript引擎</strong></p><p>JavaScript解析器则是浏览器解释和执行JavaScript脚本的部分，例如V8引擎。</p></li><li><p><strong>UI后端</strong></p><p>UI后端用于绘制基本的浏览器窗口内控件，比如组合选择框、按钮、输入框等。</p></li><li><p><strong>数据持久化存储</strong></p><p>浏览器数据持久化存储涉及cookie、localStorage等一些客户端存储技术，可以通过浏览器提供的API进行调用。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200820122632698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="（二）浏览器渲染引擎简介"><a href="#（二）浏览器渲染引擎简介" class="headerlink" title="（二）浏览器渲染引擎简介"></a>（二）浏览器渲染引擎简介</h1><h3 id="1-渲染引擎的主要工作流程"><a href="#1-渲染引擎的主要工作流程" class="headerlink" title="1. 渲染引擎的主要工作流程"></a>1. 渲染引擎的主要工作流程</h3><p>渲染引擎在浏览器中主要用于解析HTML文档和CSS文档，然后将CSS规则应用到HTML标签元素上，并将HTML渲染到浏览器窗口中一显示具体的DOM内容。</p><p><strong>推荐文章</strong>：<a href="https://blog.csdn.net/farsight1/article/details/79758347">十分钟读懂浏览器渲染流程</a></p><p><strong>推荐视频</strong>：<a href="https://www.bilibili.com/video/av73509607">浏览器渲染机制</a></p><p><img src="https://img-blog.csdnimg.cn/20200820122854714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200820122855312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-浏览器兼容性"><a href="#2-浏览器兼容性" class="headerlink" title="2. 浏览器兼容性"></a>2. 浏览器兼容性</h3><p>现在的市场上有很多种类的浏览器，不同种类的浏览器的内核也不尽相同，所以不同浏览器对代码的解析会存在差异，这就导致对页面渲染效果不统一的问题。</p><p>市场上常见的浏览器内核主要有四种：<strong>Webkit内核、Presto内核、Trident内核、Gecko内核。</strong></p><table><thead><tr><th align="center">浏览器</th><th align="center">内核</th></tr></thead><tbody><tr><td align="center">Chrome</td><td align="center">Blink（webkit的分支内核）</td></tr><tr><td align="center">Safari</td><td align="center">Webkit</td></tr><tr><td align="center">Firefox</td><td align="center">Gecko</td></tr><tr><td align="center">Opera</td><td align="center">Blink（此前使用Presto内核）</td></tr><tr><td align="center">IE</td><td align="center">Trident（俗称IE内核）</td></tr><tr><td align="center">360浏览器</td><td align="center">IE+Chrome双内核</td></tr><tr><td align="center">QQ浏览器</td><td align="center">Trident（兼容模式）+Webkit（高速模式）</td></tr><tr><td align="center">搜狗浏览器</td><td align="center">Trident（兼容模式）+Webkit（高速模式）</td></tr><tr><td align="center">猎豹浏览器</td><td align="center">Trident（兼容模式）+Webkit（高速模式）</td></tr><tr><td align="center">百度浏览器</td><td align="center">IE内核</td></tr></tbody></table><p><strong>详细见</strong>：<a href="https://www.jianshu.com/p/6afd596440bb">前端浏览器兼容性问题总结</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术知识归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件</title>
    <link href="/2020/05/21/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/05/21/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>事件是与浏览器或文档交互的瞬间，如点击按钮，填写表格等，它是JS与HTML之间交互的桥梁。</p><h2 id="（一）事件流"><a href="#（一）事件流" class="headerlink" title="（一）事件流"></a><strong>（一）事件流</strong></h2><p>DOM是树形结构，如果同时给父子节点都绑定事件时，当触发子节点的时候，这两个事件的发生顺序如何决定? 这就涉及到事件流的概念，它描述的是页面中接受事件的顺序。</p><p>事件流有两种:</p><ul><li><strong>事件冒泡</strong>(Event Capturing): 是一种从下往上的传播方式。事件最开始由最具体的元素(文档中嵌套层次最深的那个节点接受, 也就是DOM最低层的子节点), 然后逐渐向上传播到最不具体的那个节点，也就是DOM中最高层的父节点。</li><li><strong>事件捕获</strong>(Event Bubbling): 与事件冒泡相反。事件最开始由不太具体的节点最早接受事件, 而最具体的节点最后接受事件。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><br>1<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><br>2<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box1&quot;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> box2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box2&quot;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> box3 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box3&quot;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> box4 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box4&quot;</span>);</span><br><span class="javascript">    </span><br><span class="javascript">    box1.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;box1&quot;</span>);</span><br><span class="javascript">   &#125;,<span class="hljs-literal">true</span>)</span><br><span class="javascript"></span><br><span class="javascript">  box2.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;box2&quot;</span>);</span><br><span class="javascript">   &#125;,<span class="hljs-literal">false</span>)</span><br><span class="javascript"></span><br><span class="javascript">  box3.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;box3&quot;</span>);</span><br><span class="javascript">   &#125;,<span class="hljs-literal">true</span>)</span><br><span class="javascript"></span><br><span class="javascript">  box4.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;box4&quot;</span>);</span><br><span class="javascript">   &#125;,<span class="hljs-literal">true</span>)</span><br><span class="javascript"></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    * &#123;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    &#125;  </span><br><span class="css">    <span class="hljs-selector-id">#box1</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: orange;</span><br><span class="css">    &#125;  </span><br><span class="css">    <span class="hljs-selector-id">#box2</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125; </span><br><span class="css">    <span class="hljs-selector-id">#box3</span>, <span class="hljs-selector-id">#box4</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#box4</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>如何让事件先冒泡后捕获？</strong></p><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p><h2 id="（二）事件模型"><a href="#（二）事件模型" class="headerlink" title="（二）事件模型"></a><strong>（二）事件模型</strong></h2><h4 id="1-DOM0级模型"><a href="#1-DOM0级模型" class="headerlink" title="1. DOM0级模型"></a>1. <strong>DOM0级模型</strong></h4><p>又称为原始事件模型，在该模型中，事件不会传播，即没有事件流的概念。事件绑定监听函数比较简单, 有两种方式:</p><ul><li><p>HTML代码中直接绑定:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-string">&quot;fun()&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>通过JS代码指定属性值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> btn = document.getElementById(<span class="hljs-string">&#x27;.btn&#x27;</span>);<br>btn.onclick = <span class="hljs-function"><span class="hljs-keyword">fun</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>移除监听函数：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">btn.onclick</span> = null<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><p>这种方式所有浏览器都兼容，但是逻辑与显示并没有分离。</p><h4 id="2-IE事件模型"><a href="#2-IE事件模型" class="headerlink" title="2. IE事件模型"></a><strong>2. IE事件模型</strong></h4><p>IE事件模型共有两个过程:</p><ul><li><strong>事件处理阶段</strong>(target phase)。事件到达目标元素, 触发目标元素的监听函数。</li><li><strong>事件冒泡阶段</strong>(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li></ul><p>事件绑定监听函数的方式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">attachEvent(eventType, handler)<br></code></pre></td></tr></table></figure><p>事件移除监听函数的方式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">detachEvent(eventType, handler)<br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li><code>eventType</code>指定事件类型(注意加on)</li><li><code>handler</code>是事件处理函数</li></ul><h4 id="3-DOM2级模型"><a href="#3-DOM2级模型" class="headerlink" title="3. DOM2级模型"></a><strong>3. DOM2级模型</strong></h4><p>属于W3C标准模型，现代浏览器(除IE6-8之外的浏览器)都支持该模型。在该事件模型中，一次事件共有三个过程:</p><ul><li><strong>事件捕获阶段</strong>(capturing phase)。事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li><li><strong>事件处理阶段</strong>(target phase)。事件到达目标元素, 触发目标元素的监听函数。</li><li><strong>事件冒泡阶段</strong>(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li></ul><p>事件绑定监听函数的方式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">addEventListener(eventType, handler, useCapture)<br></code></pre></td></tr></table></figure><p>事件移除监听函数的方式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">removeEventListener(eventType, handler, useCapture)<br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li><code>eventType</code>指定事件类型(不要加on)</li><li><code>handler</code>是事件处理函数</li><li><code>useCapture</code>是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致。<ul><li>true - 事件句柄在捕获阶段执行</li><li>false- 默认。事件句柄在冒泡阶段执行</li></ul></li></ul><h2 id="（三）事件对象"><a href="#（三）事件对象" class="headerlink" title="（三）事件对象"></a><strong>（三）事件对象</strong></h2><p>当一个事件被触发时，会创建一个事件对象(Event Object), 这个对象里面包含了与该事件相关的属性或者方法。该对象会作为第一个参数传递给监听函数。</p><ul><li>DOM事件模型中的事件对象常用属性:<ul><li><code>type</code>用于获取事件类型</li><li><code>target</code>获取事件目标</li><li><code>stopPropagation()</code>阻止事件冒泡</li><li><code>preventDefault()</code>阻止事件默认行为</li></ul></li><li>IE事件模型中的事件对象常用属性:<ul><li><code>type</code>用于获取事件类型</li><li><code>srcElement</code>获取事件目标</li><li><code>cancelBubble</code>阻止事件冒泡</li><li><code>returnValue</code>阻止事件默认行为</li></ul></li></ul><h2 id="（四）事件委托"><a href="#（四）事件委托" class="headerlink" title="（四）事件委托"></a><strong>（四）事件委托</strong></h2><p>“事件代理”是利用事件冒泡的原理，把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。</p><p><strong>优点</strong>：</p><ul><li>可以减少事件注册，节省大量内存占用。</li><li>可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#list&#x27;</span>);</span><br><span class="javascript">ul.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> target = e.target;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">while</span>( target.tagName !== <span class="hljs-string">&#x27;LI&#x27;</span> )&#123;</span><br><span class="javascript">           <span class="hljs-keyword">if</span> ( target.tagName === <span class="hljs-string">&#x27;UL&#x27;</span> )&#123;</span><br><span class="javascript">                target = <span class="hljs-literal">null</span>;</span><br><span class="javascript">                <span class="hljs-keyword">break</span>;</span><br><span class="javascript">           &#125;</span><br><span class="javascript"></span><br><span class="javascript">           target = target.parentNode;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">if</span> ( target )&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你点击了ui里的li&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>参考文章</strong>：</p><p><a href="https://www.jb51.net/article/85477.htm">javascript事件模型介绍</a></p><p><a href="https://www.cnblogs.com/duanlibo/p/10969664.html">JS事件模型</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EventBus实现</title>
    <link href="/2020/05/16/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/EventBus%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/05/16/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/EventBus%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEventBus</span></span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">this</span>.eventQueue = &#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;  <span class="hljs-comment">//订阅</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.eventQueue[eventName]) &#123;<br><span class="hljs-built_in">this</span>.eventQueue[eventName] = []<br>&#125;<br><span class="hljs-built_in">this</span>.eventQueue[eventName].push(callback)<br>&#125;<br><span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> wrap = <span class="hljs-function">(<span class="hljs-params">...argus</span>) =&gt;</span> &#123;<br>            callback.apply(<span class="hljs-built_in">this</span>, argus)<br>            <span class="hljs-built_in">this</span>.off(eventName, wrap)<br>        &#125;<br>        <span class="hljs-built_in">this</span>.on(eventName,wrap)<br>&#125;<br><span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">eventName, ...argus</span>)</span> &#123;  <span class="hljs-comment">//发布</span><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.eventQueue[eventName]) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> callback <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.eventQueue[eventName])&#123;<br>             callback(...argus);<br>     &#125;       <br>     &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> cbList = <span class="hljs-built_in">this</span>.eventQueue[eventName];<br><span class="hljs-keyword">if</span>(cbList) &#123;<br>            <span class="hljs-keyword">if</span>(callback) &#123;<br>                cbList.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (item == callback) cbList.splice(index, <span class="hljs-number">1</span>)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cbList.length = <span class="hljs-number">0</span>;<br>            &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a><strong>测试</strong>：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> EventBus = <span class="hljs-keyword">new</span> MyEventBus()<br><br><span class="hljs-comment">//订阅消息</span><br>EventBus.once(<span class="hljs-string">&#x27;first-event&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>&#123;<br>    alert(<span class="hljs-string">`订阅的消息是：<span class="hljs-subst">$&#123;msg&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 发送消息</span><br>EventBus.emit(<span class="hljs-string">&#x27;first-event&#x27;</span>, <span class="hljs-string">&quot;123&quot;</span>)<br>EventBus.emit(<span class="hljs-string">&#x27;first-event&#x27;</span>, <span class="hljs-string">&quot;456&quot;</span>)<br><br><span class="hljs-comment">// 移除消息</span><br>EventBus.off(<span class="hljs-string">&#x27;first-event&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中的异步以及事件轮询机制</title>
    <link href="/2020/05/15/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/05/15/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-JS为何是单线程的？"><a href="#1-JS为何是单线程的？" class="headerlink" title="1. JS为何是单线程的？"></a>1. JS为何是单线程的？</h2><p> JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。（在JAVA和c#中的异步均是通过多线程实现的，没有循环队列一说，直接在子线程中完成相关的操作）</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h2 id="2-JS是单线程的，那么他是如何是实现异步操作的？"><a href="#2-JS是单线程的，那么他是如何是实现异步操作的？" class="headerlink" title="2. JS是单线程的，那么他是如何是实现异步操作的？"></a>2. JS是单线程的，那么他是如何是实现异步操作的？</h2><p>JS的异步是通过回调函数实现的，即通过任务队列，在主线程执行完当前的任务栈（所有的同步操作），主线程空闲后轮询任务队列，并将任务队列中的任务（回调函数）取出来执行。”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 <code>onclick</code>, <code>setTimeout</code>, <code>ajax</code> 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 <code>DOM Binding</code>、<code>network</code>、<code>timer</code>模块。</p><ul><li><code>onclick </code>由浏览器内核的 <code>DOM Binding</code> 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中。</li><li><code>setTimeout</code> 会由浏览器内核的 <code>timer</code> 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中。</li><li><code>ajax</code> 则会由浏览器内核的 <code>network </code>模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中。</li></ul><p><strong>JS中的异步运行机制</strong>如下:  </p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ul><h2 id="3-JS种事件队列的优先级"><a href="#3-JS种事件队列的优先级" class="headerlink" title="3. JS种事件队列的优先级"></a>3. JS种事件队列的优先级</h2><p>在JS中ES6 中新增的任务队列（promise）是在事件循环之上的，事件循环每次 tick 后会查看 ES6 的任务队列中是否有任务要执行，也就是 ES6 的任务队列比事件循环中的任务（事件）队列优先级更高。</p><p>如 Promise 就使用了 ES6 的任务队列特性。也即在执行完任务栈后首先执行的是任务队列中的promise任务。其他的上面常见的异步操作加入队列的时间没有相应的优先级。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;111&#x27;</span>)&#125;,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2222&quot;</span>);<span class="hljs-comment">//此处还没有执行异步操作，执行异步操作及执行回调函数，在promise中即then中的回调</span><br>  resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3333&#x27;</span>)&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;44444&quot;</span>);<br><span class="hljs-comment">//输出</span><br> <span class="hljs-number">2222</span><br> <span class="hljs-number">44444</span><span class="hljs-comment">//上面的两个输出属于同步操作</span><br> <span class="hljs-number">3333</span><span class="hljs-comment">//promise加入到队列的优先级高于setTimeout</span><br> <span class="hljs-number">111</span><br></code></pre></td></tr></table></figure><p>   同时在嵌套异步操作中，会将嵌套的异步加入到下次的任务队列中，以此类推（如嵌套的promise）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;<br>  resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;111&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;<br>   resolve();<br>&#125;)<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;222&quot;</span>);&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;<br>    resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;33333&quot;</span>);&#125;)<span class="hljs-comment">//输出 111 33333 222</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue路由模式hash和history模式</title>
    <link href="/2020/05/14/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8Fhash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/14/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8Fhash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="hash模式和history模式-实现原理及区别"><a href="#hash模式和history模式-实现原理及区别" class="headerlink" title="hash模式和history模式 实现原理及区别"></a>hash模式和history模式 实现原理及区别</h1><p>目前单页应用（SPA）越来越成为前端主流，单页应用一大特点就是使用前端路由，由前端来直接控制路由跳转逻辑，而不再由后端人员控制，这给了前端更多的自由。</p><p>目前前端路由主要有两种实现方式：<code>hash</code> 模式和 <code>history</code>模式，下面分别详细说明。</p><h3 id="1-hash模式"><a href="#1-hash模式" class="headerlink" title="1. hash模式"></a>1. hash模式</h3><p>比如在用超链接制作锚点跳转的时候，就会发现，url后面跟了”#id”，hash值就是url中从”#”号开始到结束的部分。</p><p>hash值变化浏览器不会重新发起请求，但是会触发<code>window.hashChange</code>事件，假如我们在hashChange事件中获取当前的hash值，并根据hash值来修改页面内容，则达到了前端路由的目的。</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html：菜单中href设置为hash形式，id为app中放置页面内容 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#index&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#news&quot;</span>&gt;</span>资讯<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#user&quot;</span>&gt;</span>个人中心<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在window.onhashchange中获取hash值，根据不同的值，修改app中不同的内容，起到了路由的效果</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashChange</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-comment">// console.log(location.hash)</span><br>    <span class="hljs-comment">// console.log(location.href)</span><br>    <span class="hljs-comment">// console.log(e.newURL)</span><br>    <span class="hljs-comment">// console.log(e.oldURL)</span><br> <br>    <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    <span class="hljs-keyword">switch</span> (location.hash) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#index&#x27;</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#news&#x27;</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#user&#x27;</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-attr">default</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">window</span>.onhashchange = hashChange<br>hashChange()<br></code></pre></td></tr></table></figure><p><strong>上面这个实现方式比较简陋，我们可以再封装一下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.routers = []  <span class="hljs-comment">//存放我们的路由配置</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">route,callback</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.routers.push(&#123;<br>            <span class="hljs-attr">path</span>:route,<br>            <span class="hljs-attr">render</span>:callback<br>        &#125;)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">listen</span>(<span class="hljs-params">callback</span>)</span>&#123;<br>        <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-built_in">this</span>.hashChange(callback)<br>        <span class="hljs-built_in">this</span>.hashChange(callback)()  <span class="hljs-comment">//首次进入页面的时候没有触发hashchange，必须要就单独调用一下</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">hashChange</span>(<span class="hljs-params">callback</span>)</span>&#123;<br>        <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">let</span> hash = location.hash<br>            <span class="hljs-built_in">console</span>.log(hash)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;self.routers.length;i++)&#123;<br>                <span class="hljs-keyword">let</span> route = self.routers[i]<br>                <span class="hljs-keyword">if</span>(hash===route.path)&#123;<br>                    callback(route.render())<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> Router()<br>router.add(<span class="hljs-string">&#x27;#index&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>&#125;) <br>router.add(<span class="hljs-string">&#x27;#news&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>&#125;)<br>router.add(<span class="hljs-string">&#x27;#user&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>&#125;)<br>router.listen(<span class="hljs-function">(<span class="hljs-params">renderHtml</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    app.innerHTML = renderHtml<br>&#125;)<br></code></pre></td></tr></table></figure><p>实现一个Router类，通过add方法添加路由配置，第一个参数为路由路径，第二个参数为render函数，返回要插入页面的html；通过listen方法，监听hash变化，并将每个路由返回的html，插入到app中。这样我们就实现了一个简单的hash路由。</p><h3 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h3><p>hash模式看起来是比较丑的，都带个”#”号，我们也可以采取history模式，history就是我们平时看到的正常的连接形式。</p><p>history模式基于<code>window.history</code>对象的方法。</p><p>在HTML4中，已经支持<code>window.history</code>对象来控制页面历史记录跳转，常用的方法包括：</p><ul><li><code>history.forward()</code>：在历史记录中前进一步</li><li><code>history.back()</code>：在历史记录中后退一步</li><li><code>history.go(n)</code>：在历史记录中跳转n步骤，n=0为刷新本页,n=-1为后退一页。</li></ul><p>在HTML5中，<code>window.history</code>对象得到了扩展，新增的API包括：</p><ul><li><code>history.pushState(data[,title][,url])</code>：向历史记录中追加一条记录</li><li><code>history.replaceState(data[,title][,url])</code>：替换当前页在历史记录中的信息。</li><li><code>history.state</code>：是一个属性，可以得到当前页的state信息。</li><li><code>window.onpopstate</code>：是一个事件，在点击浏览器后退按钮或js调用<code>forward()</code>、<code>back()</code>、<code>go()</code>时触发。监听函数中可传入一个event对象，<code>event.state</code>即为通过<code>pushState()</code>或<code>replaceState()</code>方法传入的data参数</li></ul><p>history模式原理可以这样理解，首先我们要改造我们的超链接，给每个超链接增加onclick方法，阻止默认的超链接跳转，改用<code>history.pushState</code>或<code>history.replaceState</code>来更改浏览器中的url，并修改页面内容。由于通过history的api调整，并不会向后端发起请求，所以也就达到了前端路由的目的。</p><p>如果用户使用浏览器的前进后退按钮，则会触发<code>window.onpopstate</code>事件，监听页面根据路由地址修改页面内容。</p><p>也不一定非要用超链接，任意元素作为菜单都行，只要在点击事件中通过 history 进行调整即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--html:--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/index&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/news&quot;</span>&gt;</span>资讯<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/user&quot;</span>&gt;</span>个人中心<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//js:</span><br><span class="hljs-comment">//改造超链接，阻止默认跳转，默认的跳转是会刷新页面的</span><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#menu&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(e.target.nodeName ===<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>        e.preventDefault()<br>        <span class="hljs-keyword">let</span> path = e.target.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>)  <span class="hljs-comment">//获取超链接的href，改为pushState跳转，不刷新页面</span><br>        <span class="hljs-built_in">window</span>.history.pushState(&#123;&#125;,<span class="hljs-string">&#x27;&#x27;</span>,path)  <span class="hljs-comment">//修改浏览器中显示的url地址</span><br>        render(path)  <span class="hljs-comment">//根据path，更改页面内容</span><br>    &#125;<br>&#125;)<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">path</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    <span class="hljs-keyword">switch</span> (path) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/index&#x27;</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/news&#x27;</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/user&#x27;</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-attr">default</span>:<br>            app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//监听浏览器前进后退事件，并根据当前路径渲染页面</span><br><span class="hljs-built_in">window</span>.onpopstate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    render(location.pathname)<br>&#125;<br><span class="hljs-comment">//第一次进入页面显示首页</span><br>render(<span class="hljs-string">&#x27;/index&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面这个写法太low，我们可以用类封装一下，通过 add 方法添加路由，通过 pushState 进行跳转，初始化时更改所以超链接的跳转方式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.routers = []<br>        <span class="hljs-built_in">this</span>.renderCallback = <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">route,callback</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.routers.push(&#123;<br>            <span class="hljs-attr">path</span>:route,<br>            <span class="hljs-attr">render</span>:callback<br>        &#125;)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">pushState</span>(<span class="hljs-params">path,data=&#123;&#125;</span>)</span>&#123;<br>        <span class="hljs-built_in">window</span>.history.pushState(data,<span class="hljs-string">&#x27;&#x27;</span>,path)<br>        <span class="hljs-built_in">this</span>.renderHtml(path)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">listen</span>(<span class="hljs-params">callback</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.renderCallback = callback<br>        <span class="hljs-built_in">this</span>.changeA()<br>        <span class="hljs-built_in">window</span>.onpopstate = <span class="hljs-function">()=&gt;</span><span class="hljs-built_in">this</span>.renderHtml(<span class="hljs-built_in">this</span>.getCurrentPath())<br>        <span class="hljs-built_in">this</span>.renderHtml(<span class="hljs-built_in">this</span>.getCurrentPath())<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">changeA</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span>(e.target.nodeName===<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                e.preventDefault()<br>                <span class="hljs-keyword">let</span> path = e.target.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>)<br>                <span class="hljs-built_in">this</span>.pushState(path)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">getCurrentPath</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> location.pathname<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">renderHtml</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.routers.length;i++)&#123;<br>            <span class="hljs-keyword">let</span> route = <span class="hljs-built_in">this</span>.routers[i]<br>            <span class="hljs-keyword">if</span>(path===route.path)&#123;<br>                <span class="hljs-built_in">this</span>.renderCallback(route.render())<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>  <br><span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> Router()<br>router.add(<span class="hljs-string">&#x27;/index&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>&#125;)<br>router.add(<span class="hljs-string">&#x27;/news&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>&#125;)<br>router.add(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>&#125;)<br>router.listen(<span class="hljs-function">(<span class="hljs-params">renderHtml</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    app.innerHTML = renderHtml<br>&#125;)<br></code></pre></td></tr></table></figure><p>当然，上面这个实现只是一个非常初级的 demo，并不能用于真正的开发场景，只是加深对前端路由的理解。</p><h3 id="3-hash模式和history模式的区别"><a href="#3-hash模式和history模式的区别" class="headerlink" title="3. hash模式和history模式的区别"></a>3. hash模式和history模式的区别</h3><ul><li>hash 模式较丑，history 模式较优雅</li><li>pushState 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，故只可设置与当前同文档的 URL</li><li>pushState 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中</li><li>pushState 通过 stateObject 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串</li><li>pushState 可额外设置 title 属性供后续使用</li><li>hash 兼容IE8以上，history 兼容 IE10 以上</li><li>history 模式需要后端配合将所有访问都指向 index.html，否则用户刷新页面，会导致 404 错误</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js中的隐式转换</title>
    <link href="/2020/05/13/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/js%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/05/13/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/js%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>js中的不同的数据类型之间的比较转换规则如下：</p><h3 id="1-对象和布尔值比较"><a href="#1-对象和布尔值比较" class="headerlink" title="1. 对象和布尔值比较"></a>1. 对象和布尔值比较</h3><p><strong>对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js">[] == <span class="hljs-literal">true</span>;  <span class="hljs-comment">//false  []转换为字符串&#x27;&#x27;,然后转换为数字0,true转换为数字1，所以为false</span><br></code></pre></td></tr></table></figure><h3 id="2-对象和字符串比较"><a href="#2-对象和字符串比较" class="headerlink" title="2. 对象和字符串比较"></a>2. 对象和字符串比较</h3><p><strong>对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;1,2,3&#x27;</span> <span class="hljs-comment">// true  [1,2,3]转化为&#x27;1,2,3&#x27;，然后和&#x27;1,2,3&#x27;， so结果为true;</span><br></code></pre></td></tr></table></figure><h3 id="3-对象和数字比较"><a href="#3-对象和数字比较" class="headerlink" title="3. 对象和数字比较"></a>3. 对象和数字比较</h3><p><strong>对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>;  <span class="hljs-comment">// true  `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; &#x27;1&#x27; =&gt; 1 所以结果为true</span><br></code></pre></td></tr></table></figure><h3 id="4-字符串和数字比较"><a href="#4-字符串和数字比较" class="headerlink" title="4. 字符串和数字比较"></a>4. 字符串和数字比较</h3><p><strong>字符串和数字进行比较时，字符串转换成数字，二者再比较。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="5-字符串和布尔值比较"><a href="#5-字符串和布尔值比较" class="headerlink" title="5. 字符串和布尔值比较"></a>5. 字符串和布尔值比较</h3><p><strong>字符串和布尔值进行比较时，二者全部转换成数值再比较。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-literal">true</span>; <span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure><h3 id="6-布尔值和数字比较"><a href="#6-布尔值和数字比较" class="headerlink" title="6. 布尔值和数字比较"></a>6. 布尔值和数字比较</h3><p><strong>布尔值和数字进行比较时，布尔转换为数字，二者比较。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">true</span> == <span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>许多刚接触js的童鞋看到这么多的转换规则就懵圈了，其实规律很简单，大家可以记下边这个图(是时候展现我高超的绘画技巧了)<br><img src="https://upload-images.jianshu.io/upload_images/2791152-ba592aa9b81fe174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据转换"></p><p>如图，任意两种类型比较时，如果不是同一个类型比较的话，则按如图方式进行相应类型转换，如对象和布尔比较的话，对象 =&gt; 字符串 =&gt; 数值 布尔值 =&gt; 数值。<br>另外，我们来看下一些需要”特别照顾”的。</p><p>来看一个有趣的题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[] == <span class="hljs-literal">false</span>;<br>![] == <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>这两个的结果都是true,第一个是，对象 =&gt; 字符串 =&gt; 数值0 false转换为数字0,这个是true应该没问题，<br>第二个前边多了个!，则直接转换为布尔值再取反，转换为布尔值时，<strong>空字符串(‘’),NaN,0，null,undefined</strong>这几个外返回的都是true, 所以! []这个[] =&gt; true 取反为false,所以![] == false为true。</p><h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//以下结果为true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>);  <br><br><span class="hljs-comment">//以下输出结果全为 false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> ==<span class="hljs-string">&quot; &quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;123&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;abc&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-number">123</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == []);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;[]&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;[123]&quot;</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == &#123;&#125;); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">3</span>&#125;);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;&#123;key: 3&#125;&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">false</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;false&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&quot;null&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> ==<span class="hljs-string">&quot; &quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;123&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;abc&quot;</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-number">123</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == []);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;[]&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;[123]&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == &#123;&#125;); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">3</span>&#125;); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;&#123;key: 3&#125;&quot;</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">false</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;false&quot;</span>);  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;null&quot;</span>); <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>This</title>
    <link href="/2020/05/07/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/This/"/>
    <url>/2020/05/07/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/This/</url>
    
    <content type="html"><![CDATA[<p>this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计<br>得更加简洁并且易于复用。</p><p>this 在任何情况下都不指向函数的词法作用域。</p><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调</p><p>用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包</p><p>含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的</p><p>其中一个属性，会在函数执行的过程中用到。</p><h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a><strong>绑定规则</strong></h1><p>来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。</p><p>你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释</p><p>这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a><strong>默认绑定</strong></h3><p>最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用<br>其他规则时的默认规则。</p><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用<br>其他规则时的默认规则。<br>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>foo(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。<br>那么怎么知道这里应用了默认绑定呢？</p><p>可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。<br>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定<br>到 undefined：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>foo(); <span class="hljs-comment">// TypeError: this is undefined</span><br></code></pre></td></tr></table></figure><p>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只<br>有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo()<br>的调用位置无关：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">&quot;use strict&quot;</span>;<br>foo(); <span class="hljs-comment">// 2</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。整个程序要么严格要么非严格。然而，有时候你可能会用到第三方库，其严格程度和你的代码有所不同，因此一定要注意这类兼容性细节。</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br>obj.foo(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于<br>obj 对象。<br>然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。<br>无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引<br>用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调<br>用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p><p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">obj2</span>: obj2<br>&#125;;<br>obj1.obj2.foo(); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><p><strong>隐式丢失</strong>：</p><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。<br>思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> bar = obj.foo; <span class="hljs-comment">// 函数别名！</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br>bar(); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的<br>bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。<br>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFoo</span>(<span class="hljs-params">fn</span>) </span>&#123;<br><span class="hljs-comment">// fn 其实引用的是 foo</span><br>fn(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br>doFoo( obj.foo ); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。<br>如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br><span class="hljs-built_in">setTimeout</span>( obj.foo, <span class="hljs-number">100</span> ); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTimeout</span>(<span class="hljs-params">fn,delay</span>) </span>&#123;<br><span class="hljs-comment">// 等待 delay 毫秒</span><br>fn(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就像我们看到的那样，回调函数丢失 this 绑定是非常常见的。除此之外，还有一种情况 this 的行为会出乎我们意料：调用回调函数的函数可能会修改 this。在一些流行的JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>如果不想在对象内部包含函数引用，而想在某个对象上强制调用函数，都可以使用 call(..) 和 apply(..) 方法。</p><p>思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>:<span class="hljs-number">2</span><br>&#125;;<br>foo.call( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。<br>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者new Number(..)）。这通常被称为“装箱”。</p><p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题，是显式绑定的一个变种可以解决这个问题：</p><p><strong>硬绑定</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>:<span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>foo.call( obj );<br>&#125;;<br>bar(); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">setTimeout</span>( bar, <span class="hljs-number">100</span> ); <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this</span><br>bar.call( <span class="hljs-built_in">window</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码创建了函数 bar()，并在它的内部手动调用<br>了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它<br>总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p>硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a, something);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + something;<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> foo.apply(obj, <span class="hljs-built_in">arguments</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> b = bar(<span class="hljs-number">3</span>); <span class="hljs-comment">// 2  3</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>另一种使用方法是创建一个 i 可以重复使用的辅助函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a, something );<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + something;<br>&#125;<br><span class="hljs-comment">// 简单的辅助绑定函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">fn, obj</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> fn.apply( obj, <span class="hljs-built_in">arguments</span> );<br>&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>:<span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-keyword">var</span> bar = bind( foo, obj );<br><span class="hljs-keyword">var</span> b = bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3</span><br><span class="hljs-built_in">console</span>.log( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype.<br>bind。</p><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>如果某个调用位置可以应用多条规则该怎么办？为了解决这个问题就必须给这些规则设定优先级。</p><p><strong>默认绑定的优先级是四条规则中最低的</strong>，所以我们可以先不考虑它。</p><p>隐式绑定和显式绑定哪个优先级更高？我们来测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.a );<br>&#125;<br><span class="hljs-keyword">var</span> obj1 = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">3</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br>obj1.foo(); <span class="hljs-comment">// 2</span><br>obj2.foo(); <span class="hljs-comment">// 3</span><br>obj1.foo.call( obj2 ); <span class="hljs-comment">// 3</span><br>obj2.foo.call( obj1 ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>显式绑定优先级比隐式绑定更高</strong>，也就是说在判断时应当先考虑是否可以应用显式绑定。</p><p>现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;<br><span class="hljs-built_in">this</span>.a = something;<br>&#125;<br><span class="hljs-keyword">var</span> obj1 = &#123;<br><span class="hljs-attr">foo</span>: foo<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;;<br>obj1.foo( <span class="hljs-number">2</span> );<br><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2</span><br>obj1.foo.call( obj2, <span class="hljs-number">3</span> );<br><span class="hljs-built_in">console</span>.log( obj2.a ); <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.foo( <span class="hljs-number">4</span> );<br><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log( bar.a ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>可以看到 <strong>new 绑定比隐式绑定优先级高</strong>。但是 new 绑定和显式绑定谁的优先级更高呢？</p><p>（1）默认绑定</p><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用</p><p>其他规则时的默认规则。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件绑定this指向问题</title>
    <link href="/2020/05/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Athis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Athis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-cmn-Hans&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-id">#container</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#444</span>; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--看下面代码--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-在-element-上绑定事件"><a href="#1-在-element-上绑定事件" class="headerlink" title="1. 在 element 上绑定事件"></a><strong>1. 在 element 上绑定事件</strong></h3><p>此时 this 指向 全局变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在&lt;body&lt;/body&gt;里加入: --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;addCount()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCount</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        container.innerHTML = count++;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//window</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-js-绑定-onclick-事件"><a href="#2-js-绑定-onclick-事件" class="headerlink" title="2. js 绑定 onclick 事件"></a><strong>2. js 绑定 onclick 事件</strong></h3><p>此时的 this 指向 该元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在&lt;body&lt;/body&gt;里加入: --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCount</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        container.innerHTML = count++;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">    container.onclick = addCount;</span><br><span class="javascript"><span class="hljs-comment">//如果写成 container.onclick = addCount(),则：addCount()函数只执行一次，且它this指向window,此时输出为window,就不为&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-js-使用-addEventListener-绑定事件"><a href="#3-js-使用-addEventListener-绑定事件" class="headerlink" title="3. js 使用 addEventListener 绑定事件"></a><strong>3. js 使用 addEventListener 绑定事件</strong></h3><p>此时的 this 指向 该元素,</p><p>注意： 在IE浏览器中，使用为 attachEvent(), this 指向全局变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在&lt;body&lt;/body&gt;里加入: --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCount</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        container.innerHTML = count++;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">    container.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, addCount);</span><br><span class="javascript"><span class="hljs-comment">//如果写成 container.addEventListener(&#x27;click&#x27;, addCount());,则：addCount()函数只执行一次，且它this指向window,此时输出为window,就不为&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-jquery-的-3种绑定-click-事件"><a href="#4-jquery-的-3种绑定-click-事件" class="headerlink" title="4.  jquery 的 3种绑定 click 事件"></a><strong>4.  jquery 的 3种绑定 click 事件</strong></h3><p>此时的 this 均指向该元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCount</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">   $(<span class="hljs-string">&#x27;#container&#x27;</span>).text(count++);</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); </span><br><span class="javascript">&#125;;</span><br><span class="javascript">$(<span class="hljs-string">&#x27;#container&#x27;</span>).bind(<span class="hljs-string">&#x27;click&#x27;</span>, addCount)<span class="hljs-comment">//&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="javascript">$(<span class="hljs-string">&#x27;#container&#x27;</span>).click(addCount)<span class="hljs-comment">//&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="javascript">$(<span class="hljs-string">&#x27;#container&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>,addCount)<span class="hljs-comment">//&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步操作：概述</title>
    <link href="/2020/05/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/05/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><h4 id="1-单线程模型"><a href="#1-单线程模型" class="headerlink" title="1. 单线程模型"></a><a href="#jump1"><strong>1. 单线程模型</strong></a></h4><ul><li><strong>什么是单线程模型</strong></li><li> <strong>JS为什么采用单线程模式</strong></li><li><strong>单线程模式的优缺点</strong></li></ul><h4 id="2-同步任务-和-异步任务"><a href="#2-同步任务-和-异步任务" class="headerlink" title="2. 同步任务 和 异步任务"></a><a href="#jump2"><strong>2. 同步任务 和 异步任务</strong></a></h4><h4 id="3-任务队列-和-事件循环"><a href="#3-任务队列-和-事件循环" class="headerlink" title="3. 任务队列 和 事件循环"></a><a href="#jump3"><strong>3. 任务队列 和 事件循环</strong></a></h4><h4 id="4-单线程模型"><a href="#4-单线程模型" class="headerlink" title="4. 单线程模型"></a><a href="#jump4"><strong>4. 单线程模型</strong></a></h4><ul><li><strong>回调函数</strong></li><li><strong>事件监听</strong></li><li><strong>发布/订阅</strong></li></ul><h4 id="5-单线程模型"><a href="#5-单线程模型" class="headerlink" title="5. 单线程模型"></a><a href="#jump5"><strong>5. 单线程模型</strong></a></h4><ul><li><strong>串行执行</strong></li><li><strong>并行执行</strong></li><li><strong>并行和串行的结合</strong></li></ul><br/><p><strong>本文转载于</strong>：<a href="https://wangdoc.com/javascript/async/general.html"><strong>异步操作概述</strong></a> </p><br/><h2 id="（一）单线程模型"><a href="#（一）单线程模型" class="headerlink" title="（一）单线程模型"></a><span id="jump1"><strong>（一）单线程模型</strong></span></h2><h4 id="1-什么是单线程模型？"><a href="#1-什么是单线程模型？" class="headerlink" title="1. 什么是单线程模型？"></a><strong>1. 什么是单线程模型？</strong></h4><p>单线程模型指：JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p><p>注意：JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p><h4 id="2-JS为什么采用单线程模式？"><a href="#2-JS为什么采用单线程模式？" class="headerlink" title="2. JS为什么采用单线程模式？"></a><strong>2. JS为什么采用单线程模式？</strong></h4><p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。</p><p>JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h4 id="3-单线程模式的优缺点"><a href="#3-单线程模式的优缺点" class="headerlink" title="3. 单线程模式的优缺点"></a><strong>3. 单线程模式的优缺点</strong></h4><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；</p><p>坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p><p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="（二）同步任务和异步任务"><a href="#（二）同步任务和异步任务" class="headerlink" title="（二）同步任务和异步任务"></a><span id="jump2">（<strong>二）同步任务和异步任务</strong></span></h2><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p><strong>同步任务</strong>：是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p><strong>异步任务</strong>：是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h2 id="（三）任务队列和事件循环"><a href="#（三）任务队列和事件循环" class="headerlink" title="（三）任务队列和事件循环"></a><span id="jump3"><strong>（三）任务队列和事件循环</strong></span></h2><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做<strong>事件循环</strong>（Event Loop）。<a href="https://en.wikipedia.org/wiki/Event_loop">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p><h2 id="（四）异步操作的模式"><a href="#（四）异步操作的模式" class="headerlink" title="（四）异步操作的模式"></a><span id="jump4"><strong>（四）异步操作的模式</strong></span></h2><p>下面总结一下异步操作的几种模式：</p><h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a><strong>1. 回调函数</strong></h4><p>回调函数是异步操作最基本的方法。</p><p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f1();<br>f2();<br></code></pre></td></tr></table></figure><p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p><p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  callback();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f1(f2);<br></code></pre></td></tr></table></figure><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p><h4 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2. 事件监听"></a><strong>2. 事件监听</strong></h4><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href="https://api.jquery.com/on/">写法</a>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">f1.on(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></td></tr></table></figure><p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    f1.trigger(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p><p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href="https://en.wikipedia.org/wiki/Decoupling">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p><h4 id="3-发布-订阅"><a href="#3-发布-订阅" class="headerlink" title="3. 发布/订阅"></a><strong>3. 发布/订阅</strong></h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href="https://en.wikipedia.org/wiki/Publish-subscribe_pattern">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>”（observer pattern）。</p><p>这个模式有多种<a href="https://msdn.microsoft.com/en-us/magazine/hh201955.aspx">实现</a>，下面采用的是 Ben Alman 的 <a href="https://gist.github.com/661855">Tiny Pub/Sub</a>，这是 jQuery 的一个插件。</p><p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">jQuery.subscribe(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></td></tr></table></figure><p>然后，<code>f1</code>进行如下改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    jQuery.publish(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p><p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">jQuery.unsubscribe(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></td></tr></table></figure><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><h2 id="（五）异步操作的流程控制"><a href="#（五）异步操作的流程控制" class="headerlink" title="（五）异步操作的流程控制"></a><span id="jump5"><strong>（五）异步操作的流程控制</strong></span></h2><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p><p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><span class="hljs-keyword">async</span>(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">async</span>(<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">async</span>(<span class="hljs-number">3</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>      <span class="hljs-keyword">async</span>(<span class="hljs-number">4</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-keyword">async</span>(<span class="hljs-number">5</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>          <span class="hljs-keyword">async</span>(<span class="hljs-number">6</span>, final);<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">// 参数为 1 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 2 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 3 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 4 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 5 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 6 , 1秒后返回结果</span><br><span class="hljs-comment">// 完成:  12</span><br></code></pre></td></tr></table></figure><p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p><h4 id="1-串行执行"><a href="#1-串行执行" class="headerlink" title="1. 串行执行"></a><strong>1. 串行执行</strong></h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">series</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(item) &#123;<br>    <span class="hljs-keyword">async</span>( item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br>      results.push(result);<br>      <span class="hljs-keyword">return</span> series(items.shift());<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> final(results[results.length - <span class="hljs-number">1</span>]);<br>  &#125;<br>&#125;<br><br>series(items.shift());<br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p><p>注意，上面的写法需要六秒，才能完成整个脚本。</p><h4 id="2-并行执行"><a href="#2-并行执行" class="headerlink" title="2. 并行执行"></a><strong>2. 并行执行</strong></h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br>items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">async</span>(item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>&#123;<br>    results.push(result);<br>    <span class="hljs-keyword">if</span>(results.length === items.length) &#123;<br>      final(results[results.length - <span class="hljs-number">1</span>]);<br>    &#125;<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p><p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p><h4 id="3-并行与串行的结合"><a href="#3-并行与串行的结合" class="headerlink" title="3. 并行与串行的结合"></a><strong>3. 并行与串行的结合</strong></h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><span class="hljs-keyword">var</span> running = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> limit = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">launcher</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">var</span> item = items.shift();<br>    <span class="hljs-keyword">async</span>(item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br>      results.push(result);<br>      running--;<br>      <span class="hljs-keyword">if</span>(items.length &gt; <span class="hljs-number">0</span>) &#123;<br>        launcher();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(running == <span class="hljs-number">0</span>) &#123;<br>        final(results);<br>      &#125;<br>    &#125;);<br>    running++;<br>  &#125;<br>&#125;<br><br>launcher();<br></code></pre></td></tr></table></figure><p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p><p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组、对象常用方法</title>
    <link href="/2020/05/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2020/05/05/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h1><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// reduce:</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> res1 = arr1.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> acc + cur;<br>&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, res1)<br><br><span class="hljs-keyword">const</span> arr2 = [<br>    &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>&#125;,<br>]<br><br><span class="hljs-keyword">let</span> res2 = arr2.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>   acc[cur.name] = cur.value;<br>   <span class="hljs-keyword">return</span> acc <br>&#125;, &#123;&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, res2)<br><br><span class="hljs-keyword">let</span> res3 = arr2.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>    acc.push(&#123;<span class="hljs-attr">label</span>: cur.name, <span class="hljs-attr">id</span>: cur.value&#125;);<br>    <span class="hljs-keyword">return</span> acc;<br>&#125;, [])<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3&quot;</span>, res3)<br><br><br><span class="hljs-keyword">const</span> arr3 = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]];<br><span class="hljs-keyword">let</span> res4 = arr3.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> acc.concat(cur)<br>&#125;, [])<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;arr4&quot;</span>, res4)<br><br><span class="hljs-keyword">const</span> arr4 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];<br><span class="hljs-keyword">let</span> res5 = arr4.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(cur <span class="hljs-keyword">in</span> acc) &#123;<br>        acc[cur]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        acc[cur] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> acc<br>&#125;, &#123;&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res5&quot;</span>, res5)<br><br><span class="hljs-keyword">const</span> arr5 = [<br>    &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Max&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125; <br>]<br><span class="hljs-keyword">let</span> res6 = arr5.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(cur.age <span class="hljs-keyword">in</span> acc)) &#123;<br>        acc[cur.age] = []<br>    &#125; <br>    acc[cur.age].push(cur.name);<br>    <span class="hljs-keyword">return</span> acc<br>&#125;, &#123;&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res6&quot;</span>, res6)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//map:</span><br><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> res1 = arr1.map(<span class="hljs-function">(<span class="hljs-params">cur, idx, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> cur*<span class="hljs-number">2</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, res1)<br><br><span class="hljs-keyword">const</span> arr2 = [<br>    &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>&#125;,<br>    &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">20</span>&#125;,<br>    &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">30</span>&#125;<br>]<br><span class="hljs-keyword">const</span> res2 = arr2.map(<span class="hljs-function">(<span class="hljs-params">cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;[cur.key]: cur.value&#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, res2)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// filter</span><br><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;spray&#x27;</span>, <span class="hljs-string">&#x27;limit&#x27;</span>, <span class="hljs-string">&#x27;elite&#x27;</span>, <span class="hljs-string">&#x27;exuberant&#x27;</span>, <span class="hljs-string">&#x27;destruction&#x27;</span>, <span class="hljs-string">&#x27;preent&#x27;</span>];<br><span class="hljs-keyword">const</span> res1 = arr1.filter(<span class="hljs-function">(<span class="hljs-params">cur, id, arr</span>) =&gt;</span> cur.length &gt; <span class="hljs-number">6</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, res1)<br><br><span class="hljs-keyword">const</span> res2 = [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].filter(<span class="hljs-function">(<span class="hljs-params">cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> cur &gt;= <span class="hljs-number">10</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, res2)<br><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;grapes&#x27;</span>, <span class="hljs-string">&#x27;mango&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterItems</span>(<span class="hljs-params">query</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arr2.filter(<span class="hljs-function"><span class="hljs-params">cur</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> cur.toLowerCase().indexOf(query.toLowerCase()) &gt; -<span class="hljs-number">1</span><br>    &#125;)<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3&quot;</span>, filterItems(<span class="hljs-string">&#x27;ap&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// find</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>];<br><span class="hljs-keyword">const</span> res1 = arr1.find(<span class="hljs-function">(<span class="hljs-params">cur, idx, arr</span>) =&gt;</span> cur &gt; <span class="hljs-number">10</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, res1)<br><br><span class="hljs-keyword">const</span> arr2 = [<br>    &#123;<span class="hljs-attr">name</span>: apples<span class="hljs-string">&#x27;, quantity: 2&#125;,</span><br><span class="hljs-string">    &#123;name: &#x27;</span>bananas<span class="hljs-string">&#x27;, quantity: 0&#125;,</span><br><span class="hljs-string">    &#123;name: &#x27;</span>cherries<span class="hljs-string">&#x27;, quantity: 5&#125;</span><br><span class="hljs-string">]</span><br><span class="hljs-string">const res2 = arr2.find((cur) =&gt; &#123;</span><br><span class="hljs-string">    return cur.name === &#x27;</span>cherries<span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#125;)</span><br><span class="hljs-string">console.log(&quot;res2&quot;, res2)</span><br><span class="hljs-string"></span><br><span class="hljs-string">// findIndex</span><br><span class="hljs-string">const arr1 = [5, 12, 8, 130, 44];</span><br><span class="hljs-string">const res1 = arr1.findIndex((cur, idx, arr) =&gt; &#123;</span><br><span class="hljs-string">    return cur &gt; 13</span><br><span class="hljs-string">&#125;)</span><br><span class="hljs-string">console.log(&quot;res1&quot;, res1)</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// fill</span><br><span class="hljs-comment">// 传入三个参数：1. value用来填充的元素的值。 2. start: 起始索引，默认值为0。3. end： 终止索引，默认值为this.length。</span><br><span class="hljs-comment">// fill方法是个可变方法，它会改变调用它的this对象本身，然后返回它，不是返回一个副本。</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, arr1.fill(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">//[1, 2, 0, 0]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, arr1.fill(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">//[1, 5, 5, 5]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3&quot;</span>, arr1.fill(<span class="hljs-number">6</span>));<span class="hljs-comment">//[6, 6, 6, 6]</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Array.prototype.keys()</span><br><span class="hljs-comment">// 该方法返回一个包数组中每个索引键的Array Iterator对象。</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">const</span> res1 = arr1.keys();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, res1)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> res1) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1 key:&quot;</span>, key)<br>&#125;<br><br><span class="hljs-comment">// Array.prototype.values()</span><br><span class="hljs-comment">// 该方法返回一个新的Array Iteration对象，该对象包含数组每个索引的值。</span><br><span class="hljs-keyword">const</span> res2 = arr1.values();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, res2);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> res2) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2 value:&quot;</span>, value)<br>&#125;<br><br><span class="hljs-comment">// Array.prototype.entries()</span><br><span class="hljs-comment">// 该方法返回一个新的Array Iterator 对象，该对象包含数组中每个索引的键/值对。</span><br><span class="hljs-keyword">const</span> res3 = arr1.entries();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3&quot;</span>, res3);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> res3) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3 value&quot;</span>, e)<br>&#125;<br><span class="hljs-comment">// console.log(&quot;res3 value1&quot;, res3.next().value);</span><br><span class="hljs-comment">// console.log(&quot;res3 value2&quot;,res3.next().value);</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// from</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, <span class="hljs-built_in">Array</span>.from(<span class="hljs-string">&#x27;foo&#x27;</span>)); <span class="hljs-comment">//[&quot;f&quot;, &quot;o&quot;, &quot;o&quot;];</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, <span class="hljs-built_in">Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x)); <span class="hljs-comment">// [2, 4, 6]</span><br><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>]);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3&quot;</span>, <span class="hljs-built_in">Array</span>.from(set))<br><br><span class="hljs-keyword">const</span> mapper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>], [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]]);<br><span class="hljs-built_in">console</span>.log(mapper)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res4&quot;</span>, <span class="hljs-built_in">Array</span>.from(mapper.values()));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res5&quot;</span>, <span class="hljs-built_in">Array</span>.from(mapper.keys()))<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// of</span><br><span class="hljs-comment">// Array.of()方法创建一个具有可变数量参数的新数组实例，而不是考虑参数的数量或类型</span><br><span class="hljs-comment">// Array.of()和Array构造函数之间的区别在于处理整数参数：</span><br><span class="hljs-comment">// Array.of(7)创建一个具有单个元素7的数组，而Array(7)创建一个长度为7的空数组。</span><br><br><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">7</span>) <span class="hljs-comment">//[7];</span><br><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>) <span class="hljs-comment">// [,,,,,,]</span><br><span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">//[1, 2, 3]</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// copyWithin()</span><br><span class="hljs-comment">// copyWithin()方法浅复制数组的一部分到同一数组的另一个位置，并返回它，不会改变原数组的长度。</span><br><span class="hljs-comment">// 传入参数： </span><br><span class="hljs-comment">//1. target: 0为基底的索引，复制序列到该位置。如果是负数，target将从末尾开始计算。</span><br><span class="hljs-comment">//2. start: 0为基底的索引，开始复制元素的起始位置。如果是负数，start将从末尾开始计算。如果start被忽略，copyWithin将会从0开始复制。</span><br><span class="hljs-comment">//3. end: 0为基底的索引，开始复制元素的结束位置。copyWithin将会被拷贝到该位置，但不包括end这个位置的元素。如果是负数，end将从末尾开始计算。</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(arr1.copyWithin(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">//[&#x27;d&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(-<span class="hljs-number">2</span>); <span class="hljs-comment">//[1, 2, 3, 1, 2];</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//[4, 5, 3, 4, 5];</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//[4, 2, 3, 4, 5]</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(-<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">//[1, 2, 3, 3, 4]</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// includes</span><br><span class="hljs-comment">// 输入值：1. valueToFind：要查找的元素值，2. fromIndex: 从fromIndex索引处开始查找valueToFind。</span><br><span class="hljs-comment">// 返回值为true或false</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, arr1.includes(<span class="hljs-number">2</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, arr1.includes(<span class="hljs-number">4</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3&quot;</span>, arr1.includes(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res4&quot;</span>, arr1.includes(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>))<br><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;bat&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res5&quot;</span>, arr2.includes(<span class="hljs-string">&#x27;cat&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res6&#x27;</span>, arr2.includes(<span class="hljs-string">&#x27;at&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">slice<br>splice<br>some<br>concat<br>join<br>pop<br>push<br>shift<br>unshift<br>reverse<br>sort<br>数组遍历： <br>forEach<br><span class="hljs-keyword">for</span>...in...<br><span class="hljs-keyword">for</span>...of...<br></code></pre></td></tr></table></figure><h1 id="对象常用方法"><a href="#对象常用方法" class="headerlink" title="对象常用方法"></a>对象常用方法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// values</span><br><br><span class="hljs-keyword">const</span> obj1 = &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res1&quot;</span>, <span class="hljs-built_in">Object</span>.values(obj1));<br><br><span class="hljs-keyword">const</span> obj2 = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res2&quot;</span>, <span class="hljs-built_in">Object</span>.values(obj2))<br><br><span class="hljs-comment">//keys</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res3&quot;</span>, <span class="hljs-built_in">Object</span>.keys(arr1)); <span class="hljs-comment">//[&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;];</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res4&quot;</span>, <span class="hljs-built_in">Object</span>.keys(obj2))<br><br><span class="hljs-keyword">const</span> obj3 = &#123;<span class="hljs-number">100</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res5&quot;</span>, <span class="hljs-built_in">Object</span>.keys(obj3))<br><br><span class="hljs-comment">//entries</span><br><span class="hljs-keyword">const</span> obj4 = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;somestring&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj4)) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res6&quot;</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res7&quot;</span>, <span class="hljs-built_in">Object</span>.entries(obj4)); <span class="hljs-comment">//[[&#x27;a&#x27;, &#x27;somestring&#x27;], [&#x27;b&#x27;, 42]]</span><br><br><span class="hljs-keyword">const</span> obj5 = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res8&quot;</span>, <span class="hljs-built_in">Object</span>.entries(obj5)); <span class="hljs-comment">//[[&#x27;0&#x27;, &#x27;a&#x27;], [&#x27;1&#x27;, &#x27;b&#x27;], [&#x27;2&#x27;, &#x27;c&#x27;]]</span><br></code></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖 节流 和预加载 懒加载</title>
    <link href="/2020/05/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%B2%E6%8A%96%20%E8%8A%82%E6%B5%81%20%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%20%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/05/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%B2%E6%8A%96%20%E8%8A%82%E6%B5%81%20%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%20%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-防抖-节流"><a href="#1-防抖-节流" class="headerlink" title="1. 防抖 节流"></a><a href="#jump1"><strong>1. 防抖 节流</strong></a></h4><h4 id="2-预加载"><a href="#2-预加载" class="headerlink" title="2. 预加载"></a><a href="#jump2"><strong>2. 预加载</strong></a></h4><h4 id="3-懒加载"><a href="#3-懒加载" class="headerlink" title="3. 懒加载"></a><a href="#jump3"><strong>3. 懒加载</strong></a></h4><h1 id="（一）防抖-节流"><a href="#（一）防抖-节流" class="headerlink" title="（一）防抖 节流"></a><span id="jump1"><strong>（一）防抖 节流</strong></span></h1><h3 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1. 防抖"></a><strong>1. 防抖</strong></h3><p>对于短时间内连续触发的事件（如滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。</p><p><strong>防抖实现思路</strong>：在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后：</p><ul><li>如果在200ms内没有再次触发滚动事件，那么就执行函数</li><li>如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时</li></ul><p><strong>效果</strong>：如果短时间内大量触发同一事件，只会执行一次函数。</p><p><strong>实现</strong>：既然前面都提到了计时，那实现的关键就在于setTimeOut这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* fn [function] 需要防抖的函数</span><br><span class="hljs-comment">* delay [number] 毫秒，防抖期限值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout)<br>        timeout = <span class="hljs-built_in">setTimeout</span>(func, wait);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserAction</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    container.innerHTML = count++;<br>&#125;;<br>container.onmousemove = debounce(getUserAction, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>但是如果使用上面的 debounce 函数，this 就会指向 Window 对象！所以需要将 this 指向正确的对象：绑定onmousemove的元素。且事件处理函数中要能提供事件对象 event。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//修复两个问题：1.this 指向 2.event 对象：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timeout;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout)<br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            func.apply(context, args)<br>        &#125;, wait);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserAction</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(e);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    container.innerHTML = count++;<br>&#125;;<br>container.onmousemove = debounce(getUserAction, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><a href="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a></p><h3 id="2-节流"><a href="#2-节流" class="headerlink" title="2. 节流"></a><strong>2. 节流</strong></h3><p><strong>效果</strong>：如果短时间内大量触发同一事件，那么<strong>在函数执行一次之后，该函数在指定的时间期限</strong>内不再工作，直至过了这段时间才重新生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        context = <span class="hljs-built_in">this</span>;<br>        args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">if</span> (!timeout) &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>                func.apply(context, args)<br>            &#125;, wait)<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="（二）预加载"><a href="#（二）预加载" class="headerlink" title="（二）预加载"></a><span id="jump2"><strong>（二）预加载</strong></span></h1><h3 id="1-什么是预加载？"><a href="#1-什么是预加载？" class="headerlink" title="1. 什么是预加载？"></a><strong>1. 什么是预加载？</strong></h3><p>图片等静态资源在使用前提前请求，资源后续使用可以直接从缓存中加载。</p><h3 id="2-为什么使用预加载？"><a href="#2-为什么使用预加载？" class="headerlink" title="2. 为什么使用预加载？"></a><strong>2. 为什么使用预加载？</strong></h3><p>在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。但预加载会增加服务器的负担。</p><h3 id="3-实现预加载的方法"><a href="#3-实现预加载的方法" class="headerlink" title="3. 实现预加载的方法"></a><strong>3. 实现预加载的方法</strong></h3><ul><li><p><strong>单纯的js预加载图片</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> images = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>()  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preload</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; preload.arguments.length; i++) &#123;  <br>        images[i] = <span class="hljs-keyword">new</span> Image()  <br>        images[i].src = preload.arguments[i]  <br>    &#125;  <br>&#125;  <br>preload(  <br>    <span class="hljs-string">&quot;http://domain.tld/gallery/image-001.jpg&quot;</span>,  <br>    <span class="hljs-string">&quot;http://domain.tld/gallery/image-002.jpg&quot;</span>,  <br>    <span class="hljs-string">&quot;http://domain.tld/gallery/image-003.jpg&quot;</span>  <br>)  <br></code></pre></td></tr></table></figure></li><li><p><strong>使用ajax实现预加载</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <br>        <span class="hljs-comment">// XHR to request a JS and a CSS  </span><br>        <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();  <br>        xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://domain.tld/preload.js&#x27;</span>);  <br>        xhr.send(<span class="hljs-string">&#x27;&#x27;</span>);  <br>        xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();  <br>        xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://domain.tld/preload.css&#x27;</span>);  <br>        xhr.send(<span class="hljs-string">&#x27;&#x27;</span>);  <br>        <span class="hljs-comment">// preload image  </span><br>        <span class="hljs-keyword">new</span> Image().src = <span class="hljs-string">&quot;http://domain.tld/preload.png&quot;</span>;  <br>    &#125;, <span class="hljs-number">1000</span>);  <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="（三）懒加载"><a href="#（三）懒加载" class="headerlink" title="（三）懒加载"></a><span id="jump3"><strong>（三）懒加载</strong></span></h1><h3 id="1-什么是懒加载？"><a href="#1-什么是懒加载？" class="headerlink" title="1. 什么是懒加载？"></a><strong>1. 什么是懒加载？</strong></h3><p>懒加载也就是延迟加载。简单的来说，只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。</p><h3 id="2-为什么使用懒加载"><a href="#2-为什么使用懒加载" class="headerlink" title="2. 为什么使用懒加载?"></a><strong>2. 为什么使用懒加载?</strong></h3><p>对于图片过多的场景，为了提高页面的加载速度，很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。</p><p>懒加载的主要目的是作为服务器前端的优化，降低服务器的负载，减少请求数或延迟请求数。</p><h3 id="3-懒加载原理"><a href="#3-懒加载原理" class="headerlink" title="3. 懒加载原理"></a><strong>3. 懒加载原理</strong></h3><p>将页面中的img标签src指向一张小图片或者src为空，然后自定义<code>data-src</code>属性指向真实的图片。当载入页面时，先把可视区域内的img标签的<code>data-src</code>属性值赋给<code>src</code>，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。</p><p><strong>加载条件：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.offsetTop</span> &lt; window<span class="hljs-selector-class">.innerHeight</span> + document<span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.scrollTop</span>;<br></code></pre></td></tr></table></figure><p><strong>关于页面宽高的资料</strong>：</p><p><a href="http://www.pianshen.com/article/3061655894/"><strong>页面高度详解</strong></a></p><p><a href="https://i.jakeyu.top/2016/09/04/scrollTop-offsetTop-scrollLeft-offsetLeft/"><strong>scrollTop等元素距离</strong></a></p><p><a href="https://www.jianshu.com/p/b28a4dcd1b8c"><strong>理清window和document的区别以及两者的宽高</strong></a><br><img src="https://img-blog.csdnimg.cn/20200503180534132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-实现："><a href="#4-实现：" class="headerlink" title="4. 实现："></a><strong>4. 实现</strong>：</h3><p><strong>学习并摘自</strong>：<a href="https://i.jakeyu.top/2016/11/26/%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"><strong>实现图片懒加载(lazyload)</strong></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-tag">img</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">display</span>: block;</span><br><span class="css">            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>JavaScript</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 纯js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> imgs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;img&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> num = imgs.length;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="javascript"></span><br><span class="javascript">    lazyload(); <span class="hljs-comment">//页面载入完毕加载可是区域内的图片</span></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.onscroll = lazyload;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//监听页面滚动事件</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> seeHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight; <span class="hljs-comment">//可见区域高度</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop; <span class="hljs-comment">//滚动条距离顶部高度</span></span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = n; i &lt; num; i++) &#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (imgs[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="javascript">                <span class="hljs-keyword">if</span> (imgs[i].getAttribute(<span class="hljs-string">&quot;src&quot;</span>) == <span class="hljs-string">&quot;default.jpg&quot;</span>) &#123;</span><br><span class="javascript">                    imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">&quot;data-src&quot;</span>);</span><br><span class="javascript">                &#125;</span><br><span class="javascript">                n = i + <span class="hljs-number">1</span>;</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>JQuery</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>,</span><br><span class="javascript">        imgNum = $(<span class="hljs-string">&quot;img&quot;</span>).length,</span><br><span class="javascript">        img = $(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="javascript"></span><br><span class="javascript">    lazyload();</span><br><span class="javascript"></span><br><span class="javascript">    $(<span class="hljs-built_in">window</span>).scroll(lazyload);</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params">event</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = n; i &lt; imgNum; i++) &#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (img.eq(i).offset().top &lt; <span class="hljs-built_in">parseInt</span>($(<span class="hljs-built_in">window</span>).height()) + <span class="hljs-built_in">parseInt</span>($(<span class="hljs-built_in">window</span>).scrollTop())) &#123;</span><br><span class="javascript">                <span class="hljs-keyword">if</span> (img.eq(i).attr(<span class="hljs-string">&quot;src&quot;</span>) == <span class="hljs-string">&quot;default.jpg&quot;</span>) &#123;</span><br><span class="javascript">                    <span class="hljs-keyword">var</span> src = img.eq(i).attr(<span class="hljs-string">&quot;data-src&quot;</span>);</span><br><span class="javascript">                    img.eq(i).attr(<span class="hljs-string">&quot;src&quot;</span>, src);</span><br><span class="javascript"></span><br><span class="javascript">                    n = i + <span class="hljs-number">1</span>;</span><br><span class="javascript">                &#125;</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><br/><p>如果直接将函数绑定在<code>scroll</code>事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。</p><p>下面实现限制触发频率，来优化性能。</p><p><strong>使用节流函数进行性能优化</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 简单的节流函数</span><br><span class="hljs-comment">//fun 要执行的函数</span><br><span class="hljs-comment">//delay 延迟</span><br><span class="hljs-comment">//time  在time时间内必须执行一次</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span> (<span class="hljs-params">fun, delay, time</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout<br><br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span><br><br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br><br>    <span class="hljs-keyword">let</span> curTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><br>    <span class="hljs-built_in">clearTimeout</span>(timeout)<br>    <span class="hljs-keyword">if</span> (curTime - startTime &gt;= time) &#123;<br>      <span class="hljs-comment">// 如果达到了规定的触发时间间隔，触发 handler</span><br>      fun.apply(context, args)<br>      startTime = curTime<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 没达到触发间隔，重新设定定时器</span><br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        fun.apply(context, args)<br>      &#125;, delay)<br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 实际想绑定在 scroll 事件上的 handler</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;<br><span class="hljs-comment">// 采用了节流函数</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,throttle(lazyload,<span class="hljs-number">500</span>,<span class="hljs-number">1000</span>));<br></code></pre></td></tr></table></figure><p><strong>使用防抖函数进行性能优化</strong></p><p>防抖相比较节流函数要稍微简单一点，防抖是让函数延迟执行，而节流比防抖多了一个在一定时间内必须要执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// debounce函数用来包裹我们的事件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span> (<span class="hljs-params">fn, delay</span>) </span>&#123;<br>  <span class="hljs-comment">// 持久化一个定时器 timer</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-comment">// 闭包函数可以访问 timer</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 通过 &#x27;this&#x27; 和 &#x27;arguments&#x27;</span><br>    <span class="hljs-comment">// 获得函数的作用域和参数</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>    <span class="hljs-comment">// 如果事件被触发，清除 timer 并重新开始计时</span><br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fn.apply(context, args)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 实际想绑定在 scroll 事件上的 handler</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;<br><span class="hljs-comment">// 采用了去抖函数</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,debounce(lazyload,<span class="hljs-number">500</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs相关知识点</title>
    <link href="/2020/05/03/NodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NodeJs%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/05/03/NodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NodeJs%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>NodeJs 就是运行在服务端的 JavaScript。</p><h4 id="NodeJs事件驱动-事件循环"><a href="#NodeJs事件驱动-事件循环" class="headerlink" title="NodeJs事件驱动/事件循环:"></a>NodeJs事件驱动/事件循环:</h4><ul><li>每个NodeJs进程只有一个主线程在执行程序代码，形成一个<strong>执行栈</strong>（<strong>execution context stack</strong>)。</li><li>主线程之外，还维护了一个”<strong>事件队列</strong>“（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到<code>Event Queue</code>之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。</li><li>主线程代码执行完毕完成后，然后通过<code>Event Loop</code>，也就是<strong>事件循环机制</strong>，开始到<code>Event Queue</code>的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从<strong>线程池</strong>中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交<code>Event Loop</code>处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。</li><li>主线程不断重复上面的第三步。</li></ul><h4 id="NodeJs特点："><a href="#NodeJs特点：" class="headerlink" title="NodeJs特点："></a>NodeJs特点：</h4><ul><li>它是一个Javascript运行环境</li><li> 依赖于Chrome V8引擎进行代码解释</li><li> 事件驱动</li><li> 非阻塞I/O</li><li> 轻量、可伸缩，适于实时数据交互应用</li><li> 单进程，单线程</li></ul><h4 id="NodeJs的优缺点："><a href="#NodeJs的优缺点：" class="headerlink" title="NodeJs的优缺点："></a>NodeJs的优缺点：</h4><p>优点：</p><ul><li><p>高并发；</p></li><li><p>适合I/O密集型应用。</p></li></ul><p>缺点：</p><ul><li><p>不适合CPU密集型应用，只支持单核CPU，不能充分利用CPU；</p></li><li><p>单进程，单线程，一旦代码某处出现bug，整个系统都崩溃；</p></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p>我们所看到的nodeJs单线程只是一个js主线程，本质上的异步操作还是由线程池完成的，node将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的I/O操作，从而实现异步非阻塞I/O，这便是node单线程和事件驱动的精髓之处了。</p></li><li><p>NodeJs所谓的单线程，只是主线程是单线程，所有的网络请求或者异步任务都交给了内部的线程池去实现，本身只负责不断的往返调度，由事件循环不断驱动事件执行。</p></li><li><p>NodeJs之所以单线程可以处理高并发的原因，得益于libuv层的事件循环机制，和底层线程池实现。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NodeJs学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs学习笔记</title>
    <link href="/2020/05/03/NodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/05/03/NodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="NodeJs概念："><a href="#NodeJs概念：" class="headerlink" title="NodeJs概念："></a>NodeJs概念：</h3><p>Node.js 就是运行在服务端的 JavaScript。</p><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p><p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p><h3 id="NodeJs特点："><a href="#NodeJs特点：" class="headerlink" title="NodeJs特点："></a>NodeJs特点：</h3><ul><li>它是一个Javascript运行环境</li><li>依赖于Chrome V8引擎进行代码解释</li><li>事件驱动</li><li>非阻塞I/O</li><li>轻量、可伸缩，适于实时数据交互应用</li><li>单进程，单线程</li></ul><h3 id="NodeJs的优缺点："><a href="#NodeJs的优缺点：" class="headerlink" title="NodeJs的优缺点："></a>NodeJs的优缺点：</h3><p><strong>优点</strong>：</p><ul><li>高并发；</li><li>适合I/O密集型应用。</li></ul><p><strong>缺点</strong>：</p><ul><li>不适合CPU密集型应用，只支持单核CPU，不能充分利用CPU；</li><li>单进程，单线程，一旦代码某处出现bug，整个系统都崩溃；</li></ul><h3 id="V8-JavaScript-引擎"><a href="#V8-JavaScript-引擎" class="headerlink" title="V8 JavaScript 引擎"></a>V8 JavaScript 引擎</h3><p>V8 是为 Google Chrome 提供支持的 JavaScript 引擎的名称。 当使用 Chrome 进行浏览时，它负责处理并执行 JavaScript。</p><p>V8 提供了执行 JavaScript 的运行时环境。 DOM 和其他 Web 平台 API 则由浏览器提供。</p><p>JavaScript 引擎独立于托管它的浏览器。 此关键的特性推动了 Node.js 的兴起。 V8 于 2009 年被选为为 Node.js 提供支持的引擎，并且随着 Node.js 的爆炸性发展，V8 成为了现在为大量的服务器端代码（使用 JavaScript 编写）提供支持的引擎。</p><h3 id="Node-js-REPL-交互式解释器"><a href="#Node-js-REPL-交互式解释器" class="headerlink" title="Node.js REPL(交互式解释器)"></a>Node.js REPL(交互式解释器)</h3><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p><p>Node 自带了交互式解释器，可以执行以下任务：</p><ul><li><strong>读取</strong> - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</li><li><strong>执行</strong> - 执行输入的数据结构</li><li><strong>打印</strong> - 输出结果</li><li><strong>循环</strong> - 循环操作以上步骤直到用户两次按下 <strong>ctrl-c</strong> 按钮退出。</li></ul><p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p><h3 id="NodeJs事件循环机制和浏览器事件循环机制的区别"><a href="#NodeJs事件循环机制和浏览器事件循环机制的区别" class="headerlink" title="NodeJs事件循环机制和浏览器事件循环机制的区别"></a>NodeJs事件循环机制和浏览器事件循环机制的区别</h3><p><a href="https://blog.csdn.net/qq_39989929/article/details/89109937">浏览器端与nodejs端EventLoop机制(宏任务与微任务)的异同</a></p><p><a href="https://segmentfault.com/a/1190000018951319">JS异步详解 - 浏览器/Node/事件循环/消息队列/宏任务/微任务</a></p><p><a href="http://www.manongjc.com/article/105408.html">浏览器端时间循环与nodejs端时间循环的不同之处（宏任务与微任务）</a></p>]]></content>
    
    
    <categories>
      
      <category>NodeJs学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类的创建继承 与 new原理实现</title>
    <link href="/2020/05/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E7%BB%A7%E6%89%BF%20%E4%B8%8E%20new%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/05/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E7%BB%A7%E6%89%BF%20%E4%B8%8E%20new%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><h4 id="1-类的创建"><a href="#1-类的创建" class="headerlink" title="1. 类的创建"></a><a href="#jumpa"><strong>1. 类的创建</strong></a></h4><ul><li><a href="#jump1"><strong>工厂模式</strong></a></li><li><a href="#jump2"><strong>构造函数模式</strong></a></li><li><a href="#jump3"><strong>原型模式</strong></a></li><li><a href="#jump4"><strong>组合模式</strong></a></li></ul><h4 id="2-类的继承"><a href="#2-类的继承" class="headerlink" title="2. 类的继承"></a><a href="#jumpb"><strong>2. 类的继承</strong></a></h4><ul><li><a href="#jump5"><strong>原型链继承</strong></a></li><li><a href="#jump6"><strong>构造继承</strong></a></li><li><a href="#jump7"><strong>实例继承</strong></a></li><li><a href="#jump8"><strong>拷贝继承</strong></a></li><li><a href="#jump9"><strong>组合继承</strong></a></li><li><a href="#jump10"><strong>寄生组合继承</strong></a></li></ul><h4 id="3-new-的原理实现"><a href="#3-new-的原理实现" class="headerlink" title="3. new 的原理实现"></a><a href="#jumpc"><strong>3. new 的原理实现</strong></a></h4><br/><p><strong>学习和参考于</strong>：</p><p><a href="https://www.jb51.net/article/84089.htm"><strong>JS定义类的六种方式详解</strong></a></p><p><a href="https://www.cnblogs.com/humin/p/4556820.html"><strong>JS实现继承的几种方式</strong></a></p><p><a href="https://juejin.im/post/59128676128fe100586779cc"><strong>JavaScript深入之创建对象的多种方式以及优缺点</strong></a></p><p><a href="https://www.cnblogs.com/echolun/p/10903290.html"><strong>js new一个对象的过程，实现一个简单的new方法</strong></a></p></br><h1 id="（一）类的创建"><a href="#（一）类的创建" class="headerlink" title="（一）类的创建"></a><span id="jumpa"><strong>（一）类的创建</strong></span></h1><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a><span id="jump1"><strong>1. 工厂模式</strong></span></h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-comment">//原料:</span><br>    <span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-comment">//加工:</span><br>    obj.name=name;<br>    obj.showName=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>    <span class="hljs-comment">//出场:</span><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-keyword">var</span> p1=createPerson(<span class="hljs-string">&#x27;小米&#x27;</span>);<br>p1.showName();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<span class="hljs-comment">//生成一个系统数组对象</span><br></code></pre></td></tr></table></figure><p>与系统对象的区别：</p><ul><li><p>系统对象是直接用<strong>new</strong>在外面生成，而工厂定义的是在函数内部生成</p></li><li><p>工厂定义的函数名称第一个是小写开头，而系统定义的是大写开头</p></li></ul><p><strong>工厂模式的优缺点</strong>：</p><ul><li><p><strong>优点</strong>：实例可以识别为一个特定的类型</p></li><li><p><strong>缺点</strong>：每次创建实例时，每个方法都要被创建一次</p></li></ul><h3 id="2-构造函数方式"><a href="#2-构造函数方式" class="headerlink" title="2. 构造函数方式"></a><span id="jump2"><strong>2. 构造函数方式</strong></span></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">color,door</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.color = color;<br>    <span class="hljs-built_in">this</span>.doors = door;<br>    <span class="hljs-built_in">this</span>.showColor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.color)<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> Car(“red”,<span class="hljs-number">4</span>);<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> Car(“blue”,<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p><strong>构造函数模式的优缺点：</strong></p><ul><li><p><strong>优点</strong>：实例可以识别为一个特定的类型</p></li><li><p><strong>缺点</strong>：每次创建实例时，每个方法都要被创建一次</p></li></ul><p><strong>构造函数模式优化</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.getName = getName;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;kevin&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：解决了每个方法都要被重新创建的问题</p><h3 id="3-原型方式"><a href="#3-原型方式" class="headerlink" title="3. 原型方式"></a><span id="jump3"><strong>3. 原型方式</strong></span></h3><p>该方式利用了对象的prototype属性。首先用空函数创建类名，然后所有的属性和方法都被赋予prototype属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params"></span>)</span>&#123;<br>&#125;<br>Car.prototype.color = “red”;<br>Car.prototype.doors = <span class="hljs-number">4</span>;<br>Car.prototype.showColor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>alert(<span class="hljs-built_in">this</span>.color);<br>&#125;<br><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> Car();<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> Car();<br></code></pre></td></tr></table></figure><p>在这段代码中，首先定义了一个空函数，然后通过prototype属性来定义对象的属性。调用该函数时，原型的所有属性都会立即赋予要创建的对象，所有该函数的对象存放的都是指向showColor()的指针，语法上看起来都属于同一个对象。但是这个函数没有参数，不能通过传递参数来初始化属性，必须要在对象创建后才能改变属性的默认值。</p><p><strong>原型模式的优缺点：</strong></p><ul><li><p><strong>优点</strong>：方法不会重新创建</p></li><li><p><strong>缺点</strong>：所有的属性和方法都共享 、不能初始化参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//属性指向的是对象时，如数组：下面代码由于数组的引用值，Car的两个对象指向的都是同一个数组，所以当在car1添加值后，在car2中也可以看到。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params"></span>)</span>&#123;<br>&#125;<br>Car.prototype.color = “red”;<br>Car.prototype.doors = <span class="hljs-number">4</span>;<br>Car.prototype.arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(“a”,”b”);<br>Car.prototype.showColor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>alert(<span class="hljs-built_in">this</span>.color);<br>&#125;<br><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> Car();<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> Car();<br>car1.arr.push(“cc”);<br>alert(car1.arr); <span class="hljs-comment">//output:aa,bb,cc</span><br>alert(car2.arr); <span class="hljs-comment">//output:aa,bb,cc</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-组合模型"><a href="#4-组合模型" class="headerlink" title="4. 组合模型"></a><span id="jump4"><strong>4. 组合模型</strong></span></h3><p>构造函数模式用于定义实例属性，原型模式则用于定义方法和共享的属性。这种混合模式不仅支持向构造函数传入参数，还最大限度地节约了内存，可谓是集两模式之长。推荐使用这种方式创建类（同类对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">color,door</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.color = color;<br>    <span class="hljs-built_in">this</span>.doors = door;<br>    <span class="hljs-built_in">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(“aa”,”bb”);<br>&#125;<br>Car.prototype.showColor()&#123;<br>    alert(<span class="hljs-built_in">this</span>.color);<br>&#125;<br><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> Car(“red”,<span class="hljs-number">4</span>);<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> Car(“blue”,<span class="hljs-number">4</span>);<br>car1.arr.push(“cc”);<br>alert(car1.arr); <span class="hljs-comment">//output:aa,bb,cc</span><br>alert(car2.arr); <span class="hljs-comment">//output:aa,bb</span><br></code></pre></td></tr></table></figure><p><strong>优点</strong>：该共享的共享，该私有的私有，使用最广泛的方式</p><p><strong>缺点</strong>：有的人就是希望全部都写在一起，即更好的封装性</p><h5 id="还有几种创建方式，推荐查看："><a href="#还有几种创建方式，推荐查看：" class="headerlink" title="还有几种创建方式，推荐查看："></a><strong>还有几种创建方式，推荐查看</strong>：</h5><p><a href="https://www.jb51.net/article/84089.htm"><strong>JavaScript深入之创建对象的多种方式以及优缺点</strong></a></p><h1 id="（二）类的继承"><a href="#（二）类的继承" class="headerlink" title="（二）类的继承"></a><span id="jumpb"><strong>（二）类的继承</strong></span></h1><p><strong>这部分学习并摘自</strong>：<a href="https://www.cnblogs.com/humin/p/4556820.html"><strong>JS实现继承的几种方式</strong></a>（建议直接阅读原文）</p><p>既然要实现继承，那么首先我们得有一个父类，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个动物类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-comment">// 属性</span><br>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Animal&#x27;</span>;<br>  <span class="hljs-comment">// 实例方法</span><br>  <span class="hljs-built_in">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉！&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 原型方法</span><br>Animal.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在吃：&#x27;</span> + food);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a><span id="jump5"><strong>1. 原型链继承</strong></span></h3><p><strong>核心：</strong> 将父类的实例作为子类的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;<br>Cat.prototype = <span class="hljs-keyword">new</span> Animal();<br>Cat.prototype.name = <span class="hljs-string">&#x27;cat&#x27;</span>;<br><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat;<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.eat(<span class="hljs-string">&#x27;fish&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</p></li><li><p>父类新增原型方法/原型属性，子类都能访问到</p></li><li><p>简单，易于实现</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p>要想为子类新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后执行，不能放到构造器中</p></li><li><p>无法实现多继承</p></li><li><p>来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）（详细请看附录代码： 示例1）</p></li><li><p>创建子类实例时，无法向父类构造函数传参</p></li></ul><p>推荐指数：★★（后两个缺点是两大致命缺陷）</p><h3 id="2-构造继承"><a href="#2-构造继承" class="headerlink" title="2. 构造继承"></a><span id="jump6"><strong>2. 构造继承</strong></span></h3><p><strong>核心：</strong>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  Animal.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><p>解决了1中，子类实例共享父类引用属性的问题</p></li><li><p>创建子类实例时，可以向父类传递参数</p></li><li><p>可以实现多继承（call多个父类对象）</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p>实例并不是父类的实例，只是子类的实例</p></li><li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p></li><li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p></li></ul><p>推荐指数：★★（缺点3）</p><h3 id="3-实例继承"><a href="#3-实例继承" class="headerlink" title="3. 实例继承"></a><span id="jump7"><strong>3. 实例继承</strong></span></h3><p><strong>核心：</strong>为父类实例添加新特性，作为子类实例返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> Animal();<br>  instance.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>不限制调用方式，不管是<code>new 子类()</code>还是<code>子类()</code>,返回的对象具有相同的效果</li></ul><p><strong>缺点</strong>：</p><ul><li><p>实例是父类的实例，不是子类的实例</p></li><li><p>不支持多继承</p></li></ul><p>推荐指数：★★</p><h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4. 拷贝继承"></a><span id="jump8"><strong>4. 拷贝继承</strong></span></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> animal = <span class="hljs-keyword">new</span> Animal();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> animal)&#123;<br>    Cat.prototype[p] = animal[p];<br>  &#125;<br>  Cat.prototype.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>支持多继承</li></ul><p><strong>缺点</strong>：</p><ul><li><p>效率较低，内存占用高（因为要拷贝父类的属性）</p></li><li><p>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p></li></ul><p>推荐指数：★（缺点1）</p><h3 id="5-组合继承"><a href="#5-组合继承" class="headerlink" title="5. 组合继承"></a><span id="jump9"><strong>5. 组合继承</strong></span></h3><p><strong>核心：</strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  Animal.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br>Cat.prototype = <span class="hljs-keyword">new</span> Animal();<br><br>Cat.prototype.constructor = Cat;<br><br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</p></li><li><p>既是子类的实例，也是父类的实例</p></li><li><p>不存在引用属性共享问题</p></li><li><p>可传参</p></li><li><p>函数可复用</p></li></ul><p><strong>缺点</strong>：</p><ul><li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li></ul><p>推荐指数：★★★★（仅仅多消耗了一点内存）</p><h3 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6. 寄生组合继承"></a><span id="jump10"><strong>6. 寄生组合继承</strong></span></h3><p><strong>核心：</strong>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>) </span>&#123;<br>Animal.call(<span class="hljs-built_in">this</span>);<br><span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> Super = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>Super.prototype = Animal.prototype;<br>Cat.prototype = <span class="hljs-keyword">new</span> Super()<br>&#125;)()<br><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>堪称完美</li></ul><p><strong>缺点</strong>：</p><ul><li>实现较为复杂</li></ul><p>推荐指数：★★★★（实现复杂，扣掉一颗星）</p><h3 id="7-附录代码："><a href="#7-附录代码：" class="headerlink" title="7. 附录代码："></a>7. 附录代码：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-comment">// 属性</span><br>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Animal&#x27;</span>;<br>  <span class="hljs-comment">// 实例方法</span><br>  <span class="hljs-built_in">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉！&#x27;</span>);<br>  &#125;<br>  <span class="hljs-comment">//实例引用属性</span><br>  <span class="hljs-built_in">this</span>.features = [];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>&#125;<br>Cat.prototype = <span class="hljs-keyword">new</span> Animal();<br><br><span class="hljs-keyword">var</span> tom = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">var</span> kissy = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Kissy&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(tom.name); <span class="hljs-comment">// &quot;Animal&quot;</span><br><span class="hljs-built_in">console</span>.log(kissy.name); <span class="hljs-comment">// &quot;Animal&quot;</span><br><span class="hljs-built_in">console</span>.log(tom.features); <span class="hljs-comment">// []</span><br><span class="hljs-built_in">console</span>.log(kissy.features); <span class="hljs-comment">// []</span><br><br>tom.name = <span class="hljs-string">&#x27;Tom-New Name&#x27;</span>;<br>tom.features.push(<span class="hljs-string">&#x27;eat&#x27;</span>);<br><br><span class="hljs-comment">//针对父类实例值类型成员的更改，不影响</span><br><span class="hljs-built_in">console</span>.log(tom.name); <span class="hljs-comment">// &quot;Tom-New Name&quot;</span><br><span class="hljs-built_in">console</span>.log(kissy.name); <span class="hljs-comment">// &quot;Animal&quot;</span><br><span class="hljs-comment">//针对父类实例引用类型成员的更改，会通过影响其他子类实例</span><br><span class="hljs-built_in">console</span>.log(tom.features); <span class="hljs-comment">// [&#x27;eat&#x27;]</span><br><span class="hljs-built_in">console</span>.log(kissy.features); <span class="hljs-comment">// [&#x27;eat&#x27;]</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">原因分析：</span><br><span class="hljs-comment">关键点：属性查找过程</span><br><span class="hljs-comment">执行tom.features.push，首先找tom对象的实例属性（找不到），</span><br><span class="hljs-comment">那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的</span><br><span class="hljs-comment">features属性中插入值。</span><br><span class="hljs-comment">在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。</span><br><span class="hljs-comment">刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="（三）new-原理实现"><a href="#（三）new-原理实现" class="headerlink" title="（三）new 原理实现"></a><span id="jumpc"><strong>（三）new 原理实现</strong></span></h1><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p><h3 id="1-new一个对象中间做了什么操作"><a href="#1-new一个对象中间做了什么操作" class="headerlink" title="1. new一个对象中间做了什么操作"></a>1. new一个对象中间做了什么操作</h3><ul><li>以构造器的prototype属性为原型，创建新对象；</li><li>将this(也就是上一句中的新对象)和调用参数传给构造器，执行；</li><li>如果构造器没有手动返回对象，则返回第一步创建的新对象，如果有，则舍弃掉第一步创建的新对象，返回手动return的对象。</li></ul><p>new过程中会<strong>新建对象</strong>，此对象会继承<strong>构造器的原型与原型上的属性</strong>，最后它会被<strong>作为实例返回</strong>这样一个过程。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newMethod</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">//拿到传入的参数中的第一个参数，即构造函数名Func</span><br>  <span class="hljs-keyword">let</span> constr = [].shift.call(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-comment">// 1.以构造器的prototype属性为原型，创建新对象：             </span><br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(constr.prototype);<br> <span class="hljs-comment">// 2.将this和调用参数传给构造器执行 (使用apply，将构造函数中的this指向新对象，这样新对象就可以访问构造函数中的属性和方法)：</span><br>  <span class="hljs-keyword">let</span> result = constr.apply(obj, <span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-comment">// 3.如果构造器没有手动返回对象，则返回第一步的对象(构造函数的一个实例对象)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> ? result : obj;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 构造器函数</span><br><span class="hljs-keyword">let</span> Parent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;;<br>Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br><span class="hljs-comment">//创建实例，将构造函数Parent与形参作为参数传入</span><br><span class="hljs-keyword">const</span> child = newMethod(Parent, <span class="hljs-string">&#x27;echo&#x27;</span>, <span class="hljs-number">26</span>);<br>child.sayName() <span class="hljs-comment">//&#x27;echo&#x27;;</span><br><br><span class="hljs-comment">//最后检验，与使用new的效果相同</span><br>child <span class="hljs-keyword">instanceof</span> Parent<span class="hljs-comment">//true</span><br>child.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>)<span class="hljs-comment">//true</span><br>child.hasOwnProperty(<span class="hljs-string">&#x27;age&#x27;</span>)<span class="hljs-comment">//true</span><br>child.hasOwnProperty(<span class="hljs-string">&#x27;sayName&#x27;</span>)<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>call  apply  bind 原理实现</title>
    <link href="/2020/05/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/call%20%20apply%20%20bind%20%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/05/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/call%20%20apply%20%20bind%20%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h1><h3 id="1-call-的模拟实现"><a href="#1-call-的模拟实现" class="headerlink" title="1. call 的模拟实现"></a><a href="#jump1"><strong>1. call 的模拟实现</strong></a></h3><h3 id="2-apply-的模拟实现"><a href="#2-apply-的模拟实现" class="headerlink" title="2. apply 的模拟实现"></a><a href="#jump2"><strong>2. apply 的模拟实现</strong></a></h3><h3 id="3-bind-的模拟实现"><a href="#3-bind-的模拟实现" class="headerlink" title="3. bind 的模拟实现"></a><a href="#jump3"><strong>3. bind 的模拟实现</strong></a></h3><h3 id="4-三者异同"><a href="#4-三者异同" class="headerlink" title="4. 三者异同"></a><a href="#jump4"><strong>4. 三者异同</strong></a></h3><br /><p><strong>学习并参考于</strong>：</p><p><a href="https://juejin.im/post/5907eb99570c3500582ca23c"><strong>JavaScript深入之call和apply的模拟实现</strong></a></p><p><a href="https://zhuanlan.zhihu.com/p/80151192"><strong>JS的call,apply与bind详解，及其模拟实现</strong></a></p><br/><h1 id="（一）call的模拟实现"><a href="#（一）call的模拟实现" class="headerlink" title="（一）call的模拟实现"></a><span id="jump1"><strong>（一）call的模拟实现</strong></span></h1><p><strong>call 用法</strong> ： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><strong>MDN  Function.prototype.call()</strong></a></p><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和可选的参数列表来调用一个函数。</p><p><code>call()</code> 提供新的 <strong>this</strong> 值给当前调用的函数/方法。</p><h4 id="1-call-实现主要思路："><a href="#1-call-实现主要思路：" class="headerlink" title="1. call 实现主要思路："></a><strong>1. call 实现主要思路</strong>：</h4><ul><li><p>将函数设为对象的属性</p></li><li><p>执行该函数</p></li><li><p>删除该函数</p></li></ul><p>另外还有考虑：</p><ul><li>call 函数还能给定参数执行函数</li><li>this 参数不传，或者传null，undefined， this指向window对象</li><li>函数是可以有返回值的</li></ul><h4 id="2-实现："><a href="#2-实现：" class="headerlink" title="2. 实现："></a><strong>2. 实现</strong>：</h4><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;error!&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-built_in">window</span>   <span class="hljs-comment">//this 参数可以传 null，当为 null 的时候，视为指向 window</span><br>  context.fn = <span class="hljs-built_in">this</span>  <span class="hljs-comment">// 首先要获取调用call的函数，用this可以获取</span><br>  <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>) <span class="hljs-comment">//从 Arguments 对象中取值，取出第二个到最后一个参数   </span><br>  <span class="hljs-keyword">let</span> result = context.fn(...args)  <span class="hljs-comment">//函数是可以有返回值的</span><br>  <span class="hljs-keyword">delete</span> context.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-测试："><a href="#3-测试：" class="headerlink" title="3. 测试："></a><strong>3. 测试</strong>：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 测试一下上面实现的myCall</span><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value);<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.value,<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">age</span>: age<br>    &#125;<br>&#125;<br><br>bar.call(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-built_in">console</span>.log(bar.myCall(obj, <span class="hljs-string">&#x27;kevin&#x27;</span>, <span class="hljs-number">18</span>));<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//    value: 1,</span><br><span class="hljs-comment">//    name: &#x27;kevin&#x27;,</span><br><span class="hljs-comment">//    age: 18</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h1 id="（二）apply-的模拟实现"><a href="#（二）apply-的模拟实现" class="headerlink" title="（二）apply 的模拟实现"></a><span id="jump2"><strong>（二）apply 的模拟实现</strong></span></h1><p><strong>apply 用法</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><strong>MDN Function.prototype.apply()</strong></a></p><p><code>apply()</code> 方法使用一个指定的 <code>this</code> 值和可选的参数数组 来调用一个函数。</p><p>apply 的实现跟 call 类似。</p><h4 id="1-实现："><a href="#1-实现：" class="headerlink" title="1. 实现："></a><strong>1. 实现</strong>：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;error!&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-built_in">window</span><br>  context.fn = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] ? context.fn(...arguments[<span class="hljs-number">1</span>]) : context.fn()<br>  <span class="hljs-keyword">delete</span> context.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-测试："><a href="#2-测试：" class="headerlink" title="2. 测试："></a><strong>2. 测试</strong>：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(name)<br>    <span class="hljs-built_in">console</span>.log(age)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value);<br>&#125;<br>bar.myApply(foo, [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>]) <span class="hljs-comment">// black 18 1</span><br></code></pre></td></tr></table></figure><h1 id="（三）bind-的模拟实现"><a href="#（三）bind-的模拟实现" class="headerlink" title="（三）bind 的模拟实现"></a><span id="jump3"><strong>（三）bind 的模拟实现</strong></span></h1><p><strong>bind 用法</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><strong>MDN Function.prototype.bind()</strong></a></p><p>bind()方法会创建一个新函数，称为绑定函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><p>bind是ES5新增的一个方法，不会执行对应的函数，而是返回对绑定函数的引用。</p><h4 id="1-实现：-1"><a href="#1-实现：-1" class="headerlink" title="1. 实现："></a><strong>1. 实现</strong>：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.customBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;error!&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">const</span> that = <span class="hljs-built_in">this</span>   <span class="hljs-comment">// 首先要获取调用bind的函数，用this获取并存放在that中</span><br>  <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-built_in">window</span><br>  <span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> that.apply(context, args.concat([...arguments]))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="（四）三者异同"><a href="#（四）三者异同" class="headerlink" title="（四）三者异同"></a><span id="jump4"><strong>（四）三者异同</strong></span></h1><h4 id="1-相同："><a href="#1-相同：" class="headerlink" title="1. 相同："></a><strong>1. 相同</strong>：</h4><ul><li>改变函数体内 this 的指向</li></ul><h4 id="2-不同："><a href="#2-不同：" class="headerlink" title="2. 不同："></a><strong>2. 不同</strong>：</h4><ul><li>call、apply的区别：<code>call()</code>方法接受的是<strong>参数列表</strong>，而<code>apply()</code>方法接受的是<strong>一个参数数组</strong>。</li><li>bind不立即执行。而call或apply会自动执行对应的函数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async await Generator 原理实现</title>
    <link href="/2020/05/02/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/async%20await%20Generator%20%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/05/02/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/async%20await%20Generator%20%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async  await"></a><a href="#jump1">1. async  await</a></h4><h4 id="2-Generator"><a href="#2-Generator" class="headerlink" title="2. Generator"></a><a href="#jump2">2. Generator</a></h4><h4 id="3-async-await-和-Generator-区别"><a href="#3-async-await-和-Generator-区别" class="headerlink" title="3. async await 和 Generator 区别"></a><a href="#jump3">3. async await 和 Generator 区别</a></h4><br/><p>本文主要是学习：<a href="https://msd.misuland.com/pd/4146263433584579672?page=1"><strong>异步编程二三事 | Promise/async/Generator实现原理解析</strong></a> 中一部分内容的学习笔记，（强烈推荐阅读原本）</p><br/><h1 id="（一）async-await"><a href="#（一）async-await" class="headerlink" title="（一）async await"></a><span id="jump1"><strong>（一）async await</strong></span></h1><p>在多个回调依赖的场景中，尽管Promise通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p><p>async/await 两个关键字均用来实现异步处理，使用这两个关键字，可以书写比Promise更为简洁的异步处理代码。async函数可以返回Promise，当函数返回值时，Promise返回肯定结果，当async函数抛出异常时，Promise返回否定结果。</p><p>async/await实际上是对Generator（生成器）的封装，是一个语法糖。</p><h3 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1. 自动执行"></a>1. 自动执行</h3><p>初步实现了一个<code>async/await</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">myGenerator</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>))   <span class="hljs-comment">//1</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>))   <span class="hljs-comment">//2</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>))   <span class="hljs-comment">//3</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">myGenerator</span>) </span>&#123;<br><span class="hljs-keyword">var</span> g = gen(); <span class="hljs-comment">//由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在step()之前,否则会进入死循环</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">val</span>) </span>&#123;  <span class="hljs-comment">//封装一个方法, 递归执行next()</span><br><span class="hljs-keyword">var</span> res = g.next(val)  <span class="hljs-comment">//获取迭代器对象，并返回resolve的值</span><br><span class="hljs-keyword">if</span> (res.done) <span class="hljs-keyword">return</span> res.value; <span class="hljs-comment">//递归终止条件</span><br>res.value.then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;  <span class="hljs-comment">//Promise的then方法是实现自动迭代的前提</span><br>step(val)   <span class="hljs-comment">//等待Promise完成就自动执行下一个next，并传入resolve的值</span><br>&#125;)<br>&#125;<br><br>step(); <span class="hljs-comment">//第一次执行</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-返回Promise-amp-异常处理"><a href="#2-返回Promise-amp-异常处理" class="headerlink" title="2.返回Promise &amp; 异常处理"></a>2.返回Promise &amp; 异常处理</h3><p>上面实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：</p><ul><li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li><li><strong>缺少错误处理</strong>：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的try-catch捕获到</li><li><strong>返回值是Promise</strong>：<code>async/await</code>的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise</li></ul><p>我们改造一下run方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">gen</span>) </span>&#123;<br>  <span class="hljs-comment">//把返回值包装成promise</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> g = gen()<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">val</span>) </span>&#123;<br>      <span class="hljs-comment">//错误处理</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> res = g.next(val) <br>      &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>        <span class="hljs-keyword">return</span> reject(err); <br>      &#125;<br>      <span class="hljs-keyword">if</span>(res.done) &#123;<br>        <span class="hljs-keyword">return</span> resolve(res.value);<br>      &#125;<br>      <span class="hljs-comment">//res.value包装为promise，以兼容yield后面跟基本类型的情况</span><br>      <span class="hljs-built_in">Promise</span>.resolve(res.value).then(<br>        <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>          step(val);<br>        &#125;, <br>        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>          <span class="hljs-comment">//抛出错误</span><br>          g.throw(err)<br>        &#125;);<br>    &#125;<br>    step();<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">myGenerator</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)) <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>)   <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;error&#x27;</span>))<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(error)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = run(myGenerator)     <span class="hljs-comment">//result是一个Promise</span><br><span class="hljs-comment">//输出 1 2 error</span><br></code></pre></td></tr></table></figure><h1 id="（二）Generator"><a href="#（二）Generator" class="headerlink" title="（二）Generator"></a><span id="jump2"><strong>（二）Generator</strong></span></h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen$</span>(<span class="hljs-params">_context</span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        _context.next = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result1&#x27;</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        _context.next = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result2&#x27;</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        _context.next = <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result3&#x27;</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;end&quot;</span>:<br>        <span class="hljs-keyword">return</span> _context.stop();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 低配版context  </span><br><span class="hljs-keyword">var</span> context = &#123;<br>  <span class="hljs-attr">next</span>:<span class="hljs-number">0</span>,<br>  <span class="hljs-attr">prev</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">stop</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stop</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.done = <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 低配版invoke</span><br><span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      value = context.done ? <span class="hljs-literal">undefined</span>: gen$(context)<br>      done = context.done<br>      <span class="hljs-keyword">return</span> &#123;<br>        value,<br>        done<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125; <br><br><span class="hljs-comment">// 测试使用</span><br><span class="hljs-keyword">var</span> g = gen() <br>g.next()  <span class="hljs-comment">// &#123;value: &quot;result1&quot;, done: false&#125;</span><br>g.next()  <span class="hljs-comment">// &#123;value: &quot;result2&quot;, done: false&#125;</span><br>g.next()  <span class="hljs-comment">// &#123;value: &quot;result3&quot;, done: false&#125;</span><br>g.next()  <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>这段代码并不难理解，我们分析一下调用流程：</p><p>我们定义的<code>function*</code>生成器函数被转化为以上代码</p><ol><li>转化后的代码分为三大块：<ul><li><code>gen$(_context)</code>由yield分割生成器函数代码而来</li><li><code>context对象</code>用于储存函数执行上下文</li><li><code>invoke()方法</code>定义next()，用于执行gen$(_context)来跳到下一步</li></ul></li><li>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入switch语句，switch根据context的标识，执行对应的case块，return对应结果</li><li>当生成器函数运行到末尾（没有下一个yield或已经return），switch匹配不到对应代码块，就会return空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></li></ol><p>从中我们可以看出，Generator实现的核心在于<code>上下文的保存</code>，函数并没有真的被挂起，每一次yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个context对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</p><h1 id="（一）async-await-和-Generator-区别"><a href="#（一）async-await-和-Generator-区别" class="headerlink" title="（一）async await 和 Generator 区别"></a><span id="jump3"><strong>（一）async await 和 Generator 区别</strong></span></h1><p><code>async/await</code>实际上是对<code>Generator</code>（生成器）的封装，<code>async</code>函数是<code>Generator</code>函数的语法糖，将<code>Generator</code>的星号换成<code>async</code>，将<code>yield</code>换成<code>await</code>，<code>async</code>函数比<code>Generator</code>函数更好用.</p><p><code>Generator</code>与<code>async function</code>都是返回一个特定类型的对象：</p><ul><li><code>async/await</code>自带执行器，不需要手动调用next()就能自动执行下一步</li><li><code>async</code>始终返回一个<code>Promise</code>，使用<code>await</code>或者<code>.then()</code>来获取返回值，而Generator返回的是生成器对象，一个类似<code>&#123; value: XXX, done: true &#125;</code>这样结构的<code>Object</code></li><li><code>await</code>能够返回Promise的resolve/reject的值</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2020/05/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise/"/>
    <url>/2020/05/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-Promise-基本结构"><a href="#1-Promise-基本结构" class="headerlink" title="1. Promise 基本结构"></a><a href="#jumpa"><strong>1. <code>Promise</code> 基本结构</strong></a></h4><h4 id="2-Promise-状态和值"><a href="#2-Promise-状态和值" class="headerlink" title="2. Promise 状态和值"></a><a href="#jumpb"><strong>2. <code>Promise</code> 状态和值</strong></a></h4><h4 id="3-Promise-的-then-方法"><a href="#3-Promise-的-then-方法" class="headerlink" title="3. Promise 的 then 方法"></a><a href="#jumpc"><strong>3. <code>Promise</code> 的 <code>then</code> 方法</strong></a></h4><h4 id="4-Promise基本实现"><a href="#4-Promise基本实现" class="headerlink" title="4. Promise基本实现"></a><a href="#jumpd"><strong>4. <code>Promise</code>基本实现</strong></a></h4><h4 id="5-Promise零碎知识"><a href="#5-Promise零碎知识" class="headerlink" title="5. Promise零碎知识"></a><a href="#jumpe"><strong>5. <code>Promise</code>零碎知识</strong></a></h4><p><strong>学习<code>Promise</code> 用法  见</strong> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><strong>MDN Promise</strong></a></p><p><strong>学习Promise底层实现  见</strong>：<a href="https://www.jianshu.com/p/43de678e918a"><strong>Promise实现原理（附源码）</strong></a> （本文学习并参考的一篇博客，推荐直接阅读）</p><p><strong>其他推荐</strong>：<a href="https://www.jianshu.com/p/473cd754311f/"><strong>Promise简单实现</strong></a></p><h1 id="（一）Promise-基本结构"><a href="#（一）Promise-基本结构" class="headerlink" title="（一）Promise 基本结构"></a><span id="jumpa"><strong>（一）<code>Promise</code> 基本结构</strong></span></h1><p><code>Promise</code> 是一种抽象异步处理对象，其核心概念为 “确保一件事做完之后，再做另一件事”</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;FULFILLED&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>构造函数<code>Promise</code>必须接受一个函数作为参数，称该函数为<code>handle</code>，<code>handle</code>又包含<code>resolve</code>和<code>reject</code>两个参数，它们是两个函数。</p><h1 id="（二）-Promise-状态和值"><a href="#（二）-Promise-状态和值" class="headerlink" title="（二） Promise 状态和值"></a><span id="jumpb"><strong>（二） <code>Promise</code> 状态和值</strong></span></h1><p><code>Promise</code> 对象存在以下<strong>三种状态</strong>：</p><ul><li><strong><code>Pending</code></strong>  (进行中)</li><li><strong><code>Fulfilled</code></strong>  (已成功)</li><li>**<code>Rejected</code>  **（已失败)</li></ul><p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或由 <code>Pending</code> 变为 <code>Rejected</code> ，且状态改变之后不会在发生变化，会一直保持这个状态。</p><p><code>Promise</code>的值是指状态改变时传递给回调函数的值.</p><p>上文中<code>handle</code>函数包含 <code>resolve</code> 和 <code>reject</code> 两个参数，它们是两个函数，可以用于改变 <code>Promise</code> 的状态和传入 <code>Promise</code> 的值。</p><ul><li> <strong><code>resolve</code></strong> : 将Promise对象的状态从 <code>Pending</code>(进行中) 变为 <code>Fulfilled</code>(已成功)`</li><li> <strong><code>reject</code></strong> : 将Promise对象的状态从 <code>Pending</code>(进行中) 变为 <code>Rejected</code>(已失败)`</li><li> <strong><code>resolve</code></strong> ：和 <code>reject</code> 都可以传入任意类型的值作为实参，表示 <code>Promise</code> 对象成功<code>（Fulfilled）</code>和失败<code>（Rejected）</code>的值</li></ul><p>在Promise构造函数<code>handle</code>中可以执行一些处理（可以是异步处理），如果执行结果正常则调用resolve回调函数，否则调用reject回调函数。在ES6中将“执行结果正常” 称为Promise对象返回肯定结果，将 “执行失败” 称为Promise对象返回否定结果。</p><h1 id="（三）Promise-的-then-方法"><a href="#（三）Promise-的-then-方法" class="headerlink" title="（三）Promise 的 then 方法"></a><span id="jumpc"><strong>（三）<code>Promise</code> 的 <code>then</code> 方法</strong></span></h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.then(onFulfilled, onRejected)<br></code></pre></td></tr></table></figure><p><code>Promise</code> 对象的 <code>then</code> 方法接受两个参数，<code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p><p><strong>多次调用</strong>： <code>then</code> 方法可以被同一个 <code>promise</code> 对象调用多次</p><ul><li>当 <code>promise</code> 成功状态时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li><li>当 <code>promise</code> 失败状态时，所有 <code>onRejected</code> 需按照其注册顺序依次回调</li></ul><p><strong>返回</strong>：<code>then</code> 方法必须返回一个新的 <code>promise</code> 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise2 = promise1.then(onFulfilled, onRejected);<br></code></pre></td></tr></table></figure><p>因此 <code>promise</code> 支持链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise1.then(onFulfilled1, onRejected1).then(onFulfilled2, onRejected2);<br></code></pre></td></tr></table></figure><h3 id="1-onFulfilled-特性"><a href="#1-onFulfilled-特性" class="headerlink" title="1. onFulfilled 特性"></a><strong>1. <code>onFulfilled</code> 特性</strong></h3><p> <strong>（1）<code>onFulfilled</code> 不是函数时</strong>：</p><ul><li><p> <code>onFulfilled</code> 将被忽略。</p></li><li><p><code>onFulfilled</code> 不是函数且 <code>promise1</code> 状态为成功<code>（Fulfilled）</code>时， <code>promise2</code> 必须变为成功<code>（Fulfilled）</code>并返回 <code>promise1</code> 成功的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>promise2 = promise1.then(<span class="hljs-string">&#x27;这里的onFulfilled本来是一个函数，但现在不是&#x27;</span>)<br>promise2.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res) <span class="hljs-comment">// 1秒后打印出：success</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>*（2）<code>onFulfilled</code> 是函数时**：</p></li></ul><ul><li>当 <code>promise</code> 状态变为成功时必须被调用，其第一个参数为 <code>promise</code> 成功状态传入的值（ <code>resolve</code> 执行时传入的值）</li><li>在 <code>promise</code> 状态改变前其不可被调用</li><li>其调用次数不可超过一次</li></ul><ul><li><p>如果 <code>onFulfilled</code>  返回一个值 <code>x</code> ，则运行下面的 <code>Promise</code> 解决过程：<code>[[Resolve]](promise2, x)</code></p><ul><li><p>若 <code>x</code> 不为 <code>Promise</code> ，则使 <code>x</code> 直接作为新返回的 <code>Promise</code> 对象的值， 即新的<code>onFulfilled</code> 或者 <code>onRejected</code> 函数的参数.</p></li><li><p>若 <code>x</code> 为 <code>Promise</code> ，这时后一个回调函数，就会等待该 <code>Promise</code> 对象(即 <code>x</code> )的状态发生变化，才会被调用，并且新的 <code>Promise</code> 状态和 <code>x</code> 的状态相同。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 当onFulfilled返回值不为Promise：</span><br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve()<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 返回一个普通值</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这里返回一个普通值&#x27;</span><br>&#125;)<br>promise2.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res) <span class="hljs-comment">//1秒后打印出：这里返回一个普通值</span><br>&#125;)<br><br><span class="hljs-comment">// 当onFulfilled返回值为Promise：</span><br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve()<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 返回一个Promise对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     resolve(<span class="hljs-string">&#x27;这里返回一个Promise&#x27;</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>  &#125;)<br>&#125;)<br>promise2.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res) <span class="hljs-comment">//3秒后打印出：这里返回一个Promise</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>如果 <code>onFulfilled</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须变为失败<code>（Rejected）</code>，并返回失败的值 <code>e</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;这里抛出一个异常e&#x27;</span>)<br>&#125;)<br>promise2.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err) <span class="hljs-comment">//1秒后打印出：这里抛出一个异常e</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-onRejected-特性"><a href="#2-onRejected-特性" class="headerlink" title="2. onRejected 特性"></a><strong>2. <code>onRejected</code> 特性</strong></h3><p> <strong>（1）<code>onRejected</code> 不是函数时</strong>：</p><ul><li><p><code>onRejected</code> 将被忽略。</p></li><li><p> <code>onRejected</code> 不是函数且 <code>promise1</code> 状态为失败<code>（Rejected）</code>，<code>promise2</code>必须变为失败<code>（Rejected）</code> 并返回 <code>promise1</code> 失败的值。</p></li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    reject(<span class="hljs-string">&#x27;fail&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res, <span class="hljs-string">&#x27;这里的onRejected本来是一个函数，但现在不是&#x27;</span>)<br>promise2.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err)  <span class="hljs-comment">// 1秒后打印出：fail</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>  <strong>（2）<code>onRejected</code> 是函数：</strong></p><ul><li>当 <code>promise</code> 状态变为失败时必须被调用，其第一个参数为 <code>promise</code> 失败状态传入的值（ <code>reject</code> 执行时传入的值）</li><li>在 <code>promise</code> 状态改变前其不可被调用</li><li>其调用次数不可超过一次</li></ul><ul><li><p>如果<code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <code>Promise</code> 解决过程：<code>[[Resolve]](promise2, x)</code></p><ul><li><p>若 <code>x</code> 不为 <code>Promise</code> ，则使 <code>x</code> 直接作为新返回的 <code>Promise</code> 对象的值， 即新的<code>onFulfilled</code> 或者 <code>onRejected</code> 函数的参数.</p></li><li><p>若 <code>x</code> 为 <code>Promise</code> ，这时后一个回调函数，就会等待该 <code>Promise</code> 对象(即 <code>x</code> )的状态发生变化，才会被调用，并且新的 <code>Promise</code> 状态和 <code>x</code> 的状态相同。</p></li></ul></li><li><p>如果<code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须变为失败<code>（Rejected）</code>，并返回失败的值 <code>e</code></p></li></ul><h1 id="（四）Promise基本实现"><a href="#（四）Promise基本实现" class="headerlink" title="（四）Promise基本实现"></a><span id="jumpd"><strong>（四）<code>Promise</code>基本实现</strong></span></h1><p>下面代码仅实现<code>Promise</code>中<code>resolve</code>、<code>reject</code>、<code>then</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断变量否为function</span><br><span class="hljs-keyword">const</span> isFunction = <span class="hljs-function"><span class="hljs-params">variable</span> =&gt;</span> <span class="hljs-keyword">typeof</span> variable === <span class="hljs-string">&#x27;function&#x27;</span><br><span class="hljs-comment">// 定义Promise的三种状态常量</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span><br><br><span class="hljs-comment">//定义一个名为 MyPromise 的 Class，它接受一个函数 handle 作为参数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;<br>    <span class="hljs-title">constructor</span> (<span class="hljs-params">handle</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!isFunction(handle)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)<br>      &#125;<br>      <span class="hljs-comment">// 添加状态</span><br>      <span class="hljs-built_in">this</span>._status = PENDING<br>      <span class="hljs-comment">// 添加状态</span><br>      <span class="hljs-built_in">this</span>._value = <span class="hljs-literal">undefined</span><br>      <span class="hljs-comment">// 添加成功回调函数队列</span><br>      <span class="hljs-built_in">this</span>._fulfilledQueues = []<br>      <span class="hljs-comment">// 添加失败回调函数队列</span><br>      <span class="hljs-built_in">this</span>._rejectedQueues = []<br>      <span class="hljs-comment">// 执行handle</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        handle(<span class="hljs-built_in">this</span>._resolve.bind(<span class="hljs-built_in">this</span>), <span class="hljs-built_in">this</span>._reject.bind(<span class="hljs-built_in">this</span>)) <br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-built_in">this</span>._reject(err)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 添加resovle时执行的函数</span><br>    _resolve (val) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDING) <span class="hljs-keyword">return</span><br>      <span class="hljs-comment">// 依次执行成功队列中的函数，并清空队列</span><br>      <span class="hljs-keyword">const</span> run = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>._status = FULFILLED<br>        <span class="hljs-built_in">this</span>._value = val<br>        <span class="hljs-keyword">let</span> cb;<br>        <span class="hljs-keyword">while</span> (cb = <span class="hljs-built_in">this</span>._fulfilledQueues.shift()) &#123;<br>          cb(val)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 为了支持同步的Promise，这里采用异步调用</span><br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> run(), <span class="hljs-number">0</span>)<br>    &#125;<br><span class="hljs-comment">// 添加reject时执行的函数</span><br>_reject (err) &#123; <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDING) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">// 依次执行失败队列中的函数，并清空队列</span><br>  <span class="hljs-keyword">const</span> run = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>._status = REJECTED<br>    <span class="hljs-built_in">this</span>._value = err<br>    <span class="hljs-keyword">let</span> cb;<br>    <span class="hljs-keyword">while</span> (cb = <span class="hljs-built_in">this</span>._rejectedQueues.shift()) &#123;<br>      cb(err)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 为了支持同步的Promise，这里采用异步调用</span><br>  <span class="hljs-built_in">setTimeout</span>(run, <span class="hljs-number">0</span>)<br>&#125;<br>  <span class="hljs-comment">// 添加then方法</span><br>then (onFulfilled, onRejected) &#123;<br>  <span class="hljs-keyword">const</span> &#123; _value, _status &#125; = <span class="hljs-built_in">this</span><br>  <span class="hljs-comment">// 返回一个新的Promise对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 封装一个成功时执行的函数</span><br>    <span class="hljs-keyword">let</span> fulfilled = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isFunction(onFulfilled)) &#123;<br>          onFulfilledNext(value)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">let</span> res =  onFulfilled(value);<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            <span class="hljs-comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span><br>            res.then(onFulfilledNext, onRejectedNext)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br>            onFulfilledNext(res)<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-comment">// 如果函数执行出错，新的Promise对象的状态为失败</span><br>        onRejectedNext(err)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 封装一个失败时执行的函数</span><br>    <span class="hljs-keyword">let</span> rejected = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isFunction(onRejected)) &#123;<br>          onRejectedNext(error)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> res = onRejected(error);<br>            <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>              <span class="hljs-comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span><br>              res.then(onFulfilledNext, onRejectedNext)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br>              onFulfilledNext(res)<br>            &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-comment">// 如果函数执行出错，新的Promise对象的状态为失败</span><br>        onRejectedNext(err)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> (_status) &#123;<br>      <span class="hljs-comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span><br>      <span class="hljs-keyword">case</span> PENDING:<br>        <span class="hljs-built_in">this</span>._fulfilledQueues.push(fulfilled)<br>        <span class="hljs-built_in">this</span>._rejectedQueues.push(rejected)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-comment">// 当状态已经改变时，立即执行对应的回调函数</span><br>      <span class="hljs-keyword">case</span> FULFILLED:<br>        fulfilled(_value)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> REJECTED:<br>        rejected(_value)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="（五）零碎知识"><a href="#（五）零碎知识" class="headerlink" title="（五）零碎知识"></a><span id="jumpe"><strong>（五）零碎知识</strong></span></h1><h3 id="Promise类的all方法"><a href="#Promise类的all方法" class="headerlink" title="Promise类的all方法"></a><strong>Promise类的all方法</strong></h3><ul><li>Promise类的all方法可以并行执行多个异步处理。</li><li>Promise.all方法以一个<strong>Promise对象数组</strong>作为参数，并创建一个当所有执行结果都成功时返回肯定结果的Promise对象。在该对象的then方法中可以得到一个结果数组result，无论该对象的肯定结果为何，该结果数组与传入的Promise对象数组顺序保持一致。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域</title>
    <link href="/2020/05/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2020/05/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-同源策略及其限制内容"><a href="#1-同源策略及其限制内容" class="headerlink" title="1. 同源策略及其限制内容"></a><a href="#jumpa"><strong>1. 同源策略及其限制内容</strong></a></h3><ul><li><a href="#jumpa1"><strong>同源策略</strong></a></li><li><a href="#jumpa2"><strong>同源策略限制</strong></a></li></ul><h3 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2. 跨域"></a><a href="#jumpb"><strong>2. 跨域</strong></a></h3><ul><li><a href="#jumpb1"><strong>什么是跨域</strong></a></li><li><a href="#jumpb2"><strong>跨域的常见场景</strong></a></li></ul><h3 id="3-跨域解决方案"><a href="#3-跨域解决方案" class="headerlink" title="3. 跨域解决方案"></a><a href="#jumpc"><strong>3. 跨域解决方案</strong></a></h3><ul><li><a href="#jumpc1"><strong>JSONP 跨域</strong></a></li><li><a href="#jumpc2"><strong>CORS 跨域资源共享</strong></a></li><li><a href="#jumpc3"><strong>Node 中间件代理(两次跨域)</strong></a></li><li><a href="#jumpc4"><strong>nginx 代理跨域</strong></a></li><li><a href="#jumpc5"><strong>websocket</strong></a></li><li><a href="#jumpc6"><strong>postMessage 跨域</strong></a></li><li><a href="#jumpc7"><strong>window.name + iframe 跨域</strong></a></li><li><a href="#jumpc8"><strong>location.hash + iframe 跨域</strong></a></li><li><a href="#jumpc9"><strong>document.domain + iframe 跨域</strong></a></li><li><a href="#jumpc10"><strong>总结</strong></a></li></ul><h1 id="（一）同源策略及其限制内容"><a href="#（一）同源策略及其限制内容" class="headerlink" title="（一）同源策略及其限制内容"></a><span id="jumpa"><strong>（一）同源策略及其限制内容</strong></span></h1><h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1. 同源策略"></a><span id="jumpa1"><strong>1. 同源策略</strong></span></h3><p>同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1588311963814.png" alt="1588311963814"></p><h3 id="2-同源策略限制"><a href="#2-同源策略限制" class="headerlink" title="2. 同源策略限制"></a><span id="jumpa2"><strong>2. 同源策略限制</strong></span></h3><ul><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 AJAX 请求</li></ul><p>但是有三个标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h1 id="（二）跨域"><a href="#（二）跨域" class="headerlink" title="（二）跨域"></a><span id="jumpb"><strong>（二）跨域</strong></span></h1><h3 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1. 什么是跨域？"></a><span id="jumpb1"><strong>1. 什么是跨域？</strong></span></h3><p>跨域出于浏览器的同源策略限制。当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。</p><h3 id="2-跨域的常见场景"><a href="#2-跨域的常见场景" class="headerlink" title="2. 跨域的常见场景"></a><span id="jumpb2"><strong>2. 跨域的常见场景</strong></span></h3><figure class="highlight dts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs dts">URL                      说明       是否允许通信<br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/a.js</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/b.js     同一域名下   允许</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/lab/a.js</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/script/b.js 同一域名下不同文件夹 允许</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com:8000/a.js</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/b.js     同一域名，不同端口  不允许</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/a.js</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//www.a.com/b.js 同一域名，不同协议 不允许</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/a.js</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//70.32.92.74/b.js 域名和域名对应ip 不允许</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/a.js</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/a.js</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.cnblogs.com/a.js</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.a.com/b.js 不同域名 不允许</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><p>如果是协议和端口造成的跨域问题“前台”是无能为力的。</p></li><li><p>在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</p></li></ul><h1 id="（三）跨域解决方案"><a href="#（三）跨域解决方案" class="headerlink" title="（三）跨域解决方案"></a><span id="jumpc">（三）<strong>跨域解决方案</strong></span></h1><ul><li><code>jsonp</code> 跨域</li><li><code>document.domain + iframe</code> 跨域</li><li><code>location.hash + iframe</code> 跨域</li><li><code>window.name + iframe</code> 跨域</li><li><code>postMessage</code> 跨域</li><li><code>CORS</code> 跨域资源共享</li><li><code>nginx</code> 代理跨域</li><li><code>nodejs</code> 中间件代理跨域</li><li><code>WebSocket</code> 协议跨域</li></ul><h3 id="1-jsonp跨域"><a href="#1-jsonp跨域" class="headerlink" title="1. jsonp跨域"></a><span id="jumpc1"><strong>1. jsonp跨域</strong></span></h3><h5 id="（1）原理："><a href="#（1）原理：" class="headerlink" title="（1）原理："></a><strong>（1）原理</strong>：</h5><p>在页面上直接发起一个跨域的ajax请求是不可以的，但是在页面通过script标签引入的js是不受同源策略的限制的，就像你可以在自己的页面上使用<code>&lt;img src=&quot;&quot;&gt; </code>标签来随意显示某个域上的图片一样。（  原理：利用了src不受同源策略的影响 ，可以访问其他页面的数据）</p><p> JSONP <strong>利用 <code>&lt;script&gt; </code>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong>JSONP的一个要点就是允许用户传递一个<code>callback</code> 或者开始就定义一个回调方法，参数给服务端，然后服务端返回数据时会将这个<code>callback</code> 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p><h5 id="（2）实现流程："><a href="#（2）实现流程：" class="headerlink" title="（2）实现流程："></a><strong>（2）实现流程</strong>：</h5><ul><li>声明一个回调函数，其函数名(如show)当做参数值，传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><h5 id="（3）优缺点："><a href="#（3）优缺点：" class="headerlink" title="（3）优缺点："></a><strong>（3）优缺点</strong>：</h5><ul><li>优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</li><li><strong>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></li></ul><h5 id="（4）例子："><a href="#（4）例子：" class="headerlink" title="（4）例子："></a><strong>（4）例子：</strong></h5><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.html</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)<br>    <span class="hljs-built_in">window</span>[callback] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<br>      resolve(data)<br>      <span class="hljs-built_in">document</span>.body.removeChild(script)<br>    &#125;<br>    params = &#123; ...params, callback &#125; <span class="hljs-comment">// wd=b&amp;callback=show</span><br>    <span class="hljs-keyword">let</span> arrs = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      arrs.push(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>)<br>    &#125;<br>    script.src = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;arrs.join(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span><br>    <span class="hljs-built_in">document</span>.body.appendChild(script)<br>  &#125;)<br>&#125;<br>jsonp(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/say&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">wd</span>: <span class="hljs-string">&#x27;Iloveyou&#x27;</span> &#125;,<br>  <span class="hljs-attr">callback</span>: <span class="hljs-string">&#x27;show&#x27;</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show(&#39;我不爱你&#39;)</code>，最后会运行show()这个函数，打印出’我不爱你’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = express()<br>app.get(<span class="hljs-string">&#x27;/say&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> &#123; wd, callback &#125; = req.query<br>  <span class="hljs-built_in">console</span>.log(wd) <span class="hljs-comment">// Iloveyou</span><br>  <span class="hljs-built_in">console</span>.log(callback) <span class="hljs-comment">// show</span><br>  res.end(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;我不爱你&#x27;)`</span>)<br>&#125;)<br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p><strong>jQuery的jsonp形式</strong></p><p>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">$.ajax(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://crossdomain.com/jsonServerResponse&quot;</span>,<br><span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;jsonp&quot;</span>,<br><span class="hljs-attr">type</span>:<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-comment">//可以省略</span><br><span class="hljs-attr">jsonpCallback</span>:<span class="hljs-string">&quot;show&quot;</span>,<span class="hljs-comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br><span class="hljs-attr">jsonp</span>:<span class="hljs-string">&quot;callback&quot;</span>,<span class="hljs-comment">//-&gt;把传递函数名的那个形参callback，可省略</span><br><span class="hljs-attr">success</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(data);&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>更多例子可查看</strong>：<a href="https://blog.csdn.net/DFF1993/article/details/79925874">JSONP跨域请求原理及优缺点</a></p><h3 id="2-跨域资源共享（CORS）"><a href="#2-跨域资源共享（CORS）" class="headerlink" title="2. 跨域资源共享（CORS）"></a><span id="jumpc2"><strong>2. 跨域资源共享（CORS）</strong></span></h3><p><strong>CORS 需要浏览器和后端同时支持。</strong></p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h5 id="（1）普通跨域"><a href="#（1）普通跨域" class="headerlink" title="（1）普通跨域"></a><strong>（1）普通跨域</strong></h5><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。只要同时满足以下两大条件，就属于简单请求</p><p><strong>条件1</strong>：使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p><strong>条件2</strong>：Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><h5 id="（2）复杂请求："><a href="#（2）复杂请求：" class="headerlink" title="（2）复杂请求："></a><strong>（2）复杂请求</strong>：</h5><p>不符合以上条件的请求就肯定是复杂请求了。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p><p><strong>复杂跨域的例子</strong>：</p><p>下面代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.html</span><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;name=xiamen&#x27;</span> <span class="hljs-comment">// cookie不能跨域</span><br>xhr.withCredentials = <span class="hljs-literal">true</span> <span class="hljs-comment">// 前端设置是否带cookie</span><br>xhr.open(<span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="hljs-literal">true</span>)<br>xhr.setRequestHeader(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;xiamen&#x27;</span>)<br>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((xhr.status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">300</span>) || xhr.status === <span class="hljs-number">304</span>) &#123;<br>      <span class="hljs-built_in">console</span>.log(xhr.response)<br>      <span class="hljs-comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span><br>      <span class="hljs-built_in">console</span>.log(xhr.getResponseHeader(<span class="hljs-string">&#x27;name&#x27;</span>))<br>    &#125;<br>  &#125;<br>&#125;<br>xhr.send()<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//server1.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">let</span> app = express();<br>app.use(express.static(__dirname));<br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//server2.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = express()<br><span class="hljs-keyword">let</span> whitList = [<span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>] <span class="hljs-comment">//设置白名单</span><br>app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> origin = req.headers.origin<br>  <span class="hljs-keyword">if</span> (whitList.includes(origin)) &#123;<br>    <span class="hljs-comment">// 设置哪个源可以访问我</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)<br>    <span class="hljs-comment">// 允许携带哪个头访问我</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br>    <span class="hljs-comment">// 允许哪个方法访问我</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>)<br>    <span class="hljs-comment">// 允许携带cookie</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-literal">true</span>)<br>    <span class="hljs-comment">// 预检的存活时间</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="hljs-number">6</span>)<br>    <span class="hljs-comment">// 允许返回的头</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>      res.end() <span class="hljs-comment">// OPTIONS请求不做任何处理</span><br>    &#125;<br>  &#125;<br>  next()<br>&#125;)<br>app.put(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(req.headers)<br>  res.setHeader(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jw&#x27;</span>) <span class="hljs-comment">//返回一个响应头，后台需设置</span><br>  res.end(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(req.headers)<br>  res.end(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>&#125;)<br>app.use(express.static(__dirname))<br>app.listen(<span class="hljs-number">4000</span>)<br></code></pre></td></tr></table></figure><h3 id="3-Node中间件代理-两次跨域"><a href="#3-Node中间件代理-两次跨域" class="headerlink" title="3.  Node中间件代理(两次跨域)"></a><span id="jumpc3"><strong>3.  Node中间件代理(两次跨域)</strong></span></h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong><br>代理服务器，需要做以下几个步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1588316115701.png" alt="1588316115701"></p><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html">// index.html(http://127.0.0.1:5500)<br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      $.ajax(&#123;</span><br><span class="javascript">        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="javascript">        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiamen&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;,</span><br><span class="javascript">        <span class="hljs-attr">contentType</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><br><span class="javascript">        <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">// &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span></span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(msg)</span><br><span class="javascript">        &#125;</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">     </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server1.js 代理服务器(http://localhost:3000)</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 第一步：接受客户端请求</span><br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span><br>  response.writeHead(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="hljs-string">&#x27;Content-Type&#x27;</span><br>  &#125;)<br>  <span class="hljs-comment">// 第二步：将请求转发给服务器</span><br>  <span class="hljs-keyword">const</span> proxyRequest = http<br>    .request(<br>      &#123;<br>        <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">4000</span>,<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-attr">method</span>: request.method,<br>        <span class="hljs-attr">headers</span>: request.headers<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">serverResponse</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 第三步：收到服务器的响应</span><br>        <span class="hljs-keyword">var</span> body = <span class="hljs-string">&#x27;&#x27;</span><br>        serverResponse.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> &#123;<br>          body += chunk<br>        &#125;)<br>        serverResponse.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The data is &#x27;</span> + body)<br>          <span class="hljs-comment">// 第四步：将响应结果转发给浏览器</span><br>          response.end(body)<br>        &#125;)<br>      &#125;<br>    )<br>    .end()<br>&#125;)<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The proxyServer is running at http://localhost:3000&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server2.js(http://localhost:4000)</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;fontend&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (request.url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    response.end(<span class="hljs-built_in">JSON</span>.stringify(data))<br>  &#125;<br>&#125;)<br>server.listen(<span class="hljs-number">4000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The server is running at http://localhost:4000&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</code></p><h3 id="4-nginx代理跨域"><a href="#4-nginx代理跨域" class="headerlink" title="4. nginx代理跨域"></a><span id="jumpc4"><strong>4. nginx代理跨域</strong></span></h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>先下载<a href="http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// proxy服务器</span><br>server &#123;<br>    listen       <span class="hljs-number">81</span>;<br>    server_name  www.domain1.com;<br>    location / &#123;<br>        proxy_pass   http:<span class="hljs-comment">//www.domain2.com:8080;  #反向代理</span><br>        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名<br>        index  index.html index.htm;<br><br>        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用<br>        add_header Access-Control-Allow-Origin http:<span class="hljs-comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br>        add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后通过命令行<code>nginx -s reload</code>启动nginx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.html</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span><br>xhr.withCredentials = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 访问nginx中的代理服务器</span><br>xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.send();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> server = http.createServer();<br><span class="hljs-keyword">var</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br>server.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> params = qs.parse(req.url.substring(<span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 向前台写cookie</span><br>    res.writeHead(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;Set-Cookie&#x27;</span>: <span class="hljs-string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="hljs-comment">// HttpOnly:脚本无法读取</span><br>    &#125;);<br>    res.write(<span class="hljs-built_in">JSON</span>.stringify(params));<br>    res.end();<br>&#125;);<br>server.listen(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="5-websocket"><a href="#5-websocket" class="headerlink" title="5. websocket"></a><span id="jumpc5"><strong>5. websocket</strong></span></h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p><p>WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">// socket.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&#x27;ws://localhost:3000&#x27;</span>);</span><br><span class="javascript">    socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      socket.send(<span class="hljs-string">&#x27;我爱你&#x27;</span>);<span class="hljs-comment">//向服务器发送数据</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">    socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(e.data);<span class="hljs-comment">//接收服务器返回的数据</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">let</span> app = express();<br><span class="hljs-keyword">let</span> WebSocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>);<span class="hljs-comment">//记得安装ws</span><br><span class="hljs-keyword">let</span> wss = <span class="hljs-keyword">new</span> WebSocket.Server(&#123;<span class="hljs-attr">port</span>:<span class="hljs-number">3000</span>&#125;);<br>wss.on(<span class="hljs-string">&#x27;connection&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ws</span>) </span>&#123;<br>  ws.on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>    ws.send(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="6-postMessage跨域"><a href="#6-postMessage跨域" class="headerlink" title="6. postMessage跨域"></a><span id="jumpc6"><strong>6. postMessage跨域</strong></span></h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">otherWindow.postMessage(message, targetOrigin, [transfer]);<br></code></pre></td></tr></table></figure><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p><strong>例子</strong>：</p><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.html</span><br>  &lt;iframe src=<span class="hljs-string">&quot;http://localhost:4000/b.html&quot;</span> frameborder=<span class="hljs-string">&quot;0&quot;</span> id=<span class="hljs-string">&quot;frame&quot;</span> onload=<span class="hljs-string">&quot;load()&quot;</span>&gt;&lt;<span class="hljs-regexp">/iframe&gt; /</span><span class="hljs-regexp">/等它加载完触发一个事件</span><br><span class="hljs-regexp">  /</span><span class="hljs-regexp">/内嵌在http:/</span><span class="hljs-regexp">/localhost:3000/</span>a.html<br>    &lt;script&gt;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;frame&#x27;</span>)<br>        frame.contentWindow.postMessage(<span class="hljs-string">&#x27;我爱你&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span>) <span class="hljs-comment">//发送数据</span><br>        <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-comment">//接受返回数据</span><br>          <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">//我不爱你</span><br>        &#125;<br>      &#125;<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// b.html</span><br>  <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">//我爱你</span><br>    e.source.postMessage(<span class="hljs-string">&#x27;我不爱你&#x27;</span>, e.origin)<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="7-window-name-iframe跨域"><a href="#7-window-name-iframe跨域" class="headerlink" title="7. window.name + iframe跨域"></a><span id="jumpc7"><strong>7. window.name + iframe跨域</strong></span></h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.html(http://localhost:3000/b.html)</span><br> &lt;iframe src=<span class="hljs-string">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class="hljs-string">&quot;0&quot;</span> onload=<span class="hljs-string">&quot;load()&quot;</span> id=<span class="hljs-string">&quot;iframe&quot;</span>&gt;&lt;/iframe&gt;<br> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">   <span class="hljs-keyword">let</span> first = <span class="hljs-literal">true</span></span></span><br><span class="javascript"><span class="xml">   <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="javascript"><span class="xml">   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">     <span class="hljs-keyword">if</span>(first)&#123;</span></span><br><span class="javascript"><span class="xml">     <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-keyword">let</span> iframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">       iframe.src = <span class="hljs-string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span></span><br><span class="javascript"><span class="xml">       first = <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">     &#125;<span class="hljs-keyword">else</span>&#123;</span></span><br><span class="javascript"><span class="xml">     <span class="hljs-comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="javascript"><span class="xml">       <span class="hljs-built_in">console</span>.log(iframe.contentWindow.name);</span></span><br><span class="javascript"><span class="xml">     &#125;</span></span><br><span class="javascript"><span class="xml">   &#125;</span></span><br><span class="javascript"><span class="xml"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>b.html为中间代理页，与a.html同域，内容为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">// c.html(http://localhost:4000/c.html)<br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">   <span class="hljs-built_in">window</span>.name = <span class="hljs-string">&#x27;我不爱你&#x27;</span>  </span><br><span class="javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe跨域"><a href="#8-location-hash-iframe跨域" class="headerlink" title="8.  location.hash + iframe跨域"></a><span id="jumpc8"><strong>8.  location.hash + iframe跨域</strong></span></h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。<br>同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">// a.html<br>  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//检测hash的变化</span></span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(location.hash);</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">// b.html<br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.parent.parent.location.hash = location.hash </span><br><span class="javascript">    <span class="hljs-comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// c.html</span><br> <span class="hljs-built_in">console</span>.log(location.hash);<br>  <span class="hljs-keyword">let</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>  iframe.src = <span class="hljs-string">&#x27;http://localhost:3000/b.html#idontloveyou&#x27;</span>;<br>  <span class="hljs-built_in">document</span>.body.appendChild(iframe);<br></code></pre></td></tr></table></figure><h3 id="9-document-domain-iframe跨域"><a href="#9-document-domain-iframe跨域" class="headerlink" title=" 9 document.domain + iframe跨域"></a><span id="jumpc9"> <strong>9 document.domain + iframe跨域</strong></span></h3><p>此方案仅限主域相同，子域不同的跨域应用场景。<strong>比如 a.test.com 和 b.test.com 适用于该方式</strong>。</p><p>只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">// a.html<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> helloa<br>  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(frame.contentWindow.a);</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">// b.html<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   hellob<br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">     <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><br><span class="javascript">     <span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;</span><br><span class="javascript">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a><span id="jumpc10"><strong>10. 总结</strong></span></h3><ul><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ul><p><strong>本文的内容来自于</strong>：</p><p><a href="https://segmentfault.com/a/1190000018017118">九种跨域方式实现原理（完整版）</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS</title>
    <link href="/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTPS/"/>
    <url>/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h3 id="1-HTTP基本原理"><a href="#1-HTTP基本原理" class="headerlink" title="1. HTTP基本原理"></a><a href="#jumpa"><strong>1. HTTP基本原理</strong></a></h3><ul><li><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><a href="#jump1"><strong>基本概念</strong></a></h5></li><li><h5 id="HTTPS-优缺点"><a href="#HTTPS-优缺点" class="headerlink" title="HTTPS 优缺点"></a><a href="#jump2"><strong>HTTPS 优缺点</strong></a></h5></li></ul><h3 id="2-加密"><a href="#2-加密" class="headerlink" title="2. 加密"></a><a href="#jumpb"><strong>2. 加密</strong></a></h3><ul><li><h5 id="共享密钥加密"><a href="#共享密钥加密" class="headerlink" title="共享密钥加密"></a><a href="#jump3"><strong>共享密钥加密</strong></a></h5></li><li><h5 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a><a href="#jump4"><strong>公开密钥加密</strong></a></h5></li><li><h5 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a><a href="#jump5"><strong>HTTPS采用混合加密机制</strong></a></h5></li></ul><h3 id="3-证书"><a href="#3-证书" class="headerlink" title="3. 证书"></a><a href="#jumpc"><strong>3. 证书</strong></a></h3><ul><li><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a><a href="#jump6"><strong>数字证书</strong></a></h5></li><li><h5 id="EV-SSL-证书"><a href="#EV-SSL-证书" class="headerlink" title="EV SSL 证书"></a><a href="#jump7"><strong>EV SSL 证书</strong></a></h5></li><li><h5 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a><a href="#jump8"><strong>客户端证书</strong></a></h5></li><li><h5 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a><a href="#jump9"><strong>自签名证书</strong></a></h5></li></ul><h3 id="4-HTTPS的安全通信机制"><a href="#4-HTTPS的安全通信机制" class="headerlink" title="4. HTTPS的安全通信机制"></a><a href="#jumpd"><strong>4. HTTPS的安全通信机制</strong></a></h3><ul><li><h5 id="HTTPS-通信过程"><a href="#HTTPS-通信过程" class="headerlink" title="HTTPS 通信过程"></a><a href="#jump10"><strong>HTTPS 通信过程</strong></a></h5><ul><li><a href="#jump10"><strong>具体版 通信过程</strong></a></li><li><a href="#jump11"><strong>简要版 通信过程</strong></a></li><li><a href="#jump12"><strong>不一直使用 HTTPS的原因</strong></a></li></ul></li><li><h5 id="SSL-和-TLS"><a href="#SSL-和-TLS" class="headerlink" title="SSL 和 TLS"></a><a href="#jump13"><strong>SSL 和 TLS</strong></a></h5><ul><li><a href="#jump13"><strong>SSL握手过程</strong></a></li><li><a href="#jump14"><strong>SSL速度慢的原因</strong></a></li></ul></li></ul><h3 id="5-HTTP-和-HTTPS的区别"><a href="#5-HTTP-和-HTTPS的区别" class="headerlink" title="5. HTTP 和 HTTPS的区别"></a><a href="#jumpe"><strong>5. HTTP 和 HTTPS的区别</strong></a></h3><h1 id="（一）HTTP基本原理"><a href="#（一）HTTP基本原理" class="headerlink" title="（一）HTTP基本原理"></a><span id="jumpa"><strong>（一）HTTP基本原理</strong></span></h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><span id="jump1"><strong>1. 基本概念</strong></span></h3><p><strong>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</strong></p><p>即：HTTP 加上加密处理和认证以及完整性保护后即是HTTPS<br><img src="https://img-blog.csdnimg.cn/20200501105210851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL协议这层外壳的 HTTP。HTTPS的SSL加密是在传输层实现的。在采用 SSL后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。<br><img src="https://img-blog.csdnimg.cn/20200501105239227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是当今世界上应用最为广泛的网络安全。SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p><h3 id="2-HTTPS优缺点"><a href="#2-HTTPS优缺点" class="headerlink" title="2. HTTPS优缺点"></a><span id="jump2"><strong>2. HTTPS优缺点</strong></span></h3><p><strong>优点</strong>：</p><ul><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li></ul><p><strong>缺点</strong>：</p><ul><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ul><h1 id="（二）加密"><a href="#（二）加密" class="headerlink" title="（二）加密"></a><span id="jumpb"><strong>（二）加密</strong></span></h1><p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p><h3 id="1-共享密钥加密"><a href="#1-共享密钥加密" class="headerlink" title="1. 共享密钥加密"></a><span id="jump3"><strong>1. 共享密钥加密</strong></span></h3><p>共享密钥加密：又叫做 私钥加密 或 对称加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密。<br><img src="https://img-blog.csdnimg.cn/20200501105329323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>共享密钥加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。</p><p><strong>共享密钥加密过程</strong></p><ul><li>加密过程：<strong>明文 + 加密算法 + 私钥 =&gt; 密文</strong></li><li>解密过程：<strong>密文 + 解密算法 + 私钥 =&gt; 明文</strong></li></ul><p>由于共享密钥加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以共享密钥加密的缺点是密钥安全管理困难。以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。<br><img src="https://img-blog.csdnimg.cn/20200501105403543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>于是引出下面要说的 <strong>公开密钥加密</strong>，公开密钥加密方式很好地解决了共享密钥加密的困难。</p><h3 id="2-公开密钥加密"><a href="#2-公开密钥加密" class="headerlink" title="2. 公开密钥加密"></a><span id="jump4"><strong>2. 公开密钥加密</strong></span></h3><p>公开密钥加密：也叫做公钥加密 或 非对称加密。非对称加密与对称加密相比，其安全性更好。</p><p>非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</p><p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实。</p><p><strong>公开密钥加密过程</strong>：</p><ul><li><p>被公钥加密过的密文只能被私钥解密，过程如下：</p><p><strong>明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文</strong></p></li><li><p>被私钥加密过的密文只能被公钥解密，过程如下：<br><strong>明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文</strong></p></li></ul><p>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。<br>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br><img src="https://img-blog.csdnimg.cn/20200501105447466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-HTTPS采用混合加密机制"><a href="#3-HTTPS采用混合加密机制" class="headerlink" title="3. HTTPS采用混合加密机制"></a><span id="jump5"><strong>3. HTTPS采用混合加密机制</strong></span></h3><p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方。</p><p><strong>混合加密机制</strong>：<br><img src="https://img-blog.csdnimg.cn/20200501105511140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。</p><h1 id="（三）证书"><a href="#（三）证书" class="headerlink" title="（三）证书"></a><span id="jumpc"><strong>（三）证书</strong></span></h1><h3 id="1-证明公开密钥正确性的数字证书"><a href="#1-证明公开密钥正确性的数字证书" class="headerlink" title="1. 证明公开密钥正确性的数字证书"></a><span id="jump6"><strong>1. 证明公开密钥正确性的数字证书</strong></span></h3><p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p><p>为了解决上述问题，可以使用由<strong>数字证书认证机构</strong>（CA，CertificateAuthority）和其相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p><p><strong>数字证书认证机构的业务流程</strong></p><ul><li><p>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。</p></li><li><p>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。</p></li><li><p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做<strong>数字证书</strong>或直接称为<strong>证书</strong>。</p></li><li><p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖。</p></li></ul><p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p><p><img src="https://img-blog.csdnimg.cn/20200501105601584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-可证明组织真实性的-EV-SSL-证书"><a href="#2-可证明组织真实性的-EV-SSL-证书" class="headerlink" title="2.  可证明组织真实性的 EV SSL 证书"></a><span id="jump7"><strong>2.  可证明组织真实性的 EV SSL 证书</strong><span></h3><p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL证书（Extended Validation SSLCertificate）</p><p>EV SSL证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的Web 网站能够获得更高的认可度。</p><p>持有 EV SSL证书的 Web 网站的浏览器地址栏处的背景色是绿色的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL证书中记录的组织名称以及颁发证书的认证机构的名称。</p><h3 id="3-用以确认客户端的客户端证书"><a href="#3-用以确认客户端的客户端证书" class="headerlink" title="3. 用以确认客户端的客户端证书"></a><span id="jump8"><strong>3. 用以确认客户端的客户端证书</strong></span></h3><p>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。但客户端证书仍存在几处问题点。其中的一个问题点是证书的获取及发布。想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费购买的，且每张证书对应到每位用户也就意味着需支付和用户数对等的费用。另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战。现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。</p><p>客户端证书存在的另一个问题点是，客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。</p><h3 id="4-由自认证机构颁发的证书称为自签名证书"><a href="#4-由自认证机构颁发的证书称为自签名证书" class="headerlink" title="4. 由自认证机构颁发的证书称为自签名证书"></a><span id="jump9"><strong>4. 由自认证机构颁发的证书称为自签名证书</strong></span></h3><p>如果使用 OpenSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用，似乎没什么帮助。<br>独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。<br>浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</p><p>由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。自认证机构能够产生的作用顶多也就是自己对外宣称“我是○○”的这种程度。即使采用自签名证书，通过 SSL加密之后，可能偶尔还会看见通信处在安全状态的提示，可那也是有问题的。因为 就算加密通信，也不能排除正在和已经过伪装的假服务器保持通信。值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实</p><h1 id="（四）HTTPS的安全通信机制"><a href="#（四）HTTPS的安全通信机制" class="headerlink" title="（四）HTTPS的安全通信机制"></a><span id="jumpd"><strong>（四）HTTPS的安全通信机制</strong></span></h1><h3 id="1-HTTPS-通信过程"><a href="#1-HTTPS-通信过程" class="headerlink" title="1. HTTPS 通信过程"></a><span id="jump10"><strong>1. HTTPS 通信过程</strong></sapn></h3><p><img src="https://img-blog.csdnimg.cn/20200501105647289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="（1）具体通信过程："><a href="#（1）具体通信过程：" class="headerlink" title="（1）具体通信过程："></a><strong>（1）具体通信过程</strong>：</h5><ul><li>客户端通过发送 Client Hello 报文<strong>开始 SSL通信</strong>。报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li><li>服务器以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>之后服务器发送 Certificate 报文。报文中包含<strong>公开密钥证书</strong>。</li><li>最后服务器发送 Server Hello Done 报文通知客户端，<strong>最初阶段的 SSL握手协商部分结束</strong>。</li><li><strong>SSL第一次握手结束之后</strong>，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li><li>接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</li><li>客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>服务器发送 Change Cipher Spec 报文。</li><li>服务器发送 Finished 报文。</li><li>服务器和客户端的 Finished 报文交换完毕之后，<strong>SSL连接就算建立完成</strong>。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</li><li> 应用层协议通信，即发送 HTTP 响应。</li><li>最后由客户端断开连接。断开连接时，发送 close_notify 报文。</li></ul><p>上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><p>下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。<br><img src="https://img-blog.csdnimg.cn/20200501105722948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果上面的步骤记不住，那可以参考下面这种相对简要的HTTPS通信过程步骤：</p><h5 id="（2）简要通信过程："><a href="#（2）简要通信过程：" class="headerlink" title="（2）简要通信过程："></a><span id="jump11">（2）简要通信过程：</span></h5><ul><li><p>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></li><li><p>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p></li><li><p>客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。</p></li><li><p>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p></li><li><p>Web服务器利用自己的私钥解密出会话密钥。</p></li><li><p>Web服务器利用会话密钥加密与客户端之间的通信。</p></li></ul><h5 id="（3）不一直使用-HTTPS的原因"><a href="#（3）不一直使用-HTTPS的原因" class="headerlink" title="（3）不一直使用 HTTPS的原因"></a><span id="jump12">（3）不一直使用 HTTPS的原因</span></h5><p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。<br>因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。<br>特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。</p><h3 id="2-SSL-和-TLS"><a href="#2-SSL-和-TLS" class="headerlink" title="2. SSL 和 TLS"></a><span id="jump13"><strong>2. SSL 和 TLS</strong></span></h3><p>HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport LayerSecurity）这两个协议。</p><p>SSL技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF（InternetEngineering Task Force，Internet 工程任务组）的手中。<br>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL是以 SSL为原型开发的协议，有时会统一称该协议为 SSL。<br>由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了该协议版本。当前主流的版本是 SSL3.0 和 TLS1.0。</p><h5 id="（1）SSL握手："><a href="#（1）SSL握手：" class="headerlink" title="（1）SSL握手："></a><strong>（1）SSL握手</strong>：</h5><p>SSL握手过程其实已经包含在上面的HTTPS通信过程中了。下面就再单独说明其握手过程：</p><ul><li><p>客户端发送 Client Hello 报文<strong>开始 SSL通信</strong>。</p><p>报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p></li><li><p>服务器以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。</p></li><li><p>服务器发送 Certificate 报文。报文中包含<strong>公开密钥证书</strong>。</p></li><li><p>最后服务器发送 Server Hello Done 报文通知客户端。</p></li><li><p>客户端以 Client Key Exchange 报文作为回应。</p><p>报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p></li><li><p>客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p></li><li><p>客户端发送 Finished 报文。</p></li><li><p>服务器发送 Change Cipher Spec 报文。</p></li><li><p>服务器发送 Finished 报文。</p></li></ul><p><strong>SSL连接就算建立完成</strong>。</p><h5 id="（2）SSL速度慢的原因"><a href="#（2）SSL速度慢的原因" class="headerlink" title="（2）SSL速度慢的原因"></a><span id="jump14"><strong>（2）SSL速度慢的原因</strong></span></h5><p>HTTPS 也存在一些问题，那就是当使用 SSL时，它的处理速度会变慢。HTTPS 比 HTTP 要慢 2 到 100 倍。<br><img src="https://img-blog.csdnimg.cn/20200501105755854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>SSL的慢分两种</strong>：</p><ul><li>一种是通信慢。</li><li>另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。</li></ul><p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL通信，因此整体上处理通信量不可避免会增加。另一点是 SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。</p><p>因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL通信专用硬件，相对软件来讲，能够提高数倍 SSL的计算速度。仅在 SSL处理时发挥 SSL加速器的功效，以分担负</p><h2 id="（五）HTTP-和-HTTPS的区别"><a href="#（五）HTTP-和-HTTPS的区别" class="headerlink" title="（五）HTTP 和 HTTPS的区别"></a><span id="jumpe"><strong>（五）HTTP 和 HTTPS的区别</strong></span></h2><ul><li>HTTPS协议需要到ca申请证书，一般免费证书很少，需要交费。  </li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议， 要比HTTP协议安全。</li><li> HTTP和HTTPS使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 </li><li> HTTP的连接很简单,是无状态的 。 </li></ul><p><strong>注</strong>：此文为阅读《图解HTTP》第七章 后规划整理的学习笔记。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP/"/>
    <url>/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-HTTP原理"><a href="#1-HTTP原理" class="headerlink" title="1. HTTP原理"></a><a href="#jump1"><strong>1. HTTP原理</strong></a></h4><ul><li><p><a href="jump1"><strong>概念</strong></a></p></li><li><p><a href="#jumpa"><strong>HTTP过程</strong></a></p></li><li><p><a href="#jumpb"><strong>特点</strong></a></p></li></ul><h4 id="2-HTTP请求报文"><a href="#2-HTTP请求报文" class="headerlink" title="2. HTTP请求报文"></a><a href="#jump2"><strong>2. HTTP请求报文</strong></a></h4><ul><li><p><a href="#jumpc"><strong>请求报文结构</strong></a></p></li><li><p><a href="#jumpd"><strong>请求行</strong>（请求方法、URL、协议版本）</a></p><ul><li><a href="#jumpd"><strong>请求方法</strong></a></li><li><a href="#jumpabc"><strong>URL</strong></a></li><li><a href="#jump5"><strong>协议版本</strong></a></li></ul></li><li><p><a href="#jumpe"><strong>请求头</strong></a></p></li><li><p><strong>请求体</strong></p></li></ul><h4 id="3-HTTP响应报文"><a href="#3-HTTP响应报文" class="headerlink" title="3. HTTP响应报文"></a><a href="#jump3"><strong>3. HTTP响应报文</strong></a></h4><ul><li><p><a href="#jumpf"><strong>响应报文结构</strong></a></p></li><li><p><a href="#jumpg"><strong>响应行</strong>（版本协议、状态码及状态描述）</a></p><ul><li><a href="#jumpg"><strong>状态码及状态描述</strong></a></li></ul></li><li><p><a href="#jumph"><strong>响应头</strong></a></p></li><li><p><strong>响应体</strong></p></li></ul><h4 id="4-HTTP缓存（浏览器缓存机制）"><a href="#4-HTTP缓存（浏览器缓存机制）" class="headerlink" title="4. HTTP缓存（浏览器缓存机制）"></a><a href="#jump4"><strong>4. HTTP缓存（浏览器缓存机制）</strong></a></h4><ul><li><a href="https://blog.csdn.net/jutal_ljt/article/details/80021545"><strong>强缓存</strong></a></li><li><a href="https://blog.csdn.net/jutal_ljt/article/details/80021545"><strong>协商缓存</strong></a></li></ul><h4 id="5-不同版本HTTP"><a href="#5-不同版本HTTP" class="headerlink" title="5. 不同版本HTTP"></a><a href="#jump5"><strong>5. 不同版本HTTP</strong></a></h4><ul><li><p><a href="#jumpi"><strong>HTTP 0.9</strong></a></p></li><li><p><a href="#jumpj"><strong>HTTP 1.0</strong></a></p></li><li><p><a href="#jumpk"><strong>HTTP 1.1</strong></a></p></li><li><p><a href="#jumpl"><strong>HTTP 2.0</strong></a></p></li></ul><h1 id="（一）HTTP原理"><a href="#（一）HTTP原理" class="headerlink" title="（一）HTTP原理"></a><span id="jump1"><strong>（一）HTTP原理</strong></span></h1><p><strong>这部分学习并参考于</strong>：<a href="https://www.cnblogs.com/an-wen/p/11180076.html">HTTP协议超级详解</a></p><p>超文本传输协议（英文：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</p><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。</p><p>http协议是基于TCP/IP协议之上的应用层协议。</p><h3 id="1-HTTP-请求-响应的步骤："><a href="#1-HTTP-请求-响应的步骤：" class="headerlink" title="1. HTTP 请求/响应的步骤："></a><span id="jumpa"><strong>1. HTTP 请求/响应的步骤</strong>：</span></h3><p>HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求行（请求的方法、URL、协议版本）、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括响应行（协议的版本、状态码、状态信息）、响应头部和响应数据。</p><ul><li><p>客户端连接到Web服务器</p><p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。</p></li><li><p>发送HTTP请求</p><p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p></li><li><p>服务器接受请求并返回HTTP响应</p><p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p></li><li><p>释放连接TCP连接</p><p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析HTML内容</p></li></ul><h3 id="2-HTTP特点："><a href="#2-HTTP特点：" class="headerlink" title="2. HTTP特点："></a><span id="jumpb"><strong>2. HTTP特点</strong>：</span></h3><ul><li><p><strong>基于TCP/IP协议之上的应用层协议。</strong></p></li><li><p><strong>基于 请求-响应 的模式</strong></p><p>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应</p></li><li><p><strong>无状态保存</strong></p><p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。</p></li><li><p><strong>无连接</strong></p><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。</p><p>但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p></li></ul><p><a href="https://www.cnblogs.com/an-wen/p/11180076.html">HTTP请求行、请求头、请求体详解</a></p><h1 id="（二）HTTP请求报文"><a href="#（二）HTTP请求报文" class="headerlink" title="（二）HTTP请求报文"></a><span id="jump2"><strong>（二）HTTP请求报文</strong></span></h1><h3 id="1-请求报文结构"><a href="#1-请求报文结构" class="headerlink" title="1. 请求报文结构"></a><span id="jumpc"><strong>1. 请求报文结构</strong></span></h3><p>请求报文由<strong>请求行</strong>（请求方法、URL、协议版本）、<strong>请求头</strong>部和<strong>请求体</strong>（请求数据）组成。<br><img src="https://img-blog.csdnimg.cn/20200430200238746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>下面是一个实际的请求报文：<br><img src="https://img-blog.csdnimg.cn/20200430200224751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>下面分别展开说明请求行、请求头、请求体。</p><h3 id="2-请求行"><a href="#2-请求行" class="headerlink" title="2. 请求行"></a><span id="jumpd"><strong>2. 请求行</strong></span></h3><p>请求行由三部分组成：<strong>请求方法</strong>，<strong>请求URL</strong>（不包括域名），<strong>HTTP协议版本</strong></p><h5 id="（1）请求方法："><a href="#（1）请求方法：" class="headerlink" title="（1）请求方法："></a><strong>（1）请求方法</strong>：</h5><p>请求方法比较多：<strong>GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</strong></p><p>其中：</p><ul><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</li></ul><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">从指定的资源请求数据</td></tr><tr><td align="center">HEAD</td><td align="center">向服务器请求与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</td></tr><tr><td align="center">POST</td><td align="center">向指定的资源提交要被处理的数据（例如提交表单或者上传文件）</td></tr><tr><td align="center">PUT</td><td align="center">向指定资源位置上传其最新内容</td></tr><tr><td align="center">DELETE</td><td align="center">请求服务器删除Request-URL所标识的资源</td></tr><tr><td align="center">CONNECT</td><td align="center">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="center">OPTIONS</td><td align="center">用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。允许客户端查看服务器的性能。</td></tr><tr><td align="center">TRACE</td><td align="center">回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>注意：</p><ul><li><p>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</p></li><li><p>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源<em>。</em></p></li></ul><p><a href="http://tools.jb51.net/table/http_request_method">HTTP请求方法对照表</a></p><p><strong>关于请求方法的常见面试题</strong></p><ul><li><p><strong>HEAD</strong></p><p>HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。</p><p>HEAD请求主要有以下特点：</p><ul><li><p>只请求资源的首部；</p></li><li><p>检查超链接的有效性；</p></li><li><p>检查网页是否被修改；</p></li><li><p>多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等</p></li></ul></li><li><p><strong>get和post的区别</strong></p><ul><li><p>传参方式</p><p>get传参方式是通过地址栏URL传递，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。是可以直接在url中看到get传递的参数。</p><p>post传参方式是将从参数存放在HTTP的包体内，在url看不到它传递的参数。</p></li><li><p>传输数据大小</p><p>get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制。</p></li><li><p>编码方式</p><p>　get请求只URL编码，post支持多种编码方式</p></li><li><p>字符类型</p><p>get只支持ASCII字符，post没有字符类型限制</p></li><li><p>历史记录</p><p>get请求的记录会留在历史记录中，post请求不会留在历史记录</p></li><li><p>缓存</p><p>get请求可以被缓存，post不可以被缓存</p><p>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</p></li><li><p>GET和POST的底层也是TCP/IP，GET/POST都是TCP链接。</p><p>而GET产生一个TCP数据包；POST产生两个TCP数据包。</p></li><li><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p></li><li><p><strong>终极区别</strong>：幂等性区别</p><p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p><p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。</p></li></ul></li><li><p><strong>options</strong></p><p><a href="https://www.cnblogs.com/mamimi/p/10602722.html">options</a></p></li></ul><h5 id="（2）请求URL"><a href="#（2）请求URL" class="headerlink" title="（2）请求URL"></a><span id="jumpabc">（2）请求URL</span></h5><p><strong>这部分学习并摘自</strong>：<a href="https://www.cnblogs.com/jaci/p/11470688.html">统一资源定位符URL和统一资源标识符URI</a></p><p>先说说<strong>URI</strong>（Uniform Resource Identifiers）：统一资源标识符。</p><p>HTTP使用统一资源标识符来传输数据和建立连接。URL是一种特殊类型的URI，包含用于查找某个资源的足够信息。</p><p><strong>URL</strong>（Uniform Resource Locator）：统一资源定位符。是互联网上用来标识某一处资源的地址。</p><p>以下URL为例子做介绍：</p><p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p><p>从上面的URL看出，一个完整的URL包含这7部分：</p><ul><li><p>协议部分：“http:”这里使用HTTP协议，协议后面的“//”为分隔符</p></li><li><p>域名部分：“<a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name">www.aspxfans.com</a>”，URL中也可以使用IP地址作为域名</p></li><li><p>端口部分（非必要）：“8080”，在域名之后，使用“:”作为分隔符，若省略端口则会采用默认端口</p></li><li><p>虚拟目录部分（非必要）：“<a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name">/news/</a>”域名后的第一个“/”到最后一个“/”中间是虚拟目录部分</p></li><li><p>文件名部分（非必要）：“<a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name">index.asp</a>”，从域名后的最后一个“/”到“?”之间是文件名部分；如果没有“?”，那就是从域名后的最后一个“/”到“#”是文件名部分</p></li><li><p>锚部分（非必要）：“name”，从“#”到最后都是锚部分</p></li><li><p>参数部分：也叫搜索部分、查询部分，“<a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name">boardID=5&amp;ID=24618&amp;page=1</a>”，从“?”到“#”之间是参数部分，可有多个参数，参数之间用“&amp;”作为分隔符</p></li></ul><h5 id="（3）HTTP协议版本"><a href="#（3）HTTP协议版本" class="headerlink" title="（3）HTTP协议版本"></a>（3）HTTP协议版本</h5><p>HTTP版本协议主要有HTTP1.0、HTTP1.1、HTTP2.0。</p><p>笔者在文章下面会有一部分专门写这几个版本以及HTTPS的区别，这里先不多写。</p><h3 id="3-HTTP请求头"><a href="#3-HTTP请求头" class="headerlink" title="3. HTTP请求头"></a><span id="jumpe"><strong>3. HTTP请求头</strong></span></h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p><table><thead><tr><th align="left">Header</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">指定客户端能够接受的响应内容类型</td><td align="left">Accept: text/plain, text/html</td></tr><tr><td align="left">Accept-Charset</td><td align="left">浏览器可以接受的字符编码集。</td><td align="left">Accept-Charset: iso-8859-5</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td align="left">Accept-Encoding: compress, gzip</td></tr><tr><td align="left">Accept-Language</td><td align="left">浏览器可接受的语言</td><td align="left">Accept-Language: en,zh</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">可以请求网页实体的一个或者多个子范围字段</td><td align="left">Accept-Ranges: bytes</td></tr><tr><td align="left">Authorization</td><td align="left">HTTP授权的授权证书</td><td align="left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td align="left">Cache-Control</td><td align="left">指定请求和响应遵循的缓存机制</td><td align="left">Cache-Control: no-cache</td></tr><tr><td align="left">Connection</td><td align="left">表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td align="left">Connection: close</td></tr><tr><td align="left">Cookie</td><td align="left">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><td align="left">Cookie: $Version=1; Skin=new;</td></tr><tr><td align="left">Content-Length</td><td align="left">请求的内容长度</td><td align="left">Content-Length: 348</td></tr><tr><td align="left">Content-Type</td><td align="left">请求的与实体对应的MIME信息</td><td align="left">Content-Type: application/x-www-form-urlencoded</td></tr><tr><td align="left">Date</td><td align="left">请求发送的日期和时间</td><td align="left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td align="left">Expect</td><td align="left">请求的特定的服务器行为</td><td align="left">Expect: 100-continue</td></tr><tr><td align="left">From</td><td align="left">发出请求的用户的Email</td><td align="left">From: <a href="mailto:&#x75;&#115;&#101;&#114;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#x75;&#115;&#101;&#114;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></td></tr><tr><td align="left">Host</td><td align="left">指定请求的服务器的域名和端口号</td><td align="left">Host: <a href="http://www.zcmhi.com/">www.zcmhi.com</a></td></tr><tr><td align="left">If-Match</td><td align="left">只有请求内容与实体相匹配才有效</td><td align="left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><td align="left">If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td align="left">If-None-Match</td><td align="left">如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td align="left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">If-Range</td><td align="left">如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td align="left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">If-Unmodified-Since</td><td align="left">只在实体在指定时间之后未被修改才请求成功</td><td align="left">If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td align="left">Max-Forwards</td><td align="left">限制信息通过代理和网关传送的时间</td><td align="left">Max-Forwards: 10</td></tr><tr><td align="left">Pragma</td><td align="left">用来包含实现特定的指令</td><td align="left">Pragma: no-cache</td></tr><tr><td align="left">Proxy-Authorization</td><td align="left">连接到代理的授权证书</td><td align="left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td align="left">Range</td><td align="left">只请求实体的一部分，指定范围</td><td align="left">Range: bytes=500-999</td></tr><tr><td align="left">Referer</td><td align="left">先前网页的地址，当前请求网页紧随其后,即来路</td><td align="left">Referer: <a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td align="left">TE</td><td align="left">客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td align="left">TE: trailers,deflate;q=0.5</td></tr><tr><td align="left">Upgrade</td><td align="left">向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td align="left">User-Agent</td><td align="left">User-Agent的内容包含发出请求的用户信息</td><td align="left">User-Agent: Mozilla/5.0 (Linux; X11)</td></tr><tr><td align="left">Via</td><td align="left">通知中间网关或代理服务器地址，通信协议</td><td align="left">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td align="left">Warning</td><td align="left">关于消息实体的警告信息</td><td align="left">Warn: 199 Miscellaneous warning</td></tr></tbody></table><h1 id="（三）HTTP响应报文"><a href="#（三）HTTP响应报文" class="headerlink" title="（三）HTTP响应报文"></a><span id="jump3"><strong>（三）HTTP响应报文</strong></span></h1><h3 id="1-响应报文结构概述"><a href="#1-响应报文结构概述" class="headerlink" title="1. 响应报文结构概述"></a><span id="jumpf"><strong>1. 响应报文结构概述</strong></span></h3><p>响应报文 由<strong>响应行</strong>（版本协议、状态码及其状态描述）、<strong>响应头</strong>、<strong>响应体</strong>组成。<br><img src="https://img-blog.csdnimg.cn/20200430200139484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>下面是一个实际的响应报文：<br><img src="https://img-blog.csdnimg.cn/20200430200116746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-响应行"><a href="#2-响应行" class="headerlink" title="2. 响应行"></a><span id="jumpg" ><strong>2. 响应行</strong></span></h3><p>响应行由三部分组成：<strong>版本协议</strong>、<strong>状态码</strong>、<strong>状态码描述</strong>。</p><h5 id="（1）状态码"><a href="#（1）状态码" class="headerlink" title="（1）状态码"></a>（1）状态码</h5><p>状态代码的第一个数字代表当前响应的类型：<br><img src="https://img-blog.csdnimg.cn/20200430195950952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。客户端应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><p>具体查看：<a href="http://tools.jb51.net/table/http_status_code">HTTP状态码对照表</a></p><h5 id="（2）关于状态码的常见面试题"><a href="#（2）关于状态码的常见面试题" class="headerlink" title="（2）关于状态码的常见面试题"></a>（2）关于状态码的常见面试题</h5><ul><li><p><strong>301和302有什么具体区别</strong></p><p>301：永久移动，请求的网页已永久移动到新的位置，服务器返回此响应，会自动将请求者转到新位置</p><p>302：临时移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来继续以后的请求。</p></li><li><p><strong>200和304 的区别</strong></p><p>200表示成功，服务器已成功处理了请求，通常表示为服务器提供了请求的网页</p><p>304表示未修改，自从上次请求后，请求的网页未修改过，服务器返回此响应时不会返回网页内容。</p></li><li><p><strong>400和401、403状态码</strong></p><p>400状态码：请求无效</p><p>产生原因：前端提交数据的字段名称和字段类型与后台的实体没有保持一致</p><p>前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。</p><p>解决方法：对照字段的名称，保持一致性，将obj对象通过JSON.stringify实现序列化</p><p>401状态码：当前请求需要用户验证</p><p>403状态码：服务器已经得到请求，但是拒绝执行</p></li></ul><h3 id="3-响应头"><a href="#3-响应头" class="headerlink" title="3. 响应头"></a><span id="jumph" ><strong>3. 响应头</strong></span></h3><table><thead><tr><th align="left">Header</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Accept-Ranges</td><td align="left">表明服务器是否支持指定范围请求及哪种类型的分段请求</td><td align="left">Accept-Ranges: bytes</td></tr><tr><td align="left">Age</td><td align="left">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><td align="left">Age: 12</td></tr><tr><td align="left">Allow</td><td align="left">对某网络资源的有效的请求行为，不允许则返回405</td><td align="left">Allow: GET, HEAD</td></tr><tr><td align="left">Cache-Control</td><td align="left">告诉所有的缓存机制是否可以缓存及哪种类型</td><td align="left">Cache-Control: no-cache</td></tr><tr><td align="left">Content-Encoding</td><td align="left">web服务器支持的返回内容压缩编码类型。</td><td align="left">Content-Encoding: gzip</td></tr><tr><td align="left">Content-Language</td><td align="left">响应体的语言</td><td align="left">Content-Language: en,zh</td></tr><tr><td align="left">Content-Length</td><td align="left">响应体的长度</td><td align="left">Content-Length: 348</td></tr><tr><td align="left">Content-Location</td><td align="left">请求资源可替代的备用的另一地址</td><td align="left">Content-Location: /index.htm</td></tr><tr><td align="left">Content-MD5</td><td align="left">返回资源的MD5校验值</td><td align="left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td align="left">Content-Range</td><td align="left">在整个返回体中本部分的字节位置</td><td align="left">Content-Range: bytes 21010-47021/47022</td></tr><tr><td align="left">Content-Type</td><td align="left">返回内容的MIME类型</td><td align="left">Content-Type: text/html; charset=utf-8</td></tr><tr><td align="left">Date</td><td align="left">原始服务器消息发出的时间</td><td align="left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td align="left">ETag</td><td align="left">请求变量的实体标签的当前值</td><td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">Expires</td><td align="left">响应过期的日期和时间</td><td align="left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td align="left">Last-Modified</td><td align="left">请求资源的最后修改时间</td><td align="left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr><tr><td align="left">Location</td><td align="left">用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><td align="left">Location: <a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td align="left">Pragma</td><td align="left">包括实现特定的指令，它可应用到响应链上的任何接收方</td><td align="left">Pragma: no-cache</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">它指出认证方案和可应用到代理的该URL上的参数</td><td align="left">Proxy-Authenticate: Basic</td></tr><tr><td align="left">refresh</td><td align="left">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><td align="left">Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td align="left">Retry-After</td><td align="left">如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><td align="left">Retry-After: 120</td></tr><tr><td align="left">Server</td><td align="left">web服务器软件名称</td><td align="left">Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置Http Cookie</td><td align="left">Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td></tr><tr><td align="left">Trailer</td><td align="left">指出头域在分块传输编码的尾部存在</td><td align="left">Trailer: Max-Forwards</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">文件传输编码</td><td align="left">Transfer-Encoding:chunked</td></tr><tr><td align="left">Vary</td><td align="left">告诉下游代理是使用缓存响应还是从原始服务器请求</td><td align="left">Vary: *</td></tr><tr><td align="left">Via</td><td align="left">告知代理客户端响应是通过哪里发送的</td><td align="left">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td align="left">Warning</td><td align="left">警告实体可能存在的问题</td><td align="left">Warning: 199 Miscellaneous warning</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">表明客户端请求实体应该使用的授权方案</td><td align="left">WWW-Authenticate: Basic</td></tr></tbody></table><h1 id="（四）HTTP缓存"><a href="#（四）HTTP缓存" class="headerlink" title="（四）HTTP缓存"></a><span id="jump4"><strong>（四）HTTP缓存</strong></span></h1><p>笔者只看学习HTTP缓存时阅读了下面这篇博文，觉得写得很赞，推荐阅读。第二篇主要是一些概念，可补充阅读。</p><p><a href="https://blog.csdn.net/jutal_ljt/article/details/80021545">Http缓存机制与原理</a></p><p><a href="https://segmentfault.com/a/1190000008956069">HTTP强缓存和协商缓存</a></p><h1 id="（五）不同版本HTTP"><a href="#（五）不同版本HTTP" class="headerlink" title="（五）不同版本HTTP"></a><span id="jump5"><strong>（五）不同版本HTTP</strong></span></h1><h3 id="1-HTTP-0-9"><a href="#1-HTTP-0-9" class="headerlink" title="1. HTTP 0.9"></a><span id="jumpi"><strong>1. HTTP 0.9</strong></span></h3><p>HTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP 0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。</p><p>HTTP 0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型。一次HTTP 0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。</p><h3 id="2-HTTP-1-0"><a href="#2-HTTP-1-0" class="headerlink" title="2. HTTP 1.0"></a><span id="jumpj"><strong>2. HTTP 1.0</strong></span></h3><p>HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。相对于HTTP 0.9 增加了如下主要特性：</p><ul><li>请求与响应支持头域</li><li>响应对象以一个响应状态行开始</li><li>响应内容不只限于超文本</li><li>开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法</li><li>支持长连接（默认还是使用短连接），使用长连接需要添加请求头 Connection: Keep-Alive，缓存机制，以及身份认证 </li></ul><h3 id="3-HTTP-1-1"><a href="#3-HTTP-1-1" class="headerlink" title=" 3. HTTP 1.1"></a><span id="jumpk"> <strong>3. HTTP 1.1</strong></span></h3><p>HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 。</p><p>HTTP 1.1引入了许多关键性能优化：</p><ul><li><p><strong>持久连接</strong>（Persistent Connections）</p><p>也就是 <code>Connection:keep-alive</code>，服务器返回请求之后不会立刻关闭连接，允许客户端使用同一个连接发送后续HTTP请求。这在<code>HTTP/1.1</code>是默认开启的，除非指定 <code>Connection: close</code> 首部。</p><p>好处是，使网页响应更快。但是对于访问量大的服务器来说，他要维持更多连接会有更大的开销，所以会关掉，比如大型电商网站。</p></li><li><p><strong>HTTP 管道</strong>（Pipelining）</p><p>客户端把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应。增加了并发性，进一步改善了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序请求的，先回应A请求，完成后再回应B请求。如果前一个请求非常耗时，后续的请求都会受影响，在客户端这里导致一个队首阻塞的问题，所以现代浏览器都关闭这个功能。</p></li><li><p><strong>Content-Length 字段</strong></p><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">3495</span><br></code></pre></td></tr></table></figure><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p></li><li><p><strong>Chunked 编码</strong>（Chunked Encoding）</p><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">“分块传输编码”</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">Transfer</span>-Encoding: chunked<br></code></pre></td></tr></table></figure><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。</p></li><li><p><strong>协议升级</strong>（Protocol Switching）</p><p>HTTP/1.1 引入了 Upgrade 机制，它使得客户端和服务端之间可以借助已有的 HTTP 语法升级到其它协议。</p><p>要发起协议升级，客户端必须在请求首部中指定这两个字段：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Connection</span>: UpgradeUpgrade: protocol-<span class="hljs-type">name</span>[/protocol-<span class="hljs-keyword">version</span>]<br></code></pre></td></tr></table></figure><p>如果服务端不同意升级或者不支持 Upgrade 所列出的协议，直接忽略即可（当成 HTTP/1.1 请求，以 HTTP/1.1 响应）；如果服务端同意升级，那么需要这样响应：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">101</span> Switching ProtocolsConnection: upgradeUpgrade: protocol-name[/protocol-version]<br></code></pre></td></tr></table></figure><p>HTTP <code>Upgrade</code> 响应的状态码是 101，并且响应正文可以使用新协议定义的数据格式。</p></li><li><p><strong>Host 首部</strong>（Host Header）</p><p>使用<code>HTTP/1.1</code>发送的请求，必须指明host。</p><p>因为在服务器只知道请求的IP，如果两个域名指向同一个IP，<code>HTTP/1.0</code>是无法区分的。但是携带host，就能区分了。</p></li><li><p>新增了请求方式PUT、PATCH、OPTIONS、DELETE等。</p></li></ul><h3 id="4-HTTP-2-0"><a href="#4-HTTP-2-0" class="headerlink" title=" 4. HTTP 2.0"></a><span id="jumpl"> <strong>4. HTTP 2.0</strong></span></h3><p><code>HTTP/2</code> 并没有改动 <code>HTTP/1</code> 的语义部分，例如请求方法、响应状态码、URI 以及首部字段等核心概念依旧存在。<code>HTTP/2</code> 最大的变化是重新定义了格式化和传输数据的方式，这是通过在高层 HTTP API 和低层 TCP 连接之间引入<code>二进制分帧层</code>来实现的。这样带来的好处是原来的 WEB 应用完全不用修改，就能享受到协议升级带来的收益。</p><p>HTTP 2.0是下一代HTTP协议，目前应用还非常少。主要特点有：</p><ul><li><p><strong>二进制协议</strong>（Binary Protocol）</p><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议解析起来更快，更重要的是，相比文本协议，它更少出错。</p></li><li><p><strong>多路复用</strong>（Multiplexed）</p><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p></li><li><p><strong>拥有优先级</strong>（Prioritized）</p><p>同时能进行多个请求和响应，所以需要控制顺序。<code>HTTP/2</code> 允许给每个流附上 <code>weight</code>（1~256）和对其他流的依赖，这最终会构建一个优先级树。</p></li><li><p><strong>服务端推送</strong>（Server Push）</p><p>允许服务器在给原本请求返回响应的同时，还能主动返回其他资源给客户端。</p><p>在 <code>HTTP/1.X</code> 的时代，有很多连接数优化的网站性能优化方式，比如资源内联。其实到了新版本，开启服务端推送，就能帮你解决问题，提升性能。</p></li><li><p><strong>首部压缩</strong>（Header Compression，HPACK）</p><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p></li></ul><p><strong>学习并参考于</strong>：</p><p><a href="https://www.dazhuanlan.com/2020/01/31/5e344360e45ad/">浅谈不同版本HTTP协议</a></p><p><a href="https://blog.csdn.net/qq_22238021/article/details/81197157">http协议各个版本</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TPC</title>
    <link href="/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TPC/"/>
    <url>/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TPC/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-TCP数据包结构"><a href="#1-TCP数据包结构" class="headerlink" title="1. TCP数据包结构"></a><a href="#jumpa"><strong>1. TCP数据包结构</strong></a></h4><h4 id="2-TCP三次握手-和-四次握手"><a href="#2-TCP三次握手-和-四次握手" class="headerlink" title="2. TCP三次握手 和  四次握手"></a><a href="#jumpb"><strong>2. TCP三次握手 和  四次握手</strong></a></h4><ul><li><a href="#jump1"> <strong>TPC三次握手</strong></a></li><li><a href="#jump2"><strong>TCP四次挥手</strong></a></li></ul><h4 id="3-TCP如何保证传输可靠性-详解"><a href="#3-TCP如何保证传输可靠性-详解" class="headerlink" title="3. TCP如何保证传输可靠性 详解"></a><a href="#jumpc"><strong>3. TCP如何保证传输可靠性 详解</strong></a></h4><ul><li><a href="#jump3"><strong>概述</strong></a></li><li><a href="#jump4"><strong>校验和</strong></a></li><li><a href="#jump5"><strong>确认应答+序列号</strong></a></li><li><a href="#jump6"><strong>超时重传</strong></a></li><li><a href="#jump123"><strong>停止等待协议</strong></a></li><li><a href="#jump7"><strong>流量控制</strong></a></li><li><a href="#jump8"><strong>拥塞控制</strong></a></li><li><a href="#jump9"><strong>连接管理</strong></a></li></ul><h4 id="4-TCP短连接-与-长连接"><a href="#4-TCP短连接-与-长连接" class="headerlink" title="4. TCP短连接 与 长连接"></a><a href="#jumpd"><strong>4. TCP短连接 与 长连接</strong></a></h4><ul><li><a href="#jump10"><strong>短连接</strong></a></li><li><a href="#jump11"><strong>长连接</strong></a></li></ul><h4 id="5-TCP-粘包和拆包"><a href="#5-TCP-粘包和拆包" class="headerlink" title="5. TCP 粘包和拆包 "></a><a href="#jumpe"><strong>5. TCP 粘包和拆包</strong> </a></h4><h4 id="6-TCP和UDP协议的区别"><a href="#6-TCP和UDP协议的区别" class="headerlink" title="6. TCP和UDP协议的区别"></a><a href="#jumpf"><strong>6. TCP和UDP协议的区别</strong></a></h4><h4 id="7-网络模型"><a href="#7-网络模型" class="headerlink" title="7. 网络模型"></a><a href="#jumpg"><strong>7. 网络模型</strong></a></h4><ul><li><a href="#jumpg"><strong>OSI 七层网络模型</strong></a></li><li><a href="#jumpw"><strong>TCP/IP 网络模型</strong></a></li></ul><p>传输层控制协议（Transport Control Protocol），TCP/IP协议栈的核心之一。位于传输层，提供面向连接的、可靠的字节流服务。</p><h1 id="（一）TCP数据包结构"><a href="#（一）TCP数据包结构" class="headerlink" title="（一）TCP数据包结构"></a><span id="jumpa"><strong>（一）TCP数据包结构</strong></span></h1><p><img src="https://img-blog.csdnimg.cn/20200430130357725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p><strong>源端口号</strong>（16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。</p></li><li><p><strong>目的端口号</strong>（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。</p><p>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</p><p>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里只说四元组。由这无元组可以唯一确定一个 TCP 连接。</p></li><li><p><strong>序列号</strong>（ 32 位）：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它存储当前数据包数据第一个字节的序号。<strong>用来解决网络包乱序（reordering）问题。</strong>如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2^32 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）。</p></li><li><p><strong>确认号</strong>（ 32 位）：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。<strong>用来解决不丢包的问题</strong>。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</p></li><li><p><strong>TCP 报头长度</strong>（ 4 位）：给出报头中 32bit 字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。</p></li><li><p><strong>保留位</strong>（ 6 位）：保留给将来使用，目前必须置为 0 。</p></li><li><p><strong>控制位</strong>（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为：</p><ul><li>URG ：(urgent 紧急位 0/1） 为 1 表示紧急指针有效，为 0 则忽略紧急指针值。</li><li>ACK ：（acknowledge 确认位 0/1)为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。</li><li>PSH ：(push 推标志)为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li><li>RST ：(reset 重置位 0/1）用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。</li><li>SYN ：（synchronize sequence 序列位 0/1）同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。</li><li>FIN ：（finish 完结位 0/1)用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul></li><li><p><strong>窗口大小</strong>（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535字节。也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</p></li><li><p><strong>校验和</strong>（ 16 位）：此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。</p></li><li><p><strong>紧急指针</strong>（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p></li><li><p><strong>选项</strong>：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。</p></li><li><p><strong>数据</strong>： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p></li></ul><h1 id="（二）TCP三次握手-和-四次握手"><a href="#（二）TCP三次握手-和-四次握手" class="headerlink" title="（二）TCP三次握手 和  四次握手"></a><span id="jumpb"><strong>（二）TCP三次握手 和  四次握手</strong></span></h1><h3 id="1-TPC三次握手"><a href="#1-TPC三次握手" class="headerlink" title="1. TPC三次握手"></a><span id="jump1"><strong>1. TPC三次握手</strong></span></h3><p><strong>过程</strong>：<br><img src="https://img-blog.csdnimg.cn/20200430130608454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最初两端的TCP进程都处于CLOSED状态。client是主动打开连接，server是被动打开连接。</p><ul><li>首先client的TCP客户进程向server发出连接请求报文段，这时首部中的同步位SYN=1，初始序号seq=x。这时，client的客户进程就进入SYN-SENT(同步已发送)状态。</li><li>server收到连接请求报文段后，向client发送确认。在确认报文段中把SYN和ACK位都置为1，确认号是ack=x+1,初始序号seq=y。这时server的TCP服务器进程就进入SYN-RCVD(同步已收到)状态。</li><li>client的TCP客户进程收到server的确认后，还要向server给出确认。确认报文段的ACK置为1，确认号ack=y+1，序号seq=x+1。这时，TCP连接已经建立，client进入ESTABLISHED(已建立连接)状态，当server收到client的确认后，也会进入ESTABLISHED状态。</li></ul><p>以上给出的连接建立过程就是常说的TCP三次握手。</p><p><strong>为什么要三次握手？(为什么client还要发送一次确认呢?)</strong></p><p>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><p>而第三次握手主要是为了防止已失效的连接请求报文段突然又传送到了server，因而产生错误。</p><p>假定client发出的某一个连接请求报文段在传输的过程中并没有丢失，而是在某个网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误以为client又发了一次新的连接请求，于是向client发出确认报文段，同意建立连接。假如不采用三次握手，那么只要server发出确认，新的连接就建立了。由于client并未发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立了，并一直等待client发来数据，因此白白浪费了许多资源。</p><p>采用TCP三次握手的方法可以防止上述现象发生。例如在刚才的情况下，由于client不会向server的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接。</p><p><strong>为什么要传回syn？</strong></p><p>接收端传回发送端所发送的SYN是：为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><p><strong>传了SYN,为啥还要传ACK？</strong></p><p>双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。</p><p><a href="https://www.cnblogs.com/winner-0715/p/5032661.html">TCP建立连接的三次握手过程</a></p><h3 id="2-四次握手"><a href="#2-四次握手" class="headerlink" title="2. 四次握手"></a><span id="jump2"><strong>2. 四次握手</strong></span></h3><p><strong>过程</strong><br><img src="https://img-blog.csdnimg.cn/20200430131434210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>数据传输结束后，通信的双方都可释放连接。</p><ul><li><p>现在client和server都处于ESTABLISHED状态。client的应用进程先向server发出连接释放报文段，主动关闭TCP连接。client把连接释放报文段的首部的终止控制位FIN置为1，序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FIN-WAIT-1(终止等待1)状态，等待server的确认。</p></li><li><p>server收到连接释放报文段后即发出确认(发出的不是连接释放报文段)，确认号是ack=u+1，而这个报文段自己的序号是seq = v，等于server前面已传送过的数据的最后一个字节的序号加1。然后server就进入CLOSE-WAIT(关闭等待)状态。TCP服务器进程这时通知高层应用进程，因而从client到server这个方向的连接释放了，这时的TCP连接处于半关闭状态，即client已经没有数据要发送了，但server若发送数据，client仍要接受。也就是说，从server到client这个方向的连接并未关闭。这个状态可以会持续一些时间。</p><p>client收到server的确认后，就进入FIN-WAIT-2(终止等待2)状态，等待server发出的连接释放报文段。</p></li><li><p>若server已经没有要向client发送的数据，其应用进程就通知TCP释放连接。这时server发出的连接释放报文段必须使用FIN=1。现假定server的序号为w(在半关闭状态B可能又发送了一些数据)。server还必须重复上次已发送过的确认号ack=u+1。这是server就进入LAST-ACK状态，等待A的确认。</p></li><li><p>在client收到server的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置为1，确认号ack=w+1，而自己的序号是seq=u+1(前面的FIN报文消耗了1个序号)。然后进入TIME-WAIT状态。请注意，现在TCP连接还没释放掉。必须再经过2MSL后，client才进入到CLOSED状态。MSL叫最长报文段寿命，一般为2分钟。</p><p>当server收到client发出的确认，就进入CLOSED状态。由此可见server结束TCP连接的时间要比client早一些。等到2MSL结束后client也进入CLOSED状态，至此完成了TCP四次挥手断开连接全过程。</p></li></ul><p><strong>tcp四次挥手为什么要等待2MSL</strong>？（为什么要有TIME-WAIT这个状态呢）</p><p>MSL 是Maximum Segment Lifetime,译为“报文最大生存时间”，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>2MSL是两倍的MSL(Maximum Segment Lifetime)，2MSL就是一个发送和一个回复所需的最大时间</p><ul><li><p>防止客户端最后一次发给服务器的确认在网络中丢失以至于客户端关闭，而服务端并未关闭，导致资源的浪费。</p><p>client发送出最后的ACK回复后，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL，如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p></li><li><p>等待最大的2msl可以让本次连接的所有的网络包在链路上消失，以防造成不必要的干扰。</p><p>如果client直接closed，然后又向server发起了一个新连接，我们不能保证这个新连接和刚关闭的连接的端口号是不同的。假设新连接和已经关闭的老端口号是一样的，如果前一次滞留的某些数据仍然在网络中，这些延迟数据会在新连接建立后到达Server，所以socket就认为那个延迟的数据是属于新连接的，数据包就会发生混淆。所以client要在TIME_WAIT状态等待2倍的MSL，这样保证本次连接的所有数据都从网络中消失。</p></li></ul><p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p><p>因为在握手过程中，当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p><p>四次握手因为是双方彼此都建立了连接，因此双方都要释放自己的连接，A向B发出一个释放连接请求，他要释放链接表明不再向B发送数据了，此时B收到了A发送的释放链接请求之后，给A发送一个确认，A不能再向B发送数据了，它处于FIN-WAIT-2的状态，但是此时B还可以向A进行数据的传送。此时B向A 发送一个断开连接的请求，A收到之后给B发送一个确认。此时B关闭连接。A也关闭连接。</p><h1 id="（三）TCP如何保证传输可靠性-详解"><a href="#（三）TCP如何保证传输可靠性-详解" class="headerlink" title="（三）TCP如何保证传输可靠性 详解 "></a><span id="jumpc"><strong>（三）TCP如何保证传输可靠性 详解</strong> </span></h1><p>这部分是学习并摘自：<a href="https://www.iteye.com/blog/uule-2429131">TCP如何保证传输可靠性</a></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a><span id="jump3"><strong>1. 概述</strong></span></h3><p>TCP协议保证数据传输可靠性的方式主要有：<strong>（校序重流拥）</strong></p><ul><li><p><strong>校验和</strong></p><p>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p></li><li><p><strong>确认应答+序列号</strong></p><div class="code-wrapper"><pre><code class="hljs"> TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </code></pre></div></li><li><p><strong>超时重传</strong></p><p>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p></li><li><p><strong>停止等待ARQ协议</strong></p><p>也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p></li><li><p><strong>流量控制</strong></p><p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 接收方有即时窗口（滑动窗口），随ACK报文发送 。</p></li><li><p><strong>拥塞控制</strong></p><p>当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的即时窗口，取小。</p><p>拥塞控制主要是四个算法：<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快速恢复</strong>。</p></li><li><p><strong>应用数据切割</strong>：应用数据被分隔成TCP认为最适合发送的多个报文段（由特定的算法和机制来确认）</p></li></ul><p><strong>接下来详细说明上面列举的几种举措！</strong></p><h3 id="2-校验和"><a href="#2-校验和" class="headerlink" title="2. 校验和"></a><span id="jump4"><strong>2. 校验和</strong></span></h3><p><strong>计算方式</strong>：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。 </p><p><strong>发送方</strong>：在发送数据之前计算检验和<strong>，</strong>并进行校验和的填充。 </p><p><strong>接收方</strong>：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。<br><img src="https://img-blog.csdnimg.cn/20200430131327432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> <strong>注意</strong>：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p><h3 id="3-确认应答与序列号"><a href="#3-确认应答与序列号" class="headerlink" title="3.  确认应答与序列号"></a><span id="jump5"><strong>3.  确认应答与序列号</strong></span></h3><p><strong>序列号</strong>：TCP传输时将每个字节的数据都进行了编号，这就是序列号。 </p><p><strong>确认应答</strong>：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。<br><img src="https://img-blog.csdnimg.cn/20200430131303215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p><h3 id="4-超时重传"><a href="#4-超时重传" class="headerlink" title="4. 超时重传"></a><span id="jump6"><strong>4. 超时重传</strong></span></h3><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。</p><p>如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？</p><p>首先，<strong>发送方没有接收到响应的ACK报文原因可能有两点</strong>：</p><ul><li>数据在传输过程中由于网络原因等直接全体丢包，接收方没有接收到。</li><li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</li></ul><p>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制。</strong>简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。</p><ul><li>如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。</li><li>如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</li></ul><p>那么发送方发送完毕后<strong>等待的时间是多少呢？</strong>如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p><p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p><p><strong>注意：</strong></p><p>超时以500ms（0.5秒）为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2<em>500ms的时间后，再次重传。等待4</em>500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。</p><p><strong>详细内容推荐阅读以下博客！</strong></p><p><a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a></p><h3 id="5-停止等待协议"><a href="#5-停止等待协议" class="headerlink" title="5. 停止等待协议"></a><span id="jump123"><strong>5. 停止等待协议</strong></span></h3><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li></ul><h3 id="6-流量控制"><a href="#6-流量控制" class="headerlink" title="6.  流量控制"></a><span id="jump7"><strong>6.  流量控制</strong></span></h3><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而<strong>TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制</strong>。<strong>流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。流量控制往往指的是点对点通信量的控制，是个端到端的问题。</strong></p><p>在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。<br><img src="https://img-blog.csdnimg.cn/20200430131206712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。</p><h3 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7.  拥塞控制"></a><span id="jump8"><strong>7.  拥塞控制</strong></span></h3><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p><p> 发送方维持一个叫做<strong>拥塞窗口 cwnd</strong>（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p><p>拥塞控制主要是四个算法：慢开始、拥塞避免、快重传、快恢复。</p><ul><li><p><strong>慢启动 与 拥塞避免</strong></p><p><strong>慢开始</strong>算法的思路就是：在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。</p><p>最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：</p><figure class="highlight ada"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs ada">   开始           <span class="hljs-comment">---&gt;     cwnd = 1</span><br>   经过<span class="hljs-number">1</span>个RTT后   <span class="hljs-comment">---&gt;     cwnd = 2*1 = 2</span><br>   经过<span class="hljs-number">2</span>个RTT后   <span class="hljs-comment">---&gt;     cwnd = 2*2= 4</span><br>   经过<span class="hljs-number">3</span>个RTT后   <span class="hljs-comment">---&gt;     cwnd = 4*2 = 8</span><br>如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。<br></code></pre></td></tr></table></figure><p>从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入<strong>拥塞避免</strong>阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p><strong>当cwnd&lt;ssthresh时，使用慢开始算法。</strong></p><p><strong>当cwnd&gt;ssthresh时，改用拥塞避免算法。</strong></p><p><strong>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</strong></p><p>无论是在<strong>慢开始阶段</strong>还是在<strong>拥塞避免阶段</strong>，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就将cwnd置为1，ssthresh置为cwnd的一半，然后开始执行慢启动算法（cwnd&lt;ssthresh）。<br><img src="https://img-blog.csdnimg.cn/20200430131134930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><ul><li><p><strong>快重传 和 快恢复</strong></p><p>在TCP/IP中，<strong>快速重传和恢复 FRR</strong>（fast retransmit and recovery）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。<br><img src="https://img-blog.csdnimg.cn/20200430131053680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><p><strong>详细内容推荐阅读以下博客！</strong></p><p><a href="https://blog.csdn.net/ydyang1126/article/details/72842274">TCP慢启动、拥塞避免、快速重传、快速恢复</a></p><p><a href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）</a></p><h3 id="8-连接管理"><a href="#8-连接管理" class="headerlink" title="8. 连接管理"></a><span id="jump9"><strong>8. 连接管理</strong></span></h3><p>连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。</p><h1 id="（四）TCP短连接-与-长连接"><a href="#（四）TCP短连接-与-长连接" class="headerlink" title="（四）TCP短连接 与 长连接"></a><span id="jumpd" ><strong>（四）TCP短连接 与 长连接</strong></span></h1><p><strong>学习并整理摘于</strong> ：<a href="https://www.jianshu.com/p/313798ae863d">TCP长连接与短连接</a></p><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><h3 id="1-短连接"><a href="#1-短连接" class="headerlink" title="1. 短连接"></a><span id="jump10" ><strong>1. 短连接</strong></span></h3><p>模拟一下TCP短连接的情况:</p><ul><li><p>client 向 server 发起连接请求</p></li><li><p>server 接到请求，双方建立连接</p></li><li><p>client 向 server 发送消息</p></li><li><p>server 回应 client</p></li><li><p>一次读写完成，此时双方任何一个都可以发起 close 操作</p></li></ul><p>在第 5 点中，一般都是 client 先发起 close 操作。因为一般的 server 不会回复完 client 后就立即关闭连接。当然也不排除有特殊的情况。<br><strong>短连接一般只会在 client/server 间传递一次读写操作！</strong></p><p><strong>短连接的操作步骤是：</strong></p><ul><li>建立连接——数据传输——关闭连接……建立连接——数据传输——关闭连接</li></ul><p><strong>短连接的优缺点是：</strong></p><ul><li><p><strong>优点</strong>：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p></li><li><p><strong>缺点</strong>是：但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p></li></ul><p><strong>短连接应用场景</strong>：</p><p>像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><h3 id="2-长连接"><a href="#2-长连接" class="headerlink" title="2. 长连接"></a><span id="jump11" ><strong>2. 长连接</strong></span></h3><p>模拟一下长连接的情况:</p><ul><li><p>client 向 server 发起连接</p></li><li><p>server 接到请求，双方建立连接</p></li><li><p>client 向 server 发送消息</p></li><li><p>server 回应 client</p></li><li><p>一次读写完成，连接不关闭</p></li><li><p>后续读写操作…</p></li></ul><p>长连接的<strong>操作步骤</strong>是：</p><ul><li>建立连接——数据传输……（保持连接）……数据传输——关闭连接</li></ul><p>而长连接的状态是如何保持的呢？有些博主已经总结的很好，这里就不加篇（ctrl）幅（c+v  ^_^）。推荐看下面博客：</p><p><a href="https://blog.csdn.net/TT_love9527/article/details/82887250">TCPKeepAlive保活机制</a></p><p>长连接的<strong>优缺点</strong>是：</p><ul><li><p><strong>优点</strong>：长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。</p></li><li><p><strong>缺点</strong>：在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数。</p></li></ul><p><strong>长连接应用场景</strong>：</p><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，再次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p><h1 id="（五）TCP-粘包和拆包"><a href="#（五）TCP-粘包和拆包" class="headerlink" title="（五）TCP 粘包和拆包 "></a><span id="jumpe"><strong>（五）TCP 粘包和拆包</strong> </span></h1><p>学习并摘自：<a href="https://www.cnblogs.com/panchanggui/p/9518735.html">tcp粘包和拆包</a></p><p>粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p><h3 id="1-什么是粘包、拆包？"><a href="#1-什么是粘包、拆包？" class="headerlink" title="1. 什么是粘包、拆包？"></a><strong>1. 什么是粘包、拆包？</strong></h3><p>假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。<br><img src="https://img-blog.csdnimg.cn/20200430130951407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="https://img-blog.csdnimg.cn/20200430130931400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xwAyOL8X-1588222913651)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1588215794024.png)]"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。<br><img src="https://img-blog.csdnimg.cn/20200430130855181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-为什么会发生TCP粘包、拆包？"><a href="#2-为什么会发生TCP粘包、拆包？" class="headerlink" title="2. 为什么会发生TCP粘包、拆包？"></a><strong>2. 为什么会发生TCP粘包、拆包？</strong></h3><p>发生TCP粘包、拆包主要是由于下面一些原因：</p><ul><li><p>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</p></li><li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</p></li><li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</p></li><li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</p></li></ul><h3 id="3-粘包、拆包解决办法"><a href="#3-粘包、拆包解决办法" class="headerlink" title="3. 粘包、拆包解决办法"></a><strong>3. 粘包、拆包解决办法</strong></h3><p>TCP本身是面向流的，作为网络服务器，如何从这源源不断涌来的数据流中拆分出或者合并出有意义的信息呢？通常会有以下一些常用的方法：</p><ul><li><p>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p></li><li><p>发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p></li><li><p>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p></li></ul><h1 id="（六）TCP和UDP协议的区别"><a href="#（六）TCP和UDP协议的区别" class="headerlink" title="（六）TCP和UDP协议的区别"></a><span id="jumpf"><strong>（六）TCP和UDP协议的区别</strong></span></h1><h3 id="1-UDP数据包结构"><a href="#1-UDP数据包结构" class="headerlink" title="1. UDP数据包结构"></a><strong>1. UDP数据包结构</strong></h3><p>用户数据报协议（User Datagram Protocol, UDP），是一种无连接方式的、不可靠的传输协议。<br><img src="https://img-blog.csdnimg.cn/20200430130635445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>源端口号和目的端口号如上和TCP的相同。</p></li><li><p>UDP长度：UDP报文的字节长度（包括首部和数据）。</p></li><li><p>UDP校验和: 检验UDP首部和数据部分的正确性。</p></li></ul><h3 id="2-TCP与UDP区别"><a href="#2-TCP与UDP区别" class="headerlink" title="2. TCP与UDP区别"></a><strong>2. TCP与UDP区别</strong></h3><table><thead><tr><th align="center">特点</th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">连接性</td><td align="center">面向连接</td><td align="center">面向非连接</td></tr><tr><td align="center">可靠性</td><td align="center">可靠</td><td align="center">不可靠</td></tr><tr><td align="center">报文</td><td align="center">面向字节流</td><td align="center">面向报文</td></tr><tr><td align="center">传输效率</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">传输速度</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">双工性</td><td align="center">全双工</td><td align="center">一对一、一对多、多对一、多对多</td></tr><tr><td align="center">流量控制</td><td align="center">滑动窗口</td><td align="center">无</td></tr><tr><td align="center">拥塞控制</td><td align="center">慢开始、拥塞控制、快重传、快恢复</td><td align="center">无</td></tr><tr><td align="center">应用场景</td><td align="center">对效率要求低、对准确性要求高或者要求有连接的场景</td><td align="center">对效率要求高、对准确性要求低的场景</td></tr></tbody></table><p><strong>TCP和UDP协议的一些应用</strong>：</p><table><thead><tr><th>应用层协议</th><th>应用</th><th>传输层协议</th></tr></thead><tbody><tr><td>SMTP</td><td>电子邮件</td><td>TCP</td></tr><tr><td>TELNET</td><td>远程终端接入</td><td>TCP</td></tr><tr><td>HTTP</td><td>万维网</td><td>TCP</td></tr><tr><td>FIP</td><td>文件传输</td><td>TCP</td></tr><tr><td>DNS</td><td>域名转换</td><td>UDP</td></tr><tr><td>TFIP</td><td>文件传输</td><td>UDP</td></tr><tr><td>SNMP</td><td>网络管理</td><td>UDP</td></tr><tr><td>NFS</td><td>远程文件服务器</td><td>UDP</td></tr></tbody></table><h1 id="（七）网络模型"><a href="#（七）网络模型" class="headerlink" title="（七）网络模型"></a><span id="jumpg"><strong>（七）网络模型</strong></span></h1><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a><span id="jumpg"><strong>1. OSI七层模型</strong></span></h3><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1588303941361.png" alt="1588303941361"></p><p><strong>其中各层作用：</strong></p><ul><li><p><strong>应用层</strong>：</p><p>是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p></li><li><p><strong>表示层</strong>：</p><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。</p></li><li><p><strong>会话层</strong>：</p><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。      </p></li><li><p><strong>传输层</strong>：</p><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。</p></li><li><p><strong>网络层</strong>：</p><p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p></li><li><p><strong>数据链路层</strong>：</p><p>将比特组合成字节,再将字节组合成<strong>帧</strong>,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p></li><li><p><strong>物理层</strong>：</p><p> 实际最终信号的传输是通过物理层实现的。通过物理介质传输<strong>比特流</strong>。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p></li></ul><p><strong>参考</strong>：<a href="https://www.jianshu.com/p/f32cfd6c208b">OSI网络模型</a></p><h3 id="2-TCP-IP网络模型"><a href="#2-TCP-IP网络模型" class="headerlink" title="2. TCP/IP网络模型"></a><span id="jumpw">2. TCP/IP网络模型</span></h3><p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是<strong>链路层（网络接口层）、网络层、传输层和应用层</strong>。下图表示TCP/IP模型与OSI模型各层的对照关系。<br><img src="https://img-blog.csdnimg.cn/2020043013074119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>其中各层作用：</strong></p><ul><li><strong>应用层</strong>：决定了向用户提供应用服务时通信的活动，主要负责应用之间的数据传输。</li><li><strong>传输层</strong>：主要负责的功能是将应用层的数据进行传输，为为两台主机上的应用提供端到端的通信。</li><li><strong>网络层</strong>：主要处理在网络中传输的数据包，定义了数据包在网络中传输的格式。</li><li><strong>链路层</strong>：处理连接网络的硬件部分，是这些硬件部分之间通信规范的一个标准，使这些硬件设备之间能够相互连接。</li></ul><p>TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。<br><img src="https://img-blog.csdnimg.cn/20200430130656980.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue：深入理解组件</title>
    <link href="/2020/04/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/04/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-组件注册"><a href="#1-组件注册" class="headerlink" title="1. 组件注册"></a><a href="#jumpa">1. 组件注册</a></h4><ul><li><a href="#jump1"><strong>全局注册</strong></a></li><li><a href="#jump2"><strong>局部注册</strong></a></li></ul><h4 id="2-Prop"><a href="#2-Prop" class="headerlink" title="2. Prop"></a><a href="#jumpb">2. Prop</a></h4><ul><li><a href="#jump3"><strong>Prop的大小写</strong></a></li><li><a href="#jump4"><strong>Prop验证</strong></a></li><li><a href="#jump5"><strong>传递Prop</strong></a></li></ul><h4 id="3-插槽"><a href="#3-插槽" class="headerlink" title="3. 插槽"></a><a href="#jumpc">3. 插槽</a></h4><ul><li><a href="#jump6"><strong>基本使用</strong></a></li><li><a href="#jump7"><strong>后备内容</strong></a></li><li><a href="#jump8"><strong>作用域插槽</strong></a></li></ul><h4 id="4-动态组件-amp-异步组件"><a href="#4-动态组件-amp-异步组件" class="headerlink" title="4. 动态组件 &amp; 异步组件"></a><a href="#jumpd">4. 动态组件 &amp; 异步组件</a></h4><ul><li><a href="#jump9"><strong>动态组件</strong></a></li><li><a href="#jump10"><strong>在动态组件上使用  keep-alive</strong></a></li><li><a href="#jump11"><strong>异步组件</strong></a></li></ul><h2 id="（一）组件注册"><a href="#（一）组件注册" class="headerlink" title="（一）组件注册"></a><span id="jumpa">（一）组件注册</span></h2><p>两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong>。</p><h4 id="1-全局注册"><a href="#1-全局注册" class="headerlink" title="1. 全局注册"></a><span id="jump1">1. 全局注册</span></h4><p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个名为 button-counter</span><br><span class="hljs-comment">//当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会避免和当前以及未来的 HTML 元素相冲突。</span><br>Vue.component(<span class="hljs-string">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-局部注册"><a href="#2-局部注册" class="headerlink" title="2. 局部注册"></a><span id="jump2">2. 局部注册</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//模块系统中局部注册</span><br><span class="hljs-keyword">import</span> ComponentA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentA.vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    ComponentA<br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="（二）Prop"><a href="#（二）Prop" class="headerlink" title="（二）Prop"></a><span id="jumpb">（二）Prop</span></h2><h4 id="1-Prop的大小写"><a href="#1-Prop的大小写" class="headerlink" title="1. Prop的大小写"></a><span id="jump3">1. Prop的大小写</span></h4><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;blog-post&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 在 JavaScript 中是 camelCase 的</span><br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;postTitle&#x27;</span>],<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span><br>&#125;)<br>&lt;!-- 在 HTML 中是 kebab-<span class="hljs-keyword">case</span> 的 --&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">post-title</span>=<span class="hljs-string">&quot;hello!&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</p><h4 id="2-Prop验证"><a href="#2-Prop验证" class="headerlink" title="2. Prop验证"></a><span id="jump4">2. Prop验证</span></h4><p><strong>不推荐</strong>使用数组的方式，对系统后续维护不利。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">props:[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;list&#x27;</span>, <span class="hljs-string">&#x27;isVisible&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>推荐</strong>以下写法：定制 prop 的验证方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"> props: &#123;<br>    <span class="hljs-comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">Number</span>,<br>    <span class="hljs-comment">// 多个可能的类型</span><br>    <span class="hljs-attr">propB</span>: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>],<br>    <span class="hljs-comment">// 必填的字符串</span><br>    <span class="hljs-attr">propC</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,<br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-comment">// 带有默认值的数字</span><br>    <span class="hljs-attr">propD</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br>    &#125;,<br>    <span class="hljs-comment">// 带有默认值的对象</span><br>    <span class="hljs-attr">propE</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Object</span>,<br>      <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span><br>      <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">propF</span>: &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>,<br><span class="hljs-comment">//对象或数组默认值必须从一个工厂函数获取</span><br>            <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> []<br>    &#125;，<br>    <span class="hljs-attr">propG</span>: &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">Function</span>,<br>        <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>    &#125; <br>    <span class="hljs-comment">// 自定义验证函数</span><br>    <span class="hljs-attr">propH</span>: &#123;<br>      <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].indexOf(value) !== -<span class="hljs-number">1</span><br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">propI</span>: &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">Boolean</span>,<br>         <span class="hljs-attr">default</span>:<span class="hljs-literal">false</span><br>    &#125;,<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="3-传递Prop"><a href="#3-传递Prop" class="headerlink" title="3. 传递Prop"></a><span id="jump5">3. 传递Prop</span></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1. 传递静态Prop --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- (1)传入一个数字 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">&quot;42&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (2)传入布尔值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:is-published</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (3)传入数组 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:comment-ids</span>=<span class="hljs-string">&quot;[234, 266, 273]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (4)传入对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-bind:author</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    name: &#x27;Veronica&#x27;,</span></span><br><span class="hljs-string"><span class="hljs-tag">    company: &#x27;Veridian Dynamics&#x27;</span></span><br><span class="hljs-string"><span class="hljs-tag">  &#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 传递动态Prop --&gt;</span>  <br><span class="hljs-comment">&lt;!-- (1)动态赋予一个变量的值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">&quot;post.likes&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:author</span>=<span class="hljs-string">&quot;post.author&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (2)动态赋予一个复杂表达式的值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;post.title + &#x27; by &#x27; + post.author.name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (3)传入对象的所有属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">post: &#123;</span><br><span class="hljs-comment">  id: 1,</span><br><span class="hljs-comment">  title: &#x27;My Journey with Vue&#x27;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">等效于下面代码：</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;post.id&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;post.title&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="（三）插槽"><a href="#（三）插槽" class="headerlink" title="（三）插槽"></a><span id="jumpc">（三）插槽</span></h2><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在 &lt;navigation-link&gt; 的模板中写为 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 在使用&lt;navigation-link&gt;模板时： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span>Your Profile<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  Your Profile<br>&lt;/navigation-link<br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">font-awesome-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font-awesome-icon</span>&gt;</span><br>  Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 <code>&lt;navigation-link&gt;</code> <strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p><h4 id="2-后备内容"><a href="#2-后备内容" class="headerlink" title="2. 后备内容"></a>2. 后备内容</h4><p>为一个插槽设置具体的后备 (也就是默认的) 内容，它只会在没有提供内容的时候被渲染。而如果我们提供内容，则这个提供的内容将会被渲染从而取代后备内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在 &lt;submit-button&gt; 的模板中写为 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 在使用&lt;submit-button&gt;模板时： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将被渲染为： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-具名插槽"><a href="#3-具名插槽" class="headerlink" title="3. 具名插槽"></a>3. 具名插槽</h4><p>使用场景：需要多个插槽。</p><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽。一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p><p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在 &lt;base-layout&gt; 的模板中写为 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 在使用&lt;base-layout&gt;模板时： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 上面两行代码等效为：  </span><br><span class="hljs-comment">  &lt;template v-slot:default&gt;</span><br><span class="hljs-comment">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="hljs-comment">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="hljs-comment">  &lt;/template&gt;</span><br><span class="hljs-comment"> --&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>具名插槽缩写</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h4><p><strong>编译作用域</strong>：</p><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p><p>我们在父级模板里使用带有插槽的子组件。当想在一个插槽中使用数据时，该插槽跟父级模板的其它地方一样可以访问父级的实例属性 (也就是相同的“作用域”)，而<strong>不能</strong>访问子组件的作用域。</p><p>而当我们想让插槽内容能够访问子组件中才有的数据时，可以使用作用域插槽。 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在&lt;current-user&gt;的模板中写为: --&gt;</span><br><span class="hljs-comment">&lt;!-- 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 &lt;slot&gt; 元素的一个 attribute 绑定上去 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    &#123;&#123; user.lastName &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 在使用&lt;current-user&gt;模板时： --&gt;</span><br><span class="hljs-comment">&lt;!-- 可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>    &#123;&#123; slotProps.user.firstName &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="（四）动态组件-amp-异步组件"><a href="#（四）动态组件-amp-异步组件" class="headerlink" title="（四）动态组件 &amp; 异步组件"></a><span id="jumpd">（四）动态组件 &amp; 异步组件</span></h2><h4 id="1-动态组件"><a href="#1-动态组件" class="headerlink" title=" 1. 动态组件"></a><span id="jump9"> 1. 动态组件</span></h4><p>通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，currentTabComponent 可以包括</p><ul><li>已注册组件的名字，或</li><li>一个组件的选项对象</li></ul><p><strong>例子</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentView&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeView(&#x27;A&#x27;)&quot;</span>&gt;</span>切换到A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeView(&#x27;B&#x27;)&quot;</span>&gt;</span>切换到B<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeView(&#x27;C&#x27;)&quot;</span>&gt;</span>切换到C<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript"> <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="javascript"> <span class="hljs-attr">data</span>: &#123;</span><br><span class="javascript">  <span class="hljs-attr">currentView</span>: <span class="hljs-string">&#x27;comA&#x27;</span></span><br><span class="javascript"> &#125;,</span><br><span class="javascript"> <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">  <span class="hljs-attr">changeView</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;</span><br><span class="javascript">   <span class="hljs-built_in">this</span>.currentView = <span class="hljs-string">&#x27;com&#x27;</span>+ data　　<span class="hljs-comment">//动态地改变currentView的值就可以动态挂载组件了。</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"> &#125;,</span><br><span class="javascript"> <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">  <span class="hljs-attr">comA</span>: &#123;</span><br><span class="javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;组件A&lt;/p&gt;&#x27;</span></span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">comB</span>: &#123;</span><br><span class="javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;组件B&lt;/p&gt;&#x27;</span></span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">comC</span>: &#123;</span><br><span class="javascript">   <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;组件C&lt;/p&gt;&#x27;</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"> &#125;</span><br><span class="javascript">&#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-在动态组件上使用-keep-alive"><a href="#2-在动态组件上使用-keep-alive" class="headerlink" title="2. 在动态组件上使用 keep-alive"></a><span id="jump10">2. 在动态组件上使用 <code>keep-alive</code></span></h4><p><code>&lt;keep-alive&gt; </code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt; </code>相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p><p> 当组件在<code> &lt;keep-alive&gt;</code> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。  主要用于保留组件状态或避免重新渲染。</p><p><strong>详细见</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/96740001">利用Vue中keep-alive，快速实现页面缓存</a></p><p><a href="https://www.jianshu.com/p/aad6c4f644f3">Vue keep-alive详解</a></p><h4 id="3-异步组件"><a href="#3-异步组件" class="headerlink" title="3. 异步组件"></a><span id="jump11">3. 异步组件</span></h4><p><a href="https://www.ucloud.cn/yun/88982.html">vue项目实现按需加载的3种方式：vue异步组件、es提案的import()、webpack的require.ensure()</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础：计算属性 与 侦听器</title>
    <link href="/2020/04/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E5%9F%BA%E7%A1%80%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20%E4%B8%8E%20%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
    <url>/2020/04/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E5%9F%BA%E7%A1%80%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20%E4%B8%8E%20%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="（一）计算属性computed"><a href="#（一）计算属性computed" class="headerlink" title="（一）计算属性computed"></a>（一）计算属性computed</h2><p>对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><p><strong>计算属性是基于它们的响应式依赖进行缓存的。</strong>只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要依赖数据没有发生改变，computed将从缓存中获取之前的计算结果，而不必再次执行函数。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br><span class="javascript">  <span class="hljs-attr">data</span>: &#123;</span><br><span class="javascript">    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span></span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="javascript">    <span class="hljs-comment">// 计算属性的 getter</span></span><br><span class="javascript">    <span class="hljs-attr">reversedMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-comment">// `this` 指向 vm 实例</span></span><br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面声明了一个计算属性 <code>reversedMessage</code>。其中我们提供的函数将用作属性 <code>vm.reversedMessage</code> 的 getter 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(vm.reversedMessage) <span class="hljs-comment">// =&gt; &#x27;olleH&#x27;</span><br>vm.message = <span class="hljs-string">&#x27;Goodbye&#x27;</span><br><span class="hljs-built_in">console</span>.log(vm.reversedMessage) <span class="hljs-comment">// =&gt; &#x27;eybdooG&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-计算属性的-setter"><a href="#2-计算属性的-setter" class="headerlink" title="2. 计算属性的 setter"></a>2. 计算属性的 setter</h4><p>计算属性默认只有 getter，不过在需要时也可以提供一个 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-attr">fullName</span>: &#123;<br>    <span class="hljs-comment">// getter</span><br>    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName<br>    &#125;,<br>    <span class="hljs-comment">// setter</span><br>    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> names = newValue.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>      <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>]<br>      <span class="hljs-built_in">this</span>.lastName = names[names.length - <span class="hljs-number">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h2 id="（二）侦听器watch"><a href="#（二）侦听器watch" class="headerlink" title="（二）侦听器watch"></a>（二）侦听器watch</h2><p> watch 对象就是侦听器，只有当侦听的值改变了它才会执行。</p><h4 id="1-基本使用-1"><a href="#1-基本使用-1" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">e</span>: &#123;<br>        <span class="hljs-attr">f</span>: &#123;<br>            <span class="hljs-attr">g</span>: <span class="hljs-number">5</span><br>        &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;new: %s, old: %s&#x27;</span>, val, oldVal)<br>    &#125;,<br>    <span class="hljs-comment">// 方法名</span><br>    <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;someMethod&#x27;</span>,  <span class="hljs-comment">//在方法里写对应的函数</span><br>    <span class="hljs-comment">// 深度 watcher</span><br>    <span class="hljs-attr">c</span>: &#123;<br>      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,<br>      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 更改对象的时候需要用深度监听</span><br>    &#125;,<br>    <span class="hljs-comment">// 该回调将会在侦听开始之后被立即调用</span><br>    <span class="hljs-attr">d</span>: &#123;<br>      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,<br>      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">//该属性能使函数默认的执行一次</span><br>    &#125;,<br>    <span class="hljs-attr">e</span>: [<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle1</span>(<span class="hljs-params">val, oldVal</span>)</span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle2</span>(<span class="hljs-params">val, oldVal</span>)</span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,<br>    ],<br>    <span class="hljs-comment">// 监听vm.e.f的值: &#123;g: 5&#125;</span><br>    <span class="hljs-string">&#x27;e,f&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, oldVal</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  &#125;<br>&#125;)<br>vm.a = <span class="hljs-number">2</span> <span class="hljs-comment">// =&gt; new: 2, old: 1</span><br></code></pre></td></tr></table></figure><p>注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p><h4 id="2-与计算属性computed使用场景的对比"><a href="#2-与计算属性computed使用场景的对比" class="headerlink" title="2. 与计算属性computed使用场景的对比"></a>2. 与计算属性computed使用场景的对比</h4><ul><li><code>watch</code>选项允许我们执行异步操作（访问一个API）或高消耗性能的操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态</li><li><code>computed</code> 是计算一个新的属性，并将该属性挂载到 <code>vm</code>（Vue 实例）上，而 <code>watch</code> 是监听已经存在且已挂载到 <code>vm</code> 上的数据，所以用 <code>watch</code> 同样可以监听 <code>computed</code> 计算属性的变化（其它还有 data、props）</li><li><code>computed</code> 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 <code>computed</code> 属性，才会计算新的值，而 <code>watch</code> 则是当数据发生变化便会调用执行函数</li><li><code>computed</code> 适用一个数据被多个数据影响，而 <code>watch</code> 适用一个数据影响多个数据</li></ul><p><strong>详细见</strong>：</p><p><a href="https://cn.vuejs.org/v2/api/#vm-watch">Vue官方文档 - vm.$watch</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础：指令</title>
    <link href="/2020/04/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/04/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a><a href="#jump1">v-html</a></h4></li><li><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><a href="#jump2">v-for</a></h4></li><li><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><a href="#jump3">v-if</a></h4></li><li><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><a href="#jump4">v-show</a></h4></li><li><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><a href="#jump5">v-model</a></h4></li><li><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><a href="#jump6">v-bind</a></h4></li><li><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><a href="#jump7">v-on</a></h4></li><li><h4 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a><a href="#jump8">v-once</a></h4></li></ul><h2 id="1-v-html："><a href="#1-v-html：" class="headerlink" title="1. v-html： "></a><span id="jump1">1. <code>v-html</code>： </span></h2><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，需要使用该指令。它使内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--这个 span 的内容将会被替换成为属性值 rawHtml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <br></code></pre></td></tr></table></figure><h2 id="2-v-for-："><a href="#2-v-for-：" class="headerlink" title="2. v-for ："></a><span id="jump2">2. <code>v-for</code> ：</span></h2><p> 可以绑定数组的数据来渲染一个项目列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1. 用 v-for 把一个数组对应为一组元素。第一个参数为被迭代的数组元素的别名，还支持一个可选的第二个参数，即当前项的索引。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>      &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">data: &#123;</span><br><span class="hljs-comment">    parentMessage: &#x27;Parent&#x27;,</span><br><span class="hljs-comment">    items: [</span><br><span class="hljs-comment">      &#123; message: &#x27;Foo&#x27;, id: 1 &#125;,</span><br><span class="hljs-comment">      &#123; message: &#x27;Bar&#x27;, id: 2 &#125;</span><br><span class="hljs-comment">    ]</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 用 v-for 来遍历一个对象的属性。第一个参数为被迭代的对象属性值，也可以提供第二个的参数为 property 名称 (也就是键名)。还可以用第三个参数作为索引。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in object&quot;</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name) in object&quot;</span>&gt;</span>&#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in object&quot;</span>&gt;</span>&#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">data: &#123;</span><br><span class="hljs-comment">    object: &#123;</span><br><span class="hljs-comment">      title: &#x27;How to do lists in Vue&#x27;,</span><br><span class="hljs-comment">      author: &#x27;Jane Doe&#x27;,</span><br><span class="hljs-comment">      publishedAt: &#x27;2016-04-10&#x27;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 3. 可以利用带有 v-for 的 &lt;template&gt; 来循环渲染一段包含多个元素的内容。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;divider&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;presentation&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p><p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。</p><p>当<code>v-for</code>和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。</p><h2 id="3-v-if："><a href="#3-v-if：" class="headerlink" title="3. v-if： "></a><span id="jump3">3. <code>v-if</code>： </span></h2><p>将根据后面表达式的值的真假来插入/移除元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>Not A/B/C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-v-show："><a href="#4-v-show：" class="headerlink" title="4. v-show："></a><span id="jump4">4. <code>v-show</code>：</span></h2><p>用于根据条件展示元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>与<code>v-if</code>的区别</strong>：</p><ul><li><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p></li><li><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p></li><li><p>而带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p></li><li><p><code>v-if</code>支持 <code>&lt;template&gt;</code> 元素，也支持 <code>v-else</code>。 <code>v-show</code> 都不支持。</p></li><li><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p></li></ul><h2 id="5-v-model："><a href="#5-v-model：" class="headerlink" title="5. v-model： "></a><span id="jump5">5. <code>v-model</code>： </span></h2><p>它能轻松实现表单输入和应用状态之间的双向数据绑定。</p><p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p><p><code>v-model</code> 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1. 文本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;edit me&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 多行文本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;white-space: pre-line;&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;add multiple lines&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 3. 复选框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mike&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mike&quot;</span>&gt;</span>Mike<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  data: &#123;</span><br><span class="hljs-comment">    checkedNames: []</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 4. 单选按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;One&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;picked&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;two&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Two&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;picked&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  data: &#123;</span><br><span class="hljs-comment">    picked: &#x27;&#x27;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 5. 选择框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  data: &#123;</span><br><span class="hljs-comment">    selected: &#x27;&#x27;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 6. 多选时 (绑定到一个数组) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span> <span class="hljs-attr">multiple</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 50px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  data: &#123;</span><br><span class="hljs-comment">    selected: []</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 7. 修饰符 --&gt;</span><br><span class="hljs-comment">&lt;!--  (1) 在“change”时而非“input”时更新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--  (2) 自动将用户的输入值转为数值类型 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--  (3) 自动过滤用户输入的首尾空白字符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 8. 值绑定 --&gt;</span><br><span class="hljs-comment">&lt;!-- (1)当选中时，vm.pick === vm.a --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pick&quot;</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (2) 当选中时:vm.toggle === &#x27;yes&#x27;, 当没有选中时,vm.toggle === &#x27;no&#x27; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;toggle&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">true-value</span>=<span class="hljs-string">&quot;yes&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">false-value</span>=<span class="hljs-string">&quot;no&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><span class="hljs-comment">&lt;!-- (3)当选中时, typeof vm.selected =&gt; &#x27;object&#x27;, vm.selected.number =&gt; 123 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内联对象字面量 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;&#123; number: 123 &#125;&quot;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6-v-bind："><a href="#6-v-bind：" class="headerlink" title="6. v-bind："></a><span id="jump6">6. <code>v-bind</code>：</span></h2><p>绑定元素 attribute。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1. 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:disabled</span>=<span class="hljs-string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 内联字符串拼接 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;&#x27;/path/to/images/&#x27; + fileName&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 3. 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 4. 动态参数 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 5. 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 6. class 绑定 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">data: &#123;</span><br><span class="hljs-comment">  classObject: &#123;</span><br><span class="hljs-comment">    active: true,</span><br><span class="hljs-comment">    &#x27;text-danger&#x27;: false</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  isActive: true,</span><br><span class="hljs-comment">  hasError: false,</span><br><span class="hljs-comment">  activeClass: &#x27;active&#x27;,</span><br><span class="hljs-comment">  errorClass: &#x27;text-danger&#x27;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 7. style 绑定 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[styleObjectA, styleObjectB]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">data: &#123;</span><br><span class="hljs-comment">  activeColor: &#x27;red&#x27;,</span><br><span class="hljs-comment">  fontSize: 30</span><br><span class="hljs-comment">  styleObject: &#123;</span><br><span class="hljs-comment">    color: &#x27;red&#x27;,</span><br><span class="hljs-comment">    fontSize: &#x27;13px&#x27;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!-- 8. 绑定一个有属性的对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 9. 通过 prop 修饰符绑定 DOM 属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:text-content.prop</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 10. prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">:prop</span>=<span class="hljs-string">&quot;someThing&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 11. 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$props&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-v-on-："><a href="#7-v-on-：" class="headerlink" title="7. v-on ："></a><span id="jump7">7. <code>v-on</code> ：</span></h2><p>指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1. 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 内联语句 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething(&#x27;hello&#x27;, $event)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 3. 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 4. 动态参数 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:</span>[<span class="hljs-attr">eventName</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 5. 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 6. 对象语法 (2.4.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 7. 事件修饰符 --&gt;</span><br><span class="hljs-comment">&lt;!-- (1)停止冒泡 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (2)阻止默认行为 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (3)阻止默认行为，没有表达式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-comment">&lt;!--  (4)串联修饰符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (5)键修饰符，键别名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (6)键修饰符，键代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.13</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- (7)点击回调只会触发一次 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.once</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-v-once-："><a href="#8-v-once-：" class="headerlink" title="8.  v-once ："></a><span id="jump8">8.  <code>v-once</code> ：</span></h2><p>通过该指令，只能执行一次性地插值，当数据改变时，插值处的内容不会更新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>详细见：</strong>   <strong><a href="https://cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4">Vue官方文档 -指令</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2 双向绑定原理（数据响应式</title>
    <link href="/2020/04/19/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue2%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <url>/2020/04/19/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue2%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1. MVVM"></a><a href="#jumpa">1. MVVM</a></h4><ul><li><a href="#jump1"><strong>定义</strong></a></li><li><a href="#jump2"><strong>优点</strong></a></li><li><a href="#jump3"><strong>缺点</strong></a></li></ul><h4 id="2-Vue2-双向绑定原理（数据响应式"><a href="#2-Vue2-双向绑定原理（数据响应式" class="headerlink" title="2. Vue2 双向绑定原理（数据响应式)"></a><a href="#jumpb">2. Vue2 双向绑定原理（数据响应式)</a></h4><ul><li><a href="#jump4"><strong>原理概述</strong></a></li><li><a href="#jump5"><strong>数据劫持</strong></a></li><li><a href="#jump6"><strong>发布与订阅</strong></a></li></ul><h2 id="（一）MVVM"><a href="#（一）MVVM" class="headerlink" title="（一）MVVM"></a><span id="jumpa">（一）MVVM</span></h2><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a><span id="jump1">1. 定义：</span></h4><p>MVVM 是 Model-View-ViewModel（模型-视图-视图模型）的缩写；是一种软件架构设计模式。</p><p>其中：</p><ul><li>Model：是数据模型，既后端传过来的数据；</li><li>View：是视图层，既我们看到的页面；</li><li>ViewModel：是连接Model和View的中间桥梁</li></ul><p>在MVVM的框架下，View和Model是不能直接通信的，Model与View之间通过ViewMode关联。ViewModel负责将Model数据的变化显示到View上，将View的改变反馈到Model上。这就是我们常说的<strong>双向绑定数据</strong>机制。</p><h4 id="2-优点："><a href="#2-优点：" class="headerlink" title="2. 优点："></a><span id="jump2">2. 优点：</span></h4><ul><li>降低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li>可重用性：可以把一些视图逻辑放在ViewModel层中，让很多View重用这些视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>可测试。界面素来是比较难于测试的，测试可以针对ViewModel来写。</li></ul><h4 id="3-缺点："><a href="#3-缺点：" class="headerlink" title="3. 缺点："></a><span id="jump3">3. 缺点：</span></h4><ul><li>数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。</li><li>因为使用了dataBinding，增加了大量的内存开销，增加了程序的编译时间，项目越大内存开销越大。</li></ul><p>那如何设计MVVM模型模型呢。需要解决两个关键问题：</p><ul><li><p>如何知道数据更新。</p></li><li><p>数据更新后，如何通知变化。</p></li></ul><p>下面就分别介绍vue是如何实现的以上两点，理解了这两点，基本上也就明白了双向绑定的机制。</p><h2 id="（二）Vue2-双向绑定原理（数据响应式）"><a href="#（二）Vue2-双向绑定原理（数据响应式）" class="headerlink" title="（二）Vue2 双向绑定原理（数据响应式）"></a><span id="jumpb">（二）Vue2 双向绑定原理（数据响应式）</span></h2><h4 id="1-原理概述"><a href="#1-原理概述" class="headerlink" title="1. 原理概述"></a><span id="jump4">1. 原理概述</span></h4><p>Vue2 采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。</p><p>要实现MVVM的双向绑定，就必须要实现以下几点：</p><ul><li>Compile—指令解析系统，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li><li>Observer—数据的观察者,让数据对象的读写操作都处于自己的监管之下。当初始化实例的时候，会递归遍历data，用Object.defineProperty来拦截数据（包含数组里的每个数据）。</li><li>Dep+Watcher—发布订阅模型，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。</li></ul><p>mvvm入口函数，整合以上三者，具体如图所示：</p><p><img src="C:\Users\lin\Desktop\1.jpg"></p><p>下面分别说明数据劫持与发布者-订阅者模式。</p><h4 id="2-数据劫持"><a href="#2-数据劫持" class="headerlink" title="2. 数据劫持"></a><span id="jump5">2. 数据劫持</span></h4><p><strong><code>Object.defineProperty()</code></strong></p><p>在ES5中有<code>Object.defineProperty()</code>方法，它能监听各个属性的set和get方法。</p><p>Object.defineProperty()方法，有三个参数，分别为待监听的数据对象，待监听的属性，以及对set，get的监听方法。</p><p>例如：对data对象的name属性进行监听，当执行<code>&quot;data.name=&#39;fyn&#39;&quot;</code>触发set方法，执行<code>&quot;data.name&quot;</code>触发get方法。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">let</span> data =&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tcy&#x27;</span>&#125;<br>  <span class="hljs-built_in">Object</span>.defineProperty(data,<span class="hljs-string">&#x27;name&#x27;</span>,&#123;<br>  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;更新了data的name:&#x27;</span> + newValue);<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取data数据name&#x27;</span>);<br>    &#125;<br>  &#125;)<br>data.name=<span class="hljs-string">&quot;fyn&quot;</span>;<span class="hljs-comment">//更新了data的name:fyn</span><br>data.name;<span class="hljs-comment">//获取data数据name</span><br></code></pre></td></tr></table></figure><p><strong>什么是数据劫持</strong></p><p>通过上面对Object.defineProperty的介绍，我们不难发现，当我们访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。</p><p>既然如此，我们当然可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。</p><p><strong>模拟Vue实现数据劫持</strong></p><p>vue正是采用了<code>Object.defineProperty()</code>方法，对data的属性进行劫持。我们来模拟实现其劫持的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">模拟vue的data数据</span><br><span class="hljs-comment"> var vm = new Vue(</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">   data:&#123;</span><br><span class="hljs-comment">       name:&#x27;tcy&#x27;,</span><br><span class="hljs-comment">       age:&#x27;20&#x27;</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment"> &#125;</span><br><span class="hljs-comment"> )</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> data =&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tcy&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;20&#x27;</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">data</span>)</span>&#123;<br><span class="hljs-comment">//获取所有的data数据对象中的所有属性进行遍历</span><br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(data)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> val = data[keys[i]];<br>       defineReactive(data, keys[i],val)<span class="hljs-comment">//为每个属性增加监听</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj,key,val</span>)</span>&#123;<br>   <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//可枚举</span><br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//可配置</span><br>    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">//模拟get劫持</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;get劫持&quot;</span>);<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;<br>       <span class="hljs-comment">//模拟set劫持</span><br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;set劫持,新值：&quot;</span>+newVal);<br>     val = newVal;<br>    &#125;<br>  &#125;)<br>&#125;<br>observe(data);<br>data.name=<span class="hljs-string">&quot;fyn&quot;</span>;<span class="hljs-comment">//set劫持,新值：fyn</span><br><span class="hljs-built_in">console</span>.log(data.name);<span class="hljs-comment">//get劫持,fyn</span><br></code></pre></td></tr></table></figure><p>data 模拟 vue.data 对象，observer 中对 data 的属性进行遍历，调用 defineReactive 对每个属性的 get 和 set 方法进行劫持。</p><p>由此，data数据的任何属性值变化，都可以监听和劫持，上述的第一个问题（如何知道数据更新）就解决了。那view端的数据变化是如何知道的呢，view端改变数据的组件无外乎input，select等，可以用组件的 onchange 事件监听，这里就不再重点描述。</p><h4 id="3-发布与订阅"><a href="#3-发布与订阅" class="headerlink" title="3. 发布与订阅"></a><span id="jump6">3. 发布与订阅</span></h4><p>vue在双向绑定的设计中，采用的是观察-订阅模式，前面所讲的数据劫持，其实就是为属性创建了一个观察者对象，监听数据的变化。接下来就是创建发布类和订阅类。</p><p>来看一下下面的图：</p><p><img src="C:\Users\lin\Desktop\3.png"></p><p>图中：</p><ul><li><p>observer，创建数据监听，并为每个属性建立一个发布类。</p></li><li><p>Dep是发布订阅者模型中的发布者：get数据的时候，收集订阅者，触发Watcher的依赖收集；set数据时发布更新，通知Watcher 。一个Dep实例对应一个对象属性或一个被观察的对象，用来收集订阅者和在数据改变时，发布更新。</p></li><li><p>Watcher是发布订阅者模型中的订阅者：订阅的数据改变时执行相应的回调函数（更新视图或表达式的值）。一个Watcher可以更新视图，如html模板中用到的<code>&#123;&#123;test&#125;&#125;</code>，也可以执行一个<code>$watch</code>监督的表达式的回调函数（Vue实例中的watch项底层是调用的<code>$watch</code>实现的）,还可以更新一个计算属性（即Vue实例中的computed项）。</p></li></ul><p>其中：</p>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue：生命周期</title>
    <link href="/2020/04/19/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/04/19/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p><h2 id="（一）生命周期钩子-按顺序依次为："><a href="#（一）生命周期钩子-按顺序依次为：" class="headerlink" title="（一）生命周期钩子  按顺序依次为："></a>（一）生命周期钩子  按顺序依次为：</h2><h4 id="1-beforeCreate"><a href="#1-beforeCreate" class="headerlink" title="1. beforeCreate()"></a>1. <code>beforeCreate()</code></h4><p>在实例初始化事件和生命周期之后、数据观测和事件配置之前被调用。</p><p>此时，组件的选项对象还未创建，date、method和el均没有初始化，因此无法访问到数据data， methods、computed等上的方法和数据以及真实的DOM。一般不做挂载数据，绑定事件等操作。</p><h4 id="2-created"><a href="#2-created" class="headerlink" title="2. created()"></a>2. <code>created()</code></h4><p>在实例已经创建完成之后被调用。</p><p>此时，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化。 然而，el没有还未初始化，挂载阶段还没有开始, $el属性目前不可见。</p><p>这是一个常用的生命周期，可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，获取computed中的计算属性等等。</p><h4 id="3-beforeMount"><a href="#3-beforeMount" class="headerlink" title="3. beforeMount()"></a>3. <code>beforeMount()</code></h4><p>在挂载开始之前被调用，相关的render函数首次被调用（虚拟DOM）。</p><p>此时，实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，然而，还没有挂载html到页面上。</p><p>该钩子在服务端渲染期间不被调用。 </p><h4 id="4-mounted"><a href="#4-mounted" class="headerlink" title="4. mounted()"></a>4. <code>mounted()</code></h4><p>挂载完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作。</p><p>该钩子在服务端渲染期间不被调用。 </p><h4 id="5-beforeUpdate"><a href="#5-beforeUpdate" class="headerlink" title="5. beforeUpdate()"></a>5. <code>beforeUpdate()</code></h4><p>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程。</p><p>该钩子在服务端渲染期间不被调用。 </p><h4 id="6-updated"><a href="#6-updated" class="headerlink" title="6. updated()"></a>6. <code>updated()</code></h4><p>在由于数据更改导致地虚拟DOM重新渲染和打补丁之后调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p><p>该钩子在服务器端渲染期间不被调用</p><h4 id="7-beforeDestroy"><a href="#7-beforeDestroy" class="headerlink" title="7. beforeDestroy()"></a>7. <code>beforeDestroy()</code></h4><p>在实例销毁之前调用，实例仍然完全可用。</p><p>此时，还可以用this来获取实例，一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件。</p><p>该钩子在服务端渲染期间不被调用。 </p><h4 id="8-destroy"><a href="#8-destroy" class="headerlink" title="8. destroy()"></a>8. <code>destroy()</code></h4><p>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用。</p><h4 id="用更直观的图说明："><a href="#用更直观的图说明：" class="headerlink" title="用更直观的图说明："></a>用更直观的图说明：</h4><ul><li><p><strong>生命周期</strong>：</p><p><img src="C:\Users\lin\Desktop\4.png" alt="4"></p></li><li><p><strong>创建阶段</strong>：</p><p><img src="C:\Users\lin\Desktop\5.png" alt="5"></p></li><li><p><strong>更新阶段</strong>：</p><p><img src="C:\Users\lin\Desktop\6.png" alt="6"></p></li><li><p><strong>销毁阶段</strong>：</p><p><img src="C:\Users\lin\Desktop\7.png" alt="7"></p></li></ul><p><strong>注意点：</strong></p><ul><li>不要在选项属性或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致错误。</li><li>如果不指定 el 选项，就只会执行  beforeCreate() 、created()。</li><li>做一些和DOM有关的操作时，一般放在mounted()</li><li>和数据有关的操作一般放在created()或mounted()</li><li>beforeCreate()、created()、beforeMount()、mounted()在组件生命周期中只执行一次。</li></ul><h4 id="10-Vue实例和子组件之间的生命周期"><a href="#10-Vue实例和子组件之间的生命周期" class="headerlink" title="10. Vue实例和子组件之间的生命周期"></a>10. Vue实例和子组件之间的生命周期</h4><p>在Vue中，由于父元素的template模板嵌套了子元素，因此在编译模板时，会先进入到父元素的template，然后层层递归进行子元素的模板编译。</p><ul><li>在创建时，父子组件的生命周期是：<br>父组件beforeCreated -&gt; 父组件created -&gt; 父组件beforeMounted -&gt; <strong>子组件beforeCreated -&gt; 子组件created -&gt; 子组件beforeMounted -&gt; 子组件mounted</strong> -&gt; 父组件mounted。</li><li>在销毁时，父子组件的生命周期是：<br>父组件beforeDestory -&gt; <strong>子组件beforeDestoryed -&gt; 子组件destoryed</strong> -&gt; 父组件destoryed</li></ul><p>总之记住，父子组件的生命周期遵循：<strong>由外到内，再由内到外</strong></p><h2 id="（二）官方的生命周期图示"><a href="#（二）官方的生命周期图示" class="headerlink" title="（二）官方的生命周期图示"></a>（二）官方的生命周期图示</h2><p><img src="C:\Users\lin\Desktop\lifecycle.png"></p><p><strong>参考链接：</strong></p><p><a href="https://segmentfault.com/a/1190000014816685">Vue的生命周期详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同版本vue-cli区别详解</title>
    <link href="/2020/04/19/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACvue-cli%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/04/19/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACvue-cli%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="不同版本vue-cli区别详解"><a href="#不同版本vue-cli区别详解" class="headerlink" title="不同版本vue-cli区别详解"></a>不同版本vue-cli区别详解</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><h4 id="vue-cli-命令"><a href="#vue-cli-命令" class="headerlink" title="vue-cli 命令"></a><a href="#jump1">vue-cli 命令</a></h4></li><li><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><a href="#jump2">项目结构</a></h4></li><li><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a><a href="#jump2">设置环境变量</a></h4></li></ul><h2 id="（一）vue-cli-命令"><a href="#（一）vue-cli-命令" class="headerlink" title="（一）vue-cli 命令"></a><span id="jump1">（一）vue-cli 命令</span></h2><h4 id="1-vue-cli下载安装："><a href="#1-vue-cli下载安装：" class="headerlink" title="1. vue-cli下载安装："></a>1. vue-cli下载安装：</h4><ul><li><p>vue-cli2:</p><p><code>npm install vue-cli -g</code></p></li><li><p>vue-cli3/cli4:</p><p><code>npm install -g vue@cli</code></p></li></ul><h4 id="2-创建新项目"><a href="#2-创建新项目" class="headerlink" title="2. 创建新项目"></a>2. 创建新项目</h4><ul><li><p>vue-cli2:</p><p><code>vue init webpack 2.0project</code></p></li><li><p>vue-cli3/cli4:</p><p><code>vue create 3.0project</code></p><p>或通过视图创建项目：<code>vue ui</code></p></li></ul><h4 id="3-启动项目"><a href="#3-启动项目" class="headerlink" title="3. 启动项目"></a>3. 启动项目</h4><ul><li><p>vue-cli2:</p><p><code>npm run dev</code></p></li><li><p>vue-cli3/cli4:</p><p><code>npm run serve</code></p></li></ul><h2 id="（二）项目结构"><a href="#（二）项目结构" class="headerlink" title="（二）项目结构"></a><span id="jump2">（二）项目结构</span></h2><p>vue-cli3/cli4中移除了配置文件目录：<code>config</code> 和 <code>build</code> 文件夹。</p><p>同时移除了 <code>static</code> 静态文件夹，新增了 <code>public</code> 文件夹，将 <code>index.html</code> 移动到 <code>public</code> 中。</p><h4 id="1-vue-cli2"><a href="#1-vue-cli2" class="headerlink" title="1. vue-cli2"></a>1. vue-cli2</h4><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">|-- build                            <span class="hljs-regexp">//</span> 项目构建(webpack)相关代码<br>|   |-- build.js                     <span class="hljs-regexp">//</span> 生产环境构建代码<br>|   |-- check-version.js             <span class="hljs-regexp">//</span> 检查node、npm等版本<br>|   |-- utils.js                     <span class="hljs-regexp">//</span> 构建工具相关<br>|   |-- vue-loader.conf.js           <span class="hljs-regexp">//</span> webpack loader配置<br>|   |-- webpack.base.conf.js         <span class="hljs-regexp">//</span> webpack基础配置<br>|   |-- webpack.dev.conf.js          <span class="hljs-regexp">//</span> webpack开发环境配置,构建开发本地服务器<br>|   |-- webpack.prod.conf.js         <span class="hljs-regexp">//</span> webpack生产环境配置<br>|-- config                           <span class="hljs-regexp">//</span> 项目开发环境配置<br>|   |-- dev.env.js                   <span class="hljs-regexp">//</span> 开发环境变量<br>|   |-- index.js                     <span class="hljs-regexp">//</span> 项目一些配置变量<br>|   |-- prod.env.js                  <span class="hljs-regexp">//</span> 生产环境变量<br>|-- src                              <span class="hljs-regexp">//</span> 源码目录<br>|   |-- components                   <span class="hljs-regexp">//</span> vue公共组件<br>|   |-- router                       <span class="hljs-regexp">//</span> vue的路由管理<br>|   |-- App.vue                      <span class="hljs-regexp">//</span> 页面入口文件<br>|   |-- main.js                      <span class="hljs-regexp">//</span> 程序入口文件，加载各种公共组件<br>|-- static                           <span class="hljs-regexp">//</span> 静态文件，比如一些图片，json数据等<br>|-- .babelrc                         <span class="hljs-regexp">//</span> ES6语法编译配置<br>|-- .editorconfig                    <span class="hljs-regexp">//</span> 定义代码格式<br>|-- .gitignore                       <span class="hljs-regexp">//</span> git上传需要忽略的文件格式<br>|-- .postcsssrc                      <span class="hljs-regexp">//</span> postcss配置文件<br>|-- README.md                        <span class="hljs-regexp">//</span> 项目说明<br>|-- index.html                       <span class="hljs-regexp">//</span> 入口页面<br>|-- package.json                     <span class="hljs-regexp">//</span> 项目基本信息,包依赖信息等<br></code></pre></td></tr></table></figure><p>推荐阅读：</p><p><a href="https://blog.csdn.net/tanzhenyan/article/details/78871610">vue-cli项目结构详解</a></p><h4 id="2-vue-cli3-cli4"><a href="#2-vue-cli3-cli4" class="headerlink" title="2. vue cli3/cli4"></a>2. vue cli3/cli4</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">|-- src                            <span class="hljs-regexp">//</span> 源码目录<br>|  |-- components                  <span class="hljs-regexp">//</span> vue公共组件<br>|  |-- router                      <span class="hljs-regexp">//</span> vue的路由管理<br>|  |-- App.vue                     <span class="hljs-regexp">//</span> 页面入口文件<br>|  |-- main.js                     <span class="hljs-regexp">//</span> 程序入口文件，加载各种公共组件<br>|-- public                         <span class="hljs-regexp">//</span> 静态文件，比如一些图片，json数据等<br>|  |-- favicon.ico                 <span class="hljs-regexp">//</span> 图标文件<br>|  |-- index.html                  <span class="hljs-regexp">//</span> 入口页面<br>|-- vue.config.js                  <span class="hljs-regexp">//</span> 是一个可选的配置文件，包含了大部分的vue项目配置<br>|-- .babelrc                       <span class="hljs-regexp">//</span> ES6语法编译配置<br>|-- .editorconfig                  <span class="hljs-regexp">//</span> 定义代码格式<br>|-- .gitignore                     <span class="hljs-regexp">//</span> git上传需要忽略的文件格式<br>|-- .postcsssrc                    <span class="hljs-regexp">//</span> postcss配置文件<br>|-- README.md                      <span class="hljs-regexp">//</span> 项目说明<br>|-- package.json                  <span class="hljs-regexp">//</span> 项目基本信息,包依赖信息等<br></code></pre></td></tr></table></figure><h2 id="（三）设置环境变量"><a href="#（三）设置环境变量" class="headerlink" title="（三）设置环境变量"></a><span id="jump3">（三）设置环境变量</span></h2><p>项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。</p><p>不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。</p><h4 id="1-vue-cli2-1"><a href="#1-vue-cli2-1" class="headerlink" title="1. vue-cli2:"></a>1. vue-cli2:</h4><p>推荐阅读：</p><p><a href="https://www.cnblogs.com/sinosaurus/p/10294399.html">vue-cli如何添加多种环境变量</a></p><h4 id="2-vue-cli3："><a href="#2-vue-cli3：" class="headerlink" title="2. vue-cli3："></a>2. vue-cli3：</h4><p>vue-cli3构建的项目中默认只有development模式和production模式，默认的NODE_ENV分别是development和production，很多配置也只依据NODE_ENV区分这2种模式。</p><p>但当我们需要其他模式，如测试模式时，就需要添加相关配置。</p><p>详细设置过程，推荐看：</p><p><a href="https://www.cnblogs.com/sinosaurus/p/10294399.html">vue-cli如何添加多种环境变量</a></p><p><strong>补充：</strong></p><p>在 .env.[mode] 模式文件中，三个环境变量及其含义：</p><ul><li> <code>NODE_ENV</code>（对应当前模式的名称）</li><li><code>VUE_APP_RUNTIME_ENV</code>（对应当前环境的名称）</li><li><code>VUE_APP_BASE_URL</code>（当前环境向后台发请求的baseurl）</li></ul><p>使用环境变量：</p><p>只有以 <code>VUE_APP_</code> 开头的变量会被 <code>webpack.DefinePlugin</code> 静态嵌入到客户端侧的包中。</p><p>在js文件或者在vue文件中process.env.{环境变量名}，比如上文定义的VUE_APP_BASE_URL，使用process.env.VUE_APP_BASE_URL即可获取环境变量的值。</p><p>在html文件中使用环境变量，采用模板引用指令&lt;%= process.env.process.env.{环境变量名} %&gt;，比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx.com&quot;</span> <span class="hljs-attr">app_id</span>=<span class="hljs-string">&quot;&lt;%= process.env.process.env.MY_APP_ID %&gt;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-vue-cli4"><a href="#3-vue-cli4" class="headerlink" title="3. vue-cli4"></a>3. vue-cli4</h4><p>推荐阅读：</p><p><a href="https://blog.csdn.net/qq_28988969/article/details/104558991">vue cli4-环境变量和模式</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue：模板编译 Virtual DOM</title>
    <link href="/2020/04/17/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%20Virtual%20DOM/"/>
    <url>/2020/04/17/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%20Virtual%20DOM/</url>
    
    <content type="html"><![CDATA[<h2 id="（一）Vue模板编译"><a href="#（一）Vue模板编译" class="headerlink" title="（一）Vue模板编译"></a>（一）Vue模板编译</h2><p>在Vue中我们有三种方式来创建HTML</p><ul><li>模板</li><li>手动写渲染函数</li><li>JSX</li></ul><p>渲染函数是最原始的方法，而模板最终会通过编译转换陈渲染函数。渲染函数执行后，会得到一份vnode用来渲染真实DOM。所以，模板编译其实是配合虚拟DOM进行渲染。</p><h4 id="1-什么是模板编译？"><a href="#1-什么是模板编译？" class="headerlink" title="1. 什么是模板编译？"></a>1. 什么是模板编译？</h4><p>所谓模板编译就是把模板编译成vnode的渲染函数。</p><h4 id="2-模板编译过程："><a href="#2-模板编译过程：" class="headerlink" title="2. 模板编译过程："></a>2. 模板编译过程：</h4><p>模板编译可以分为三个阶段：<br><img src="https://img-blog.csdnimg.cn/20200419204823902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p>将模板解析为AST（抽象语法树）—— 解析器</p></li><li><p>遍历AST，对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化 —— 优化器</p></li><li><p>使用AST生成render函数代码字符串—— 代码生成器</p></li></ul><p>关于模板编译的源码可以在<code>vue-template-compiler</code>包中查看。</p><h2 id="（二）Vue虚拟DOM"><a href="#（二）Vue虚拟DOM" class="headerlink" title="（二）Vue虚拟DOM"></a>（二）Vue虚拟DOM</h2><h4 id="1-Virtual-DOM"><a href="#1-Virtual-DOM" class="headerlink" title="1. Virtual DOM"></a>1. Virtual DOM</h4><p><strong>概念：</strong></p><p> Virtual DOM是一个能够直接描述一段HTML DOM结构的JavaScript对象，浏览器可以根据它的结构按照一定规则创建出确定唯一的HTML DOM结构。</p><p><strong>实现原理：</strong></p><p>Virtual DOM模式来控制页面DOM结构更新的过程：创建原始页面或组件的Virtual DOM结构，用户操作后需要进行DOM更新时，生成用户操作后页面或组件的Virtual DOM结构并与之前的结构进行比对，找到最小变化Virtual DOM的差异化描述对象，最后把差异化的Virtual DOM根据特定的规则渲染到页面上。</p><p> 所以核心操作可以抽象成三个步骤：</p><ul><li>创建Virtual DOM</li><li>对比两个Virtual DOM生成差异化Virtual DOM</li><li>将差异化Virtual DOM渲染到页面上</li></ul><p><strong>优势：</strong></p><p>Virtual DOM的交互模式减少了MVVM或其他框架中对DOM的扫描和操作次数，并且在数据发生改变后只在合适的地方根据JavaScript对象来进行最小化的页面DOM操作，避免大量重新渲染。</p><p>Virtual DOM交互模式的优势 与以前交互模式相比，Virtual DOM最本质的区别在于减少了对DOM对象的操作，通过JavaScript 对象来代替DOM对象树，并且在页面结构改变进行最小代价的DOM渲染操作，提高了交互的性能和效率。这也是提高前端交互性能的根本原因。</p><h4 id="2-Vue实现虚拟DOM原理"><a href="#2-Vue实现虚拟DOM原理" class="headerlink" title="2. Vue实现虚拟DOM原理"></a>2. Vue实现虚拟DOM原理</h4><p><strong>Vue具体如何实现虚拟DOM</strong>（待更新…）</p><p><strong>vue2为什么要引入虚拟Dom，谈谈对虚拟Dom的理解？</strong></p><ul><li>随着现代应用对页面的功能要求越复杂，管理的状态越多，如果还是使用之前的<code>JavaScript</code>线程去频繁操作<code>GUI</code>线程的硕大<code>Dom</code>，对性能会有很大的损耗，而且也会造成状态难以管理，逻辑混乱等情况。引入虚拟<code>Dom</code>后，在框架的内部就将虚拟<code>Dom</code>树形结构与真实<code>Dom</code>做了映射，让我们不用在命令式的去操作<code>Dom</code>，可以将重心转为去维护这棵树形结构内的状态即可，状态的变化就会驱动<code>Dom</code>发生改变，具体的<code>Dom</code>操作<code>vue</code>帮我们完成，而且这些大部分可以在<code>JavaScript</code>线程完成，性能更高。</li><li>虚拟<code>Dom</code>只是一种数据结构，可以让它不仅仅使用在浏览器环境，还可以用与<code>SSR</code>以及<code>Weex</code>等场景。</li></ul><h2 id="（三）模板转换成视图的过程"><a href="#（三）模板转换成视图的过程" class="headerlink" title="（三）模板转换成视图的过程"></a>（三）模板转换成视图的过程</h2><p>Vue.js通过编译将template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</p><p>在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行DOM操作来更新视图。</p><p>简单点讲，在Vue的底层实现上，Vue将模板编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应到DOM操作上。</p><p>我们先对上图几个概念加以解释:<br><img src="https://img-blog.csdnimg.cn/20200419204951458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>渲染函数</strong>：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。</li><li><strong>VNode 虚拟节点</strong>：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成<strong>节点描述对象</strong>，它描述了应该怎样去创建真实的DOM节点。</li><li><strong>patch(也叫做patching算法)<strong>：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。Vue的Virtual DOM Patching算法是基于</strong>Snabbdom</strong>的实现，并在些基础上作了很多的调整和改进。</li></ul><p><strong>附上 Vue2.0 模板渲染过程：</strong><br><img src="https://img-blog.csdnimg.cn/20200419204756531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>此文是对网上查找的资料的总结与笔记，由于还未深入源码，所以对Vue模板编译的具体过程还有疑惑。</p><p><strong>疑惑</strong>：</p><ul><li><p>到底在什么时候进行模板编译？</p><p>我觉得，Vue官方的Vue生命周期图和上面的模板渲染过程有些出入，加上网上博客说法不一，实在是困惑。</p></li><li><p>静态模板 、动态模板是什么？</p></li><li><p>模板渲染 、模板编译具体区别？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库：区分笛卡儿积、自然连接、内连接、等值连接、外连接</title>
    <link href="/2020/04/15/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%8C%BA%E5%88%86%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF%E3%80%81%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
    <url>/2020/04/15/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%8C%BA%E5%88%86%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF%E3%80%81%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>假设存在两张表 c 和 p，这里使用的是MySQL数据库。</p><p><strong>数据表 c</strong>：</p><table><thead><tr><th align="left">course_id</th><th>title</th><th>dept_name</th><th>credits</th></tr></thead><tbody><tr><td align="left">BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td></tr><tr><td align="left">CS-190</td><td>Game Design</td><td>Comp.sci</td><td>4</td></tr><tr><td align="left">CS-315</td><td>Robotics</td><td>Comp.sci</td><td>3</td></tr></tbody></table><p><strong>数据表 p</strong>：</p><table><thead><tr><th>course_id</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>CS-101</td></tr><tr><td>CS-347</td><td>CS-101</td></tr></tbody></table><h2 id="1-笛卡儿积"><a href="#1-笛卡儿积" class="headerlink" title="1. 笛卡儿积"></a>1. 笛卡儿积</h2><p><strong>SQL语句如下</strong>：</p><p><code>select * from c,p;</code></p><p>或</p><p><code>select * from c cross join p;</code></p><p><strong>结果如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20200415150246127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-自然连接"><a href="#2-自然连接" class="headerlink" title="2. 自然连接"></a>2. 自然连接</h2><p>”natrual join 自然连接”的处理方式：先进行笛卡儿积操作，然后重复的属性只保留一份。</p><p>自然连接的步骤是将第一张表的第一条记录和第二张表的每一条记录匹配，如果符合条件就组成一条记录，然后第一张表的第二条记录再和第二张表的每一条记录匹配，这步骤一直循环到第一张表的最后一条记录。</p><p><strong>SQL语句如下</strong>：</p><p><code>select c.course_id, c.title, c.dept_name, c.credits, p.prereq_id from c,p where c.course_id = p.course_id;</code></p><p>或</p><p><code>select * from c natural join p;</code></p><p><strong>结果如下：</strong><br><img src="https://img-blog.csdnimg.cn/20200415150307148.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3-内连接"><a href="#3-内连接" class="headerlink" title="3. 内连接"></a>3. 内连接</h2><p>“inner join 内连接”的处理方式：虽然重复，但两份都保留。</p><p>内连接的结果和自然连接的结果是一样的，只不过是显示的属性不一样而已。内连接会将两张表的重复属性都分别列出来。</p><p><strong>SQL语句如下</strong>：</p><p><code>select * from c,p where c.course_id = p.course_id;</code></p><p>或</p><p><code>select * from c inner join p on c.course_id = p.course_id;</code></p><p><strong>结果如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20200415150323525.png#pic_center" alt="在这里插入图片描述"></p><h2 id="4-等值连接"><a href="#4-等值连接" class="headerlink" title="4. 等值连接"></a>4. 等值连接</h2><p>从集合论角度看：等值连接是内连接的子集。</p><h2 id="5-外连接"><a href="#5-外连接" class="headerlink" title="5. 外连接"></a>5. 外连接</h2><h4 id="（1）左连接"><a href="#（1）左连接" class="headerlink" title="（1）左连接"></a>（1）左连接</h4><p>left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。左(外)连接，左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。其实就是将右边的表的第一项根据条件分别和左边的每一行数据进行对比，如果符合条件，就拼成一条记录。</p><p><strong>SQL语句如下</strong>：</p><p><code>select * from c left join p on c.course_id = p.course_id;</code></p><p><strong>结果如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20200415150340348.png#pic_center" alt="在这里插入图片描述"></p><p><strong>SQL语句如下</strong>：</p><p><code>select * from c natural left join p;</code></p><p><strong>结果如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20200415150353730.png#pic_center" alt="在这里插入图片描述"></p><h4 id="（2）右连接"><a href="#（2）右连接" class="headerlink" title="（2）右连接"></a>（2）右连接</h4><p>right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。与左(外)连接相反，右(外)连接，左表只会显示符合搜索条件的记录，而右表的记录将会全部表示出来。左表记录不足的地方均为NULL。</p><p>右连接的匹配步骤是先将左边的表的第一项根据条件分别和右边的每一行数据进行对比，如果符合条件，就拼成一条记录。</p><p><strong>SQL语句如下</strong>：</p><p><code>select * from c right join p on c.course_id = p.course_id;</code></p><p><strong>结果如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20200415150408771.png#pic_center" alt="在这里插入图片描述"></p><p><strong>SQL语句如下</strong>：</p><p><code>select * from c natural right join p;</code></p><p><strong>结果如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20200415150423247.png#pic_center" alt="在这里插入图片描述"></p><h4 id="（3）全连接"><a href="#（3）全连接" class="headerlink" title="（3）全连接"></a>（3）<strong>全连接</strong></h4><p>全连接也是属于外连接的一种。但是MySQL里没有全连接的关键字。但是可以通过union来实现。</p><p>注意：</p><p>UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p><p>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p><p>UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p><p><strong>SQL语句如下</strong>：</p><p><code>(select * from c left join p on c.course_id = p.course_id) union (select * from c right join p on c.course_id = p.course_id);</code></p><p><strong>结果如下</strong>：<br><img src="https://img-blog.csdnimg.cn/2020041515043660.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>项目开发常用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上线部署</title>
    <link href="/2020/04/10/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/04/10/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>剔除项目无用代码</p><p>前端性能优化</p><p>配置服务器做域名解析    </p><p>上传项目     启动服务</p><h4 id="（1）路由按需加载方案"><a href="#（1）路由按需加载方案" class="headerlink" title="（1）路由按需加载方案"></a>（1）路由按需加载方案</h4><p>路由懒加载能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>路由懒加载主要目的是防止 首屏加载内容过多，延时过长，造成白屏，不利于用户体验。</p><p><strong>方式1</strong>：</p><p>在router.js中：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br>Vue.use(Router);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>            <span class="hljs-attr">component</span>:Home,<br>            <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,<br>            <span class="hljs-attr">children</span>: [<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;index&#x27;</span>,<br>                    <span class="hljs-attr">component</span>: Index,<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/:id&#x27;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;product&#x27;</span>,<br>                    <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./pages/index.vue&#x27;</span>], resolve),<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail/:id&#x27;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;detail&#x27;</span>,<br>                    <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./pages/detail.vue&#x27;</span>], resolve),<br>                &#125;                <br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./pages/login.vue&#x27;</span>], resolve),<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/cart&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cart&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./pages/cart.vue&#x27;</span>], resolve),<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>方式2</strong>：</p><p>使用动态 import语法来定义代码分块点。</p><ul><li><p>安装插件<code>syntax-dynamic-import</code>：</p><p><code>npm i @babel/plugin-syntax-dynamic-import --save</code></p></li><li><p>在router.js中：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br>Vue.use(Router);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>            <span class="hljs-attr">component</span>:Home,<br>            <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,<br>            <span class="hljs-attr">children</span>: [<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;index&#x27;</span>,<br>                    <span class="hljs-attr">component</span>: Index,<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/:id&#x27;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;product&#x27;</span>,<br>                    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/index.vue&#x27;</span>),<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail/:id&#x27;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;detail&#x27;</span>,<br>                    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/detail.vue&#x27;</span>),<br>                &#125;                <br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/login.vue&#x27;</span>),<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/cart&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cart&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/cart.vue&#x27;</span>), <br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="（2）删除预加载-真正按需"><a href="#（2）删除预加载-真正按需" class="headerlink" title="（2）删除预加载 - 真正按需"></a>（2）删除预加载 - 真正按需</h4><p>在vue.config.js中加入配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>        config.plugins.delete(<span class="hljs-string">&#x27;prefetch&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）服务器部署准备工作"><a href="#（3）服务器部署准备工作" class="headerlink" title="（3）服务器部署准备工作"></a>（3）服务器部署准备工作</h4><ul><li><p>购买域名并备案</p></li><li><p>购买服务器</p></li><li><p>域名解析</p></li></ul><h4 id="（4）服务器Nginx软件安装和配置"><a href="#（4）服务器Nginx软件安装和配置" class="headerlink" title="（4）服务器Nginx软件安装和配置"></a>（4）服务器Nginx软件安装和配置</h4><h4 id="（5）Node环境搭建"><a href="#（5）Node环境搭建" class="headerlink" title="（5）Node环境搭建"></a>（5）Node环境搭建</h4><h4 id="（6）项目部署"><a href="#（6）项目部署" class="headerlink" title="（6）项目部署"></a>（6）项目部署</h4>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>订单列表页面实现</title>
    <link href="/2020/04/07/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%AE%A2%E5%8D%95%E5%88%97%E8%A1%A8%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/04/07/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%AE%A2%E5%8D%95%E5%88%97%E8%A1%A8%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#jump1"><strong>调整Order父组件结构（解决Bug）</strong></a></p></li><li><p><a href="#jump2"><strong>订单列表数据渲染</strong></a></p></li><li><p><a href="#jump3"><strong>Loading 和 NoData优化</strong></a></p></li><li><p><a href="#jump4"><strong>订单列表分页 - 分页器</strong></a></p></li><li><p><a href="#jump5"><strong>订单列表分页 - 加载更多</strong></a></p></li><li><p><a href="#jump6"><strong>订单列表分页 - 滚动加载</strong></a></p></li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1586405026795.png" alt="1586405026795"></p><h4 id="（1）调整Order父组件结构（解决Bug）"><a href="#（1）调整Order父组件结构（解决Bug）" class="headerlink" title="（1）调整Order父组件结构（解决Bug）"></a><span id="jump1">（1）调整Order父组件结构（解决Bug）</span></h4><p>之前在<a href="https://blog.csdn.net/weixin_46124214/article/details/105363073">Vue项目实战：订单确认页面实现</a>中关于订单父组件结构封装里写到：在order.vue中引入<code>&lt;order-header&gt;&lt;/order-header&gt;</code>，然后通过路由判断当前页面属于哪个，并展示不同内容。但现在发现那样子做存在一个问题：</p><p><strong>问题</strong>：</p><p>在使用微信支付完后跳转到订单列表页面，但是订单列表页面中的<code>&lt;order-header&gt;&lt;/order-header&gt;</code>的内容仍是订单支付页面中<code>&lt;order-header&gt;&lt;/order-header&gt;</code>的内容，没有变成<code>&lt;order-header&gt;&lt;/order-header&gt;</code>对应的内容。但是如果跳转完订单列表页面，在重新刷新一下页面，那<code>&lt;order-header&gt;&lt;/order-header&gt;</code>的内容就会改变。</p><p><strong>原因</strong>：</p><p>订单列表的路由是order的子路由，当我们从order路由跳转到它的子路由时，并不会再次执行order.vue中的mounted()函数。此函数只有在页面渲染时才会执行。也就是说，如果想用之前的方法，那只有在第一次从别的路由（比如购物车路由）跳转到订单列表路由时，此前order页面并没有被渲染过，则可以出现相应的<code>&lt;order-header&gt;&lt;/order-header&gt;</code>组件内容。如果是从订单订单确认跳转到订单列表的话，此时没有重新渲染order页面，那<code>&lt;order-header&gt;&lt;/order-header&gt;</code>内容不会改变。</p><p><strong>解决方法</strong>：</p><p>不用之前的第二种方法，删去之前路由判断的代码，而用第一次，在每个页面中引入<code>&lt;order-header&gt;&lt;/order-header&gt;</code>。</p><p>如，在orderConfirm.vue:</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">order-header</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;订单确认&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:tip</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>请认真填写收货地址<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">order-header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> OrderHeader <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./../components/OrderHeader&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">    OrderHeader,</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="（2）订单列表数据渲染"><a href="#（2）订单列表数据渲染" class="headerlink" title="（2）订单列表数据渲染"></a><span id="jump2">（2）订单列表数据渲染</span></h4><p>在orderList.vue中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 省略不重要代码，下面是如何判断并展示订单状态 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;good-state fr&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;order.status == 20&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>&#123;&#123;order.statusDesc&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;good-state fr&quot;</span> <span class="hljs-attr">v-else</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;goPay(order.orderNo)&quot;</span>&gt;</span>&#123;&#123;order.statusDesc&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">list</span>: []</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.getOrderList();</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getOrderList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/orders&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.list = res.list;</span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">goPay</span>(<span class="hljs-params">orderNo</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-comment">//三种路由跳转方式</span></span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$router.push(&#123;</span><br><span class="javascript">                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/order/pay&#x27;</span>,</span><br><span class="javascript">                <span class="hljs-attr">query</span>: &#123;</span><br><span class="javascript">                    orderNo</span><br><span class="javascript">                &#125;</span><br><span class="javascript">            &#125;)</span><br><span class="javascript">           <span class="hljs-comment">/* this.$router.push(&#123;</span></span><br><span class="hljs-comment"><span class="javascript">                name: &#x27;order-pay&#x27;,</span></span><br><span class="hljs-comment"><span class="javascript">                query: &#123;</span></span><br><span class="hljs-comment"><span class="javascript">                    orderNo</span></span><br><span class="hljs-comment"><span class="javascript">                &#125;</span></span><br><span class="hljs-comment"><span class="javascript">            &#125;)</span></span><br><span class="hljs-comment"><span class="javascript">            */</span> </span><br><span class="javascript">           <span class="hljs-comment">//this.$router.push(&#x27;/order/pay&#x27;)         </span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）Loading-和-NoData优化"><a href="#（3）Loading-和-NoData优化" class="headerlink" title="（3）Loading 和 NoData优化"></a><span id="jump3">（3）Loading 和 NoData优化</span></h4><ul><li><p>在orderList.vue中引入并使用之前定义的Loading组件：</p><p>这个优化是针对请求发出来，响应还没回来前做个loading处理。在请求时显示，请求回来后不显示。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">loading</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loading&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">loading</span>&gt;</span>   //3.使用组件<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">import</span> Loading <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/Loading&#x27;</span>;  <span class="hljs-comment">//1.导入组件</span></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">      Loading  <span class="hljs-comment">//2.注册组件</span></span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getOrderList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/orders&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.list = res.list;</span><br><span class="javascript">            &#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125; </span><br><span class="javascript">  &#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>NoData优化：</p><p>在订单列表无数据时，显示NoData组件，给用户订单列表为空提示。</p><p>在components文件夹中新建NoData.vue：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;no-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imgs/icon-no-data.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前暂无提交的订单记录.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-comment">&lt;!--此处省略样式等不重要代码--&gt;</span><br></code></pre></td></tr></table></figure><p>​    在orderList.vue中引入并使用NoData组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">no-data</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!loading &amp;&amp; list.length == 0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">no-data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">import</span> NoData <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/NoData&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">      NoData</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">list</span>: [],</span><br><span class="javascript">            <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getOrderList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/orders&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.list = [] || res.list;</span><br><span class="javascript">            &#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br></code></pre></td></tr></table></figure><h4 id="（4）订单列表分页-分页器"><a href="#（4）订单列表分页-分页器" class="headerlink" title="（4）订单列表分页 - 分页器"></a><span id="jump4">（4）订单列表分页 - 分页器</span></h4><p>​    在orderList.vue中使用ElementUI中的Pagination组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html">          <span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span></span><br><span class="hljs-tag">            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagination&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">background</span></span><br><span class="hljs-tag">            <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;pre, pager, next&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">:pageSize</span>=<span class="hljs-string">&quot;pageSize&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">:total</span>=<span class="hljs-string">&quot;total&quot;</span></span><br><span class="hljs-tag">            @<span class="hljs-attr">current-change</span>=<span class="hljs-string">&quot;handleChange&quot;</span></span><br><span class="hljs-tag">          &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">import</span> &#123;Pagination&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">      [Pagination.name]: Pagination</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">list</span>: [],</span><br><span class="javascript">      <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,</span><br><span class="javascript">      <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">//每页几条数据</span></span><br><span class="javascript">      <span class="hljs-attr">pageNum</span>: <span class="hljs-number">1</span>,  <span class="hljs-comment">//当前是第几页</span></span><br><span class="javascript">      <span class="hljs-attr">total</span>: <span class="hljs-number">0</span>   <span class="hljs-comment">//总条数</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getOrderList();</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getOrderList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios</span><br><span class="javascript">        .get(<span class="hljs-string">&quot;/orders&quot;</span>, &#123;</span><br><span class="javascript">          <span class="hljs-attr">params</span>: &#123;</span><br><span class="javascript">            <span class="hljs-attr">pageNum</span>: <span class="hljs-built_in">this</span>.pageNum</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.list = [] || res.list;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.total = res.total;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .catch(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">pageNum</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.pageNum = pageNum;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.getOrderList();</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（5）订单列表分页-加载更多"><a href="#（5）订单列表分页-加载更多" class="headerlink" title="（5）订单列表分页 - 加载更多"></a>（5）订单列表分页 - 加载更多</h4><p>​    在orderList.vue中使用ElementUI中的Button组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;load-more&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showNextPage&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">:loading</span>=<span class="hljs-string">&quot;loading&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;loadMore&quot;</span>&gt;</span>加载更多<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">import</span> &#123;Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">      [Button.name]: Button</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">list</span>: [],</span><br><span class="javascript">      <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,</span><br><span class="javascript">      <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span>,</span><br><span class="javascript">      <span class="hljs-attr">pageNum</span>: <span class="hljs-number">1</span>,</span><br><span class="javascript">      <span class="hljs-attr">showNextPage</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否显示按钮，但数据都加载完了，就不需要显示“加载更多”按钮。</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getOrderList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios</span><br><span class="javascript">        .get(<span class="hljs-string">&quot;/orders&quot;</span>, &#123;</span><br><span class="javascript">          <span class="hljs-attr">params</span>: &#123;</span><br><span class="javascript">            <span class="hljs-attr">pageNum</span>: <span class="hljs-number">10</span>,</span><br><span class="javascript">            <span class="hljs-attr">pageNum</span>: <span class="hljs-built_in">this</span>.pageNum</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.list = res.list.concat(res.list);  <span class="hljs-comment">//数据累加</span></span><br><span class="javascript">          <span class="hljs-built_in">this</span>.showNextPage = res.hasNext</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .catch(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">loadMore</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.pageNum++;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.getOrderList();</span><br><span class="javascript">      &#125;   </span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（6）订单列表分页-滚动加载"><a href="#（6）订单列表分页-滚动加载" class="headerlink" title="（6）订单列表分页 - 滚动加载"></a>（6）订单列表分页 - 滚动加载</h4><ul><li><p>安装该插件：</p><p><code>npm install vue-infinite-scroll --save</code></p></li><li><p>在orderList.vue中使用Vue中的vue-infinite-scroll插件：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;scroll-more&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">v-infinite-scroll</span>=<span class="hljs-string">&quot;scrollMore&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">infinite-scroll-disabled</span> = <span class="hljs-string">&quot;busy&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">infinite-scroll-distance</span>=<span class="hljs-string">&quot;410&quot;</span></span><br><span class="hljs-tag">     &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imgs/loading-svg/loading-spinning-bubbles.svg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;loading&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">// v-infinite-scroll=&quot;scrollMore&quot; :滚动的时候会调用的方法</span></span><br><span class="javascript"><span class="hljs-comment">//infinite-scroll-disabled = &quot;busy&quot; : 控制滚动加载是否有效，在busy为false：滚动才有效，才能触发loadMore函数，为true时，滚动不会触发函数。</span></span><br><span class="javascript"><span class="hljs-comment">//infinite-scroll-distance=&quot;410&quot; : 不是距离底部410px时才触发loadMore函数</span></span><br><span class="javascript">  <span class="hljs-keyword">import</span> &#123;Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">directives</span>: &#123;infiniteScroll&#125;,</span><br><span class="javascript">    <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">      [Button.name]: Button</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">list</span>: [],</span><br><span class="javascript">      <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,</span><br><span class="javascript">      <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span>,</span><br><span class="javascript">      <span class="hljs-attr">pageNum</span>: <span class="hljs-number">1</span>,</span><br><span class="javascript">      <span class="hljs-attr">busy</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">//滚动加载，是否触发</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getOrderList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">true</span>; </span><br><span class="javascript">      <span class="hljs-built_in">this</span>.busy = <span class="hljs-literal">true</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios</span><br><span class="javascript">        .get(<span class="hljs-string">&quot;/orders&quot;</span>, &#123; </span><br><span class="javascript">          <span class="hljs-attr">params</span>: &#123;</span><br><span class="javascript">            <span class="hljs-attr">pageNum</span>: <span class="hljs-number">10</span>,</span><br><span class="javascript">            <span class="hljs-attr">pageNum</span>: <span class="hljs-built_in">this</span>.pageNum</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.list = res.list.concat(res.list);  <span class="hljs-comment">//数据累加</span></span><br><span class="javascript">          <span class="hljs-built_in">this</span>.busy = <span class="hljs-literal">false</span>;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .catch(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">true</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.busy = <span class="hljs-literal">true</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios</span><br><span class="javascript">        .get(<span class="hljs-string">&quot;/orders&quot;</span>, &#123;</span><br><span class="javascript">          <span class="hljs-attr">params</span>: &#123; </span><br><span class="javascript">            <span class="hljs-attr">pageNum</span>: <span class="hljs-number">10</span>,</span><br><span class="javascript">            <span class="hljs-attr">pageNum</span>: <span class="hljs-built_in">this</span>.pageNum</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.list = res.list.concat(res.list);  <span class="hljs-comment">//数据累加</span></span><br><span class="javascript">          <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="javascript">          <span class="hljs-keyword">if</span>(res.hasNextPage) &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.busy = <span class="hljs-literal">false</span>;</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.busy = <span class="hljs-literal">true</span>;</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">scrollMore</span>(<span class="hljs-params"></span>)</span> &#123; </span><br><span class="javascript">          <span class="hljs-built_in">this</span>.busy= <span class="hljs-literal">true</span>;</span><br><span class="javascript">          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.pageNum++;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.getList();</span><br><span class="javascript">          &#125;, <span class="hljs-number">500</span>)</span><br><span class="javascript">      &#125;   </span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>订单结算功能实现</title>
    <link href="/2020/04/07/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%AE%A2%E5%8D%95%E7%BB%93%E7%AE%97%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/04/07/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%AE%A2%E5%8D%95%E7%BB%93%E7%AE%97%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#jump1"><strong>订单详情数据加载</strong></a></li><li><a href="#jump2"><strong>支付宝支付对接</strong></a></li><li><a href="#jump3"><strong>微信支付对接</strong></a></li><li><a href="#jump4"><strong>微信支付转态轮询</strong></a></li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1586239549884.png" alt="1586239549884"></p><h4 id="（1）订单详情数据加载"><a href="#（1）订单详情数据加载" class="headerlink" title="（1）订单详情数据加载"></a><span id="jump1">（1）订单详情数据加载</span></h4><p>在orderPay.vue中：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    订单详情<br>    <span class="hljs-tag">&lt;<span class="hljs-name">em</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-down up&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;up&#x27;: showDetail&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDetail=!showDetail&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>  <span class="hljs-comment">&lt;!--控制订单详情是否展示--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">orderId</span>: <span class="hljs-built_in">this</span>.$route.query.orderNo,</span><br><span class="javascript">      <span class="hljs-attr">addressInfo</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">//收货人地址</span></span><br><span class="javascript">      <span class="hljs-attr">orderDetail</span>: [], <span class="hljs-comment">//订单详情，包含商品列表</span></span><br><span class="javascript">      <span class="hljs-attr">showDetail</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否显示订单详情</span></span><br><span class="javascript">      <span class="hljs-attr">payment</span>:<span class="hljs-number">0</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getOrderDetail();</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getOrderDetail</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">`/orders/<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.orderId&#125;</span>`</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> item = res.shippingVo;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.addressInfo = <span class="hljs-string">`<span class="hljs-subst">$&#123;item.receiverName&#125;</span> <span class="hljs-subst">$&#123;item.receiverMobile&#125;</span> <span class="hljs-subst">$&#123;item.receiverProvince&#125;</span> <span class="hljs-subst">$&#123;item.receiverCity&#125;</span> <span class="hljs-subst">$&#123;item.recevierDistrict&#125;</span> <span class="hljs-subst">$&#123;item.receiverAddress&#125;</span>`</span>;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.orderDetail = res.orderItemVoList;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.payment:<span class="hljs-number">0</span>,<span class="hljs-comment">//订单总金额</span></span><br><span class="javascript">      &#125;);</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）支付宝支付对接"><a href="#（2）支付宝支付对接" class="headerlink" title="（2）支付宝支付对接"></a><span id="jump2">（2）支付宝支付对接</span></h4><p>在orderPay页面中点击 支付宝支付 后，页面跳转到支付宝支付页面alipay。</p><ul><li>在orderPay.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--省略了很多代码--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pay-way&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>支付平台<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pay pay-ali&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27; : payType == 1&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;paySubmit(1)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pay pay-wechat&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;: payType == 2&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;paySubmit(2)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">payType</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">//支付类型</span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">paySubmit</span>(<span class="hljs-params">payType</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (payType == <span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&quot;/#/order/alipay?orderId =&quot;</span> + <span class="hljs-built_in">this</span>.orderId, <span class="hljs-string">&quot;_blank&quot;</span>);</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在alipay.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ali-pay&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form&quot;</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;coutent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> Loading <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/Loading&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alipay&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">orderId</span>: <span class="hljs-built_in">this</span>.$route.query.orderNo,</span><br><span class="javascript">            <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">//支付宝返回给前端的源码</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">        Loading</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.paySubumit();</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">paySubumit</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/pay&#x27;</span>, &#123;</span><br><span class="javascript">                <span class="hljs-attr">orderId</span>: <span class="hljs-built_in">this</span>.orderId,</span><br><span class="javascript">                <span class="hljs-attr">orderName</span>: <span class="hljs-string">&#x27;Vue高仿小米商城&#x27;</span>,</span><br><span class="javascript">                <span class="hljs-attr">amount</span>: <span class="hljs-number">0.01</span>, <span class="hljs-comment">//单位元</span></span><br><span class="javascript">                <span class="hljs-attr">payType</span>: <span class="hljs-number">1</span> <span class="hljs-comment">//1支付宝， 2微信</span></span><br><span class="javascript">            &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.content = res.coutent;</span><br><span class="javascript">                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-built_in">document</span>.form[<span class="hljs-number">0</span>].submit();</span><br><span class="javascript">                &#125;, <span class="hljs-number">100</span>)</span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）微信支付对接"><a href="#（3）微信支付对接" class="headerlink" title="（3）微信支付对接"></a><span id="jump3">（3）微信支付对接</span></h4><p>点击 微信支付 后，会出现微信支付图片弹窗。其中的二维码是通过qrcode插件将后端返回的字符串转换来的 。</p><ul><li>在orderPay.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">scan-pay-code</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showPay&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;closePayModal&quot;</span> <span class="hljs-attr">:img</span>=<span class="hljs-string">&quot;payImg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scan-pay-code</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> ScanPayCode <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./../components/ScanPayCode&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> QRCode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qrcode&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">showPay</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否显示微信支付弹框</span></span><br><span class="javascript">      <span class="hljs-attr">payType</span>: <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">//支付类型</span></span><br><span class="javascript">      <span class="hljs-attr">payImg</span>: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">//微信支付的二维码地址 </span></span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">    ScanPayCode</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-comment">// 关闭微信弹框</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">closePayModal</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showPay = <span class="hljs-literal">false</span>;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">paySubmit</span>(<span class="hljs-params">payType</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (payType == <span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&quot;/#/order/alipay?orderId =&quot;</span> + <span class="hljs-built_in">this</span>.orderId, <span class="hljs-string">&quot;_blank&quot;</span>);</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/pay&#x27;</span>, &#123;</span><br><span class="javascript">              <span class="hljs-attr">orderId</span>:<span class="hljs-built_in">this</span>.orderId,</span><br><span class="javascript">              <span class="hljs-attr">orderName</span>: <span class="hljs-string">&#x27;Vue高仿小米商城&#x27;</span>,</span><br><span class="javascript">              <span class="hljs-attr">amount</span>: <span class="hljs-number">0.01</span>,</span><br><span class="javascript">              <span class="hljs-attr">payType</span>: <span class="hljs-number">2</span></span><br><span class="javascript">          &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">              QRCode.toDataURL(res.content).then(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;</span><br><span class="javascript">                  <span class="hljs-built_in">this</span>.showPay = <span class="hljs-literal">true</span>;</span><br><span class="javascript">                  <span class="hljs-built_in">this</span>.payImg = url;</span><br><span class="javascript">              &#125;).catch( <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                  <span class="hljs-built_in">this</span>.$message.error(<span class="hljs-string">&quot;微信二维码生成失败&quot;</span>)</span><br><span class="javascript">              &#125;)</span><br><span class="javascript">          &#125;)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在ScanPayCode.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;scan&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mask&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-wrap&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-scan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-pay&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>微信支付<span class="hljs-tag">&lt;<span class="hljs-name">em</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;qrcode&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;img&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tip&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>请使用<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;theme-color&quot;</span>&gt;</span>微信<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>扫一扫<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>二维码完成支付<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;scan-pay-code&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;img&#x27;</span>],</span><br><span class="javascript">    <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">close</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;close&#x27;</span>);</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）微信支付转态轮询"><a href="#（4）微信支付转态轮询" class="headerlink" title="（4）微信支付转态轮询"></a><span id="jump4">（4）微信支付转态轮询</span></h4><p>在支付弹窗出现后，可能出现两种情况，一种是用户没有完成支付就关闭支付弹窗。另一种是用户支付完成，自动跳转到订单列表。</p><p>为了防止由于网络延时导致用户支付完成但未自动跳转，而用户又把支付弹窗关闭了，所以添加一个支付确认弹框，在支付弹窗关闭后会出现支付确认弹框，让用户手动选择是否完成支付，如果选择用户支付确认弹框中 “查看订单” （表示自己已经完成支付）后会查询是否真的已支付，如果已支付就跳转到订单列表。</p><p>另外为了用户体验，添加订单轮询，实时获取当前用户支付状态，在用户支付完成后跳转到订单列表，而无需手动关闭弹窗和再次确认。</p><ul><li>在orderPay.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">modal</span></span><br><span class="hljs-tag">      <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;支付确认&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">btnType</span>=<span class="hljs-string">&quot;3&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:showModal</span>=<span class="hljs-string">&quot;showPayModal&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">sureText</span>=<span class="hljs-string">&quot;查看订单&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">cancelText</span>=<span class="hljs-string">&quot;未支付&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">cancel</span>=<span class="hljs-string">&quot;showPayModal=false&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">submit</span>=<span class="hljs-string">&quot;goOrderList&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您确认是否完成支付？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modal</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> Modal <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/Modal&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;order-pay&#x27;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">showPayModal</span>:<span class="hljs-literal">false</span>,<span class="hljs-comment">//是否显示二次支付确认弹框</span></span><br><span class="javascript">      <span class="hljs-attr">payment</span>:<span class="hljs-number">0</span>,<span class="hljs-comment">//订单总金额</span></span><br><span class="javascript">      <span class="hljs-attr">T</span>:<span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">//定时器ID</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">    Modal</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">paySubmit</span>(<span class="hljs-params">payType</span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">if</span>(payType == <span class="hljs-number">1</span>)&#123;</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;/#/order/alipay?orderId=&#x27;</span>+<span class="hljs-built_in">this</span>.orderId,<span class="hljs-string">&#x27;_blank&#x27;</span>);</span><br><span class="javascript">      &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/pay&#x27;</span>,&#123;</span><br><span class="javascript">          <span class="hljs-attr">orderId</span>:<span class="hljs-built_in">this</span>.orderId,</span><br><span class="javascript">          <span class="hljs-attr">orderName</span>:<span class="hljs-string">&#x27;Vue高仿小米商城&#x27;</span>,</span><br><span class="javascript">          <span class="hljs-attr">amount</span>:<span class="hljs-number">0.01</span>,<span class="hljs-comment">//单位元</span></span><br><span class="javascript">          <span class="hljs-attr">payType</span>:<span class="hljs-number">2</span> <span class="hljs-comment">//1支付宝，2微信</span></span><br><span class="javascript">        &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;</span><br><span class="javascript">          QRCode.toDataURL(res.content)</span><br><span class="javascript">          .then(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.showPay = <span class="hljs-literal">true</span>;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.payImg = url;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.loopOrderState();</span><br><span class="javascript">          &#125;)</span><br><span class="javascript">          .catch(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$message.error(<span class="hljs-string">&#x27;微信二维码生成失败，请稍后重试&#x27;</span>);</span><br><span class="javascript">          &#125;)</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-comment">// 关闭微信弹框</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">closePayModal</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showPay = <span class="hljs-literal">false</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showPayModal = <span class="hljs-literal">true</span>;</span><br><span class="javascript">      <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.T);</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-comment">// 轮询当前订单支付状态</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">loopOrderState</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.T = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123; </span><br><span class="javascript">        <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">`/orders/<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.orderId&#125;</span>`</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;</span><br><span class="javascript">          <span class="hljs-keyword">if</span>(res.status == <span class="hljs-number">20</span>)&#123;</span><br><span class="javascript">            <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.T);</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.goOrderList();</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">      &#125;,<span class="hljs-number">1000</span>);</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">goOrderList</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/order/list&#x27;</span>);</span><br><span class="javascript">    &#125;      </span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>订单确认页面</title>
    <link href="/2020/04/06/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%E9%A1%B5%E9%9D%A2/"/>
    <url>/2020/04/06/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="订单确认页面"><a href="#订单确认页面" class="headerlink" title="订单确认页面"></a>订单确认页面</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#jump1"><strong>订单父组件结构封装</strong></a></li><li><a href="#jump2"><strong>地址和商品数据加载</strong></a></li><li><a href="#jump3"><strong>地址删除功能实现</strong></a></li><li><a href="#jump4"><strong>新增地址交互实现</strong></a></li><li><a href="#jump5"><strong>地址编辑和订单提交</strong></a></li></ul><p><strong>订单确认页面 如下</strong>：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1586171626629.png" alt="1586171626629"></p><h4 id="（1）订单父组件结构封装"><a href="#（1）订单父组件结构封装" class="headerlink" title="（1）订单父组件结构封装"></a><span id="jump1">（1）订单父组件结构封装</span></h4><ul><li>回顾路由文件router.js中关于order的路由:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs js">&#123;<br>     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/order&#x27;</span>,<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;order&#x27;</span>,<br>     <span class="hljs-attr">component</span>: Order,<br>     <span class="hljs-attr">children</span>: [<br>         &#123;<br>             <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;list&#x27;</span>,<br>             <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;order-list&#x27;</span>,<br>             <span class="hljs-attr">component</span>: OrderList<br>         &#125;,<br>         &#123;<br>             <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;confirm&#x27;</span>,<br>             <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;order-confirm&#x27;</span>,<br>             <span class="hljs-attr">component</span>: OrderConfirm<br>         &#125;,<br>         &#123;<br>             <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;pay&#x27;</span>,<br>             <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;order-pay&#x27;</span>,<br>             <span class="hljs-attr">component</span>: OrderPay<br>         &#125;,<br>         &#123;<br>             <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;alipay&#x27;</span>,<br>             <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alipay&#x27;</span>,<br>             <span class="hljs-attr">component</span>: AliPay<br>         &#125;<br>     ]<br> &#125;<br></code></pre></td></tr></table></figure><p>上面那样子定义路由是因为订单列表、支付、确认页面的页面结构相似。所以把他们封装在order路由下。</p><ul><li>order.vue文件如下：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">order-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">order-header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ServiceBar</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ServiceBar</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav-footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav-footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> OrderHeader <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/OrderHeader&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> ServiceBar <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/ServiceBar&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> NavFooter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/NavFooter&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;order&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">        OrderHeader,</span><br><span class="javascript">        NavFooter，</span><br><span class="javascript">        ServiceBar</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>订单确定、列表、支付页面的<code>&lt;order-header&gt;&lt;/order-header&gt;</code>组件中的文字内容不一样。</p><p>我们可以通过在各个页面中去单独引入<code>&lt;order-header&gt;&lt;/order-header&gt;</code>同时绑定不同的文字内容，添加展示内容。或者像上面order.vue文件一样，在order.vue中引入，然后通过路由判断当前页面属于哪个，并展示不同内容。</p><p>下面是第二种方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html">        <span class="hljs-tag">&lt;<span class="hljs-name">order-header</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:tip</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;tip&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">order-header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">            <span class="hljs-attr">tip</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">       <span class="hljs-keyword">let</span> path = <span class="hljs-built_in">this</span>.$route.path;</span><br><span class="javascript">       <span class="hljs-keyword">if</span> (path == <span class="hljs-string">&#x27;/order/confirm&#x27;</span>) &#123;</span><br><span class="javascript">           <span class="hljs-built_in">this</span>.title = <span class="hljs-string">&#x27;订单确认&#x27;</span>;</span><br><span class="javascript">           <span class="hljs-built_in">this</span>.tip = <span class="hljs-string">&#x27;请认真填写收货地址&#x27;</span>;</span><br><span class="javascript">       &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path == <span class="hljs-string">&#x27;/order/list&#x27;</span>) &#123;</span><br><span class="javascript">           <span class="hljs-built_in">this</span>.title = <span class="hljs-string">&#x27;订单列表&#x27;</span>;</span><br><span class="javascript">           <span class="hljs-built_in">this</span>.tip = <span class="hljs-string">&#x27;请谨防钓鱼链接或咋骗电话，了解更多&#x27;</span>;           </span><br><span class="javascript">       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path == <span class="hljs-string">&#x27;/order/pay&#x27;</span>) &#123;</span><br><span class="javascript">           <span class="hljs-built_in">this</span>.title = <span class="hljs-string">&#x27;订单支付&#x27;</span>;</span><br><span class="javascript">           <span class="hljs-built_in">this</span>.tip = <span class="hljs-string">&#x27;请谨防钓鱼链接或咋骗电话，了解更多&#x27;</span>;           </span><br><span class="javascript">       &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）地址和商品数据加载"><a href="#（2）地址和商品数据加载" class="headerlink" title="（2）地址和商品数据加载"></a><span id="jump2">（2）地址和商品数据加载</span></h4><p>在orderConfirm.vue中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--省略样式和结构代码--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">list</span>: [], <span class="hljs-comment">//收货地址列表</span></span><br><span class="javascript">      <span class="hljs-attr">cartList</span>: [], <span class="hljs-comment">//购物车中需要结算的商品列表</span></span><br><span class="javascript">      <span class="hljs-attr">cartTotalPrice</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">//商品总金额</span></span><br><span class="javascript">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//商品结算数量  </span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.getAddressList();</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.getCartList();</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getAddressList</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">//获取收货地址列表</span></span><br><span class="javascript">        <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/shippings&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.list = res.list;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getCartList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/carts&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> list = res.cartProductVoList; <span class="hljs-comment">//获取购物车中所有商品数据</span></span><br><span class="javascript">            <span class="hljs-built_in">this</span>.cartTotalPrice = res.cartTotalPrice;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.cartList = list.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.productSelected);</span><br><span class="javascript">            list.cartList.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.count += item.quantity;</span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）地址删除功能实现"><a href="#（3）地址删除功能实现" class="headerlink" title="（3）地址删除功能实现"></a><span id="jump3">（3）地址删除功能实现</span></h4><p>在orderConfirm.vue中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> Modal <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/Modal&#x27;</span>   </span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">checkedItem</span>: &#123;&#125;, <span class="hljs-comment">// 选中的商品对象</span></span><br><span class="javascript">      <span class="hljs-attr">userAction</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 用户行为， 0是新增，1是编辑，2是删除</span></span><br><span class="javascript">      <span class="hljs-attr">showDelModal</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否弹窗   </span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">    Modal</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">delAddress</span>(<span class="hljs-params">item</span>)</span> &#123; <span class="hljs-comment">//点击删除图标会出现弹窗</span></span><br><span class="javascript">        <span class="hljs-built_in">this</span>.checkedItem = item;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.userAction = <span class="hljs-number">2</span>;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.showDelModal = <span class="hljs-literal">true</span>;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">submitAddress</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">//在弹窗中点击“确认”时会触发该方法</span></span><br><span class="javascript">        <span class="hljs-comment">//地址删除、编辑、新增功能</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> &#123;checkedItem, userAction&#125; = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> method, url;</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (userAction == <span class="hljs-number">0</span>) &#123;</span><br><span class="javascript">            method = <span class="hljs-string">&#x27;post&#x27;</span>, url = <span class="hljs-string">&#x27;/shippings&#x27;</span>;</span><br><span class="javascript">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userAction == <span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">            method = <span class="hljs-string">&#x27;put&#x27;</span>, url = <span class="hljs-string">`/shippings/<span class="hljs-subst">$&#123;checkedItem.id&#125;</span>`</span>;</span><br><span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">            method = <span class="hljs-string">&#x27;delete&#x27;</span>, url = <span class="hljs-string">`/shippings/<span class="hljs-subst">$&#123;checkedItem.id&#125;</span>`</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.axios[method](url).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.closeModal();</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.getAddressList();</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$message.success(<span class="hljs-string">&#x27;操作成功&#x27;</span>);</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">    &#125;, </span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">closeModal</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.checkedItem = &#123;&#125;;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.userAction = <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showDelModal = <span class="hljs-literal">false</span>;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）新增地址交互实现"><a href="#（4）新增地址交互实现" class="headerlink" title="（4）新增地址交互实现"></a><span id="jump4">（4）新增地址交互实现</span></h4><ul><li>在点击 “添加新地址” 后触发<code>openAddressModal()</code>方法，弹出如下弹窗：</li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1586181472047.png" alt="1586181472047"></p><ul><li>在orderConfirm.vue中添加：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs html">   <span class="hljs-tag">&lt;<span class="hljs-name">modal</span></span><br><span class="hljs-tag">      <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;新增确认&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">btnType</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:showModal</span>=<span class="hljs-string">&quot;showEditModal&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">cancel</span>=<span class="hljs-string">&quot;showEditModal=false&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">submit</span>=<span class="hljs-string">&quot;submitAddress&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;edit-wrap&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;姓名&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedItem.receiverName&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;手机号&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedItem.receiverMobile&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;province&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedItem.receiverProvince&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;北京&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;天津&quot;</span>&gt;</span>天津<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedItem.receiverCity&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;北京&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;district&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedItem.receiverDistrict&quot;</span>&gt;</span> <br>              <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;北京&quot;</span>&gt;</span>昌平区<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;天津&quot;</span>&gt;</span>海淀区<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedItem.recevierAddress&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;邮编&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedItem.receiverZip&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modal</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">showDelModal</span>:<span class="hljs-literal">false</span>, <span class="hljs-comment">//是否弹窗      </span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">submitAddress</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> &#123;checkedItem, userAction&#125; = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> method, url,params = &#123;&#125;;</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (userAction == <span class="hljs-number">0</span>) &#123;</span><br><span class="javascript">            method = <span class="hljs-string">&#x27;post&#x27;</span>, url = <span class="hljs-string">&#x27;/shippings&#x27;</span>;</span><br><span class="javascript">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userAction == <span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">            method = <span class="hljs-string">&#x27;put&#x27;</span>, url = <span class="hljs-string">`/shippings/<span class="hljs-subst">$&#123;checkedItem.id&#125;</span>`</span>;</span><br><span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">            method = <span class="hljs-string">&#x27;delete&#x27;</span>, url = <span class="hljs-string">`/shippings/<span class="hljs-subst">$&#123;checkedItem.id&#125;</span>`</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (userAction == <span class="hljs-number">0</span> || userAction == <span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> &#123; receiverName, receiverMobile, receiverProvince, receiverCity, receiverDistrict, receiverAddress, receiverZip &#125; = checkedItem;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> errMsg;</span><br><span class="javascript">          <span class="hljs-keyword">if</span>(!receiverName) &#123;</span><br><span class="javascript">            errMsg=<span class="hljs-string">&quot;请输入收货人名称&quot;</span>;</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!receiverMobile || !<span class="hljs-regexp">/\d&#123;11&#125;/</span>.test(receiverMobile)) &#123;</span><br><span class="javascript">            errMsg=<span class="hljs-string">&quot;请输入正确格式的手机号&quot;</span>;</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!receiverProvince) &#123;</span><br><span class="javascript">             errMsg=<span class="hljs-string">&quot;请选择省份&quot;</span>;</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!receiverCity) &#123;</span><br><span class="javascript">            errMsg=<span class="hljs-string">&quot;请选择对应的城市&quot;</span>;</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!receiverDistrict || !receiverAddress) &#123;</span><br><span class="javascript">            errMsg=<span class="hljs-string">&quot;请输入收货地址&quot;</span>;</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\d&#123;6&#125;/</span>.test(receiverZip)) &#123;</span><br><span class="javascript">            errMsg=<span class="hljs-string">&quot;请输入邮编&quot;</span>;</span><br><span class="javascript">          &#125;</span><br><span class="javascript">          <span class="hljs-keyword">if</span> (errMsg) &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$message.error(errMsg)</span><br><span class="javascript">            <span class="hljs-keyword">return</span>;</span><br><span class="javascript">          &#125;</span><br><span class="javascript">          params = &#123;</span><br><span class="javascript">            receiverName,</span><br><span class="javascript">            receiverMobile,</span><br><span class="javascript">            receiverProvince,</span><br><span class="javascript">            receiverCity,</span><br><span class="javascript">            receiverDistrict,</span><br><span class="javascript">            receiverAddress,</span><br><span class="javascript">            receiverZip</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.axios[method](url, params).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.closeModal();</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.getAddressList();</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$message.success(<span class="hljs-string">&#x27;操作成功&#x27;</span>);</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">    &#125;, </span><br><span class="javascript">    <span class="hljs-comment">// 打开新增地址弹框</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">openAddressModal</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showEditModal = <span class="hljs-literal">true</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.checkedItem = &#123;&#125;;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showEditModal = <span class="hljs-literal">true</span>;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">      <span class="hljs-comment">// 关闭弹框</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">closeModal</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showEditModal = <span class="hljs-literal">false</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.checkedItem = &#123;&#125;;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.userAction = <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showDelModal = <span class="hljs-literal">false</span>;</span><br><span class="javascript">    &#125;     </span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（5）地址编辑和订单提交"><a href="#（5）地址编辑和订单提交" class="headerlink" title="（5）地址编辑和订单提交"></a><span id = "jump5">（5）地址编辑和订单提交</span></h4><ul><li><p>地址编辑</p><p>点击编辑图标会出现弹窗，在弹窗表单中编辑新地址后，点击确认后弹出消失，页面中出现新地址项。</p><p>当点击地址项时，地址项的边框会变色。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;addr-info&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;: index == checkIndex&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;checkIndex=index&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">checkIndex</span>:<span class="hljs-number">0</span>, <span class="hljs-comment">//当前收货地址中索引  </span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">ditAddressModal</span>(<span class="hljs-params">item</span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.userAction = <span class="hljs-number">1</span>;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.checkedItem = &#123;&#125;;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showEditModal = <span class="hljs-literal">true</span>;</span><br><span class="javascript">    &#125;      </span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>订单提交</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fr&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon-edit&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#icon-edit&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;editAddressModal(item)&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript"><span class="hljs-comment">// 订单提交</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">orderSubmit</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> item = <span class="hljs-built_in">this</span>.list[<span class="hljs-built_in">this</span>.checkIndex];</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (!item) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$message.error(<span class="hljs-string">&quot;请选择一个收货地址&quot;</span>);</span><br><span class="javascript">        <span class="hljs-keyword">return</span>;</span><br><span class="javascript">      &#125;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios</span><br><span class="javascript">        .post(<span class="hljs-string">&quot;/orders&quot;</span>, &#123;</span><br><span class="javascript">          <span class="hljs-attr">shippingId</span>: item.id</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">        .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.$router.push(&#123;</span><br><span class="javascript">            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/order/pay&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">query</span>: &#123;</span><br><span class="javascript">              <span class="hljs-attr">orderNo</span>: res.orderNo</span><br><span class="javascript">            &#125;</span><br><span class="javascript">          &#125;);</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">    &#125;     </span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>退出功能实现</title>
    <link href="/2020/04/06/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/04/06/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="退出功能实现"><a href="#退出功能实现" class="headerlink" title="退出功能实现"></a>退出功能实现</h2><p><strong>（1）退出功能实现</strong></p><p>在NavHeader.vue中：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs html">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;topbar-user&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!username&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;username&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;logout&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>我的订单<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-cart&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-cart&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;goToCart&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> 购物车(&#123;&#123;cartCount&#125;&#125;)<br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">logout</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/user/logout&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$message.success(<span class="hljs-string">&quot;退出成功&quot;</span>);</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$cookie.set(<span class="hljs-string">&#x27;userId&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, &#123;<span class="hljs-attr">expires</span>: <span class="hljs-string">&#x27;-1&#x27;</span>&#125;); <span class="hljs-comment">//清空cookie中的信息</span></span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveUserName&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">//清除页面中的用户名</span></span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveCartCount&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment">// 清空购物车数量</span></span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（2）解决一个问题</strong>：</p><ul><li><p><strong>问题</strong>：在退出后，再次登录后，发现购物车数量为0，不是用户购物车中该有的数量。</p></li><li><p><strong>原因</strong>：虽然之前在App.vue中写过代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getUser(); </span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getCartCount();</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getUser</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/user&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveUserName&#x27;</span>, res.username);</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getCartCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/carts/products/sum&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res = <span class="hljs-number">0</span></span>) =&gt;</span> &#123;</span><br><span class="javascript">         <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveCartCount&#x27;</span>, res);</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但当时这么写的原因：Vuex是在内存中存储数据的，但我们页面刷新时，内存中数据会自动消失，为保持数据一致性，所以需要重新获取数据，并存储在Vuex中。</p><p>但在单页面应用中，但我们重新退出再登录时，页面并没有重新刷新，所以这个过程中并没有重新调用App.vue。（App.vue只在第一次进入时调用，在之前页面跳转时不会调用）</p></li><li><p><strong>解决方法</strong>：我们需要在NavHeader.vue中再次获取购物车数量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getCartCount();</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getCartCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/carts/products/sum&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res = <span class="hljs-number">0</span></span>) =&gt;</span> &#123;</span><br><span class="javascript">         <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveCartCount&#x27;</span>, res);</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>（3）</strong>然而，上面的解决方法<strong>还会存在一个问题</strong>：</p><ul><li><p><strong>问题</strong>：如果我们刷新后，会重复两次获取购物车数量，存在资源浪费。</p></li><li><p><strong>解决方法</strong>：在NavHeader.vue中做个判断：只有从登陆页面中跳转过来的才获取购物车数量。</p><p>如何判断是从登陆跳转过来的呢？可以通过导航守卫。或在登陆页面中做参数跳转。</p><p>下面用在登陆页面中做参数跳转来解决问题：</p><p>在登陆页面做参数跳转方式有很多：query传参、parmas传参或直接在路由上通过？拼接，加入参数。</p><p>下面在NavHeader.vue通过parmas传参：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getProductList();</span><br><span class="javascript">    <span class="hljs-keyword">let</span> params = <span class="hljs-built_in">this</span>.$router.push.params;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (params &amp;&amp; params.from == <span class="hljs-string">&#x27;login&#x27;</span>) &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.getCartCount() </span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>（4）接口优化</strong></p><p>解决了上面的问题，但是有个问题：如果用户没有登录的话，那在App.vue中就没必要去获取购物车的值。所以在App.vue中做个优化：屏蔽不需要调用的接口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$cookie.get(<span class="hljs-string">&#x27;userId&#x27;</span>)) &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.getUser(); </span><br><span class="javascript">      <span class="hljs-built_in">this</span>.getCartCount();</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在login.vue中把cookie改成会话级别的：（会话级别的意思是当浏览器退出后，会话才消失）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> &#123;username, password&#125; = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/user/login&#x27;</span>, &#123;</span><br><span class="javascript">               username,</span><br><span class="javascript">               password</span><br><span class="javascript">          &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$cookie.set(<span class="hljs-string">&#x27;userId&#x27;</span>, res.id, &#123;<span class="hljs-attr">expires</span>:<span class="hljs-string">&#x27;Session&#x27;</span>&#125;); <span class="hljs-comment">//更改为Session</span></span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveUserName&#x27;</span>, res.username);</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/index&#x27;</span>)</span><br><span class="javascript">          &#125;)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>购物车页面实现与ElementUI集成</title>
    <link href="/2020/04/02/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%B4%AD%E7%89%A9%E8%BD%A6%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E4%B8%8EElementUI%E9%9B%86%E6%88%90/"/>
    <url>/2020/04/02/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%B4%AD%E7%89%A9%E8%BD%A6%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E4%B8%8EElementUI%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-购物车页面"><a href="#1-购物车页面" class="headerlink" title="1. 购物车页面"></a><a href="#jumpa">1. 购物车页面</a></h4><ul><li><a href="#jump1"><strong>Order-Header组件</strong></a></li><li><a href="#jump2"><strong>购物车列表渲染</strong></a></li><li><a href="#jump3"><strong>购物车全选和非全选</strong></a></li><li><a href="#jump4"><strong>购物车商品更新和删除</strong></a></li><li><a href="#jump5"><strong>购物车结算</strong></a></li></ul><h4 id="2-ElementUI集成"><a href="#2-ElementUI集成" class="headerlink" title="2. ElementUI集成"></a><a href="#jumpb">2. ElementUI集成</a></h4><h4 id="3-Babel介绍"><a href="#3-Babel介绍" class="headerlink" title="3. Babel介绍"></a><a href="#jumpc">3. Babel介绍</a></h4><h2 id="购物车页面"><a href="#购物车页面" class="headerlink" title="购物车页面"></a><span id="jumpa">购物车页面</span></h2><h4 id="（1）Order-Header组件"><a href="#（1）Order-Header组件" class="headerlink" title="（1）Order-Header组件"></a><span id="jump1">（1）Order-Header组件</span></h4><ul><li>在Order-Header.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;order-header&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container clearfix&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header-logo&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/#/index&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tip&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123;mapState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;order-header&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="javascript">        <span class="hljs-attr">title</span>:<span class="hljs-built_in">String</span>, </span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">computed</span>: &#123;</span><br><span class="javascript">        ...mapState([<span class="hljs-string">&#x27;username&#x27;</span>])</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!--省略样式--&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在使用该样式的文件中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">order-header</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我的购物车&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:tip</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>温馨提示：产品是否购买成功，以最终下单为准哦，请尽快结算。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">order-header</span>&gt;</span> <br></code></pre></td></tr></table></figure><h4 id="（2）购物车列表渲染"><a href="#（2）购物车列表渲染" class="headerlink" title="（2）购物车列表渲染"></a><span id="jump2">（2）购物车列表渲染</span></h4><p>在cart.vue中：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585986466180.png" alt="1585986466180"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs html">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-box&quot;</span>&gt;</span>       <br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-item-head&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;:allChecked&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>全选<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-3&quot;</span>&gt;</span>商品 名称<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span>单价<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-2&quot;</span>&gt;</span>数量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span>小计<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-item-list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in list&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-check&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;:item.productSelected&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-name&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-lazy</span>=<span class="hljs-string">&quot;item.productMainImage&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.productName + &#x27; , &#x27; + item.productSubtitle&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-price&quot;</span>&gt;</span>&#123;&#123;item.productPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-num&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num-box&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.quantity&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> &gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-total&quot;</span>&gt;</span>&#123;&#123;item.productTotalPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-del&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>   <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;order-wrap clearfix&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-tip fl&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/#/index&quot;</span>&gt;</span>继续购物<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            共<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;list.length&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>件商品，已选择<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;checkedNum&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>件<br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;total fr&quot;</span>&gt;</span><br>            合计：<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;cartTotalPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>元<br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>去结算<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cart&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">list</span>: [],</span><br><span class="javascript">            <span class="hljs-attr">allChecked</span>: <span class="hljs-literal">false</span>,</span><br><span class="javascript">            <span class="hljs-attr">cartTotalPrice</span>:<span class="hljs-number">0</span>,</span><br><span class="javascript">            <span class="hljs-attr">checkedNum</span>:<span class="hljs-number">0</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.getCartList();</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getCartList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axois.get(<span class="hljs-string">&#x27;/carts&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.list = res.cartProductVoList || [];</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.allChecked = res.selectedAll;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.cartTotalPrice =res.cartTotalPrice;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.checkedNum = <span class="hljs-built_in">this</span>.list.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.productSelected).length;</span><br><span class="javascript"></span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）购物车全选和非全选"><a href="#（3）购物车全选和非全选" class="headerlink" title="（3）购物车全选和非全选"></a><span id="jump3">（3）购物车全选和非全选</span></h4><p>在cart.vue中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--添加click事件在span元素上--&gt;</span>  <br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-item-head&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;:allChecked&#125;&quot;</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleAll&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>全选<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-3&quot;</span>&gt;</span>商品 名称<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span>单价<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-2&quot;</span>&gt;</span>数量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span>小计<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-1&quot;</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">list</span>: [],</span><br><span class="javascript">            <span class="hljs-attr">allChecked</span>: <span class="hljs-literal">false</span>,</span><br><span class="javascript">            <span class="hljs-attr">cartTotalPrice</span>:<span class="hljs-number">0</span>,</span><br><span class="javascript">            <span class="hljs-attr">checkedNum</span>:<span class="hljs-number">0</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.getCartList();</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getCartList</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axois.get(<span class="hljs-string">&#x27;/carts&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.renderData(res);</span><br><span class="javascript"></span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">toggleAll</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> url = <span class="hljs-built_in">this</span>.allChecked ? <span class="hljs-string">&#x27;/carts/unSelectAll&#x27;</span> : <span class="hljs-string">&#x27;/carts/selectedAll&#x27;</span>;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axois.put(url).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.renderData(res);</span><br><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">            &#125;)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">         <span class="hljs-function"><span class="hljs-title">renderData</span>(<span class="hljs-params">res</span>)</span> &#123;</span><br><span class="javascript">             <span class="hljs-built_in">this</span>.list = res.cartProductVoList || [];</span><br><span class="javascript">             <span class="hljs-built_in">this</span>.allChecked = res.selectedAll;</span><br><span class="javascript">             <span class="hljs-built_in">this</span>.cartTotalPrice = res.cartTotalPrice;</span><br><span class="javascript">             <span class="hljs-built_in">this</span>.checkedNum = <span class="hljs-built_in">this</span>.list.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.productSelected).length;</span><br><span class="javascript">         &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）购物车商品更新和删除"><a href="#（4）购物车商品更新和删除" class="headerlink" title="（4）购物车商品更新和删除"></a><span id="jump4">（4）购物车商品更新和删除</span></h4><p>在cart.vue中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs html">          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-item-list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in list&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-check&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;:item.productSelected&#125;&quot;</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateCart(item)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-name&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-lazy</span>=<span class="hljs-string">&quot;item.productMainImage&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.productName + &#x27; , &#x27; + item.productSubtitle&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-price&quot;</span>&gt;</span>&#123;&#123;item.productPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-num&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num-box&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateCart(item,&#x27;-&#x27;)&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.quantity&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateCart(item,&#x27;+&#x27;)&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-total&quot;</span>&gt;</span>&#123;&#123;item.productTotalPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-del&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;delProduct(item)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          &lt;/ul<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">//在methods中添加两个方法。</span></span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">updateCart</span>(<span class="hljs-params">item, type</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> quantity = item.quantity,</span><br><span class="javascript">                selected = item.productSelected;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;</span><br><span class="javascript">              <span class="hljs-keyword">if</span> (quantity == <span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">                alert(<span class="hljs-string">&#x27;商品至少保留一件&#x27;</span>);</span><br><span class="javascript">                <span class="hljs-keyword">return</span>;</span><br><span class="javascript">              &#125;</span><br><span class="javascript">              -- quantity;</span><br><span class="javascript">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;+&quot;</span>) &#123;</span><br><span class="javascript">              <span class="hljs-keyword">if</span> (quantity &gt; item.productStock) &#123;</span><br><span class="javascript">                alert(<span class="hljs-string">&#x27;商品不能超过库存数量&#x27;</span>);</span><br><span class="javascript">                <span class="hljs-keyword">return</span>;</span><br><span class="javascript">              &#125;</span><br><span class="javascript">              ++ quantity;</span><br><span class="javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">              selected = !item.productSelected;</span><br><span class="javascript">            &#125;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.axois.put(<span class="hljs-string">`/carts/<span class="hljs-subst">$&#123;item.productId&#125;</span>`</span>,&#123;</span><br><span class="javascript">              quantity,</span><br><span class="javascript">              selected</span><br><span class="javascript">            &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.renderData(res)</span><br><span class="javascript">            &#125;)</span><br><span class="javascript"></span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">delProduct</span>(<span class="hljs-params">item</span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.axois.delete(<span class="hljs-string">`/carts/<span class="hljs-subst">$&#123;item.productId&#125;</span>`</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.renderData(res)</span><br><span class="javascript">          &#125;)</span><br><span class="javascript">        &#125;              </span><br><span class="javascript">   &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（5）购物车结算"><a href="#（5）购物车结算" class="headerlink" title="（5）购物车结算"></a><span id="jump5">（5）购物车结算</span></h4><p>在cart.vue中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span>去结算<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">//在methods中添加两个方法。</span></span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-comment">//购物车下单</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">order</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> isCheck = <span class="hljs-built_in">this</span>.list.every( <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !item.productSelected);</span><br><span class="javascript">          <span class="hljs-keyword">if</span> (isCheck) &#123;</span><br><span class="javascript">            alert(<span class="hljs-string">&#x27;请选择一件商品&#x27;</span>)</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/order/confirm&#x27;</span>);</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="ElementUI集成"><a href="#ElementUI集成" class="headerlink" title=" ElementUI集成"></a><span id="jumpb"> ElementUI集成</span></h2><ul><li><p>安装ElementUI与balel-plugin-component:</p><p><code>npm  i element-ui babel-plugin-component --save-dev</code></p></li><li><p>安装@babel/preset-env:</p><p><code>npm i @babel/preset-env -D</code></p></li><li><p>在项目根目录下创建文件.babelrc，并添加配置：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;presets&quot;</span>: [[<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, &#123;<span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span>&#125;]],<br>    <span class="hljs-string">&quot;plugins&quot;</span>: [<br>        [<br>            <span class="hljs-string">&quot;component&quot;</span>,<br>            &#123;<br>                <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,<br>                <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span><br>            &#125;<br>        ]<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>下面以使用ElementUI中的Message插件为例：</p><p>由于Message是一个插件，插件有两种使用方式。</p><p><strong>第1种是在使用到的文件中导入。如：</strong></p><ul><li>在main.js中引入ElementUI并使用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Message&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><br>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = response.data;<br>  <span class="hljs-keyword">let</span> path = location.hash;<br>  <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.data;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">if</span> (path != <span class="hljs-string">&#x27;#/index&#x27;</span>) &#123;<br>        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&#x27;/#/login&#x27;</span>;<br>        <br>      &#125; <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(res);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    Message.warning(res.msg);  <span class="hljs-comment">//使用ElementUI</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(res);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>在cart.vue中使用：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123;Message&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span></span><br><span class="javascript"><span class="hljs-comment">//购物车下单</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">order</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> isCheck = <span class="hljs-built_in">this</span>.list.every( <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !item.productSelected);</span><br><span class="javascript">          <span class="hljs-keyword">if</span> (isCheck) &#123;</span><br><span class="javascript">            Message.warning(<span class="hljs-string">&#x27;请选择一件商品&#x27;</span>)</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/order/confirm&#x27;</span>);</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第2中是通过prototype将其扩展到Vue原型上，通过this调用。如：</strong></p><ul><li>在main.js中引入ElementUI并使用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;Message&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><br>Vue.prototype.$message = Message;<br><br>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = response.data;<br>  <span class="hljs-keyword">let</span> path = location.hash;<br>  <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.data;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">if</span> (path != <span class="hljs-string">&#x27;#/index&#x27;</span>) &#123;<br>        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&#x27;/#/login&#x27;</span>;<br>        <br>      &#125; <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(res);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">this</span>.$message.warning(res.msg);  <span class="hljs-comment">//使用ElementUI</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(res);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>在cart.vue中使用：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//购物车下单</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">order</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> isCheck = <span class="hljs-built_in">this</span>.list.every( <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !item.productSelected);</span><br><span class="javascript">          <span class="hljs-keyword">if</span> (isCheck) &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$message.warning(<span class="hljs-string">&#x27;请选择一件商品&#x27;</span>)</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/order/confirm&#x27;</span>);</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Babel介绍"><a href="#Babel介绍" class="headerlink" title=" Babel介绍"></a><span id="jumpc"> Babel介绍</span></h2><p><strong>Babel 是一个JavaScript编译器</strong></p><p>Babel是一个工具链，主要用于将ECMAScript2015+版本的代码转换为向后兼容的JavaScript语法，以便能够运行在当前和就版本的浏览器或其他环境中。</p><ul><li>将文件.babelrc合并到babel.config.js，并删除该文件：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;presets&quot;</span>: [[<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, &#123;<span class="hljs-attr">&quot;modules&quot;</span>: <span class="hljs-literal">false</span>&#125;]],<br>    <span class="hljs-attr">&quot;plugins&quot;</span>: [<br>        [<br>            <span class="hljs-string">&quot;component&quot;</span>,<br>            &#123;<br>                <span class="hljs-attr">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,<br>                <span class="hljs-attr">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span><br>            &#125;<br>        ]<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在babel.config.js中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-string">&quot;presets&quot;</span>: [<br>    <span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span><br>  ],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<br>    [<br>        <span class="hljs-string">&quot;component&quot;</span>,<br>        &#123;<br>            <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,<br>            <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span><br>        &#125;<br>    ]<br>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>产品站与商品详情实现</title>
    <link href="/2020/03/31/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E4%BA%A7%E5%93%81%E7%AB%99%E4%B8%8E%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/03/31/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E4%BA%A7%E5%93%81%E7%AB%99%E4%B8%8E%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="产品站与商品详情实现"><a href="#产品站与商品详情实现" class="headerlink" title="产品站与商品详情实现"></a>产品站与商品详情实现</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-产品站页面"><a href="#1-产品站页面" class="headerlink" title="1. 产品站页面"></a><a href="#jumpa">1. 产品站页面</a></h4><ul><li><a href="#jump1"><strong>组件吸顶实现</strong></a></li><li><a href="#jump2"><strong>视频模块实现</strong></a></li><li><a href="#jump3"><strong>视频模块实现</strong></a></li><li><a href="#jump4"><strong>交互实现</strong></a></li><li><a href="#jump5"><strong>解决一个视频模块bug</strong></a></li></ul><h4 id="2-商品详情页面"><a href="#2-商品详情页面" class="headerlink" title="2. 商品详情页面"></a><a href="#jumpb">2. 商品详情页面</a></h4><ul><li><a href="#jump6"><strong>清楚浮动</strong></a></li><li><a href="#jump7"><strong>交互实现</strong></a></li></ul><h2 id="产品站页面"><a href="#产品站页面" class="headerlink" title="产品站页面"></a><span id = "jumpa">产品站页面</span></h2><h4 id="（1）组件吸顶实现"><a href="#（1）组件吸顶实现" class="headerlink" title="（1）组件吸顶实现"></a><span id = "jump1">（1）组件吸顶实现</span></h4><ul><li>在要实现吸顶的组件文件ProductParam.Vue中</li></ul><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-bar&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pro-title&quot;</span>&gt;</span><br>                小米8<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pro-param&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>概述<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>参数<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>用户评价<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;buy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;nav-bar&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">isFixed</span>: <span class="hljs-literal">false</span></span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-built_in">this</span>.initHeight)  </span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">initHeight</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">window</span>.pageYOffset || <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.isFixed = scrollTop &gt; <span class="hljs-number">152</span>? <span class="hljs-literal">true</span>: <span class="hljs-literal">false</span></span><br><span class="javascript"></span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">destroyed</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-built_in">this</span>.initHeight, <span class="hljs-literal">false</span>)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./../assets/scss/config.scss&#x27;</span>;</span><br><span class="css">  <span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./../assets/scss/mixin.scss&#x27;</span>;</span><br><span class="css">  <span class="hljs-selector-class">.nav-bar</span>&#123;</span><br><span class="css">    <span class="hljs-attribute">height</span>:<span class="hljs-number">70px</span>;</span><br><span class="css">    <span class="hljs-attribute">line-height</span>:<span class="hljs-number">70px</span>;</span><br><span class="css">    <span class="hljs-attribute">border-top</span>:<span class="hljs-number">1px</span> solid $colorH;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>:$colorG;</span><br><span class="css">    <span class="hljs-attribute">z-index</span>:<span class="hljs-number">10</span>;</span><br><span class="css">    &amp;<span class="hljs-selector-class">.is_fixed</span>&#123;</span><br><span class="css">      <span class="hljs-attribute">position</span>:fixed;</span><br><span class="css">      <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-number">5px</span> $colorE;</span><br><span class="css">    &#125;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）视频模块实现"><a href="#（2）视频模块实现" class="headerlink" title="（2）视频模块实现"></a><span id = "jump2">（2）视频模块实现</span></h4><ul><li>在需要视频模块的文件product.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-box&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;overlay&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-close&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--controls属性指定视频控件, muted静音输出  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imgs/product/video.mp4&quot;</span> <span class="hljs-attr">muted</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>  <br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-class">.video-box</span>&#123;</span><br><span class="css">          <span class="hljs-selector-class">.overlay</span>&#123;</span><br><span class="css">            <span class="hljs-keyword">@include</span> position(fixed);</span><br><span class="css">            <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#333333</span>;</span><br><span class="css">            <span class="hljs-attribute">opacity</span>:.<span class="hljs-number">4</span>;</span><br><span class="css">            <span class="hljs-attribute">z-index</span>:<span class="hljs-number">10</span>;</span><br><span class="css">          &#125;</span><br><span class="css">          <span class="hljs-selector-class">.video</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">position</span>:fixed;</span><br><span class="css">            <span class="hljs-attribute">top</span>:-<span class="hljs-number">50%</span>;</span><br><span class="css">            <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;</span><br><span class="css">            <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);</span><br><span class="css">            <span class="hljs-attribute">z-index</span>:<span class="hljs-number">10</span>;</span><br><span class="css">            <span class="hljs-attribute">width</span>:<span class="hljs-number">1000px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">536px</span>;</span><br><span class="css">            <span class="hljs-selector-class">.icon-close</span>&#123;</span><br><span class="css">              <span class="hljs-attribute">position</span>:absolute;</span><br><span class="css">              <span class="hljs-attribute">top</span>:<span class="hljs-number">20px</span>;</span><br><span class="css">              <span class="hljs-attribute">right</span>:<span class="hljs-number">20px</span>;</span><br><span class="css">              <span class="hljs-keyword">@include</span> bgImg(<span class="hljs-number">20px</span>,<span class="hljs-number">20px</span>,<span class="hljs-string">&#x27;/imgs/icon-close.png&#x27;</span>);</span><br><span class="css">              <span class="hljs-attribute">cursor</span>:pointer;</span><br><span class="css">              <span class="hljs-attribute">z-index</span>:<span class="hljs-number">11</span>;</span><br><span class="css">            &#125;</span><br><span class="css">            <span class="hljs-selector-tag">video</span>&#123;</span><br><span class="css">              <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;</span><br><span class="css">              <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;</span><br><span class="css">              <span class="hljs-attribute">object-fit</span>:cover;</span><br><span class="css">              <span class="hljs-attribute">outline</span>:none;</span><br><span class="css">            &#125;</span><br><span class="css">          &#125;</span><br><span class="css">        &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）视频模块实现"><a href="#（3）视频模块实现" class="headerlink" title="（3）视频模块实现"></a><span id = "jump3">（3）视频模块实现</span></h4><ul><li>在文件product.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs html">       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-bg&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showSlide=&#x27;slideDown&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-box&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;overlay&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showSlide=&#x27;slideDown&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;showSlide&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-close&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showSlide=&#x27;slideUp&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imgs/product/video.mp4&quot;</span> <span class="hljs-attr">muted</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;product&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">showSlide</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//控制动画效果</span></span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"> <span class="hljs-comment">/*省略重复样式代码*/</span></span><br><span class="css">    <span class="hljs-selector-class">.video-box</span>&#123;</span><br><span class="css">          <span class="hljs-keyword">@keyframes</span> slideDown&#123;</span><br><span class="css">            <span class="hljs-selector-tag">from</span>&#123;</span><br><span class="css">              <span class="hljs-attribute">top</span>:-<span class="hljs-number">50%</span>;</span><br><span class="css">              <span class="hljs-attribute">opacity</span>:<span class="hljs-number">0</span>;</span><br><span class="css">            &#125;</span><br><span class="css">            <span class="hljs-selector-tag">to</span>&#123;</span><br><span class="css">              <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;</span><br><span class="css">              <span class="hljs-attribute">opacity</span>:<span class="hljs-number">1</span>;</span><br><span class="css">            &#125;</span><br><span class="css">          &#125;</span><br><span class="css">          <span class="hljs-keyword">@keyframes</span> slideUp&#123;</span><br><span class="css">            <span class="hljs-selector-tag">from</span>&#123;</span><br><span class="css">              <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;</span><br><span class="css">              <span class="hljs-attribute">opacity</span>:<span class="hljs-number">1</span>;</span><br><span class="css">            &#125;</span><br><span class="css">            <span class="hljs-selector-tag">to</span>&#123; </span><br><span class="css">              <span class="hljs-attribute">top</span>:-<span class="hljs-number">50%</span>;</span><br><span class="css">              <span class="hljs-attribute">opacity</span>:<span class="hljs-number">0</span>;</span><br><span class="css">            &#125;</span><br><span class="css">          &#125;</span><br><span class="css">          <span class="hljs-selector-class">.video</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">opacity</span>:<span class="hljs-number">1</span>; </span><br><span class="css">            &amp;<span class="hljs-selector-class">.slideDown</span>&#123;</span><br><span class="css">              <span class="hljs-attribute">animation</span>:slideDown .<span class="hljs-number">6s</span> linear;</span><br><span class="css">              <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;</span><br><span class="css">            &#125;</span><br><span class="css">            &amp;<span class="hljs-selector-class">.slideUp</span>&#123;</span><br><span class="css">              <span class="hljs-attribute">animation</span>:slideUp .<span class="hljs-number">6s</span> linear;</span><br><span class="css">            &#125;</span><br><span class="css">          &#125;</span><br><span class="css">        &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）交互实现"><a href="#（4）交互实现" class="headerlink" title="（4）交互实现"></a><span id = "jump4">（4）交互实现</span></h4><ul><li>在product.vue页面中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--省略了无关代码--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">product-param</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;product.name&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:buy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;buy&quot;</span>&gt;</span>立即购买<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">product-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-bg&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;product.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;product.subtitle&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;price&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>￥<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>&#123;&#123;product.price&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;product&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">product</span>:&#123;&#125;,<span class="hljs-comment">//商品信息</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.getProductInfo();</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">getProductInfo</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">this</span>.$route.params.id;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">`/products/<span class="hljs-subst">$&#123;id&#125;</span>`</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.product = res;</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">buy</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">this</span>.$route.params.id;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">`/detail/<span class="hljs-subst">$&#123;id&#125;</span>`</span>); <span class="hljs-comment">//跳转到商品详情页面</span></span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（5）解决一个视频模块bug"><a href="#（5）解决一个视频模块bug" class="headerlink" title="（5）解决一个视频模块bug"></a><span id = "jump5">（5）解决一个视频模块bug</span></h4><p><strong>问题</strong>：在调试时，用于页面窗口变小时，视频样式出现问题。</p><ul><li>在文件product.vue中修改：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html">       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-bg&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showSlide=&#x27;slideDown&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-box&quot;</span>  <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;showSlide&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;overlay&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;showSlide&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-close&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;closeVideo&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imgs/product/video.mp4&quot;</span> <span class="hljs-attr">muted</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;product&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">showSlide</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//控制动画效果</span></span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">       <span class="hljs-function"><span class="hljs-title">closeVideo</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.showSlide=<span class="hljs-string">&#x27;slideUp&#x27;</span>;</span><br><span class="javascript">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.showSlide=<span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="javascript">        &#125;,<span class="hljs-number">600</span>)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="商品详情页面"><a href="#商品详情页面" class="headerlink" title="商品详情页面"></a><span id = "jumpb">商品详情页面</span></h2><h4 id="（1）清除浮动"><a href="#（1）清除浮动" class="headerlink" title="（1）清除浮动"></a><span id = "jump6">（1）清除浮动</span></h4><ul><li>在需要清除浮动的页面：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-version clearfix&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;phone fl&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;:version==1&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;version=1&quot;</span>&gt;</span>6GB+64GB 全网通<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;phone fr&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;checked&#x27;:version==2&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;version=2&quot;</span>&gt;</span>4GB+64GB 移动4G<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在base.scss文件中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.clearfix</span>:before,.clearfix:after&#123;<br>  content:<span class="hljs-string">&#x27; &#x27;</span>;<br>  <span class="hljs-attribute">display</span>:table;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span>:after&#123;<br>  clear: both;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）交互实现"><a href="#（2）交互实现" class="headerlink" title="（2）交互实现"></a><span id = "jump7">（2）交互实现</span></h4><ul><li>在detail.vue文件中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;detail&#x27;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">err</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">      <span class="hljs-attr">id</span>: <span class="hljs-built_in">this</span>.$router.params.id,</span><br><span class="javascript">      <span class="hljs-attr">Product</span>: &#123;&#125;,</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getProductInfo();</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getProductInfo</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axois.get(<span class="hljs-string">`/product/<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.id&#125;</span>`</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.Product = res;</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">addCart</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/carts&#x27;</span>, &#123;</span><br><span class="javascript">        <span class="hljs-attr">productId</span>: <span class="hljs-built_in">this</span>.id,</span><br><span class="javascript">        <span class="hljs-attr">selected</span>: <span class="hljs-literal">true</span></span><br><span class="javascript">      &#125;).then(<span class="hljs-function">(<span class="hljs-params">res = &#123;cartProductVoList:<span class="hljs-number">0</span>&#125;</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveCartCount&#x27;</span>, res.cartProductVoList.length);</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/cart&#x27;</span>);</span><br><span class="javascript">      &#125;).catch(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.error = res;</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 动态规划</title>
    <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p><h4 id="（2）基本思想与策略"><a href="#（2）基本思想与策略" class="headerlink" title="（2）基本思想与策略"></a>（2）基本思想与策略</h4><p>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>​    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p><h4 id="能用动规解决的问题的特点"><a href="#能用动规解决的问题的特点" class="headerlink" title="能用动规解决的问题的特点"></a>能用动规解决的问题的特点</h4><p>能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li> 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li><li> 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li><li>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</li></ul><p><strong>上面概念太抽象，建议看：</strong>（有些回答很赞）</p><p><a href="https://www.zhihu.com/question/39948290">如何理解动态规划？</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 回溯算法</title>
    <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h4 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h4><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。<br>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h4 id="（2）基本思想"><a href="#（2）基本思想" class="headerlink" title="（2）基本思想"></a>（2）基本思想</h4><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。<a href="https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">八皇后问题</a>就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9">节点</a>，从而减少状态空间树节点的生成。<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95">回溯法</a>是一个既带有系统性又带有跳跃性的的<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">搜索算法</a>。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95">回溯法</a>在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p><h4 id="（3）解空间的树结构"><a href="#（3）解空间的树结构" class="headerlink" title="（3）解空间的树结构"></a>（3）解空间的树结构</h4><p>使用回溯法的解空间一般有两种解空间：<strong>子集树和排列树</strong></p><ul><li><p><strong>子集树</strong></p><p>当所给的问题从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。常用于0-1问题，如0-1背包问题。</p></li><li><p><strong>排列树</strong></p><p>当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称之为排列树。排序树通常有n！叶结点。</p></li></ul><h4 id="（4）用回溯法解题的一般步骤"><a href="#（4）用回溯法解题的一般步骤" class="headerlink" title="（4）用回溯法解题的一般步骤"></a>（4）用回溯法解题的一般步骤</h4><ul><li><p>针对所给问题，确定问题的解空间：<br>首先明确定义问题的解空间，问题的解空间应该至少包含问题的一个解</p></li><li><p>确定结点扩展搜索规则</p></li><li><p>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</p></li></ul><p>确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95">回溯法</a>即以这种工作方式<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92">递归</a>地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。</p><h4 id="（5）算法框架"><a href="#（5）算法框架" class="headerlink" title="（5）算法框架"></a>（5）算法框架</h4><ul><li><p><strong>问题框架</strong></p><p>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</p></li><li><p><strong>递归回溯框架</strong></p><p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span> (<span class="hljs-params">t</span>) //<span class="hljs-title">t</span>表示递归深度</span><br><span class="hljs-function"></span>&#123;<br>       <span class="hljs-keyword">if</span> (t&gt;n) output(x); <span class="hljs-comment">//n表示深度界限</span><br>       <span class="hljs-keyword">else</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=f(n,t);i&lt;=g(n,t);i++) <span class="hljs-comment">// f(n,t)，g(n,t)分别表示当前扩展结点未搜索过的子树的起始编号和终止编号</span><br>           &#123;<br>           x[t]=h(i); <br>           <span class="hljs-keyword">if</span> (constraint(t) &amp;&amp; bound(t)) <span class="hljs-comment">//满足约束函数和限界函数</span><br>              backtrack(t+<span class="hljs-number">1</span>);<br>           &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>非递归的算法框架</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterativeBacktrack</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">let</span> t=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (t&gt;<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (f(n,t)&lt;=g(n,t)) <br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=f(n,t);i&lt;=g(n,t);i++) &#123;<br>        x[t]=h(i);<br>        <span class="hljs-keyword">if</span> (constraint(t) &amp;&amp; bound(t)) &#123;<br>          <span class="hljs-keyword">if</span> (solution(t)) output(x);<br>          <span class="hljs-keyword">else</span> t++;&#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span> t--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>学习参考于：</strong></p><p><a href="https://www.jianshu.com/p/f6d3732e86fb">回溯算法</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 -递归算法  分治算法</title>
    <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%20%20%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%20%20%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><h4 id="（1）递归需要满足的三个条件"><a href="#（1）递归需要满足的三个条件" class="headerlink" title="（1）递归需要满足的三个条件"></a>（1）递归需要满足的三个条件</h4><ul><li><p><strong>一个问题的解可以分解为几个子问题的解</strong></p><p>何为子问题？子问题就是数据规模更小的问题。</p></li><li><p><strong>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></p></li><li><p><strong>存在递归终止条件</strong></p><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p></li></ul><h4 id="（2）如何编写递归代码？"><a href="#（2）如何编写递归代码？" class="headerlink" title="（2）如何编写递归代码？"></a>（2）如何编写递归代码？</h4><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><p>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p><h4 id="（3）递归的弊端："><a href="#（3）递归的弊端：" class="headerlink" title="（3）递归的弊端："></a>（3）递归的弊端：</h4><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。</p><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h4 id="（1）什么是分治算法"><a href="#（1）什么是分治算法" class="headerlink" title="（1）什么是分治算法"></a>（1）什么是分治算法</h4><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h4 id="（2）基本思想及策略"><a href="#（2）基本思想及策略" class="headerlink" title="（2）基本思想及策略"></a>（2）基本思想及策略</h4><p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h4 id="（3）分治法适用的情况"><a href="#（3）分治法适用的情况" class="headerlink" title="（3）分治法适用的情况"></a>（3）分治法适用的情况</h4><p>分治法所能解决的问题一般具有以下几个特征：</p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决</li><li> 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li><li> 利用该问题分解出的子问题的解可以合并为该问题的解；</li><li> 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li></ul><h4 id="（4）分治法的基本步骤"><a href="#（4）分治法的基本步骤" class="headerlink" title="（4）分治法的基本步骤"></a>（4）分治法的基本步骤</h4><ul><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解。</li></ul><p><strong>递归使用的就是分治的思想，它是分治思想的一种具体实现。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录页面实现与Vuex集成</title>
    <link href="/2020/03/29/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E4%B8%8EVuex%E9%9B%86%E6%88%90/"/>
    <url>/2020/03/29/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E4%B8%8EVuex%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-登录页面"><a href="#1-登录页面" class="headerlink" title="1. 登录页面"></a><a href="#jumpa">1. 登录页面</a></h4><ul><li><a href="#jump1"><strong>登录功能</strong></a></li><li><a href="#jump2"><strong>拉取用户信息</strong></a></li></ul><h4 id="2-Vuex集成"><a href="#2-Vuex集成" class="headerlink" title="2. Vuex集成"></a><a href="#jumpb"><strong>2. Vuex集成</strong></a></h4><ul><li><p><a href="#jump3"><strong>Vuex框架搭建</strong></a></p></li><li><p><a href="#jump4"><strong>Vuex存储读取数据</strong></a></p></li><li><p><a href="#jump5"><strong>解决vuex页面数据延迟</strong></a></p></li></ul><h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a><span id="jumpa">登录页面</span></h2><h4 id="（1）登录功能"><a href="#（1）登录功能" class="headerlink" title="（1）登录功能"></a><span id="jump1">（1）登录功能</span></h4><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login-form&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span>帐号登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sep-line&quot;</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>扫码登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入帐号&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入密码&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn-box&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sms&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;register&quot;</span>&gt;</span>手机短信登录/注册<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;reg&quot;</span>&gt;</span>立即注册<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>忘记密码？<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">      <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">      <span class="hljs-attr">userId</span>:<span class="hljs-string">&#x27;&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> &#123;username, password&#125; = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/user/login&#x27;</span>, &#123;</span><br><span class="javascript">               username,</span><br><span class="javascript">               password</span><br><span class="javascript">          &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$cookie.set(<span class="hljs-string">&#x27;userId&#x27;</span>, res.id, &#123;<span class="hljs-attr">expires</span>:<span class="hljs-string">&#x27;1M&#x27;</span>&#125;);</span><br><span class="javascript">              <span class="hljs-comment">//to-do保存用户名</span></span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/index&#x27;</span>)</span><br><span class="javascript">          &#125;)</span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/user/register&#x27;</span>, &#123;</span><br><span class="javascript">              <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;admin&#x27;</span>,</span><br><span class="javascript">              <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;admin1&#x27;</span>,</span><br><span class="javascript">              <span class="hljs-attr">email</span>:<span class="hljs-string">&#x27;admin@163.com&#x27;</span></span><br><span class="javascript">          &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">              alert(<span class="hljs-string">&#x27;注册成功&#x27;</span>);</span><br><span class="javascript">          &#125;)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）拉取用户信息"><a href="#（2）拉取用户信息" class="headerlink" title="（2）拉取用户信息"></a><span id="jump2">（2）拉取用户信息</span></h4><p>在App.vue中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-comment">//import storage from &#x27;./storage&#x27; </span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123; </span><br><span class="javascript">      <span class="hljs-attr">res</span>: &#123;&#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getUser(); </span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getCartCount();</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getUser</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/user&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">//to-do保存在vuex</span></span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getCartCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/carts/products/sum&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">//to-do 保存在vuex</span></span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Vuex集成"><a href="#Vuex集成" class="headerlink" title="Vuex集成"></a><span id="jumpb">Vuex集成</span></h2><h4 id="（1）Vuex框架搭建"><a href="#（1）Vuex框架搭建" class="headerlink" title="（1）Vuex框架搭建"></a><span id="jump3">（1）Vuex框架搭建</span></h4><ul><li><p>在src文件夹中创建文件夹store，并在store文件夹下创建三个文件，分别是 action.js、index.js、mutations.js。</p></li><li><p>在index.js中：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> mutations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mutations&#x27;</span><br><span class="hljs-keyword">import</span> actions <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./action&#x27;</span><br>Vue.use(Vuex);<br><span class="hljs-keyword">const</span> state = &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">cartCount</span>: <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    state,<br>    mutations,<br>    actions<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>在mutations.js中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;   <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在action.js中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在main.js中新增：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="（2）Vuex存储读取数据"><a href="#（2）Vuex存储读取数据" class="headerlink" title="（2）Vuex存储读取数据"></a><span id="jump4">（2）Vuex存储读取数据</span></h4><ul><li>在action.js中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">saveUserName</span>(<span class="hljs-params">context, username</span>)</span> &#123;<br>        context.commit(<span class="hljs-string">&#x27;saveUserName&#x27;</span>, username);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">saveCartCount</span>(<span class="hljs-params">context, count</span>)</span> &#123;<br>        context.commit(<span class="hljs-string">&#x27;saveCartCount&#x27;</span>, count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在mutations.js中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">saveUserName</span>(<span class="hljs-params">state, username</span>)</span> &#123;<br>        state.username = username;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">saveCartCount</span>(<span class="hljs-params">state, count</span>)</span> &#123;<br>        state.cartCount = count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在login.vue中存储用户信息：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--大部分无关无关代码被省略--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn-box&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript"> <span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> &#123;username, password&#125; = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.axios.post(<span class="hljs-string">&#x27;/user/login&#x27;</span>, &#123;</span><br><span class="javascript">               username,</span><br><span class="javascript">               password</span><br><span class="javascript">          &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$cookie.set(<span class="hljs-string">&#x27;userId&#x27;</span>, res.id, &#123;<span class="hljs-attr">expires</span>:<span class="hljs-string">&#x27;1M&#x27;</span>&#125;);</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveUserName&#x27;</span>, res.username); <span class="hljs-comment">//将用户信息存入state中</span></span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/index&#x27;</span>)</span><br><span class="javascript">          &#125;)     </span><br><span class="javascript">  &#125;</span><br><span class="javascript"> &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在NavHeader.vue读取用户信息：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.$store.state.username,</span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>在App.vue中</p><p>由于store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值。当页面重新加载时，在App.vue中重新存储一次用户信息到state里。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.getUser(); <br>  &#125;, <br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">getUser</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/user&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;saveUserName&#x27;</span>, res.username);<br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="（3）解决vuex页面数据延迟"><a href="#（3）解决vuex页面数据延迟" class="headerlink" title="（3）解决vuex页面数据延迟"></a><span id="jump5">（3）解决vuex页面数据延迟</span></h4><p>vuex数据更新,页面数据没有跟着刷新？这是由于先通过<code>this.$store.state.username,</code>读取到了变量，而此时这个变量还未被存储到state中，所以为空。读取了空变量后才执行了<code> this.$store.dispatch(&#39;saveUserName&#39;, res.username);</code>。</p><p><strong>解决方法之一</strong>：使用计算属性。</p><p>将NavHeader.vue中修改为如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">    &#125;;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">username</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.state.username;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 堆</title>
    <link href="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%A0%86/"/>
    <url>/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h4 id="（1）什么是二叉堆"><a href="#（1）什么是二叉堆" class="headerlink" title="（1）什么是二叉堆"></a>（1）什么是二叉堆</h4><p>二叉堆本质上是一种完全二叉树，二叉堆的经典表示方法是使用一个数组表示，其中：</p><ul><li><p>根结点为数组的第一个元素A[0]。</p></li><li><p>其它结点中，第i个结点和数组索引元素对应的关系为：</p></li></ul><table><thead><tr><th>A[(i – 1) / 2]</th><th>返回第i个结点的父结点</th></tr></thead><tbody><tr><td>A[(2 * i) + 1]</td><td>返回第i个结点的左儿子结点</td></tr><tr><td>A[(2 * i) + 2]</td><td>返回第i个结点的右儿子结点</td></tr></tbody></table><p>它分为两个类型：</p><ul><li><p><strong>最大堆</strong></p><p>最大堆任何一个父节点的值，都<strong>大于等于</strong>它左右孩子节点的值。</p></li><li><p><strong>最小堆</strong></p><p>最小堆任何一个父节点的值，都<strong>小于等于</strong>它左右孩子节点的值。</p></li></ul><p>假设父节点的下标是parent，那么它的左孩子下标就是 <strong>2*parent+1</strong>；它的右孩子下标就是  <strong>2*parent+2</strong> 。</p><h4 id="（2）二叉堆的主要操作"><a href="#（2）二叉堆的主要操作" class="headerlink" title="（2）二叉堆的主要操作"></a>（2）二叉堆的主要操作</h4><ul><li><p><strong>堆的构建</strong></p><p><strong>大顶堆</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//从第一个非叶子节点开始依次对数组中的元素进行下沉操作</span><br><span class="hljs-comment">//和孩子节点的最大值max比较</span><br><span class="hljs-comment">//大于max — 不需要在下沉</span><br><span class="hljs-comment">//小于max — 和max交换位置 - 继续和下一层孩子节点比较，直到队列末尾</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajustMaxHeap</span>(<span class="hljs-params">array, index, length</span>) </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>; i &lt; length; i = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; length &amp;&amp; array[i + <span class="hljs-number">1</span>] &gt; array[i]) &#123;<br>          i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (array[index] &gt;= [array[i]]) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          [array[index], array[i]] = [array[i], array[index]];<br>          index = i;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMaxHeap</span>(<span class="hljs-params">arr, length</span>) </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(length / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        ajustMaxHeap(arr, i, length);<br>      &#125;<br>      <span class="hljs-keyword">return</span> arr;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>小顶堆</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//从第一个非叶子节点开始依次对数组中的元素进行下沉操作</span><br><span class="hljs-comment">//和孩子节点的最小值min比较</span><br><span class="hljs-comment">//小于min — 不需要在下沉</span><br><span class="hljs-comment">//大于min — 和min交换位置（下沉） - 继续和下一层孩子节点比较，直到队列末尾</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajustMinHeap</span>(<span class="hljs-params">array, index, length</span>) </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>; i &lt; length; i = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; length &amp;&amp; array[i + <span class="hljs-number">1</span>] &lt; array[i]) &#123;<br>          i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (array[index] &lt; [array[i]]) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          [array[index], array[i]] = [array[i], array[index]];<br>          index = i;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMinHeap</span>(<span class="hljs-params">arr, length</span>) </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(length / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        ajustMinHeap(arr, i, length);<br>      &#125;<br>      <span class="hljs-keyword">return</span> arr;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>堆的插入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//由于堆属于优先队列，只能从末尾添加</span><br><span class="hljs-comment">//添加后有可能破坏堆的结构，需要从下到上进行调整</span><br><span class="hljs-comment">//如果元素小于父元素，上浮</span><br><span class="hljs-comment">//以小顶堆为例：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minHeapAdd</span>(<span class="hljs-params">array = [], element</span>) </span>&#123;<br>      array.push(element);<br>      <span class="hljs-keyword">if</span> (array.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> index = array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> target = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">while</span> (target &gt;= <span class="hljs-number">0</span>) &#123; array[target]);<br>          <span class="hljs-keyword">if</span> (array[index] &lt; array[target]) &#123;<br>            [array[index], array[target]] = [array[target], array[index]]<br>            index = target;<br>            target = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> array;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>堆的移除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//由于堆属于优先队列，只能从头部移除</span><br><span class="hljs-comment">//移除头部后，使用末尾元素填充头部，开始头部下沉操作</span><br><span class="hljs-comment">//以小顶堆为例：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minHeapPop</span>(<span class="hljs-params">array = []</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">if</span> (array.length &gt; <span class="hljs-number">1</span>) &#123;<br>        result = array[<span class="hljs-number">0</span>];<br>        array[<span class="hljs-number">0</span>] = array.pop();<br>        ajustMinHeap(array, <span class="hljs-number">0</span>, array.length);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array.length === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> array.pop();<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>封装</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arr, type</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.data = [...arr];<br>    <span class="hljs-built_in">this</span>.type = type;<br>    <span class="hljs-built_in">this</span>.size = <span class="hljs-built_in">this</span>.data.length;<br>  &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-built_in">this</span>.size / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">this</span>.ajust(i);<br>      &#125; <br>  &#125;<br>    <br>  ajust (index) &#123;<br>      <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>.data;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">this</span>.size; i = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">this</span>.size) &#123;<br>          <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.type === <span class="hljs-string">&#x27;max&#x27;</span> &amp;&amp; arr[i + <span class="hljs-number">1</span>] &gt; arr[i]) ||<br>            (<span class="hljs-built_in">this</span>.type === <span class="hljs-string">&#x27;min&#x27;</span> &amp;&amp; arr[i + <span class="hljs-number">1</span>] &lt; arr[i])) &#123;<br>            i++;<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.type === <span class="hljs-string">&#x27;max&#x27;</span> &amp;&amp; arr[index] &lt; [arr[i]]) ||<br>          (<span class="hljs-built_in">this</span>.type === <span class="hljs-string">&#x27;min&#x27;</span> &amp;&amp; arr[index] &gt; [arr[i]])) &#123;<br>          [arr[index], arr[i]] = [arr[i], arr[index]];<br>          index = i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <br>    add (element) &#123;<br>      <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>.data;<br>      arr.push(element);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.size &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> target = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">while</span> (target &gt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.type === <span class="hljs-string">&#x27;min&#x27;</span> &amp;&amp; arr[index] &lt; arr[target]) ||<br>            (<span class="hljs-built_in">this</span>.type === <span class="hljs-string">&#x27;max&#x27;</span> &amp;&amp; arr[index] &gt; arr[target])) &#123;<br>            [arr[index], arr[target]] = [arr[target], arr[index]]<br>            index = target;<br>            target = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <br>    pop () &#123;<br>      <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>.data;<br>      <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.size &gt; <span class="hljs-number">1</span>) &#123;<br>        result = arr[<span class="hljs-number">0</span>];<br>        arr[<span class="hljs-number">0</span>] = arr.pop();<br>        <span class="hljs-built_in">this</span>.ajust(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.size);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.size === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr.pop();<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;<br><br>    <span class="hljs-keyword">var</span> heap = <span class="hljs-keyword">new</span> Heap(<span class="hljs-string">&#x27;max&#x27;</span>);<br>    heap.add(<span class="hljs-number">6</span>)<br>    heap.add(<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">console</span>.log(heap.value);<br>    <span class="hljs-built_in">console</span>.log(heap.pop());<br>    <span class="hljs-built_in">console</span>.log(heap.value);<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://www.php.cn/js-tutorial-414206.html">JavaScript中二叉树（二叉堆）的介绍（代码示例）</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 for...of  解构赋值  扩展、剩余运算符  reduce</title>
    <link href="/2020/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20for...of%20%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%20%20%E6%89%A9%E5%B1%95%E3%80%81%E5%89%A9%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6%20%20reduce/"/>
    <url>/2020/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20for...of%20%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%20%20%E6%89%A9%E5%B1%95%E3%80%81%E5%89%A9%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6%20%20reduce/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#jump1"><strong>for…in 和 for…of</strong></a></p></li><li><p><a href="#jump2"><strong>解构赋值</strong></a></p></li><li><p><a href="#jump3"><strong>扩展运算符(spread)和剩余运算符(rest)</strong></a></p></li><li><p><a href="#jump4"><strong>reduce()</strong></a></p></li></ul><h2 id="1-for…in-和-for…of"><a href="#1-for…in-和-for…of" class="headerlink" title="1. for…in 和 for…of"></a><span id="jump1">1. for…in 和 for…of</span></h2><h4 id="（1）for…in是遍历数组、对象的key"><a href="#（1）for…in是遍历数组、对象的key" class="headerlink" title="（1）for…in是遍历数组、对象的key"></a>（1）for…in是遍历数组、对象的key</h4><ul><li>index索引为字符串型数字，不能直接进行几何运算</li><li>遍历顺序有可能不是按照实际数组的内部顺序</li><li>使用for in会遍历数组所有的可枚举属性，包括原型。</li><li>所以for in更适合遍历对象，不要使用for in遍历数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">//0  1  2</span><br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wuxiaodi&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-built_in">console</span>.log(i)  <span class="hljs-comment">// name  age</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果想用for…in遍历值那就把JS代码改成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(arr[i])  <span class="hljs-comment">//1  2  3 </span><br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wuxiaodi&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-built_in">console</span>.log(obj[i]) <span class="hljs-comment">// wuxiaodi  18</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）for-of循环机制可以对任何集合-Array、Map、Set、String或迭代器-进行循环，遍历的是value"><a href="#（2）for-of循环机制可以对任何集合-Array、Map、Set、String或迭代器-进行循环，遍历的是value" class="headerlink" title="（2）for-of循环机制可以对任何集合(Array、Map、Set、String或迭代器)进行循环，遍历的是value"></a>（2）for-of循环机制可以对任何集合(Array、Map、Set、String或迭代器)进行循环，遍历的是value</h4><ul><li>for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为对象没有迭代器.与forEach()不同的是，它可以正确响应break、continue和return语句</li><li>for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环或内建的Object.keys()方法</li><li>遍历map对象时适合用解构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> a) &#123;<br>    <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//3</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;com&#x27;</span>, <span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;org&#x27;</span>, <span class="hljs-attr">c</span>:<span class="hljs-string">&#x27;top&#x27;</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;<br>    <span class="hljs-built_in">console</span>.log(obj[key]);<br>&#125;<br><span class="hljs-comment">//com</span><br><span class="hljs-comment">//org</span><br><span class="hljs-comment">//top</span><br><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;six&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> str) &#123;<br>    <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">//s</span><br><span class="hljs-comment">//i</span><br><span class="hljs-comment">//x</span><br><br><span class="hljs-keyword">let</span> mp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, item] <span class="hljs-keyword">of</span> mp) &#123;<br>    <span class="hljs-built_in">console</span>.log(key)<br>    <span class="hljs-built_in">console</span>.log(item)<br>&#125;<br><span class="hljs-comment">//&#123;o:&#x27;233&#x27;&#125;</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//b</span><br><span class="hljs-comment">//2</span><br><br><span class="hljs-keyword">let</span> st = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> st) &#123;<br>    <span class="hljs-built_in">console</span>.log(key)<br>&#125;<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2. 解构赋值"></a><span id="jump2">2. 解构赋值</span></h2><p>所谓解构赋值，是指同时使用数组或对象属性中保存的多个值分别为多个变量赋值。</p><h4 id="（1）数组的解构赋值"><a href="#（1）数组的解构赋值" class="headerlink" title="（1）数组的解构赋值"></a>（1）数组的解构赋值</h4><ul><li><p><strong>基本</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//变量声明并赋值时的解构:</span><br><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// a = 1 // b = 2 // c = 3</span><br><br><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&#x27;苹果&#x27;</span>, <span class="hljs-string">&#x27;桔子&#x27;</span>, <span class="hljs-string">&#x27;梨&#x27;</span>];<br><span class="hljs-keyword">let</span> [apple, orange, pear] = fruits;<br><span class="hljs-built_in">console</span>.log(apple); <span class="hljs-comment">//&quot;苹果&quot;</span><br><span class="hljs-built_in">console</span>.log(orange); <span class="hljs-comment">//&quot;桔子&quot;</span><br><span class="hljs-built_in">console</span>.log(pear); <span class="hljs-comment">//&quot;梨&quot;</span><br><br><span class="hljs-keyword">var</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">var</span> [y, z] = x;<br><span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(z); <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">//变量先声明后赋值时的解构:</span><br><span class="hljs-keyword">var</span> a, b;<br>[a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p><strong>可嵌套</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, [[b], c]] = [<span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>]]; <span class="hljs-comment">// a = 1 // b = 2 // c = 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong>可忽略</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// a = 1 // b = 3</span><br><br><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&#x27;苹果&#x27;</span>, <span class="hljs-string">&#x27;桔子&#x27;</span>, <span class="hljs-string">&#x27;梨&#x27;</span>];<br><span class="hljs-keyword">let</span> [, orange] = fruits; <br><span class="hljs-built_in">console</span>.log(orange); <span class="hljs-comment">// 桔子</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不完全解构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a = <span class="hljs-number">1</span>, b] = []; <span class="hljs-comment">// a = 1, b = undefined</span><br></code></pre></td></tr></table></figure></li><li><p><strong>剩余运算符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> [a, ...b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>字符串等</strong></p><p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>; <br><span class="hljs-comment">// a = &#x27;h&#x27; // b = &#x27;e&#x27; // c = &#x27;l&#x27; // d = &#x27;l&#x27; // e = &#x27;o&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>交换变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;<br>[a, b] = [b, a];<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>解构默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a = <span class="hljs-number">3</span>, b = a] = [];   <span class="hljs-comment">// a 与 b 匹配结果为 undefined ，触发默认值：a = 3, b = 3 </span><br><span class="hljs-keyword">let</span> [a=<span class="hljs-number">5</span>, b=<span class="hljs-number">7</span>] = [<span class="hljs-number">1</span>]; <span class="hljs-comment">// a = 1, b =  7</span><br><span class="hljs-keyword">let</span> [a = <span class="hljs-number">3</span>, b = a] = [<span class="hljs-number">1</span>];   <span class="hljs-comment">//a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1</span><br><br><span class="hljs-keyword">let</span> [a = <span class="hljs-number">3</span>, b = a] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// a 与 b 正常解构赋值，匹配结果: a = 1, b = 2</span><br></code></pre></td></tr></table></figure></li><li><p><strong>解析一个从函数返回的数组</strong></p><p>从一个函数返回一个数组是十分常见的情况。解构使得处理返回值为数组时更加方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>&#125;<br><span class="hljs-keyword">var</span> a, b; <br>[a, b] = f1(); <br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 2</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">var</span> [a, , b] = f2();<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="（2）对象的解构赋值"><a href="#（2）对象的解构赋值" class="headerlink" title="（2）对象的解构赋值"></a>（2）对象的解构赋值</h4><ul><li><p><strong>基本</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;name,age&#125; = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;swr&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">28</span>&#125;<br><span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// &#x27;swr&#x27;</span><br><span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// 28</span><br></code></pre></td></tr></table></figure></li><li><p><strong>无声明赋值</strong></p><p>赋值语句周围的圆括号 <code>( ... )</code> 在使用对象字面量无声明解构赋值时是必须的.</p><p><code>&#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code> 不是有效的独立语法，因为左边的 <code>&#123;a, b&#125;</code> 被认为是一个块而不是对象字面量。</p><p>然而，<code>(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;)</code> 是有效的，正如 <code>var &#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code></p><p>你的 <code>( ... )</code> 表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b;<br>(&#123;a, b&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>给新的变量名赋值</strong></p><p>可以从一个对象中提取变量并赋值给和对象属性名不同的新的变量名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<span class="hljs-attr">p</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">q</span>: <span class="hljs-literal">true</span>&#125;;<br><span class="hljs-keyword">var</span> &#123;<span class="hljs-attr">p</span>: foo, <span class="hljs-attr">q</span>: bar&#125; = o;<br> <br><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 42 </span><br><span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure></li><li><p><strong>可嵌套可忽略</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">p</span>: [<span class="hljs-string">&#x27;hello&#x27;</span>, &#123;<span class="hljs-attr">y</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;] &#125;;<br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj; <span class="hljs-comment">// x = &#x27;hello&#x27; y = &#x27;world&#x27; </span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">p</span>: [x, &#123;  &#125;] &#125; = obj; <span class="hljs-comment">// x = &#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不完全解构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">p</span>: [&#123;<span class="hljs-attr">y</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;] &#125;; <br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">p</span>: [&#123; y &#125;, x ] &#125; = obj; <span class="hljs-comment">// x = undefined // y = &#x27;world&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>剩余运算符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">40</span>&#125;; <span class="hljs-comment">// a = 10  b = 20  rest = &#123;c: 30, d: 40&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>解构默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;a = <span class="hljs-number">10</span>, b = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// a = 3; b = 5; </span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">a</span>:aa = <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>:bb = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">console</span>.log(aa); <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(bb); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure></li><li><p><strong>函数参数默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//ES5 版本</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawES5Chart</span>(<span class="hljs-params">options</span>) </span>&#123;<br>  options = options === <span class="hljs-literal">undefined</span> ? &#123;&#125; : options;<br>  <span class="hljs-keyword">var</span> size = options.size === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">&#x27;big&#x27;</span> : options.size;<br>  <span class="hljs-keyword">var</span> cords = options.cords === <span class="hljs-literal">undefined</span> ? &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125; : options.cords;<br>  <span class="hljs-keyword">var</span> radius = options.radius === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">25</span> : options.radius;<br>  <span class="hljs-built_in">console</span>.log(size, cords, radius);<br>  <span class="hljs-comment">// now finally do some chart drawing</span><br>&#125;<br><br>drawES5Chart(&#123;<br>  <span class="hljs-attr">cords</span>: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">30</span> &#125;,<br>  <span class="hljs-attr">radius</span>: <span class="hljs-number">30</span><br>&#125;);<br><br><span class="hljs-comment">//ES6 版本</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawES2015Chart</span>(<span class="hljs-params">&#123;size = <span class="hljs-string">&#x27;big&#x27;</span>, cords = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;, radius = <span class="hljs-number">25</span>&#125; = &#123;&#125;</span>) </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">console</span>.log(size, cords, radius);<br>  <span class="hljs-comment">// do some chart drawing</span><br>&#125;<br><br>drawES2015Chart(&#123;<br>  <span class="hljs-attr">cords</span>: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">30</span> &#125;,<br>  <span class="hljs-attr">radius</span>: <span class="hljs-number">30</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-扩展运算符-spread-和剩余运算符-rest"><a href="#3-扩展运算符-spread-和剩余运算符-rest" class="headerlink" title="3. 扩展运算符(spread)和剩余运算符(rest)"></a><span id="jump1">3. 扩展运算符(spread)和剩余运算符(rest)</span></h2><p>在ES6中，三个点(…) 有2个含义。分别表示 扩展运算符 和 剩余运算符。</p><h4 id="（1）扩展运算符-spread"><a href="#（1）扩展运算符-spread" class="headerlink" title="（1）扩展运算符(spread)"></a>（1）扩展运算符(spread)</h4><p><strong>作用</strong>：将一个数组或类数组对象转为用逗号分隔的参数序列</p><p><strong>例子：</strong></p><ul><li><p>数组之前</p><p>当运算符”…”用在<strong>数组之前</strong>时，数组会被转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x, y, z</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(x, y, z)<br>&#125;<br>foo.appley(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])　　<span class="hljs-comment">//在ES6之前我们这样使用数组作为函数参数调用。</span><br>foo(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])　　<span class="hljs-comment">//此处...[1, 2, 3]就被展开为用逗号隔开的1, 2, 3参数序列</span><br></code></pre></td></tr></table></figure></li><li><p>替代<code>apply()</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES5的 写法</span><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-built_in">Array</span>.prototype.push.apply(arr1, arr2);　　<span class="hljs-comment">//push方法参数不能为数组，ES5需要借助apply()方法实现。</span><br><br><span class="hljs-comment">// ES6 的写法</span><br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr1.push(...arr2);　　　　　　　　　　　　　　<span class="hljs-comment">//ES6中借助扩展运算符直接将数组转为了参数序列。</span><br></code></pre></td></tr></table></figure></li><li><p>替代数组的<code>concat()</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> b = [<span class="hljs-number">1</span>, ...a, <span class="hljs-number">5</span>]    <span class="hljs-comment">//此处a数组被展开为2, 3, 4</span><br><span class="hljs-built_in">console</span>.log(b)          <span class="hljs-comment">//结果为[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></li><li><p>扩展运算符后如果是<strong>空数组</strong>，<strong>不会产生任何效果</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[...[], <span class="hljs-number">1</span>]<br><span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure></li><li><p>字符串转数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&#x27;loycoder&#x27;</span>;<br><span class="hljs-keyword">var</span> arr3= [...str];<br><span class="hljs-built_in">console</span>.log(arr3);<br></code></pre></td></tr></table></figure></li></ul><h4 id="（2）剩余运算符-rest"><a href="#（2）剩余运算符-rest" class="headerlink" title="（2）剩余运算符(rest)"></a>（2）剩余运算符(rest)</h4><p><strong>作用：</strong>作用与扩展运算符恰好相反，把逗号隔开的值序列组合成一个数组。</p><p><strong>例子：</strong></p><ul><li><p>函数参数之前，当函数参数个数不确定时，用 rest运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x, y, ...z</span>)</span>&#123;   <span class="hljs-comment">//z表示把剩余的参数收集到一起组成一个名叫z的数组。</span><br>    <span class="hljs-built_in">console</span>.log(x, y, z)<br>&#125;<br>foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)          <span class="hljs-comment">//x赋值1，y赋值2，z中赋值[3, 4, 5]数组</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rest01</span>(<span class="hljs-params">...arr</span>) </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>            <span class="hljs-built_in">console</span>.log(item);<br>        &#125;<br>    &#125;<br>rest01(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p>解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];　　<span class="hljs-comment">//此处&#x27;...&#x27;作为rest收集运算符使用</span><br>first <span class="hljs-comment">// 1</span><br>rest  <span class="hljs-comment">// [2, 3, 4, 5]</span><br><br><span class="hljs-keyword">const</span> [first, ...rest] = [];<br>first <span class="hljs-comment">// undefined</span><br>rest  <span class="hljs-comment">// []</span><br><br><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-string">&quot;foo&quot;</span>];<br>first  <span class="hljs-comment">// &quot;foo&quot;</span><br>rest   <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="（3）总结："><a href="#（3）总结：" class="headerlink" title="（3）总结："></a>（3）总结：</h4><p>如何判断ES6中的运算符是扩展运算符(spread)还是收集运算符(rest)，主要取决于其<strong>作用的位置</strong>。</p><ul><li><p>当三个在等号右边，或放在实参上，或数组之前，作为spread运算符使用，将数组转为逗号分隔的参数序列。</p></li><li><p>当三个点(…)在等号左边，或者放在函数形参中，作为 rest 运算符，收集传入的参数为数组。</p></li><li><p>解构赋值中，放在被赋值一方是rest  运算符。放在赋值一方是 spread运算符。</p></li></ul><h2 id="4-reduce"><a href="#4-reduce" class="headerlink" title="4. reduce()"></a><span id="jump4">4. reduce()</span></h2><h4 id="1-什么是reduce"><a href="#1-什么是reduce" class="headerlink" title="(1) 什么是reduce()"></a>(1) 什么是reduce()</h4><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。对空数组是不会执行回调函数的。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">array.reduce( callback(total, currentValue, currentIndex, arr), initialValue )<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><table><thead><tr><th align="center">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>callback(total, currentValue, currentIndex, arr)</code></td><td align="left">必需。用于执行每个数组元素的函数。<br />其中：<br /><code>total</code>：必需。初始值，或者计算结束后的返回值。<br /><code>currentValue</code>：必需。当前元素。<br /><code>currentIndex</code>：可选。当前元素的索引。<br /><code>arr</code>：可选。当前元素所属的数组对象。</td></tr><tr><td align="center"><code>initialValue</code></td><td align="left">可选。传递给函数的初始值。</td></tr></tbody></table><p><code>reduce(callback,initiaValue)</code>会传入两个变量，回调函数(callback)和初始值(initiaValue)。</p><p>假设函数有个传入参数，total和currentValue，currentIndex和arr：</p><p>当没有传入初始值时，total是从数组中第一个元素开始的，currentValue是第二个元素。</p><p>但是当传入初始值后, 第一个total将是initivalValue，currentValue将是数组中的第一个元素。</p><h4 id="（2）例子"><a href="#（2）例子" class="headerlink" title="（2）例子"></a>（2）例子</h4><ul><li><p><strong>数组求和</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sum = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">accumulator, currentValue</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> accumulator + currentValue;<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 和为 6</span><br><br><span class="hljs-comment">//也可以写成箭头函数的形式</span><br><span class="hljs-keyword">var</span> total = [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ].reduce(<br>  <span class="hljs-function">(<span class="hljs-params"> acc, cur </span>) =&gt;</span> acc + cur,<br>  <span class="hljs-number">0</span><br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>累加对象数组里的值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//要累加对象数组中包含的值，必须提供初始值，以便各个item正确通过你的函数。</span><br><span class="hljs-keyword">var</span> initialValue = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> sum = [&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">3</span>&#125;].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">accumulator, currentValue</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> accumulator + currentValue.x;<br>&#125;,initialValue)<br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// logs 6</span><br><br><span class="hljs-comment">//也可以写成箭头函数的形式</span><br><span class="hljs-keyword">var</span> initialValue = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> sum = [&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">3</span>&#125;].reduce(<br>    <span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue.x<br>    ,initialValue<br>);<br><br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// logs 6</span><br></code></pre></td></tr></table></figure></li><li><p><strong>将二维数组转化为一维</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> flattened = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]].reduce(<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a.concat(b);<br>  &#125;,<br>  []<br>);<br><span class="hljs-comment">// flattened is [0, 1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">//也可以写成箭头函数的形式：</span><br><span class="hljs-keyword">var</span> flattened = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]].reduce(<br> <span class="hljs-function">(<span class="hljs-params"> acc, cur </span>) =&gt;</span> acc.concat(cur),<br> []<br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>计算数组中每个元素出现的次数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> names = [<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tiff&#x27;</span>, <span class="hljs-string">&#x27;Bruce&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>];<br><br><span class="hljs-keyword">var</span> countedNames = names.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">allNames, name</span>) </span>&#123; <br>  <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> allNames) &#123;<br>    allNames[name]++;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    allNames[name] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> allNames;<br>&#125;, &#123;&#125;);<br><span class="hljs-comment">// countedNames is:</span><br><span class="hljs-comment">// &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用扩展运算符和initialValue绑定包含在对象数组中的数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// friends - 对象数组</span><br><span class="hljs-comment">// where object field &quot;books&quot; - list of favorite books </span><br><span class="hljs-keyword">var</span> friends = [&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Anna&#x27;</span>,<br>  <span class="hljs-attr">books</span>: [<span class="hljs-string">&#x27;Bible&#x27;</span>, <span class="hljs-string">&#x27;Harry Potter&#x27;</span>],<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;, &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  <span class="hljs-attr">books</span>: [<span class="hljs-string">&#x27;War and peace&#x27;</span>, <span class="hljs-string">&#x27;Romeo and Juliet&#x27;</span>],<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">26</span><br>&#125;, &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">books</span>: [<span class="hljs-string">&#x27;The Lord of the Rings&#x27;</span>, <span class="hljs-string">&#x27;The Shining&#x27;</span>],<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;];<br><br><span class="hljs-comment">// allbooks - list which will contain all friends&#x27; books +  </span><br><span class="hljs-comment">// additional list contained in initialValue</span><br><span class="hljs-keyword">var</span> allbooks = friends.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, curr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> [...prev, ...curr.books];<br>&#125;, [<span class="hljs-string">&#x27;Alphabet&#x27;</span>]);<br><br><span class="hljs-comment">// allbooks = [</span><br><span class="hljs-comment">//   &#x27;Alphabet&#x27;, &#x27;Bible&#x27;, &#x27;Harry Potter&#x27;, &#x27;War and peace&#x27;, </span><br><span class="hljs-comment">//   &#x27;Romeo and Juliet&#x27;, &#x27;The Lord of the Rings&#x27;,</span><br><span class="hljs-comment">//   &#x27;The Shining&#x27;</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>数组去重</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br><span class="hljs-keyword">var</span> myOrderedArray = myArray.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">accumulator, currentValue</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (accumulator.indexOf(currentValue) === -<span class="hljs-number">1</span>) &#123;<br>    accumulator.push(currentValue);<br>  &#125;<br>  <span class="hljs-keyword">return</span> accumulator<br>&#125;, [])<br><br><span class="hljs-built_in">console</span>.log(myOrderedArray);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据结构与算法之美》学习笔记(5) 哈希算法 红黑树</title>
    <link href="/2020/03/27/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%20%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2020/03/27/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%20%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h4 id="（1）什么是哈希算法？"><a href="#（1）什么是哈希算法？" class="headerlink" title="（1）什么是哈希算法？"></a>（1）什么是哈希算法？</h4><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p><h4 id="（2）设计好的哈希算法要求"><a href="#（2）设计好的哈希算法要求" class="headerlink" title="（2）设计好的哈希算法要求"></a>（2）设计好的哈希算法要求</h4><p>要想设计一个优秀的哈希算法，需要满足的几点要求：</p><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ul><h4 id="（3）哈希算法的应用"><a href="#（3）哈希算法的应用" class="headerlink" title="（3）哈希算法的应用"></a>（3）哈希算法的应用</h4><ul><li><p><strong>安全加密</strong></p><p>最常用于加密的哈希算法是<strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和<strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。除了这两个之外，当然还有很多其他加密算法，比如<strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p></li><li><p><strong>唯一标识</strong></p><p>先来举一个例子。如果要在海量的图库中，搜索一张图是否存在，不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那该如何搜索呢？</p><p>可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p></li><li><p><strong>数据校验</strong></p><p>用于校验数据的完整性和正确性。</p></li><li><p><strong>散列函数</strong></p></li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h4 id="1-什么是“平衡二叉查找树”？"><a href="#1-什么是“平衡二叉查找树”？" class="headerlink" title="1. 什么是“平衡二叉查找树”？"></a>1. 什么是“平衡二叉查找树”？</h4><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585316287765.png" alt="1585316287765"></p><p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>所以，<strong>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</strong></p><p>所以，如果设计一个新的平衡二叉查找树，只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的），尽管它不符合前面讲的严格的平衡二叉查找树的定义，但仍然可以说，这是一个合格的平衡二叉查找树。</p><h4 id="2-如何定义一棵“红黑树”？"><a href="#2-如何定义一棵“红黑树”？" class="headerlink" title="2. 如何定义一棵“红黑树”？"></a>2. 如何定义一棵“红黑树”？</h4><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，</p><p>它的定义是不严格符合平衡二叉查找树的定义的。那红黑树究竟是怎么定义的呢？</p><p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ul><p>这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是为了简化红黑树的代码实现而设置的。</p><p><strong>两个红黑树的图例</strong>：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585316746267.png" alt="1585316746267"></p>]]></content>
    
    
    <categories>
      
      <category>《数据结构与算法之美》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 Map 和Set对象</title>
    <link href="/2020/03/27/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20Map%20%E5%92%8CSet%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/03/27/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20Map%20%E5%92%8CSet%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a><a href="#jump1">Set</a></h4><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="#jump2">Map</a></h4><h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a><span id ="jump1">1. Set</span></h2><h4 id="（1）什么是Set对象？"><a href="#（1）什么是Set对象？" class="headerlink" title="（1）什么是Set对象？"></a>（1）什么是Set对象？</h4><p>Set对象一些元素的集合。可以在其中添加及移除元素。它类似于数组，但又有着很大区别。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([iterable]);<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><p>参数：<code>iterable</code></p><p>如果传递一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">可迭代对象</a>，它的所有元素将不重复地被添加到新的 <strong>Set</strong>中。如果不指定此参数或其值为<code>null</code>，则新的 <strong>Set</strong>为空。</p></li></ul><ul><li>返回值：一个新的<code>Set</code>对象。</li></ul><h4 id="（2）Set-中的特殊值"><a href="#（2）Set-中的特殊值" class="headerlink" title="（2）Set 中的特殊值"></a>（2）Set 中的特殊值</h4><p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p><ul><li><code>+0</code>与<code>-0 </code>在存储判断唯一性的时候是恒等的，所以不重复；</li><li><code>undefined</code> 与<code> undefined</code> 是恒等的，所以不重复；</li><li><code>NaN </code>与<code>NaN</code>是不恒等的，但是在 Set 中只能存一个，不重复。</li></ul><ul><li><code>&#123;&#125;</code>被认为是不同的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([&#123;&#125;,&#123;&#125;])<br>set  <span class="hljs-comment">//&#123;&#123;&#125;,&#123;&#125;&#125;</span><br>set.size  <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-literal">NaN</span>,<span class="hljs-literal">NaN</span>])<br>set  <span class="hljs-comment">//&#123;NaN&#125;</span><br>set.size  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="（3）Set对象的属性方法"><a href="#（3）Set对象的属性方法" class="headerlink" title="（3）Set对象的属性方法"></a>（3）Set对象的属性方法</h4><ul><li><p><strong><code>size</code></strong>:</p><p>该属性值为Set对象中保存的元素的数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mySet1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);<br>mySet1.size; <span class="hljs-comment">// 4</span><br>[...mySet1]; <span class="hljs-comment">// [1,2,3,4]</span><br><br><span class="hljs-keyword">let</span> mySet2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">&quot;一二三四&quot;</span>);<br><span class="hljs-built_in">console</span>.log(mySet2.size); <span class="hljs-comment">//4</span><br>mySet2.add(<span class="hljs-string">&quot;四&quot;</span>);<br><span class="hljs-built_in">console</span>.log(mySet2.size); <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>add()</code> **</p><p>方法用来向一个 <code>Set</code> 对象的末尾添加一个指定的值。返回该对象。注意：不能添加重复的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br> <br>mySet.add(<span class="hljs-number">1</span>);<br>mySet.add(<span class="hljs-number">5</span>).add(<span class="hljs-string">&quot;some text&quot;</span>); <span class="hljs-comment">// 可以链式调用</span><br> <br><span class="hljs-built_in">console</span>.log(mySet);<br><span class="hljs-comment">// Set [1, 5, &quot;some text&quot;]</span><br> <br>mySet.add(<span class="hljs-number">5</span>).add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 重复的值不会被添加进去</span><br><span class="hljs-built_in">console</span>.log(mySet); <span class="hljs-comment">// &#123;1, 5, &quot;some text&quot;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>clear()</code> **:</p><p>方法用来清空一个 <code>Set</code> 对象中的所有元素。返回值：<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">mySet.clear();<br></code></pre></td></tr></table></figure></li><li><p>**<code>delete()</code>**：</p><p> 方法可以从一个 <code>Set</code> 对象中删除指定的元素。成功删除返回 <code>true</code>，否则返回 <code>false。</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>mySet.add(<span class="hljs-string">&quot;foo&quot;</span>);<br> <br>mySet.delete(<span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// 返回 false，不包含 &quot;bar&quot; 这个元素</span><br>mySet.delete(<span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// 返回 true，删除成功</span><br> <br>mySet.has(<span class="hljs-string">&quot;foo&quot;</span>);    <span class="hljs-comment">// 返回 false，&quot;foo&quot; 已经成功删除</span><br></code></pre></td></tr></table></figure></li><li><p><strong>has()</strong> ：</p><p>方法返回一个布尔值来指示对应的值value是否存在Set对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>mySet.add(<span class="hljs-string">&#x27;foo&#x27;</span>);<br> <br>mySet.has(<span class="hljs-string">&#x27;foo&#x27;</span>);  <span class="hljs-comment">// 返回 true</span><br>mySet.has(<span class="hljs-string">&#x27;bar&#x27;</span>);  <span class="hljs-comment">// 返回 false</span><br> <br><span class="hljs-keyword">var</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-number">1</span>&#125;;<br>set1.add(obj1);<br> <br>set1.has(obj1);        <span class="hljs-comment">// 返回 true</span><br>set1.has(&#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// 会返回 false，因为其是另一个对象的引用</span><br>set1.add(&#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// 现在 set1 中有2条（不同引用的）对象了</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>entries() </code>**：</p><p>g该方法返回一个新的迭代器对象 ，这个对象的元素是类似 [value, value] 形式的数组，value 是集合对象中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序。由于集合对象不像 Map 对象那样拥有 key，然而，为了与 Map 对象的 API 形式保持一致，故使得每一个 entry 的 key 和 value 都拥有相同的值，因而最终返回一个 [value, value] 形式的数组。<br>返回值：一个新的包含 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器 对象元素的顺序即集合对象中元素插入的顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>mySet.add(<span class="hljs-string">&quot;foobar&quot;</span>);<br>mySet.add(<span class="hljs-number">1</span>);<br>mySet.add(<span class="hljs-string">&quot;baz&quot;</span>);<br> <br><span class="hljs-keyword">var</span> setIter = mySet.entries(); <span class="hljs-comment">// SetIterator &#123;&quot;foobar&quot; =&gt; &quot;foobar&quot;, 1 =&gt; 1, &quot;baz&quot; =&gt; &quot;baz&quot;&#125;</span><br> <br><span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// [&quot;foobar&quot;, &quot;foobar&quot;]</span><br><span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// [1, 1]</span><br><span class="hljs-built_in">console</span>.log(setIter.next().value); <span class="hljs-comment">// [&quot;baz&quot;, &quot;baz&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>values()</code></strong>:</p><p> 该方法返回一个新的迭代器对象，该迭代器对象按照原Set 对象元素的插入顺序返回其所有元素。</p></li><li><p><strong><code>keys()</code></strong> :<br>返回值：将返回一个新生成的可迭代对象，以插入 Set 对象的顺序返回其包含的每个元素的值。</p></li><li><p><strong><code>forEach（callback, thisArg）</code></strong> 方法会根据集合中元素的插入顺序，依次执行提供的回调函数。<br>**callback:**回调函数有三个参数:</p><ul><li>元素的值</li><li>元素的索引</li><li>正在遍历的集合对象</li></ul><p>**thisArg:**回调函数执行过程中的 <code>this</code> 值。可选。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logSetElements</span>(<span class="hljs-params">value1, value2, set</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s[&quot;</span> + value1 + <span class="hljs-string">&quot;] = &quot;</span> + value2, set);<br>&#125;<br> <br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-literal">undefined</span>]).forEach(logSetElements);<br> <br><span class="hljs-comment">// logs:</span><br><span class="hljs-comment">// &quot;s[foo] = foo&quot; Set(3) &#123;&quot;foo&quot;, &quot;bar&quot;, undefined&#125;</span><br><span class="hljs-comment">// &quot;s[bar] = bar&quot; Set(3) &#123;&quot;foo&quot;, &quot;bar&quot;, undefined&#125;</span><br><span class="hljs-comment">// &quot;s[undefined] = undefined&quot; Set(3) &#123;&quot;foo&quot;, &quot;bar&quot;, undefined&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="（4）Set应用实例"><a href="#（4）Set应用实例" class="headerlink" title="（4）Set应用实例"></a>（4）Set应用实例</h4><ul><li><p><strong>数组去重</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">[...new <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">34</span>, <span class="hljs-number">555</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])] <span class="hljs-comment">// [1, 3, 34, 555, 2]</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dedupe</span>(<span class="hljs-params">array</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(array));<br>&#125;<br><br>dedupe([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// [1, 2, 3]</span><br>arrRemove([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">34</span>, <span class="hljs-number">555</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]) <span class="hljs-comment">// [1, 3, 34, 555, 2]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrRemove</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> tempArr = arr<br>    arr = []<br>    <span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(tempArr)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> set) &#123;<br>        arr.push(i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>去除字符串里面的重复字符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[...new <span class="hljs-built_in">Set</span>(<span class="hljs-string">&#x27;ababbc&#x27;</span>)].join(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>set对象与数组之间的转换</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr) <span class="hljs-comment">//数组转换set对象</span><br>set <span class="hljs-comment">//&#123;1,2,3,4&#125;</span><br><span class="hljs-comment">//方法一</span><br><span class="hljs-built_in">Array</span>.from(set) <span class="hljs-comment">//[1,2,3,4]</span><br><span class="hljs-comment">//方法二</span><br>[...set] <span class="hljs-comment">//[1,2,3,4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>数组去重 &amp; 并集</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>];<br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr1);<br><span class="hljs-keyword">let</span> b= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr2)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...arr1,...arr2]) <span class="hljs-comment">//&#123;1,2,3,4,5,6,7,8&#125;</span><br><span class="hljs-keyword">let</span> arr3 = [...new <span class="hljs-built_in">Set</span>([...arr1,...arr2])] <span class="hljs-comment">//[1,2,3,4,5,6,7,8]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>交集</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr1.filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>b.has(x))) <span class="hljs-comment">//&#123;4,5&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>差集</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr1.filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>!b.has(x))) <span class="hljs-comment">//&#123;1,2,3&#125;</span><br><span class="hljs-keyword">let</span> arr4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr2.filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>!a.has(x))) <span class="hljs-comment">//&#123;6,7,8&#125;</span><br>[...arr3,...arr4] <span class="hljs-comment">//[1,2,3,6,7,8]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>参考学习于：</strong></p><p>《HTML 5 与 CSS3权威指南》</p><p><a href="https://blog.csdn.net/weixin_40013817/article/details/101363465">ES6之Set对象详解</a></p><h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a><span id="jump2">2. Map</span></h2><h4 id="（1）什么是Map对象？"><a href="#（1）什么是Map对象？" class="headerlink" title="（1）什么是Map对象？"></a>（1）什么是Map对象？</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键，这给它的使用带来了很大的限制。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([iterable])<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><p>参数：<code>iterable</code></p><p>Iterable 可以是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>数组</code></a>或者其他 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/iterable">iterable</a> 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。<code>null</code> 会被当做 <code>undefined。</code></p></li></ul><p><strong>Map的key</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//key 是字符串</span><br><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">var</span> keyString = <span class="hljs-string">&quot;a string&quot;</span>; <br> <br>myMap.set(keyString, <span class="hljs-string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);<br> <br>myMap.get(keyString);    <span class="hljs-comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span><br>myMap.get(<span class="hljs-string">&quot;a string&quot;</span>);   <span class="hljs-comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span><br>                         <span class="hljs-comment">// 因为 keyString === &#x27;a string&#x27;</span><br><span class="hljs-comment">//key 是对象</span><br><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">var</span> keyObj = &#123;&#125;, <br> <br>myMap.set(keyObj, <span class="hljs-string">&quot;和键 keyObj 关联的值&quot;</span>);<br><br>myMap.get(keyObj); <span class="hljs-comment">// &quot;和键 keyObj 关联的值&quot;</span><br>myMap.get(&#123;&#125;); <span class="hljs-comment">// undefined, 因为 keyObj !== &#123;&#125;</span><br><br><span class="hljs-comment">//key 是函数</span><br><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">var</span> keyFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-comment">// 函数</span><br> <br>myMap.set(keyFunc, <span class="hljs-string">&quot;和键 keyFunc 关联的值&quot;</span>);<br> <br>myMap.get(keyFunc); <span class="hljs-comment">// &quot;和键 keyFunc 关联的值&quot;</span><br>myMap.get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;) <span class="hljs-comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span><br><br><span class="hljs-comment">//key 是 NaN</span><br><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>myMap.set(<span class="hljs-literal">NaN</span>, <span class="hljs-string">&quot;not a number&quot;</span>);<br> <br>myMap.get(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// &quot;not a number&quot;</span><br> <br><span class="hljs-keyword">var</span> otherNaN = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>myMap.get(otherNaN); <span class="hljs-comment">// &quot;not a number&quot;</span><br></code></pre></td></tr></table></figure><h4 id="（2）Map-和-Objects-的区别"><a href="#（2）Map-和-Objects-的区别" class="headerlink" title="（2）Map 和 Objects 的区别"></a>（2）Map 和 Objects 的区别</h4><ul><li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li><li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li><li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li><li><code>Map</code> 可直接进行迭代，而 <code>Object</code> 的迭代需要先获取它的键数组，然后再进行迭代。</li><li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li><li><code>Map</code> 在涉及频繁增删键值对的场景下会有些性能优势。</li></ul><h4 id="（3）Map对象的属性方法"><a href="#（3）Map对象的属性方法" class="headerlink" title="（3）Map对象的属性方法"></a>（3）Map对象的属性方法</h4><ul><li><p><strong><code>size</code></strong></p><p>该属性返回 Map 对象中保存的键名/键值的数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map.set(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>);<br>map.set(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-literal">false</span>);<br>map.size <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>set(key, value)</code></strong></p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新为value，否则就新生成该键。</p><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br> <br>m.set(<span class="hljs-string">&#x27;edition&#x27;</span>, <span class="hljs-number">6</span>)        <span class="hljs-comment">// 键是字符串</span><br>m.set(<span class="hljs-number">262</span>, <span class="hljs-string">&#x27;standard&#x27;</span>)     <span class="hljs-comment">// 键是数值</span><br>m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>)    <span class="hljs-comment">// 键是 undefined</span><br><br><br><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>  .set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>  .set(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>  .set(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong><code>get(key)</code></strong></p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br> <br><span class="hljs-keyword">const</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);&#125;;<br>m.set(hello, <span class="hljs-string">&#x27;Hello ES6!&#x27;</span>) <span class="hljs-comment">// 键是函数</span><br> <br>m.get(hello)  <span class="hljs-comment">// Hello ES6!</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>has(key)</code></strong></p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br> <br>m.set(<span class="hljs-string">&#x27;edition&#x27;</span>, <span class="hljs-number">6</span>);<br>m.set(<span class="hljs-number">262</span>, <span class="hljs-string">&#x27;standard&#x27;</span>);<br>m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>);<br> <br>m.has(<span class="hljs-string">&#x27;edition&#x27;</span>)     <span class="hljs-comment">// true</span><br>m.has(<span class="hljs-string">&#x27;years&#x27;</span>)       <span class="hljs-comment">// false</span><br>m.has(<span class="hljs-number">262</span>)           <span class="hljs-comment">// true</span><br>m.has(<span class="hljs-literal">undefined</span>)     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>delete(key)</code></strong></p><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>);<br>m.has(<span class="hljs-literal">undefined</span>)     <span class="hljs-comment">// true</span><br> <br>m.delete(<span class="hljs-literal">undefined</span>)<br>m.has(<span class="hljs-literal">undefined</span>)       <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>clear()</code></strong></p><p>移除Map对象中保存的所有键名/键值对，方法没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map.set(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>);<br>map.set(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-literal">false</span>);<br> <br>map.size <span class="hljs-comment">// 2</span><br>map.clear()<br>map.size <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>keys()</code></strong> </p><p>返回一个新的 <code>Iterator</code> 对象。它包含按照顺序插入 <code>Map</code> 对象中每个元素的key值。</p></li><li><p><strong><code>values()</code></strong> </p><p>该方法返回一个新的Iterator对象。它包含按顺序插入Map对象中每个元素的value值。</p></li><li><p><strong><code>entires()</code></strong>:</p><p>该方法返回一个新的Iterator对象。它包含按顺序插入Map对象中每个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>myMap.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;零&quot;</span>);<br>myMap.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;一&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> myMap.keys()) &#123;<br>    <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">//0  1</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> myMap.key()) &#123;<br>    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">//  零  一</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;<br>    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&quot;=&quot;</span> + value);  <span class="hljs-comment">//0=零   1=一</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>forEach(callback, thisArg)</code></strong>:</p><p><code>forEach()</code> 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数。</p><p>其中：</p><ul><li><p><strong>参数</strong>：</p><p><code>callback</code>：必要，每个元素所要执行的函数。</p><p><code>thisArg</code>：可选，<code>callback</code> 执行时其 <code>this</code> 的值。</p></li><li><p><strong>返回值</strong>：undefined</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>myMap.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;零&quot;</span>);<br>myMap.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;一&quot;</span>);<br>myMap.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&quot;=&quot;</span> + value);<br>&#125;, myMap)<br></code></pre></td></tr></table></figure></li></ul><h4 id="（4）Map-对象的操作"><a href="#（4）Map-对象的操作" class="headerlink" title="（4）Map 对象的操作"></a>（4）Map 对象的操作</h4><ul><li><p><strong>Map 与 Array的转换</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> kvArray = [[<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>], [<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>]];<br> <br><span class="hljs-comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span><br><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(kvArray);<br> <br><span class="hljs-comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span><br><span class="hljs-keyword">var</span> outArray = <span class="hljs-built_in">Array</span>.from(myMap);<br></code></pre></td></tr></table></figure></li><li><p><strong>Map 的克隆</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myMap1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>], [<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>]]);<br><span class="hljs-keyword">var</span> myMap2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(myMap1);<br> <br><span class="hljs-built_in">console</span>.log(original === clone); <br><span class="hljs-comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Map 的合并</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> first = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;one&#x27;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;two&#x27;</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;three&#x27;</span>],]);<br><span class="hljs-keyword">var</span> second = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;uno&#x27;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;dos&#x27;</span>]]);<br> <br><span class="hljs-comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span><br><span class="hljs-keyword">var</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([...first, ...second]);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 散列</title>
    <link href="/2020/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%95%A3%E5%88%97/"/>
    <url>/2020/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%95%A3%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h3 id="1-什么是散列表"><a href="#1-什么是散列表" class="headerlink" title="1. 什么是散列表"></a>1. 什么是散列表</h3><p>根据关键码值（Key value）直接进行访问的数据结构；它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度；这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>散列算法的作用是尽可能快地在数据结构中找到一个值。</p><p><strong>例子：</strong></p><p>使用最常见的散列函数 - ‘lose lose’散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。如下图：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585145636529.png" alt="1585145636529"></p><h3 id="2-实现一个散列表"><a href="#2-实现一个散列表" class="headerlink" title="2. 实现一个散列表"></a>2. 实现一个散列表</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.table = []<br>    &#125;<br><br>    <span class="hljs-comment">// 散列函数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">loseloseHashCode</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> codePoint <span class="hljs-keyword">of</span> key) &#123;<br>            hash += codePoint.charCodeAt()<br>        &#125;<br>        <span class="hljs-keyword">return</span> hash % <span class="hljs-number">37</span><br>    &#125;<br><br>    <span class="hljs-comment">// 修改和增加元素</span><br>    <span class="hljs-function"><span class="hljs-title">put</span>(<span class="hljs-params">key, value</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> position = HashTable.loseloseHashCode(key)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;position&#125;</span> - <span class="hljs-subst">$&#123;key&#125;</span>`</span>)<br>        <span class="hljs-built_in">this</span>.table[position] = value<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.table[HashTable.loseloseHashCode(key)]<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.table[HashTable.loseloseHashCode(key)] = <span class="hljs-literal">undefined</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用 HashTable 类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hash = <span class="hljs-keyword">new</span> HashTable()<br>hash.put(<span class="hljs-string">&#x27;Surmon&#x27;</span>, <span class="hljs-string">&#x27;surmon.me@email.com&#x27;</span>) <span class="hljs-comment">// 19 - Surmon</span><br>hash.put(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;johnsnow@email.com&#x27;</span>) <span class="hljs-comment">// 29 - John</span><br>hash.put(<span class="hljs-string">&#x27;Tyrion&#x27;</span>, <span class="hljs-string">&#x27;tyrion@email.com&#x27;</span>) <span class="hljs-comment">// 16 - Tyrion</span><br><br><span class="hljs-comment">// 测试get方法</span><br><span class="hljs-built_in">console</span>.log(hash.get(<span class="hljs-string">&#x27;Surmon&#x27;</span>)) <span class="hljs-comment">// surmon.me@email.com</span><br><span class="hljs-built_in">console</span>.log(hash.get(<span class="hljs-string">&#x27;Loiane&#x27;</span>)) <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(hash)<br></code></pre></td></tr></table></figure><p>下面的图表展现了包含这三个元素的 HashTable 数据结构:</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585145886547.png" alt="1585145886547"></p><h3 id="3-散列函数"><a href="#3-散列函数" class="headerlink" title="3. 散列函数"></a>3. 散列函数</h3><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成**hash(key)**，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p><p>散列函数的作用是给定一个键值，然后返回值在表中的地址。</p><p><strong>散列函数设计的基本要求：</strong></p><ul><li><p>散列函数计算得到的散列值是一个非负整数；</p><p>因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数。</p></li><li><p>如果 key1 = key2，那 hash(key1) == hash(key2)；</p><p>相同的 key，经过散列函数得到的散列值也应该是相同的。</p></li><li><p>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</p><p>这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>、<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">SHA</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">CRC</a>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p></li></ul><h3 id="4-散列冲突"><a href="#4-散列冲突" class="headerlink" title="4. 散列冲突"></a>4. 散列冲突</h3><h5 id="（1）开放寻址法"><a href="#（1）开放寻址法" class="headerlink" title="（1）开放寻址法"></a>（1）开放寻址法</h5><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲的位置。</p><p>开放寻址法解决方案有线性探测法、二次探测、双重散列等方案：</p><ul><li><p><strong>线性探测法（Linear Probing）：</strong></p><ul><li><p><strong>插入数据</strong>：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找（到底后从头开始），看是否有空闲位置，直到找到为止。</p></li><li><p><strong>查找数据</strong>：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。</p><p>当然这里存在一个问题，就是存数据那块位置往前的某个数据被删除了，那么线性探索查到那块位置的时候就会判断元素不在散列表，查找就会失效，面对这个问题，我们在删除的时候，用下面删除的方法</p></li><li><p><strong>删除数据</strong>：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。</p></li></ul></li><li><p><strong>二次探测（Quadratic probing）</strong>：</p><p>线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。</p></li><li><p><strong>双重散列（Double hashing）</strong>：</p><p>使用一组散列函数，直到找到空闲位置为止。</p></li></ul><p><strong>线性探测法的性能描述</strong>：<br>用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数/散列表的长度。<br>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h5 id="（2）链表法"><a href="#（2）链表法" class="headerlink" title="（2）链表法"></a>（2）链表法</h5><p>散列表中，每个“桶（bucket）”都会对应一个条链表，在查找时先听过hash(key)找到位置，然后遍历链表找到对应元素</p><p><strong>插入数据</strong>：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。<br><strong>查找或删除数据</strong>：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585148252357.png" alt="1585148252357"></p><h5 id="（3）冲突解决方法对比："><a href="#（3）冲突解决方法对比：" class="headerlink" title="（3）冲突解决方法对比："></a>（3）冲突解决方法对比：</h5><table><thead><tr><th></th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th><th align="center">案例</th></tr></thead><tbody><tr><td>开放寻址法</td><td align="center">1. 数据存储在数组，可以有效利用CPU缓存加速查询速度.<br />2. 序列化简单</td><td align="center">1. 删除需要特殊标记已删除数据<br />2. 所有数据存储在一个数组，发生冲突时，解决的代价更高，造成装载因子不能太大，使得更加浪费内存空间</td><td align="center">1. 数据量小<br />2. 装载因子小</td><td align="center">Java的ThreadLocalMap</td></tr><tr><td>链表法</td><td align="center">1. 内存利用率高，需要时再申请<br />2. 对大装载因子容忍度高，可大于1</td><td align="center">1. 因为链表需要存储指针，存储指针需要消耗内存，不适合小对象存储.<br />2. 链表节点不是连续空间，因此CPU缓存不友好</td><td align="center">1. 存储大对象、大数据量的散列表<br />2. 支持更多优化策略，如红黑树代替链表。</td><td align="center">Java的LinkedHashMap</td></tr></tbody></table><p><strong>参考资料：</strong></p><p><a href="https://blog.csdn.net/u010530712/article/details/93166430">散列表及散列冲突解决方案</a></p><p><a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构和算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 树</title>
    <link href="/2020/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%A0%91/"/>
    <url>/2020/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="（1）相关概念"><a href="#（1）相关概念" class="headerlink" title="（1）相关概念"></a>（1）相关概念</h3><p><strong>兄弟节点</strong>：节点的父节点是同一个节点，所以它们之间互称为兄弟节点。</p><p><strong>根节点</strong>：没有父节点的节点叫作根节点</p><p><strong>叶子节点</strong>：没有子节点的节点叫作叶子节点或者叶节点。</p><p><strong>节点的高度</strong>：节点到叶子节点的最长路径（边数）。</p><p><strong>节点的深度</strong>：根节点到这个节点所经历的边的个数。</p><p><strong>节点的层数</strong>：节点的深度 + 1.</p><p><strong>树的高度</strong>：根节点的高度。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585227146916.png" alt="1585227146916"></p><p>记这几个概念，还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在生活中的含义。</p><p>在生活中，“高度”这个概念，其实就是从下往上度量，比如要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。</p><p>“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。</p><p>“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。</p><h3 id="（2）二叉树（Binary-Tree）"><a href="#（2）二叉树（Binary-Tree）" class="headerlink" title="（2）二叉树（Binary Tree）"></a>（2）二叉树（Binary Tree）</h3><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585228609837.png" alt="1585228609837"></p><p>编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong>。</p><p>编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong>。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585228784320.png" alt="1585228784320"></p><p>存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p><h5 id="1-链式存储法"><a href="#1-链式存储法" class="headerlink" title="1. 链式存储法"></a>1. 链式存储法</h5><p>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。</p><p>只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585229479175.png" alt="1585229479175"></p><h5 id="2-顺序存储法"><a href="#2-顺序存储法" class="headerlink" title="2. 顺序存储法"></a>2. 顺序存储法</h5><p>把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</p><p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585229609566.png" alt="1585229609566"></p><p>不过，上面的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585229773296.png" alt="1585229773296"></p><p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p><h5 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3. 二叉树的遍历"></a>3. 二叉树的遍历</h5><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585232103561.png" alt="1585232103561"></p><p>经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。</p><ul><li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">preOrderTraverse</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> preOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;<br>            callback(node.key)<br>            preOrderTraverseNode(node.left, callback)<br>            preOrderTraverseNode(node.right, callback)<br>        &#125;<br>    &#125;<br>    preOrderTraverseNode(<span class="hljs-built_in">this</span>.root, callback)<br>&#125;<br>tree.inOrderTraverse(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(value) &#125;)<br></code></pre></td></tr></table></figure></li><li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">inOrderTraverse</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> inOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;<br>            inOrderTraverseNode(node.left, callback)<br>            callback(node.key)<br>            inOrderTraverseNode(node.right, callback)<br>        &#125;<br>    &#125;<br>    inOrderTraverseNode(<span class="hljs-built_in">this</span>.root, callback)<br>&#125;<br>tree.inOrderTraverse(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(value) &#125;)<br></code></pre></td></tr></table></figure></li><li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">postOrderTraverse</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> postOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;<br>            postOrderTraverseNode(node.left, callback)<br>            postOrderTraverseNode(node.right, callback)<br>            callback(node.key)<br>        &#125;<br>    &#125;<br>    postOrderTraverseNode(<span class="hljs-built_in">this</span>.root, callback)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)。</p><h3 id="（3）二叉查找树（Binary-Search-Tree）"><a href="#（3）二叉查找树（Binary-Search-Tree）" class="headerlink" title="（3）二叉查找树（Binary Search Tree）"></a>（3）二叉查找树（Binary Search Tree）</h3><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。</p><p>顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？这些都依赖于二叉查找树的特殊结构。</p><p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong> </p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585231319498.png" alt="1585231319498"></p><h5 id="1-二叉查找树的查找操作"><a href="#1-二叉查找树的查找操作" class="headerlink" title="1. 二叉查找树的查找操作"></a>1. 二叉查找树的查找操作</h5><p>先取根节点，如果它等于我们要查找的数据，那就返回。</p><p>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</p><p>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585231510341.png" alt="1585231510341"></p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">search</span>(<span class="hljs-params">key</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> searchNode = <span class="hljs-function">(<span class="hljs-params">node, key</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">if</span> (node.key === key) <span class="hljs-keyword">return</span> node<br>        <span class="hljs-keyword">return</span> searchNode((key &lt; node.key) ? node.left : node.right, key)<br>    &#125;<br>    <span class="hljs-keyword">return</span> searchNode(root, key)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-二叉查找树的插入操作"><a href="#2-二叉查找树的插入操作" class="headerlink" title="2. 二叉查找树的插入操作"></a>2. 二叉查找树的插入操作</h5><p>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585232443213.png" alt="1585232443213"></p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key<br>        <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span><br>        <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> Node(key)<br>        <span class="hljs-keyword">const</span> insertNode = <span class="hljs-function">(<span class="hljs-params">node, newNode</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (newNode.key &lt; node.key) &#123;<br>                <span class="hljs-keyword">if</span> (node.left === <span class="hljs-literal">null</span>) &#123;<br>                    node.left = newNode<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    insertNode(node.left, newNode)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (node.right === <span class="hljs-literal">null</span>) &#123;<br>                    node.right = newNode<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    insertNode(node.right, newNode)<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.root) &#123;<br>            <span class="hljs-built_in">this</span>.root = newNode<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            insertNode(<span class="hljs-built_in">this</span>.root, newNode)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> tree = <span class="hljs-keyword">new</span> BinarySearchTree()<br>tree.insert(<span class="hljs-number">11</span>)<br>tree.insert(<span class="hljs-number">7</span>)<br>tree.insert(<span class="hljs-number">5</span>)<br>tree.insert(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h5 id="3-二叉查找树的删除操作"><a href="#3-二叉查找树的删除操作" class="headerlink" title="3. 二叉查找树的删除操作"></a>3. 二叉查找树的删除操作</h5><p>删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p><ul><li><p>第一种情况是，如果要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。</p></li><li><p>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</p></li><li><p>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</p></li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585232936669.png" alt="1585232936669"></p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteNode</span>(<span class="hljs-params">root, key</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!root)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;删除失败&quot;</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (root.value &gt; key)&#123;  <span class="hljs-comment">//若当前结点值大于删除值，则继续在左子树中寻找删除值</span><br>        root.left = deleteNode(root.left, key);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.value &lt; key)&#123;  <span class="hljs-comment">//若当前结点值小于删除值，则继续在右子树中寻找删除值</span><br>        root.right = deleteNode(root.right, key);<br>    &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//找到与删除中相等的结点</span><br>        <span class="hljs-keyword">if</span> (root.left === <span class="hljs-literal">null</span> &amp; root.right === <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">//叶子结点</span><br>            root = <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left === <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">//只有右子树</span><br>            root = root.right;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right === <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">//只有左子树</span><br>            root = root.left;<br>        &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//同时具有左右子树</span><br>            <span class="hljs-keyword">let</span> prevNode = root.left;<br>            <span class="hljs-keyword">while</span>(prevNode.right)&#123;  <span class="hljs-comment">//寻找不大于当前结点值的最大结点值</span><br>                prevNode = prevNode.right;<br>            &#125;<br>            root.value = prevNode.value;  <span class="hljs-comment">//替换值</span><br>            root.left = deleteNode(root.left, prevNode.value);  <span class="hljs-comment">//递归左子树，删除重复值的结点</span><br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-搜索最小值和最大值"><a href="#4-搜索最小值和最大值" class="headerlink" title="4. 搜索最小值和最大值"></a>4. 搜索最小值和最大值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">min</span>(<span class="hljs-params">node</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> minNode = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> node ? (node.left ? minNode(node.left) : node) : <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> minNode(node || <span class="hljs-built_in">this</span>.root)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">max</span>(<span class="hljs-params">node</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> maxNode = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> node ? (node.right ? maxNode(node.right) : node) : <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> maxNode(node || <span class="hljs-built_in">this</span>.root)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-时间复杂度分析"><a href="#5-时间复杂度分析" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h5><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585233813271.png" alt="1585233813271"></p><p>图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。这是一种最糟糕的情况。</p><p>最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。不管操作是插入、删除还是查找，**时间复杂度其实都跟树的高度成正比，也就是 O(height)**。</p><h3 id="（4）相对散列表，二叉树的优势"><a href="#（4）相对散列表，二叉树的优势" class="headerlink" title="（4）相对散列表，二叉树的优势"></a>（4）相对散列表，二叉树的优势</h3><ul><li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li><li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li><li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li><li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li><li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li></ul><p><strong>学习于：</strong></p><p>极客时间《数据结构与算法之美》</p><p><a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构与算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据结构与算法之美》学习笔记(4) 二分查找及其变形问题</title>
    <link href="/2020/03/25/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/"/>
    <url>/2020/03/25/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找及其变形问题"><a href="#二分查找及其变形问题" class="headerlink" title="二分查找及其变形问题"></a>二分查找及其变形问题</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p><h4 id="（1）O-logn-惊人的查找速度"><a href="#（1）O-logn-惊人的查找速度" class="headerlink" title="（1）O(logn) 惊人的查找速度"></a>（1）O(logn) 惊人的查找速度</h4><p>二分查找是一种非常高效的查找算法。</p><p>即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。</p><h4 id="（2）二分查找实现"><a href="#（2）二分查找实现" class="headerlink" title="（2）二分查找实现"></a>（2）二分查找实现</h4><p>我的博客:</p><p><a href="https://blog.csdn.net/weixin_46124214/article/details/104978186">算法 -查找算法</a></p><h4 id="（3）二分查找应用场景的局限性"><a href="#（3）二分查找应用场景的局限性" class="headerlink" title="（3）二分查找应用场景的局限性"></a>（3）二分查找应用场景的局限性</h4><p>二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。</p><ul><li><p><strong>首先，二分查找依赖的是顺序表结构，简单点说就是数组。</strong></p><p>那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p><p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果数据是通过其他数据结构存储的，则无法应用二分查找。</p></li><li><p><strong>其次，二分查找针对的是有序数据</strong>。</p><p>二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，需要先排序。</p><p>如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。</p></li><li><p><strong>再次，数据量太小不适合二分查找。</strong></p><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。</p><p>不过，有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p></li><li><p><strong>最后，数据量太大也不适合二分查找。</strong></p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p></li></ul><h2 id="二分查找变形问题"><a href="#二分查找变形问题" class="headerlink" title="二分查找变形问题"></a>二分查找变形问题</h2><p>为了简化讲解，以下的内容，都以数据是从小到大排列为前提。</p><h4 id="（1）查找第一个值等于给定值的元素"><a href="#（1）查找第一个值等于给定值的元素" class="headerlink" title="（1）查找第一个值等于给定值的元素"></a>（1）查找第一个值等于给定值的元素</h4><p>上面二分查找是最简单的一种，即有序数据集合中不存在重复的数据，在其中查找值等于某个给定值的数据。如果将这个问题稍微修改下，有序数据集合中存在重复的数据，希望找到第一个值等于给定值的数据。</p><p><strong>例子：</strong></p><p>比如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585139248573.png" alt="1585139248573"></p><p>如果用之前的二分查找的代码实现，首先拿 8 与区间的中间值 a[4] 比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7] 正好等于 8，所以代码就返回了。</p><p>尽管 a[7] 也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。</p><p><strong>算法实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bsearch</span>(<span class="hljs-params">arr, value</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> high = arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high) &#123;<br>        <span class="hljs-keyword">let</span> mid = low + ((high - low) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || a[mid - <span class="hljs-number">1</span>] != value) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法理解：</strong></p><ul><li><p>a[mid] 跟要查找的 value 的大小关系有三种情况：大于、小于、等于。</p></li><li><p>对于 a[mid]&gt;value 的情况，我们需要更新 high= mid-1；</p></li><li><p>对于 a[mid]&lt;value 的情况，我们需要更新 low=mid+1。</p></li><li><p>那当 a[mid]=value 的时候应该如何处理呢？</p><p>当 a[mid] 等于要查找的值时，a[mid] 就是要找的元素。但是，如果求解的是第一个值等于给定值的元素，当 a[mid] 等于要查找的值时，就需要先确认一下这个 a[mid] 是不是第一个值等于给定值的元素。</p><p>如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是要找的；如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现 a[mid] 前面的一个元素 a[mid-1] 也等于 value，那说明此时的 a[mid] 肯定不是要查找的第一个值等于给定值的元素。那就更新 high=mid-1，因为要找的元素肯定出现在 [low, mid-1] 之间。</p></li></ul><h4 id="（2）查找最后一个值等于给定值的元素"><a href="#（2）查找最后一个值等于给定值的元素" class="headerlink" title="（2）查找最后一个值等于给定值的元素"></a>（2）查找最后一个值等于给定值的元素</h4><p>如果掌握了前面的写法，那这个问题你应该很轻松就能解决。</p><p><strong>算法实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bsearch</span>(<span class="hljs-params">arr, value</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> high = arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-keyword">let</span> mid = low + ((high - low) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; value) &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; value) &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((mid == arr.length - <span class="hljs-number">1</span> || arr[mid + <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> low mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法理解：</strong></p><p>重点看第 11 行代码。</p><ul><li><p>如果 a[mid] 这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid] 的后一个元素 a[mid+1] 不等于 value，那也说明 a[mid] 就是要找的最后一个值等于给定值的元素。</p></li><li><p>如果经过检查之后，发现 a[mid] 后面的一个元素 a[mid+1] 也等于 value，那说明当前的这个 a[mid] 并不是最后一个值等于给定值的元素。就更新 low=mid+1，因为要找的元素肯定出现在 [mid+1, high] 之间。</p></li></ul><h4 id="（3）查找第一个大于大于给定值的元素"><a href="#（3）查找第一个大于大于给定值的元素" class="headerlink" title="（3）查找第一个大于大于给定值的元素"></a>（3）查找第一个大于大于给定值的元素</h4><p>在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p><p><strong>算法实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bsearch</span>(<span class="hljs-params">arr, value</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> high = arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high) &#123;<br>        <span class="hljs-keyword">let</span> mid = low + ((high - low) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;<br>            <span class="hljs-keyword">if</span>((mid == <span class="hljs-number">0</span>) || arr[mid - <span class="hljs-number">1</span>] &lt; value) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法理解：</strong></p><ul><li><p>如果 a[mid] 小于要查找的值 value，那要查找的值肯定在 [mid+1, high] 之间，所以，我们更新 low=mid+1。</p></li><li><p>对于 a[mid] 大于等于给定值 value 的情况，要先看下这个 a[mid] 是不是要找的第一个值大于等于给定值的元素。如果 a[mid] 前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid] 就是要找的元素。这段逻辑对应的代码是第 7 行。</p></li><li><p>如果 a[mid-1] 也大于等于要查找的值 value，那说明要查找的元素在 [low, mid-1] 之间，所以，我们将 high 更新为 mid-1。</p></li></ul><h4 id="（4）查找最后一个小于等于给定值的元素"><a href="#（4）查找最后一个小于等于给定值的元素" class="headerlink" title="（4）查找最后一个小于等于给定值的元素"></a>（4）查找最后一个小于等于给定值的元素</h4><p>比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bsearch</span>(<span class="hljs-params">arr, value</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> high = arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-keyword">let</span> mid = low + ((high - low) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt;= value) &#123;<br>            <span class="hljs-keyword">if</span> (mid == arr.length - <span class="hljs-number">1</span> || arr[mid] &gt; value) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>《数据结构与算法之美》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 排序算法</title>
    <link href="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585109897753.png" alt="1585109897753"></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><a href="#jump1">冒泡排序</a></h4></li><li><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><a href="#jump2">选择排序</a></h4></li><li><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><a href="#jump3">插入排序</a></h4></li><li><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><a href="#jump4">希尔排序</a></h4></li><li><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><a href="#jump5">归并排序</a></h4></li><li><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><a href="#jump6">快速排序</a></h4></li><li><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><a href="#jump7">堆排序</a></h4></li><li><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><a href="#jump8">计数排序</a></h4></li><li><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="#jump9">桶排序</a></h4></li><li><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><a href="#jump10">基数排序</a></h4></li></ul><h4 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h4><p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p><ul><li><p><strong>最好情况、最坏情况、平均情况时间复杂度</strong> </p><p>为什么要区分这三种时间复杂度呢？</p><p>第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。</p><p>第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p></li><li><p><strong>时间复杂度的系数、常数 、低阶</strong></p><p>时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把系数、常数、低阶也考虑进来。</p></li><li><p><strong>比较次数和交换（或移动）次数</strong></p><p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p></li></ul><h4 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h4><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。我们今天讲的三种排序算法，都是原地排序算法。</p><h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li></ul><h3 id="（一）冒泡排序"><a href="#（一）冒泡排序" class="headerlink" title="（一）冒泡排序"></a><span id = "jump1">（一）冒泡排序</span></h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><p><strong>算法描述</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr<br>    &#125;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>        <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len - i - <span class="hljs-number">1</span>; j ++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">let</span> temp = arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = temp;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化</strong>：当一次循环没有发生冒泡，说明已经排序完成，停止循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>        <span class="hljs-keyword">let</span> complete = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span> - j; i++) &#123;<br>          <span class="hljs-comment">// 比较相邻数</span><br>          <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>            [arr[i], arr[i + <span class="hljs-number">1</span>]] = [arr[i + <span class="hljs-number">1</span>], arr[i]];<br>            complete = <span class="hljs-literal">false</span>;<br>          &#125;<br>        &#125;<br>        <span class="hljs-comment">// 没有冒泡结束循环</span><br>        <span class="hljs-keyword">if</span> (complete) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> arr;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>冒泡排序是原地排序算法</strong></p><p><strong>复杂度：</strong></p><ul><li><p>平均时间复杂度：<code>O(n²)</code></p><p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。</p><p>最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。</p></li><li><p>空间复杂度:<code>O(1)</code></p></li></ul><p><strong>稳定性：</strong></p><p>稳定</p><h3 id="（二）选择排序"><a href="#（二）选择排序" class="headerlink" title="（二）选择排序"></a><span id = "jump2">（二）选择排序</span></h3><p>选择排序算法是一种原址比较排序算法。选择排序算法的思路是：找到数据结构中的最小值并 将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr<br>    &#125;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i ++) &#123;<br>        <span class="hljs-keyword">let</span> min = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j ++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> temp = arr[i];<br>        arr[i] = arr[min];<br>        arr[min] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度：</strong></p><ul><li><p>时间复杂度：<code>O(n²)</code></p><p>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 <code>O(n²)</code>。</p></li><li><p>空间复杂度:<code>O(1)</code></p></li></ul><p><strong>稳定性：</strong></p><p>不稳定</p><h3 id="（三）插入排序"><a href="#（三）插入排序" class="headerlink" title="（三）插入排序"></a><span id = "jump3">（三）插入排序</span></h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述</strong></p><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr<br>    &#125;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>        <span class="hljs-keyword">let</span> temp = arr[i];<br>        <span class="hljs-keyword">let</span> k = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(; k &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[k] &gt; temp) &#123;<br>                 arr[k + <span class="hljs-number">1</span>] = arr[k];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        arr[k + <span class="hljs-number">1</span>] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>插入排序是原地排序算法</strong></p><p><strong>复杂度：</strong></p><ul><li><p>平均时间复杂度：<code>O(n²)</code></p><p>最好是时间复杂度为 O(n)。这里是<strong>从尾到头遍历已经有序的数据</strong>。</p><p>最坏情况：数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。</p></li><li><p>空间复杂度:<code>O(1)</code></p></li></ul><p><strong>稳定性：</strong></p><p>稳定</p><h3 id="（四）希尔排序"><a href="#（四）希尔排序" class="headerlink" title="（四）希尔排序"></a><span id = "jump4">（四）希尔排序</span></h3><p>1959年Shell发明，第一个突破O(n²)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p><strong>算法描述</strong></p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> gap = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>); gap &gt; <span class="hljs-number">0</span>; gap = <span class="hljs-built_in">Math</span>.floor(gap / <span class="hljs-number">2</span>)) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = gap; i &lt; len; i ++) &#123;<br>            <span class="hljs-keyword">let</span> temp = arr[i];<br>            <span class="hljs-keyword">let</span> k = i - gap;<br>            <span class="hljs-keyword">while</span> (k &gt;=<span class="hljs-number">0</span> &amp;&amp; arr[k] &gt; temp) &#123;<br>                arr[k + gap] = arr[k];<br>                k = k - gap;<br>            &#125;<br>            arr[k + gap] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度：</strong></p><ul><li><p>时间复杂度：<code>O(n1.3)</code></p><p>最好情况下：<code>O(n)</code></p><p>最坏情况下：<code>O(n²)</code></p></li><li><p>空间复杂度:<code>O(1)</code></p></li></ul><p><strong>稳定性：</strong></p><p>不稳定</p><h3 id="（五）归并排序"><a href="#（五）归并排序" class="headerlink" title="（五）归并排序"></a><span id = "jump5">（五）归并排序</span></h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><p> <strong>算法描述</strong></p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">let</span> left = arr.slice(<span class="hljs-number">0</span>, middle);<br>    <span class="hljs-keyword">let</span> right = arr.slice(middle);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">while</span>(left.length &gt; <span class="hljs-number">0</span> &amp;&amp; right.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>            result.push(left.shift())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.push(right.shift())<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left.length) &#123;<br>        result.push(left.shift())<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right.length) &#123;<br>        result.push(right.shift())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度：</strong></p><ul><li><p>时间复杂度：<code>O(nlogn)</code></p><p>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p></li><li><p>空间复杂度:<code>O(n)</code></p></li></ul><p><strong>稳定性：</strong></p><p>稳定</p><h3 id="六-快速排序"><a href="#六-快速排序" class="headerlink" title="(六) 快速排序"></a><span id = "jump6">(六) 快速排序</span></h3><p>快速排序的基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。</p><p><strong>算法描述</strong></p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>选择一个基准元素<code>target</code>（一般选择第一个数）</li><li>将比<code>target</code>小的元素移动到数组左边，比<code>target</code>大的元素移动到数组右边</li><li>分别对<code>target</code>左侧和右侧的元素进行快速排序</li></ul><p>从上面的步骤中我们可以看出，快速排序也利用了分治的思想（将问题分解成一些小问题递归求解）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">const</span> target = arr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> left = [];<br>  <span class="hljs-keyword">const</span> right = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; target) &#123;<br>      left.push(arr[i]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      right.push(arr[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> quickSort(left).concat([target], quickSort(right));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>快排是一种原地排序算法。</strong></p><p><strong>复杂度：</strong></p><ul><li><p>时间复杂度：平均<code>O(nlogn)</code>，最坏<code>O(n²)</code>，实际上大多数情况下小于<code>O(nlogn)</code></p></li><li><p>空间复杂度:<code>O(logn)</code>（递归调用消耗）</p></li></ul><p><strong>稳定性：</strong></p><p>不稳定</p><h3 id="（七）堆排序"><a href="#（七）堆排序" class="headerlink" title="（七）堆排序"></a><span id = "jump7">（七）堆排序</span></h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><strong>思想：</strong></p><p>创建一个大顶堆，大顶堆的堆顶一定是最大的元素。</p><p>交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。</p><p>从后往前以此和第一个元素交换并重新构建，排序完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">array</span>) </span>&#123;<br>     creatHeap(array);<br>     <span class="hljs-built_in">console</span>.log(array);<br>     <span class="hljs-comment">// 交换第一个和最后一个元素，然后重新调整大顶堆</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>       [array[i], array[<span class="hljs-number">0</span>]] = [array[<span class="hljs-number">0</span>], array[i]];<br>       adjust(array, <span class="hljs-number">0</span>, i);<br>     &#125;<br>     <span class="hljs-keyword">return</span> array;<br>   &#125;<br>   <span class="hljs-comment">// 构建大顶堆，从第一个非叶子节点开始，进行下沉操作</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creatHeap</span>(<span class="hljs-params">array</span>) </span>&#123;<br>     <span class="hljs-keyword">const</span> len = array.length;<br>     <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">parseInt</span>(len / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>       adjust(array, i, len);<br>     &#125;<br>   &#125;<br>   <span class="hljs-comment">// 将第target个元素进行下沉，孩子节点有比他大的就下沉</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adjust</span>(<span class="hljs-params">array, target, len</span>) </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span> * target + <span class="hljs-number">1</span>; i &lt; len; i = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-comment">// 找到孩子节点中最大的</span><br>       <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; array[i + <span class="hljs-number">1</span>] &gt; array[i]) &#123;<br>         i = i + <span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-comment">// 下沉</span><br>       <span class="hljs-keyword">if</span> (array[i] &gt; array[target]) &#123;<br>         [array[i], array[target]] = [array[target], array[i]]<br>         target = i;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">break</span>;<br>       &#125;<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度：</strong></p><ul><li><p>平均、最好、最坏时间复杂度：<code>O(nlogn)</code></p></li><li><p>空间复杂度:<code>O(1)</code></p></li></ul><p><strong>稳定性：</strong></p><p>不稳定</p><h3 id="（八）计数排序"><a href="#（八）计数排序" class="headerlink" title="（八）计数排序"></a><span id = "jump8">（八）计数排序</span></h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>算法描述</strong></p><p>假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8] 中，它们分别是：2，5，3，0，2，3，0，3。</p><p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6] 表示桶，其中下标对应分数。C[k] 里存储小于等于分数 k 的考生个数。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585060951916.png" alt="1585060951916"></p><p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。</p><p>以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。</p><p><img src="C:\Users\lin\Desktop\下载.png"></p><p><strong>算法实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 计数排序，arr 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countingSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">let</span> max = arr[<span class="hljs-number">0</span>];<br>     <span class="hljs-comment">// 查找数组中数据的范围</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (max &lt; arr[i]) &#123;<br>            max = arr[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> c = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= max; ++i) &#123;<br>        c[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>     <span class="hljs-comment">// 计算每个元素的个数，放入 c 中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        c[arr[i]]++;<br>    &#125;<br>     <span class="hljs-comment">// 依次累加</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= max; ++i) &#123;<br>        c[i] = c[i-<span class="hljs-number">1</span>] + c[i];<br>    &#125;<br>     <span class="hljs-comment">// 临时数组 r，存储排序之后的结果</span><br>    <span class="hljs-keyword">let</span> r = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">let</span> index = c[a[i]] - <span class="hljs-number">1</span>;<br>        r[index] = arr[i];<br>        c[arr[i]] --;<br>    &#125;<br><span class="hljs-keyword">return</span> r[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p><p><strong>复杂度：</strong></p><ul><li><p>平均时间复杂度：<code>O(n)</code></p></li><li><p>空间复杂度:<code>O(1)</code></p></li></ul><p><strong>稳定性：</strong></p><p>不稳定</p><h3 id="（九）桶排序"><a href="#（九）桶排序" class="headerlink" title="（九）桶排序"></a><span id = "jump9">（九）桶排序</span></h3><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585107889311.png" alt="1585107889311"></p><p><strong>算法描述</strong></p><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><p><strong>算法实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bucketSort</span>(<span class="hljs-params">arr, bucketSize</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">let</span> minValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> maxValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; len; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; minValue) &#123;<br>            minValue = arr[i];<span class="hljs-comment">// 输入数据的最小值</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; maxValue) &#123;<br>            maxValue = arr[i]<span class="hljs-comment">// 输入数据的最大值</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 桶的初始化</span><br>    <span class="hljs-keyword">let</span> backetCount = <span class="hljs-built_in">Math</span>.floor((maxValue - minValue) / bucketSize);<br>    <span class="hljs-keyword">let</span> backets = [];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> i &lt; backetCount; i ++) &#123;<br>        buckets[i] = []<br>    &#125;<br>    <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; backetCount; i ++) &#123;<br>        buckets[<span class="hljs-built_in">Math</span>.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);<br>    &#125;<br>    arr = [];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; backetCount; i ++) &#123;<br>        insertionSort(buckets[i]); <span class="hljs-comment">// 对每个桶进行排序，这里使用了插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; backetCount; j ++) &#123;<br>            arr.push(buckets[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>非原地排序</strong></p><p><strong>复杂度：</strong></p><ul><li><p>平均时间复杂度：<code>O(n + k)</code></p><p>最好时间复杂度：<code>O(n)</code></p><p>最坏时间复杂度：<code>O(n²)</code></p></li><li><p>空间复杂度:<code>O(n + k)</code></p></li></ul><p><strong>稳定性：</strong></p><p>稳定</p><h3 id="（十）基数排序"><a href="#（十）基数排序" class="headerlink" title="（十）基数排序"></a><span id = "jump10">（十）基数排序</span></h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><strong>算法描述：</strong></p><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><p><strong>算法实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">rcounter = [];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">radixSort</span>(<span class="hljs-params">arr, maxDigit</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> mod = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> dev = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">let</span> bucket = <span class="hljs-built_in">parseInt</span>((arr[j] % mod) / dev);<br>            <span class="hljs-keyword">if</span>(counter[bucket]==<span class="hljs-literal">null</span>) &#123;<br>                counter[bucket] = [];<br>            &#125;<br>            counter[bucket].push(arr[j]);<br>        &#125;<br>        <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; counter.length; j++) &#123;<br>            <span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(counter[j]!=<span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span>((value = counter[j].shift()) != <span class="hljs-literal">null</span>) &#123;<br>                      arr[pos++] = value;<br>                &#125;<br>          &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p><strong>非原地排序</strong></p><p><strong>复杂度：</strong></p><ul><li><p>平均、最好、最坏时间复杂度：<code>O(n * k)</code></p></li><li><p>空间复杂度:<code>O(n * k)</code></p></li></ul><p><strong>稳定性：</strong></p><p>稳定</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>首页实现</title>
    <link href="/2020/03/23/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E9%A6%96%E9%A1%B5%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/03/23/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E9%A6%96%E9%A1%B5%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="商场首页"><a href="#商场首页" class="headerlink" title="商场首页"></a>商场首页</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-Nav-Header组件"><a href="#1-Nav-Header组件" class="headerlink" title="1. Nav-Header组件"></a><a href="#jumpa">1. Nav-Header组件</a></h4><ul><li><a href="#jump1"><strong>组件复用的一个技巧</strong></a></li><li><a href="#jump2"><strong>通过 @mixin 简化代码</strong></a></li><li><a href="#jump3"><strong>统一修改系统主题色</strong></a></li><li><a href="#jump4"><strong>数据请求</strong></a></li></ul><h4 id="2-首页轮播功能实现"><a href="#2-首页轮播功能实现" class="headerlink" title="2. 首页轮播功能实现"></a><a href="#jumpb">2. 首页轮播功能实现</a></h4><ul><li><a href="#jump5"><strong>使用 vue-awesome-swiper 实现轮播图</strong></a></li><li><a href="#jump6"><strong>首页轮播菜单实现</strong></a></li><li><a href="#jump7"><strong>Modal 弹窗动画 与 父子组件通信</strong></a></li><li><a href="#jump8"><strong>懒加载</strong></a></li></ul><h2 id="一-Nav-Header组件"><a href="#一-Nav-Header组件" class="headerlink" title="一. Nav-Header组件"></a><span id="jumpa">一. Nav-Header组件</span></h2><h4 id="（1）组件复用的一个技巧："><a href="#（1）组件复用的一个技巧：" class="headerlink" title="（1）组件复用的一个技巧："></a><span id="jump1">（1）组件复用的一个技巧：</span></h4><p>因为商场网站中多个页面共用了头部组件nav-header和底部组件nav-footer，而为了避免 每个需要这两个组件的页面中都需要单独引入组件，我们可以通过一个home页面来复用共用的组件。</p><ul><li>在路由文件中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>           <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>           <span class="hljs-attr">component</span>:Home,<br>           <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,<br>           <span class="hljs-attr">children</span>: [ <span class="hljs-comment">//下面是需要头部和底部组件的页面</span><br>               &#123;<br>                   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,<br>                   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;index&#x27;</span>,<br>                   <span class="hljs-attr">component</span>: Index,<br>               &#125;,<br>               &#123;<br>                   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/:id&#x27;</span>,<br>                   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;product&#x27;</span>,<br>                   <span class="hljs-attr">component</span>: Product,<br>               &#125;,<br>               &#123;<br>                   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail/:id&#x27;</span>,<br>                   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;detail&#x27;</span>,<br>                   <span class="hljs-attr">component</span>: Detail,<br>               &#125;                <br>           ]<br>       &#125;,<br></code></pre></td></tr></table></figure><ul><li>在home.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        home<br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav-header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav-footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav-footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> NavHeader <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/NavHeader&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> NavFooter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/NavFooter&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;nav-home&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">        NavHeader,</span><br><span class="javascript">        NavFooter</span><br><span class="javascript"></span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）通过-mixin简化代码"><a href="#（2）通过-mixin简化代码" class="headerlink" title="（2）通过@mixin简化代码 "></a><span id="jump2">（2）通过<code>@mixin</code>简化代码 </span></h4><p>为了有效的维护和开发项目，代码的重复利用就显得尤为重要。在Sass中，除了<a href="https://link.jianshu.com/?t=http://vanseodesign.com/css/sass-the-import-directive/"><code>@import</code></a>和<a href="https://link.jianshu.com/?t=http://vanseodesign.com/css/sass-the-extend-directive/"><code>@extend</code></a>可以使代码更加具有重复利用性，<code>@mixin</code>指令也同样能提高代码的重复使用率并简化你的代码。</p><ul><li>在assets文件夹中创建一个scss文件夹。在scss文件夹中创建mixin.scss文件，在里面存放将会共用的代码：</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> flex(<span class="hljs-variable">$hov</span>: space-between, <span class="hljs-variable">$col</span>:center) &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: <span class="hljs-variable">$hov</span>;<br>    <span class="hljs-attribute">align-items</span>: <span class="hljs-variable">$col</span>;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> bgImg(<span class="hljs-variable">$w</span>:<span class="hljs-number">0</span>, <span class="hljs-variable">$h</span>:<span class="hljs-number">0</span>, <span class="hljs-variable">$img</span>:<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$size</span>:contain) &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">$w</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-variable">$h</span>;<br>    <span class="hljs-attribute">background</span>:url(<span class="hljs-variable">$img</span>) no-repeat center;<br>    <span class="hljs-attribute">background-size</span>: <span class="hljs-variable">$size</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在用到mixin.scss里样式的文件NavHeader里，在<code>&lt;style&gt;</code>标签中引入mixin.scss文件并替换用到的css代码</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs scss">&lt;style lang=&quot;scss&quot;&gt;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./../assets/scss/mixin.scss&#x27;</span>;<br>    <span class="hljs-selector-class">.container</span>&#123;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">112px</span>;<br><span class="hljs-comment">/*display: flex;</span><br><span class="hljs-comment">        justify-content: $hov;</span><br><span class="hljs-comment">         align-items: $col; */</span><br>            <span class="hljs-keyword">@include</span> flex();<br>    &#125;<br>        <span class="hljs-selector-class">.my-cart</span>&#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FF6600</span>;<br>            <span class="hljs-attribute">text-align</span>: center;<br>            <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>            <span class="hljs-selector-class">.icon-cart</span>&#123;<br>           <span class="hljs-comment">/*</span><br><span class="hljs-comment">               display: inline-block;</span><br><span class="hljs-comment">     width: 16px;</span><br><span class="hljs-comment">          height: 12px;</span><br><span class="hljs-comment">       background:url(&#x27;/imgs/icon-cart-checked.png&#x27;) no-repeat center;</span><br><span class="hljs-comment">    background-size: contain;</span><br><span class="hljs-comment">    margin-right: 4px;</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-keyword">@include</span> bgImg(<span class="hljs-number">16px</span>, <span class="hljs-number">12px</span>, <span class="hljs-string">&#x27;/imgs/icon-cart-checked.png&#x27;</span>);<br>                <span class="hljs-attribute">margin-right</span>:<span class="hljs-number">4px</span>;<br>            &#125;<br>        &#125;  <br>    <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li>@mixin学习资料：</li></ul><p><a href="https://www.w3cplus.com/preprocessor/sass-the-mixin-directive.html">Sass: @mixin指令介绍</a></p><p><a href="https://www.runoob.com/sass/sass-mixin-include.html">Sass: @mixin 菜鸟教程</a></p><h4 id="3-统一修改系统主题色"><a href="#3-统一修改系统主题色" class="headerlink" title="(3)统一修改系统主题色"></a><span id="jump3">(3)统一修改系统主题色</span></h4><ul><li>在scss文件夹中加入文件config.scss文件，该文件定义了一些常规样式。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  样式规范表</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable">$min-width</span>:<span class="hljs-number">1226px</span>;  <span class="hljs-comment">//容器安全区域宽度</span><br><br><span class="hljs-comment">// 常规字体大小设置</span><br><span class="hljs-variable">$fontA</span>:       <span class="hljs-number">80px</span>; <span class="hljs-comment">//产品站大标题</span><br><span class="hljs-variable">$fontB</span>:       <span class="hljs-number">38px</span>; <span class="hljs-comment">//产品站标题</span><br><span class="hljs-variable">$fontC</span>:       <span class="hljs-number">28px</span>; <span class="hljs-comment">//导航标题</span><br><span class="hljs-variable">$fontD</span>:       <span class="hljs-number">26px</span>; <span class="hljs-comment">//产品站副标题</span><br><span class="hljs-variable">$fontE</span>:       <span class="hljs-number">24px</span>; <br><span class="hljs-variable">$fontF</span>:       <span class="hljs-number">22px</span>;<br><span class="hljs-variable">$fontG</span>:       <span class="hljs-number">20px</span>; <span class="hljs-comment">//用在较为重要的文字、操作按钮</span><br><span class="hljs-variable">$fontH</span>:       <span class="hljs-number">18px</span>; <span class="hljs-comment">//用于大多数文字</span><br><span class="hljs-variable">$fontI</span>:       <span class="hljs-number">16px</span>; <span class="hljs-comment">//用于辅助性文字</span><br><span class="hljs-variable">$fontJ</span>:       <span class="hljs-number">14px</span>; <span class="hljs-comment">//用于一般文字</span><br><span class="hljs-variable">$fontK</span>:       <span class="hljs-number">12px</span>; <span class="hljs-comment">//系统默认大小</span><br><br><span class="hljs-comment">// 常规配色设置</span><br><span class="hljs-variable">$colorA</span>:      <span class="hljs-number">#FF6600</span> !default; <span class="hljs-comment">//用于需要突出和强调的文字、按钮和icon</span><br><span class="hljs-variable">$colorB</span>:      <span class="hljs-number">#333333</span> !default; <span class="hljs-comment">//用于较为重要的文字信息、内页标题等</span><br><span class="hljs-variable">$colorC</span>:      <span class="hljs-number">#666666</span> !default; <span class="hljs-comment">//用于普通段落信息 引导词</span><br><span class="hljs-variable">$colorD</span>:      <span class="hljs-number">#999999</span> !default; <span class="hljs-comment">//用于辅助、此要的文字信息、普通按钮的描边</span><br><span class="hljs-variable">$colorE</span>:      <span class="hljs-number">#cccccc</span> !default; <span class="hljs-comment">//用于特别弱的文字</span><br><span class="hljs-variable">$colorF</span>:      <span class="hljs-number">#d7d7d7</span> !default; <span class="hljs-comment">//用于列表分割线、标签秒变</span><br><span class="hljs-variable">$colorG</span>:      <span class="hljs-number">#ffffff</span> !default; <span class="hljs-comment">//用于导航栏文字、按钮文字、白色背景</span><br><span class="hljs-variable">$colorH</span>:      <span class="hljs-number">#e5e5e5</span> !default; <span class="hljs-comment">//用于上下模块分割线</span><br><span class="hljs-variable">$colorI</span>:      <span class="hljs-number">#000000</span> !default; <span class="hljs-comment">//纯黑色背景，用于遮罩层</span><br><span class="hljs-variable">$colorJ</span>:      <span class="hljs-number">#F5F5F5</span> !default; <span class="hljs-comment">//弹框标题背景色</span><br><span class="hljs-variable">$colorK</span>:      <span class="hljs-number">#FFFAF7</span> !default; <span class="hljs-comment">//订单标题背景色</span><br></code></pre></td></tr></table></figure><ul><li>在需要用到常规样式的组件或页面中引入config.scss并使用样式：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;./../assets/scss/config.scss&quot;</span>;</span><br><span class="css">          &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="css">              <span class="hljs-attribute">color</span>:$colorA;</span><br><span class="css">          &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <br></code></pre></td></tr></table></figure><h4 id="4-数据请求"><a href="#4-数据请求" class="headerlink" title="(4) 数据请求"></a><span id="jump4">(4) 数据请求</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;nav-header&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;jack&quot;</span>,<br>      <span class="hljs-attr">phoneList</span>: []<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.getProductList();<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">getProductList</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.axios<br>        .get(<span class="hljs-string">&quot;/products&quot;</span>, &#123;<br>          <span class="hljs-attr">params</span>: &#123;<br>            <span class="hljs-attr">categoryId</span>: <span class="hljs-string">&quot;100012&quot;</span><br>          &#125;<br>        &#125;)<br>        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (res.list.length &gt; <span class="hljs-number">6</span>) &#123;<br>            <span class="hljs-built_in">this</span>.phoneList = res.list.slice(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>          &#125;<br>        &#125;);<br>    &#125;,<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二-首页轮播功能实现"><a href="#二-首页轮播功能实现" class="headerlink" title="二. 首页轮播功能实现"></a><span id="jumpb">二. 首页轮播功能实现</span></h2><h4 id="（1）使用vue-awesome-swiper实现轮播图"><a href="#（1）使用vue-awesome-swiper实现轮播图" class="headerlink" title="（1）使用vue-awesome-swiper实现轮播图"></a><span id="jump5">（1）使用vue-awesome-swiper实现轮播图</span></h4><ul><li>安装vue-awesome-swiper:</li></ul><p><code>npm install vue-awesome-swiper --save</code></p><ul><li>在需要用到该插件的文件里导入和使用组件：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">v-bind:options</span>=<span class="hljs-string">&quot;swiperOption&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">swiper-slide</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in slideList&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;&#x27;/#/product&#x27; + item.id&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;item.img&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-slide</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-pagination&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;pagination&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-prev&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;button-prev&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-next&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;button-next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123;swiper, swiperSlide&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-awesome-swiper&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;swiper/dist/css/swiper.css&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;index&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">        swiper,</span><br><span class="javascript">        swiperSlide,</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">swiperOption</span>: &#123;</span><br><span class="javascript">                <span class="hljs-attr">autoplay</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//自动播放</span></span><br><span class="javascript">                <span class="hljs-attr">loop</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//循环播放</span></span><br><span class="javascript">                <span class="hljs-attr">effect</span>:<span class="hljs-string">&#x27;cube&#x27;</span>, <span class="hljs-comment">//切换效果</span></span><br><span class="javascript">                <span class="hljs-attr">cubeEffect</span>: &#123; <span class="hljs-comment">//cube的相关配置参数</span></span><br><span class="javascript">                    <span class="hljs-attr">slideShadows</span>:<span class="hljs-literal">true</span>,</span><br><span class="javascript">                    <span class="hljs-attr">shadow</span>:<span class="hljs-literal">true</span>,</span><br><span class="javascript">                    <span class="hljs-attr">shadowOffset</span>:<span class="hljs-number">100</span>,</span><br><span class="javascript">                    <span class="hljs-attr">shadowScale</span>:<span class="hljs-number">0.6</span></span><br><span class="javascript">                &#125;,</span><br><span class="javascript">                <span class="hljs-attr">pagination</span>: &#123; <span class="hljs-comment">//指定分页器</span></span><br><span class="javascript">                    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.swiper-pagination&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-attr">clickable</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">//允许分页器可点击</span></span><br><span class="javascript">                &#125;,</span><br><span class="javascript">                <span class="hljs-attr">navigation</span>: &#123; <span class="hljs-comment">//指定前进后退按钮</span></span><br><span class="javascript">                    <span class="hljs-attr">nextEl</span>: <span class="hljs-string">&#x27;.swiper-button-next&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-attr">prevEl</span>: <span class="hljs-string">&#x27;.swiper-button-prev&#x27;</span></span><br><span class="javascript">                &#125;</span><br><span class="javascript">            &#125;,</span><br><span class="javascript">            <span class="hljs-attr">slideList</span>: [ <span class="hljs-comment">//轮播图片数组</span></span><br><span class="javascript">                &#123;</span><br><span class="javascript">                   <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;42&#x27;</span>,</span><br><span class="javascript">                   <span class="hljs-attr">img</span>:<span class="hljs-string">&#x27;/imgs/slider/slide-1.jpg&#x27;</span>   </span><br><span class="javascript">                &#125;,</span><br><span class="javascript">                &#123;</span><br><span class="javascript">                   <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;45&#x27;</span>,</span><br><span class="javascript">                   <span class="hljs-attr">img</span>:<span class="hljs-string">&#x27;/imgs/slider/slide-2.jpg&#x27;</span>   </span><br><span class="javascript">                &#125;,</span><br><span class="javascript">                &#123;</span><br><span class="javascript">                   <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;46&#x27;</span>,</span><br><span class="javascript">                   <span class="hljs-attr">img</span>:<span class="hljs-string">&#x27;/imgs/slider/slide-3.jpg&#x27;</span>   </span><br><span class="javascript">                &#125;</span><br><span class="javascript">            ]</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!--省略样式代码--&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）首页轮播菜单实现"><a href="#（2）首页轮播菜单实现" class="headerlink" title="（2）首页轮播菜单实现"></a><span id="jump6">（2）首页轮播菜单实现</span></h4><p>关于实现一个3行4列的图片展示区域：（数据为已定义好的静态数据）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html">              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;children&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,i) in menuList&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(sub, j) in item&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;j&quot;</span>&gt;</span><br>                          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;sub?&#x27;/#/product/&#x27;+sub.id : &#x27;&#x27;&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;sub?sub.img:&#x27;/imgs/item-box-1.png&#x27;&quot;</span>&gt;</span><br>                            &#123;&#123;sub?sub.name:&#x27;小米9&#x27;&#125;&#125;<br>                          <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">menuList</span>: [</span><br><span class="javascript">          [</span><br><span class="javascript">              &#123;</span><br><span class="javascript">                  <span class="hljs-attr">id</span>:<span class="hljs-number">30</span>,</span><br><span class="javascript">                  <span class="hljs-attr">img</span>:<span class="hljs-string">&#x27;/imgs/item-box-1.png&#x27;</span>,</span><br><span class="javascript">                  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小米CC9&#x27;</span></span><br><span class="javascript">              &#125;,&#123;</span><br><span class="javascript">                   <span class="hljs-attr">id</span>:<span class="hljs-number">31</span>,</span><br><span class="javascript">                  <span class="hljs-attr">img</span>:<span class="hljs-string">&#x27;/imgs/item-box-2.png&#x27;</span>,</span><br><span class="javascript">                  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小米8青春版&#x27;</span>                 </span><br><span class="javascript">              &#125;,&#123;</span><br><span class="javascript">                    <span class="hljs-attr">id</span>:<span class="hljs-number">32</span>,</span><br><span class="javascript">                  <span class="hljs-attr">img</span>:<span class="hljs-string">&#x27;/imgs/item-box-3.jpg&#x27;</span>,</span><br><span class="javascript">                  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Redmi K20 Pro&#x27;</span>                  </span><br><span class="javascript">              &#125;,&#123;</span><br><span class="javascript">                <span class="hljs-attr">id</span>:<span class="hljs-number">33</span>,</span><br><span class="javascript">                  <span class="hljs-attr">img</span>:<span class="hljs-string">&#x27;/imgs/item-box-2.png&#x27;</span>,</span><br><span class="javascript">                  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;移动4G专区&#x27;</span> </span><br><span class="javascript">              &#125;</span><br><span class="javascript">              </span><br><span class="javascript">          ],</span><br><span class="javascript">          [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],</span><br><span class="javascript">          [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]</span><br><span class="javascript">      ]</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）Modal弹窗动画-与-父子组件通信"><a href="#（3）Modal弹窗动画-与-父子组件通信" class="headerlink" title="（3）Modal弹窗动画 与 父子组件通信"></a><span id="jump7">（3）Modal弹窗动画 与 父子组件通信</span></h4><ul><li>用到vue的transition组件，考虑到较多页面需要用到弹窗，所以将弹窗写成一个独立的组件，在Modal.vue中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--弹窗内容写在transition组件中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slide&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;showModal&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mask&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-dialog&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-header&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-close&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;cancel&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-body&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-footer&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;btnType==1&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;submit&#x27;)&quot;</span>&gt;</span>&#123;&#123;sureText&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;btnType==2&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;cancel&#x27;)&quot;</span>&gt;</span>&#123;&#123;cancelText&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn-group&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;btnType==3&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;submit&#x27;)&quot;</span>&gt;</span>&#123;&#123;sureText&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-default&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;cancel&#x27;)&quot;</span>&gt;</span>&#123;&#123;cancelText&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;modal&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">props</span>:&#123;</span><br><span class="javascript">      <span class="hljs-comment">// 弹框类型：小small、中middle、大large、表单form</span></span><br><span class="javascript">      <span class="hljs-attr">modalType</span>:&#123;</span><br><span class="javascript">        <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>,</span><br><span class="javascript">        <span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;form&#x27;</span></span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-comment">// 弹框标题</span></span><br><span class="javascript">      <span class="hljs-attr">title</span>:<span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-comment">// 按钮类型: 1:确定按钮 2：取消按钮 3：确定取消</span></span><br><span class="javascript">      <span class="hljs-attr">btnType</span>:<span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-attr">sureText</span>:&#123;</span><br><span class="javascript">        <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>,</span><br><span class="javascript">        <span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;确定&#x27;</span></span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-attr">cancelText</span>:&#123;</span><br><span class="javascript">        <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>,</span><br><span class="javascript">        <span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;取消&#x27;</span></span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-attr">showModal</span>:<span class="hljs-built_in">Boolean</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./../assets/scss/config.scss&#x27;</span>;</span><br><span class="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./../assets/scss/mixin.scss&#x27;</span>;</span><br><span class="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./../assets/scss/modal.scss&#x27;</span>;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在modal.scss中关于弹窗的动画：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-class">.modal</span>&#123;<br> <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">5s</span>;<br>     &amp;<span class="hljs-selector-class">.slide-enter-active</span>&#123;<br>         <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<br>     &#125;<br>     &amp;<span class="hljs-selector-class">.slide-leave-active</span>&#123;<br>         <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<br>     &#125;<br>     &amp;<span class="hljs-selector-class">.slide-enter</span>&#123;<br>         <span class="hljs-attribute">top</span>:-<span class="hljs-number">100%</span>;<br>     &#125;     <br>&#125;<br><span class="hljs-comment">/*其他样式省略*/</span><br></code></pre></td></tr></table></figure><ul><li>在index.vue页面中使用弹窗组件：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">modal</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;提示&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">sureText</span>=<span class="hljs-string">&quot;查看购物车&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">btnType</span>=<span class="hljs-string">&quot;1&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">modalType</span>=<span class="hljs-string">&quot;middle&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">v-bind:showModal</span>=<span class="hljs-string">&quot;showModal&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-on:submit</span>=<span class="hljs-string">&quot;goToCart&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-on:cancel</span>=<span class="hljs-string">&quot;showModal=false&quot;</span></span><br><span class="hljs-tag">      &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>商品添加成功！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modal</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> Modal <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../components/Modal&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;index&quot;</span>,</span><br><span class="javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">    Modal</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">          <span class="hljs-attr">showModal</span>: <span class="hljs-literal">false</span></span><br><span class="javascript">      &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">addCart</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.showModal = <span class="hljs-literal">true</span>;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">gotoCart</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/cart&#x27;</span>);</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;      </span><br><span class="javascript">  &#125;</span><br><span class="javascript">    </span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）懒加载"><a href="#（4）懒加载" class="headerlink" title="（4）懒加载"></a><span id="jump8">（4）懒加载</span></h4><ul><li>下载插件：</li></ul><p><code>npm i vue-lazyload -S</code></p><ul><li>在main.js里引入并配置：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> VueLazyLoad <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-lazyload&#x27;</span><br>Vue.use(VueLazyLoad, &#123;<br>  <span class="hljs-attr">loading</span>:<span class="hljs-string">&#x27;/imgs/loading-svg/loading-bars.svg&#x27;</span><span class="hljs-comment">//图片在加载过程的动画</span><br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>在index.vue中使用懒加载：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--没有懒加载的写法--&gt;</span>        <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><br><span class="hljs-tag">     <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;&#x27;/#/product/&#x27; + item.id&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in adsList&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;index&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;item.img&quot;</span> <span class="hljs-attr">alt</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/#/product/30&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&#x27;/imgs/banner-1.png&#x27;&quot;</span> <span class="hljs-attr">alt</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--使用懒加载的写法--&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;&#x27;/#/product/&#x27; + item.id&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in adsList&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;index&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-lazy</span>=<span class="hljs-string">&quot;item.img&quot;</span> <span class="hljs-attr">alt</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/#/product/30&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-lazy</span>=<span class="hljs-string">&quot;&#x27;/imgs/banner-1.png&#x27;&quot;</span> <span class="hljs-attr">alt</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 常见的链表操作</title>
    <link href="/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%20%E5%B8%B8%E8%A7%81%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS%20%E5%B8%B8%E8%A7%81%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-常见的链表操作"><a href="#JS-常见的链表操作" class="headerlink" title="JS 常见的链表操作"></a>JS 常见的链表操作</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h4 id="1-单链表反转"><a href="#1-单链表反转" class="headerlink" title="1. 单链表反转"></a>1.<a href="#jumpa"> <strong>单链表反转</strong></a></h4><h4 id="2-链表中环的检测-相关问题"><a href="#2-链表中环的检测-相关问题" class="headerlink" title="2. 链表中环的检测 相关问题"></a>2.<a href="#jumpb"> <strong>链表中环的检测 相关问题</strong></a></h4><ul><li><a href="#jump1"><strong>判断是否有环</strong></a></li><li><a href="#jump2"><strong>找出环的入口点</strong></a></li><li><a href="#jump3"><strong>找出环上结点的个数</strong></a></li><li><a href="#jump4"><strong>求出链表的长度</strong></a></li><li><a href="#jump5"><strong>求出环上距离任意一个结点最远的结点</strong></a></li><li><a href="#jump6"><strong>求出链表的长度</strong></a></li><li><a href="#jump7"><strong>如果相交，求出第一个相交结点。</strong></a></li></ul><h4 id="3-两个有序的链表合并"><a href="#3-两个有序的链表合并" class="headerlink" title="3. 两个有序的链表合并"></a>3. <a href="#jumpc"><strong>两个有序的链表合并</strong></a></h4><h4 id="4-删除链表倒数第-n-个结点"><a href="#4-删除链表倒数第-n-个结点" class="headerlink" title="4. 删除链表倒数第 n 个结点"></a>4. <a href="#jumpd"><strong>删除链表倒数第 n 个结点</strong></a></h4><h4 id="5-求链表的中间结点"><a href="#5-求链表的中间结点" class="headerlink" title="5. 求链表的中间结点"></a>5.<a href="#jumpe"> <strong>求链表的中间结点</strong></a></h4><h2 id="1-单链表反转-1"><a href="#1-单链表反转-1" class="headerlink" title="1. 单链表反转"></a><span id="jumpa">1. 单链表反转</span></h2><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断对象是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmptyObject</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseList</span>(<span class="hljs-params">pHead</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (isEmptyObject(pHead)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> pre = pHead;<br>    <span class="hljs-keyword">var</span> PreNext = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (pre.next != <span class="hljs-literal">null</span>) &#123;<br>        preNext = pre.next;<br>        pre.next = preNext.next;<br>        preNext.next = pHead;<br>        pHead = preNext;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pHead;<br>&#125;<br></code></pre></td></tr></table></figure><p>反转链表的思路：1-2-3-4-5，先将2换到第一个，变为：2-1-3-4-5。然后将3换到第一个，3-2-1-4-5。<br>以此类推。其中，pre始终指向1，preNext指向pre的下一个，即本轮需要换到第一个的数。<br>如此列表：<br>1-2-3-4-5<br>2-1-3-4-5<br>3-2-1-4-5<br>4-3-2-1-5<br>5-4-3-2-1</p><h2 id="2-链表中环的检测-相关问题-1"><a href="#2-链表中环的检测-相关问题-1" class="headerlink" title="2. 链表中环的检测 相关问题"></a><span id="jumpb">2. 链表中环的检测 相关问题</span></h2><p>关于链表中环的检测，相关问题一般有如下几种：</p><ul><li>给定一个单链表，判断其中是否有环的存在</li><li>如果存在环，找.出环的入口点</li><li>如果存在环，找出环上结点的个数</li><li>如果存在环，求出链表的长度</li><li>如果存在环，求出环上距离任意一个结点最远的结点（环的对面结点问题）</li><li>判断两个无环链表是否相交</li><li>如果相交，求出第一个相交结点</li></ul><p>针对如上七种问题，下面逐一进行分析并写出相应实现代码。</p><h4 id="（1）判断是否有环"><a href="#（1）判断是否有环" class="headerlink" title="（1）判断是否有环"></a><span id="jump1">（1）判断是否有环</span></h4><p><strong>问题分析：</strong></p><p>对于这个问题，有一种非常巧妙的“快慢指针”的方法，就是定义两个指针：fast和slow，最初的时候fast和slow都指向链表的初始结点head，然后每一次操作，fast向前走两步，slow向前走一步。<br>因为fast比slow移动快，如果有环，那么fast一定会先进入环，而slow后进入环。当两个指针都进入环后，经过一定次数的操作，fast和slow最终会在环上相遇，并且一定是在slow绕环走完一圈之前相遇。</p><p><img src="https://img-blog.csdnimg.cn/20200323205459293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tFNpgL9b-1584968051925)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584887806278.png)]"></p><p>如图所示，slow进入环时，fast可能处于图示状态，然后每次操作，slow会向前走一步，而fast会向前追两步。因此每次操作完fast到slow的距离都会缩短一步，5、4、3、2、1…直到相遇。<br>又因为同一个环中，slow和fast的距离不可能大于环的总长度，所以fast和slow一定会在slow走完一圈之前相遇。<br>特殊情况：开始时，slow和fast就在环的入口处，这样相遇时，slow刚好走完一圈。</p><p><strong>实现代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isExitLoop</span>(<span class="hljs-params">head</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.next === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> slow = head;<br>    <span class="hljs-keyword">let</span> fast = head;<br>    <span class="hljs-keyword">while</span> (slow !== <span class="hljs-literal">null</span> &amp;&amp; fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）找出环的入口点"><a href="#（2）找出环的入口点" class="headerlink" title="（2）找出环的入口点"></a><span id="jump2">（2）找出环的入口点</span></h4><p><img src="https://img-blog.csdnimg.cn/20200323205516504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aejQ4UX5-1584968051935)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584888602980.png)]"></p><p><strong>问题分析：</strong></p><p>如果链表有环，则在slow绕环走完一圈之前，一定会和fast相遇。<br>我们假设相遇时slow走了s个结点，则fast走了2s个结点。<br>设环的长度为r，相遇时fast已绕环走了 n 圈(n&gt;=1)，可得等式：<br>2s = s + n <em>r 简化得 =&gt; s = n</em> r<br>又设head与环的入口点距离为 a ，入口点与相遇点的距离为 x ，根据slow的总路径为s可得：<br>s = a + x<br>结合上式：a + x = n <em>r 变形 =&gt; a + x = ( n - 1 )</em> r + r<br>设链表总长度为L，则：r = L - a ，带入上式，得：a = ( n - 1 ) * r + ( L - a - x )<br>好了，注意看图，L - a - x 的长度就是从相遇点到环入口点的长度，也就是说，如果我们放置两个指针p1和p2，分别从起始点和相遇点出发，那么在p2绕环 ( n - 1 ) 圈后，最终一定会在环的入口点和p1相遇。<br>这样，我们就得到了环的入口点。</p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLoopPort</span>(<span class="hljs-params">head</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.next === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> show = head;<br>    <span class="hljs-keyword">let</span> fast = head;<br>    <span class="hljs-comment">//找到相遇点</span><br>    <span class="hljs-keyword">while</span> (slow !== <span class="hljs-literal">null</span> &amp;&amp; fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>        <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    slow = head;<span class="hljs-comment">//slow指向开头，fast指在相遇点</span><br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）找出环上结点的个数"><a href="#（3）找出环上结点的个数" class="headerlink" title="（3）找出环上结点的个数"></a><span id="jump3">（3）找出环上结点的个数</span></h4><p><strong>问题分析：</strong></p><p>对于这个问题，有两种常见的解决方法：</p><ul><li>在slow和fast相遇后，让其中一个继续向前走，下次相遇时，所经过的结点，就是环上的结点个数。</li><li>在slow和fast相遇后，让slow和fast同时继续向前走，下次相遇时，所经过的结点，就是环上的结点个数。</li></ul><p>稍微解释一下第二种方法，因为slow和fast的速度不同，同时出发后，两指针最大距离为环的总长度r，然后每次操作距离都会缩短一位，最终一定会再次相遇。再次相遇时，正好操作r次，也正好经过r个结点。</p><p><strong>方法1实现代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLoopPort</span>(<span class="hljs-params">head</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.next === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> show = head;<br>    <span class="hljs-keyword">let</span> fast = head;<br>    <span class="hljs-comment">//找到相遇点</span><br>    <span class="hljs-keyword">while</span> (slow !== <span class="hljs-literal">null</span> &amp;&amp; fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>        <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(slow != fast) &#123;<br>        count ++;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）求出链表的长度"><a href="#（4）求出链表的长度" class="headerlink" title="（4）求出链表的长度"></a><span id="jump4">（4）求出链表的长度</span></h4><p><strong>问题分析：</strong></p><p>链表长度L = 起点到入口点的距离 + 环的长度r ;<br>在前面的基础上，我们可以很轻松的得到这个题目的解。</p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLoopPort</span>(<span class="hljs-params">head</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.next === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> fasle;<br>&#125;<br><span class="hljs-keyword">let</span> slow = head;<br><span class="hljs-keyword">let</span> fast = head;<br><span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>slow = slow.next;<br>fast = fast.next.next;<br><span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> len = <span class="hljs-number">1</span>; <span class="hljs-comment">//放环的长度</span><br><span class="hljs-keyword">let</span> temp = fast;<span class="hljs-comment">//暂时存放相遇点</span><br><span class="hljs-comment">//下面先求出起点到入口点的距离</span><br>slow = head; <br><span class="hljs-keyword">while</span>(slow != fast) &#123;<br>len ++;<br>slow = slow.next;<br>fast = fast.next.next;<br>&#125;<br><span class="hljs-comment">//下面在求完起点到入口点的距离的基础上，加上环的长度，等于链表长度</span><br>slow = temp;<br>fast = temp;<br><span class="hljs-keyword">while</span>(slow != fast) &#123;<br>len ++;<br>slow = slow.next;<br>&#125;<br><span class="hljs-keyword">return</span> len;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）求出环上距离任意一个结点最远的结点（环的对面结点问题）"><a href="#（5）求出环上距离任意一个结点最远的结点（环的对面结点问题）" class="headerlink" title="（5）求出环上距离任意一个结点最远的结点（环的对面结点问题）"></a><span id="jump5">（5）求出环上距离任意一个结点最远的结点（环的对面结点问题）</span></h4><p><strong>问题分析：</strong></p><p>如图所示，结点1和结点4，结点2和结点5，结点3和结点6分别互为“对面结点”，也就是环上距离最远的结点。<br>我们依然可以使用“快慢指针”的思想来解决这道题，定义一个每次移动两个结点的指针fast和每次移动一个结点的指针slow，两指针同时在问题结点出发，当fast或者fast-&gt;next再次回到问题结点时，slow所指向的结点就是问题结点的“对面结点”。</p><p><img src="https://img-blog.csdnimg.cn/20200323205600806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LTN90Rzb-1584968051941)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584889823245.png)]"></p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFacePort</span>(<span class="hljs-params">prt</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> slow = prt;<br>    <span class="hljs-keyword">let</span> fast = prt;<br>    <span class="hljs-keyword">do</span> &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125; <span class="hljs-keyword">while</span>(fast != prt &amp;&amp; fast != prt.next);<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）判断两个无环链表是否相交"><a href="#（6）判断两个无环链表是否相交" class="headerlink" title="（6）判断两个无环链表是否相交"></a><span id="jump6">（6）判断两个无环链表是否相交</span></h4><p><strong>问题分析：</strong></p><p>对于判断两个无环链表是否相交类的问题，看起来无从下手，但其实只需要转换一下思路就豁然开朗了。</p><p><img src="https://img-blog.csdnimg.cn/20200323205617566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JzxKm1cP-1584968051947)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584889861120.png)]"></p><p>如图所示，存在ListA和ListB两个无环相交链表，我们只需要将ListA的首尾相连，这样就变成我们熟悉的判断是否有环的问题了。</p><p><img src="https://img-blog.csdnimg.cn/20200323205631916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-45puncNi-1584968051954)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584889876496.png)]"></p><h4 id="7-如果相交，求出第一个相交结点。"><a href="#7-如果相交，求出第一个相交结点。" class="headerlink" title="(7)如果相交，求出第一个相交结点。"></a><span id="jump7">(7)如果相交，求出第一个相交结点。</span></h4><p>同理，可转化为求环的相交点的问题。</p><p><strong>学习参考于：</strong></p><p><a href="http://www.chinacion.cn/article/4598.html">链表专项练习题二 | 链表中环的检测 相关问题总结</a></p><h2 id="3-两个有序的链表合并-1"><a href="#3-两个有序的链表合并-1" class="headerlink" title="3. 两个有序的链表合并"></a><span id="jumpc">3. 两个有序的链表合并</span></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>() </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> mergeLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list1, list2</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> list3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">var</span> c = list3;<br>    <span class="hljs-keyword">while</span>(list1 !== <span class="hljs-literal">null</span> &amp;&amp; list2 !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;<br>            c.next = list1;<br>            list1 = list1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            c.next= list2;<br>            list2 = list2.next;<br>        &#125;<br>        c = c.next;<br>    &#125;<br>    c.next = (list1 == <span class="hljs-literal">null</span>) ? list2 : list1;<br>    <span class="hljs-keyword">return</span> list3.next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-删除链表倒数第-n-个结点-1"><a href="#4-删除链表倒数第-n-个结点-1" class="headerlink" title="4. 删除链表倒数第 n 个结点"></a><span id="jump4">4. 删除链表倒数第 n 个结点</span></h2><p>这道题要用双指针来实现。先用first指针前进n，然后让second从head开始和first一起前进，直到first到了末尾，此时second的下一个节点就是要删除的节点。（另外，若first一开始前进n就已经不在链表中了，说明要删除的节点正是head节点，那么直接返回head的下一个节点接口。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNode</span>(<span class="hljs-params">head, n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head || k &lt;=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> first = head;<br>    <span class="hljs-keyword">let</span> second = head;<br>    <span class="hljs-keyword">while</span>(--k) &#123;<br>        <span class="hljs-keyword">if</span>(first.next != <span class="hljs-literal">null</span>) first = first.next;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(first.next != <span class="hljs-literal">null</span>)&#123;<br>        first = first.next;<br>        second = second.next;<br>    &#125;<br>    second.next = second.next.next;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-求链表的中间结点-1"><a href="#5-求链表的中间结点-1" class="headerlink" title="5. 求链表的中间结点"></a><span id="jump5">5. 求链表的中间结点</span></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> middleNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> fast = head,<br>        slow = head;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast.next) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据结构与算法之美》学习笔记(3) 数据结构</title>
    <link href="/2020/03/22/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/03/22/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h4 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h4><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>这个定义里有几个关键词。</p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584881336544.png" alt="1584881336544"></p><p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584881391322.png" alt="1584881391322"></p><p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用。</p><p>三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。</p><h3 id="（1）单链表"><a href="#（1）单链表" class="headerlink" title="（1）单链表"></a>（1）单链表</h3><p>首先来看最简单、最常用的<strong>单链表</strong>。</p><p>每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584882913719.png" alt="1584882913719"></p><p>把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p><p>针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p><h3 id="（2）循环链表"><a href="#（2）循环链表" class="headerlink" title="（2）循环链表"></a>（2）循环链表</h3><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。</p><p>单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584884713397.png" alt="1584884713397"></p><p>和单链表相比，<strong>循环链表</strong>的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</p><h3 id="（3）双向链表"><a href="#（3）双向链表" class="headerlink" title="（3）双向链表"></a>（3）双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584884820589.png" alt="1584884820589"></p><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p><p><strong>相比单链表，双向链表适合解决哪种问题呢？</strong></p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>而单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？</p><p>先来看<strong>删除操作</strong>。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li>删除结点中“值等于某个给定值”的结点；</li><li>删除给定指针指向的结点。</li></ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过指针操作将其删除。</p><p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><p>对于第二种情况，已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p><p>同理，如果希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><h3 id="（4）双向循环链表"><a href="#（4）双向循环链表" class="headerlink" title="（4）双向循环链表"></a>（4）双向循环链表</h3><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584885146988.png" alt="1584885146988"></p><h3 id="（5）链表-VS-数组性能大比拼"><a href="#（5）链表-VS-数组性能大比拼" class="headerlink" title="（5）链表 VS 数组性能大比拼"></a>（5）链表 VS 数组性能大比拼</h3><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584885188020.png" alt="1584885188020"></p><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h3 id="（1）相关概念"><a href="#（1）相关概念" class="headerlink" title="（1）相关概念"></a>（1）相关概念</h3><p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，应该首选“栈”这种数据结构</strong>。</p><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。</p><p>不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</p><h3 id="（2）栈的应用"><a href="#（2）栈的应用" class="headerlink" title="（2）栈的应用"></a>（2）栈的应用</h3><ul><li><p><strong>栈在函数调用中的应用</strong></p><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p></li><li><p><strong>栈在表达式求值中的应用</strong></p></li><li><p><strong>栈在括号匹配中的应用</strong></p></li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>先进者先出，这就是典型的“队列”</strong>。</p><p>栈只支持两个基本操作：**入栈 push()和出栈 pop()<strong>。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：</strong>入队 enqueue()<strong>，放一个数据到队列尾部；</strong>出队 dequeue()**，从队列头部取一个元素。</p><p>队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p><h3 id="（1）顺序队列和链式队列"><a href="#（1）顺序队列和链式队列" class="headerlink" title="（1）顺序队列和链式队列"></a>（1）顺序队列和链式队列</h3><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><p><strong>顺序队列：</strong></p><p>队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p><p>结合下面这幅图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584969788718.png" alt="1584969788718"></p><p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584969807141.png" alt="1584969807141"></p><p>随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。</p><p><strong>链式队列：</strong></p><p>同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584970108932.png" alt="1584970108932"></p><h3 id="（2）循环队列"><a href="#（2）循环队列" class="headerlink" title="（2）循环队列"></a>（2）循环队列</h3><p>刚才用数组来实现队列的时候，在 tail==n 时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？我们来看看循环队列的解决思路。</p><p>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584970158563.png" alt="1584970158563"></p><p>图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584970306742.png" alt="1584970306742"></p><p>通过这样的方法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有 bug 的循环队列的实现代码，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p><p>在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。那针对循环队列，如何判断队空和队满呢？</p><p>队列为空的判断条件仍然是 head == tail。</p><p>但队列满的判断条件就稍微有点复杂了。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584970380335.png" alt="1584970380335"></p><p>图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。</p><p>当队满时，**(tail+1)%n=head**。</p><p>图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p>]]></content>
    
    
    <categories>
      
      <category>《数据结构与算法之美》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据结构与算法之美》学习笔记(2) 复杂度分析</title>
    <link href="/2020/03/22/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <url>/2020/03/22/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="一-如何分析、统计算法的执行效率和资源消耗？"><a href="#一-如何分析、统计算法的执行效率和资源消耗？" class="headerlink" title="一. 如何分析、统计算法的执行效率和资源消耗？"></a>一. 如何分析、统计算法的执行效率和资源消耗？</h2><h3 id="（1）大-O-复杂度表示法"><a href="#（1）大-O-复杂度表示法" class="headerlink" title="（1）大 O 复杂度表示法"></a>（1）大 O 复杂度表示法</h3><p>先看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js">int <span class="hljs-function"><span class="hljs-title">cal</span>(<span class="hljs-params">int n</span>)</span> &#123;<br>  int sum = <span class="hljs-number">0</span>;<br>  int i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt;= n; ++i) &#123;<br>    sum = sum + i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据</strong>-<strong>运算</strong>-<strong>写数据</strong>。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？</p><p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p><p>再来一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">int <span class="hljs-function"><span class="hljs-title">cal</span>(<span class="hljs-params">int n</span>)</span> &#123;<br>   int sum = <span class="hljs-number">0</span>;<br>   int i = <span class="hljs-number">1</span>;<br>   int j = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; i &lt;= n; ++i) &#123;<br>     j = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">for</span> (; j &lt;= n; ++j) &#123;<br>       sum = sum +  i * j;<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>我们依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？</p><p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，第 7、8 行代码循环执行了 n2遍，所以需要 2n2 * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n2+2n+3)*unit_time。</p><p>尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>。</p><p>我们可以把这个规律总结成一个公式。注意，大 O 就要登场了！</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584795111383.png" alt="1584795111383"></p><p>其中，T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p>所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。</p><p><strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p><h3 id="（2）时间复杂度分析"><a href="#（2）时间复杂度分析" class="headerlink" title="（2）时间复杂度分析"></a>（2）时间复杂度分析</h3><p>三个比较实用的方法：</p><ul><li><p><strong>只关注循环执行次数最多的一段代码</strong></p><p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p></li><li><p> <strong>加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p></li></ul><p>  一段代码：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">int <span class="hljs-function"><span class="hljs-title">cal</span>(<span class="hljs-params">int n</span>)</span> &#123;<br>   int sum_1 = <span class="hljs-number">0</span>;<br>   int p = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; p &lt; <span class="hljs-number">100</span>; ++p) &#123;<br>     sum_1 = sum_1 + p;<br>   &#125;<br> <br>   int sum_2 = <span class="hljs-number">0</span>;<br>   int q = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; q &lt; n; ++q) &#123;<br>     sum_2 = sum_2 + q;<br>   &#125;<br> <br>   int sum_3 = <span class="hljs-number">0</span>;<br>   int i = <span class="hljs-number">1</span>;<br>   int j = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; i &lt;= n; ++i) &#123;<br>     j = <span class="hljs-number">1</span>; <br>     <span class="hljs-keyword">for</span> (; j &lt;= n; ++j) &#123;<br>       sum_3 = sum_3 +  i * j;<br>     &#125;<br>   &#125;<br> <br>   <span class="hljs-keyword">return</span> sum_1 + sum_2 + sum_3;<br> &#125;<br></code></pre></td></tr></table></figure><p>  这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p><p>  第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。</p><p>  那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n2)。</p><p>  综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：<strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong>。</p><p>  那我们将这个规律抽象成公式就是：</p><p>  如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p><ul><li><p><strong>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p><p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">int <span class="hljs-function"><span class="hljs-title">cal</span>(<span class="hljs-params">int n</span>)</span> &#123;<br>   int ret = <span class="hljs-number">0</span>; <br>   int i = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>     ret = ret + f(i);<br>   &#125; <br> &#125; <br> <br> int <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-params">int n</span>)</span> &#123;<br>  int sum = <span class="hljs-number">0</span>;<br>  int i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    sum = sum + i;<br>  &#125; <br>  <span class="hljs-keyword">return</span> sum;<br> &#125;<br></code></pre></td></tr></table></figure><p>我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。</p></li></ul><h3 id="（3）几种常见时间复杂度实例分析"><a href="#（3）几种常见时间复杂度实例分析" class="headerlink" title="（3）几种常见时间复杂度实例分析"></a>（3）几种常见时间复杂度实例分析</h3><p>这些复杂度量级几乎涵盖了今后可以接触的所有代码的复杂度量级：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584796207706.png" alt="1584796207706"></p><p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p><p>几种常见的<strong>多项式时间复杂度</strong>：</p><ul><li> <strong>O(1)</strong></li></ul><p>  O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">int i = <span class="hljs-number">8</span>;<br>int j = <span class="hljs-number">6</span>;<br>int sum = i + j;<br></code></pre></td></tr></table></figure><p>  只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。</p><ul><li><p><strong>O(logn)、O(nlogn)</strong></p><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。通过一个例子来说明一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= n)  &#123;<br>  i = i * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584796633913.png" alt="1584796633913"></p><p>我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。</p><p>现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">i=<span class="hljs-number">1</span>;<br> <span class="hljs-keyword">while</span> (i &lt;= n)  &#123;<br>   i = i * <span class="hljs-number">3</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。</p><p><strong>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。</strong>为什么呢？</p><p>我们知道，对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))**。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><p>而如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p></li><li><p><strong>O(m+n)、O(m*n)</strong></p><p>再来讲一种跟前面都不一样的时间复杂度，代码的复杂度<strong>由两个数据的规模</strong>来决定。</p><p>先看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">int <span class="hljs-function"><span class="hljs-title">cal</span>(<span class="hljs-params">int m, int n</span>)</span> &#123;<br>  int sum_1 = <span class="hljs-number">0</span>;<br>  int i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; m; ++i) &#123;<br>    sum_1 = sum_1 + i;<br>  &#125;<br> <br>  int sum_2 = <span class="hljs-number">0</span>;<br>  int j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; j &lt; n; ++j) &#123;<br>    sum_2 = sum_2 + j;<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。</p></li></ul><h3 id="（4）空间复杂度分析"><a href="#（4）空间复杂度分析" class="headerlink" title="（4）空间复杂度分析"></a>（4）空间复杂度分析</h3><p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。</p><p>类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p><p>具体的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params">int n</span>)</span> &#123;<br>  int i = <span class="hljs-number">0</span>;<br>  int[] a = <span class="hljs-keyword">new</span> int[n];<br>  <span class="hljs-keyword">for</span> (i; i &lt;n; ++i) &#123;<br>    a[i] = i * i;<br>  &#125;<br> <br>  <span class="hljs-keyword">for</span> (i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    print out a[i]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟时间复杂度分析一样，可以看到，第 2 行代码中，申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p><p>常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。</p><h3 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584798079398.png" alt="1584798079398"></p><h2 id="二-浅析最好、最坏、平均、均摊时间复杂度"><a href="#二-浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="二. 浅析最好、最坏、平均、均摊时间复杂度"></a>二. 浅析最好、最坏、平均、均摊时间复杂度</h2><h3 id="（1）最好、最坏情况时间复杂度"><a href="#（1）最好、最坏情况时间复杂度" class="headerlink" title="（1）最好、最坏情况时间复杂度"></a>（1）最好、最坏情况时间复杂度</h3><p>来看一个稍微复杂的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// n 表示数组 array 的长度</span><br>int <span class="hljs-function"><span class="hljs-title">find</span>(<span class="hljs-params">int[] array, int n, int x</span>)</span> &#123;<br>  int i = <span class="hljs-number">0</span>;<br>  int pos = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (array[i] == x) pos = i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。按照上节课讲的分析方法，这段代码的复杂度是 O(n)，其中，n 代表数组的长度。</p><p>在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。可以这样优化一下这段查找代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// n 表示数组 array 的长度</span><br>int <span class="hljs-function"><span class="hljs-title">find</span>(<span class="hljs-params">int[] array, int n, int x</span>)</span> &#123;<br>  int i = <span class="hljs-number">0</span>;<br>  int pos = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (array[i] == x) &#123;<br>       pos = i;<br>       <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，问题就来了。优化完之后，这段代码的时间复杂度还是 O(n) 吗？很显然，咱们上一节讲的分析方法，解决不了这个问题。</p><p>因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p><p>为了表示代码在不同情况下的不同时间复杂度，需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。</p><p><strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</strong>。</p><p><strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</strong>。</p><h3 id="（2）平均情况时间复杂度"><a href="#（2）平均情况时间复杂度" class="headerlink" title="（2）平均情况时间复杂度"></a>（2）平均情况时间复杂度</h3><p>最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，需要引入另一个概念：平均情况时间复杂度，后面简称为平均时间复杂度。</p><p>要查找的变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0～n-1 位置中</strong>和<strong>不在数组中</strong>。把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584798623659.png" alt="1584798623659"></p><p>时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p><p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？刚讲的这 n+1 种情况，出现的概率并不是一样的。</p><p>要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p><p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584798729222.png" alt="1584798729222"></p><p>这个值就是概率论中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p><p>实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。</p><h3 id="（3）均摊时间复杂度"><a href="#（3）均摊时间复杂度" class="headerlink" title="（3）均摊时间复杂度"></a>（3）均摊时间复杂度</h3><p>大部分情况下，并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p><p>具体例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// array 表示一个长度为 n 的数组</span><br><span class="hljs-comment">// 代码中的 array.length 就等于 n</span><br>int[] array = <span class="hljs-keyword">new</span> int[n];<br>int count = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">int val</span>)</span> &#123;<br>   <span class="hljs-keyword">if</span> (count == array.length) &#123;<br>      int sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; array.length; ++i) &#123;<br>         sum = sum + array[i];<br>      &#125;<br>      array[<span class="hljs-number">0</span>] = sum;<br>      count = <span class="hljs-number">1</span>;<br>   &#125;<br><br>   array[count] = val;<br>   ++count;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p><p>先用我们刚讲到的三种时间复杂度的分析方法来分析一下：</p><ul><li><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。</p></li><li><p>最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p></li><li><p>那平均时间复杂度是多少呢？答案是 O(1)。还是可以通过前面讲的概率论的方法来分析。</p><p>假设数组的长度是 n，根据数据插入的位置的不同，可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584799159650.png" alt="1584799159650"></p></li></ul><p>先来对比一下这个 insert() 的例子和前面那个 find() 的例子，就会发现这两者有很大差别。</p><p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()<strong>第一个</strong>区别于 find() 的地方。</p><p>对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p><p>所以，针对这样一种特殊场景的复杂度分析，并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p><p>针对这种特殊的场景，引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度起了一个名字，叫<strong>均摊时间复杂度</strong>。</p><p>那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p><p>继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，所以并不会经常用到。为了方便理解、记忆，这里简单总结一下它们的应用场景。如果遇到了，知道是怎么回事儿就行了。</p><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>《数据结构与算法之美》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据结构与算法之美》学习笔记(1)</title>
    <link href="/2020/03/22/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2020/03/22/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么学习数据结构与算法？"><a href="#为什么学习数据结构与算法？" class="headerlink" title="为什么学习数据结构与算法？"></a>为什么学习数据结构与算法？</h3><ul><li><p>直接的好处是能够写出性能更优的代码。</p></li><li><p>算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面。</p></li><li><p>数据结构与算法，能有效训练大脑思考能力，使我们看待问题的深度，解决问题的角度就会完全不一样。提升个人的核心竞争力。</p></li></ul><h3 id="什么是数据结构？什么是算法？"><a href="#什么是数据结构？什么是算法？" class="headerlink" title="什么是数据结构？什么是算法？"></a>什么是数据结构？什么是算法？</h3><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p><p>从狭义上讲，也就是《数据结构与算法之美》这个专栏要讲的，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。我们要讲的这些经典数据结构和算法，都是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。</p><p>数据结构和算法是相辅相成的。<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</strong></p><h3 id="学习的重点在什么地方？"><a href="#学习的重点在什么地方？" class="headerlink" title="学习的重点在什么地方？"></a>学习的重点在什么地方？</h3><p><strong>首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。</strong></p><p>它是数据结构和算法学习的精髓。数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。</p><p>搞定复杂度分析，就要进入<strong>数据结构与算法的正文内容</strong>了。</p><p>下图，里面几乎涵盖了所有数据结构和算法书籍中都会讲到的知识点。</p><p><img src="C:\Users\lin\Desktop\1.png"></p><p>作为初学者，或者一个非算法工程师来说，并不需要掌握图里面的所有知识点。</p><p><strong>20 个最常用的、最基础</strong>数据结构与算法：</p><p>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；</p><p>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p><h3 id="学习技巧："><a href="#学习技巧：" class="headerlink" title="学习技巧："></a>学习技巧：</h3><ul><li>边学边练，适度刷题</li><li>多问、多思考、多互动</li><li>打怪升级学习法</li><li>知识需要沉淀，不要想试图一下子掌握所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>《数据结构与算法之美》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock设置</title>
    <link href="/2020/03/22/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/Mock%E8%AE%BE%E7%BD%AE/"/>
    <url>/2020/03/22/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/Mock%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Mock设置"><a href="#Mock设置" class="headerlink" title="Mock设置"></a>Mock设置</h1><p><strong>作用：</strong></p><ul><li>开发阶段，为了高效率，需要提前Mock</li><li>减少代码冗余，灵活插拔</li><li>减少沟通，减少接口联调时间</li></ul><h4 id="mock设置三种方式："><a href="#mock设置三种方式：" class="headerlink" title="mock设置三种方式："></a>mock设置三种方式：</h4><ul><li>本地创建json</li><li>集成Mock API</li><li>easy-mock平台</li></ul><p><strong>（1）本地加载请求静态json文件</strong>：</p><ul><li>在public下创建文件夹mock，mock里创建文件夹user,user里添加文件login.json:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;status&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>        <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,<br>        <span class="hljs-attr">&quot;phone&quot;</span>: <span class="hljs-literal">null</span>,<br>        <span class="hljs-attr">&quot;role&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">&quot;createTime&quot;</span>: <span class="hljs-number">123</span>,<br>        <span class="hljs-attr">&quot;updataTime&quot;</span>:<span class="hljs-number">456</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在App.vue中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <br>      <span class="hljs-attr">res</span>: &#123;&#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/mock/user/login.json&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>     <span class="hljs-built_in">this</span>.res = res<br>   &#125;) <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在main.js中将以下注释掉内容：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//import env from &#x27;./env&#x27;</span><br><span class="hljs-comment">//axios.defaults.baseURL = &#x27;/api&#x27;;</span><br><span class="hljs-comment">//axios.default.baseURL = env.baseURL;</span><br></code></pre></td></tr></table></figure><p>这种方式虽然简单，但是请求的地址并不是真正的地址，但接口联调对接时，就需要改代码。</p><p><strong>（2）本地集成mock.js实现数据mock：</strong></p><ul><li>先安装mock.js</li></ul><p><code>npm i mockjs --save-dev</code></p><ul><li>安装完，在main.js中加入:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//mock开关</span><br><span class="hljs-keyword">const</span> mock = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (mock) &#123;<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./mock/api&#x27;</span>)<br>&#125;<br>axios.defaults.baseURL = <span class="hljs-string">&#x27;/api&#x27;</span>;<br><br></code></pre></td></tr></table></figure><ul><li>在src文件夹建一个mock文件夹，在改文件夹中新建api.js文件：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Mock <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mockjs&#x27;</span><br>Mock.mock(<span class="hljs-string">&#x27;/api/user/login&#x27;</span>, &#123;<br>    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>        <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,<br>        <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-literal">null</span>,<br>        <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;createTime&quot;</span>: <span class="hljs-number">123</span>,<br>        <span class="hljs-string">&quot;updataTime&quot;</span>:<span class="hljs-number">456</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>在App.vue中，修改：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <br>      <span class="hljs-attr">res</span>: &#123;&#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;/user/login&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>     <span class="hljs-built_in">this</span>.res = res<br>   &#125;) <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）easy-mock平台</strong></p><ul><li><p>在Easy Mock官网上创建好项目。（创建过程中将 项目基础URL可随便取）</p></li><li><p>在main.js中修改：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//mock开关</span><br><span class="hljs-keyword">const</span> mock = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (mock) &#123;<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./mock/api&#x27;</span>)<br>&#125;<br>axios.defaults.baseURL = <span class="hljs-string">&#x27;...为Easy Mock上生成的base URL地址&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>在Easy Mock官网创建接口，URL和数据都设置为自己需要的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口错误拦截与环境设置</title>
    <link href="/2020/03/22/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E6%8E%A5%E5%8F%A3%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA%E4%B8%8E%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
    <url>/2020/03/22/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E6%8E%A5%E5%8F%A3%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA%E4%B8%8E%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="（一）接口错误拦截"><a href="#（一）接口错误拦截" class="headerlink" title="（一）接口错误拦截"></a>（一）接口错误拦截</h1><p><strong>使用场景</strong>：</p><ul><li>统一报错</li><li>未登录拦截</li><li>请求值、返回值统一处理</li></ul><p><strong>使用axios插件进行拦截:</strong></p><ul><li><p>安装axios</p><p><code>npm i axios --save-dev</code></p></li><li><p>在main.js文件中加入：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> VueAxios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-axios&#x27;</span><br><br>axios.defaults.baseURL = <span class="hljs-string">&#x27;/api&#x27;</span>;  <br>axios.defaults.timeout = <span class="hljs-number">8000</span>;<br><span class="hljs-comment">//接口错误拦截  </span><br><span class="hljs-comment">//其中：第一个参数是拦截业务（接口错误）异常（前提是http状态码是200）的函数，第二个参数拦截http状态码异常的函数。</span><br>axios.interceptors.response.use(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> res = response.data;<span class="hljs-comment">//这个response不是接口返回，而是axios封装给我们的。response.data才是接口返回值。</span><br>  <span class="hljs-keyword">let</span> path = location.hash;<br>  <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.data;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.status == <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">if</span> (path != <span class="hljs-string">&#x27;#/index&#x27;</span>) &#123;<br>        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&#x27;/#/login&#x27;</span>;<br>        <br>      &#125; <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(res);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    Message.warning(res.msg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(res);<br>  &#125;<br>&#125;, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> res = error.response;<br>    Message.warning(res.data.message);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>&#125;);<br>Vue.use(VueAxios, axios);<br></code></pre></td></tr></table></figure><h2 id="（二）接口环境设置"><a href="#（二）接口环境设置" class="headerlink" title="（二）接口环境设置"></a>（二）接口环境设置</h2><p><strong>场景：</strong></p><ul><li>开发上线的不同阶段，需要不同的配置</li><li>不同跨域方式，配置不同</li><li>打包的时候统一注入环境参数</li></ul><h4 id="1-跨域方式为JSONP-CORS-时："><a href="#1-跨域方式为JSONP-CORS-时：" class="headerlink" title="1. 跨域方式为JSONP  CORS 时："></a>1. 跨域方式为JSONP  CORS 时：</h4><p>把环境变量抽取出来，封装在一个模块中，便于管理与维护。</p><ul><li>在package.json，修改：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;serve&quot;</span>: <span class="hljs-string">&quot;vue-cli-service serve --mode=development&quot;</span>,<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;vue-cli-service build --mode=test&quot;</span>,<br>  <span class="hljs-string">&quot;lint&quot;</span>: <span class="hljs-string">&quot;vue-cli-service lint --mode=production&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><ul><li>在src下新建一个env.js:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> baseURL;<br><span class="hljs-keyword">switch</span> (process.env.NODE_ENV) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;development&#x27;</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://dev-mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;test&#x27;</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://test-mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;production&#x27;</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://prod-mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    baseURL<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 mian.js 中，加入：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> env <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./env&#x27;</span><br>axios.default.baseURL = env.baseURL;<br></code></pre></td></tr></table></figure><p>如何想再添加一个自定义的环境变量 myProd：</p><ul><li>在src下新建一个env.myProd:</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">NODE_ENV</span> = <span class="hljs-string">&quot;myProd&quot;</span><br></code></pre></td></tr></table></figure><ul><li>在 package.json 中，添加：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;serve&quot;</span>: <span class="hljs-string">&quot;vue-cli-service serve --mode=development&quot;</span>,<br>  <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;vue-cli-service build --mode=test&quot;</span>,<br>  <span class="hljs-attr">&quot;lint&quot;</span>: <span class="hljs-string">&quot;vue-cli-service lint --mode=production&quot;</span>,<br>  <span class="hljs-attr">&quot;myProd&quot;</span>: <span class="hljs-string">&quot;vue-cli-service lint --mode=myProd&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><ul><li>在 env.js 中，添加:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> baseURL;<br><span class="hljs-keyword">switch</span> (process.env.NODE_ENV) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;development&#x27;</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://dev-mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;test&#x27;</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://test-mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;production&#x27;</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://prod-mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pr&#x27;</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://prod-mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;    <br>    <span class="hljs-keyword">default</span>:<br>        baseURL = <span class="hljs-string">&#x27;http://mall-pre.springboot.cn/api&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    baseURL<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-跨域方式为代理时："><a href="#2-跨域方式为代理时：" class="headerlink" title="2. 跨域方式为代理时："></a>2. 跨域方式为代理时：</h4><ul><li>在vue.config.js文件中修改target值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,<br>        <span class="hljs-attr">proxy</span>: &#123;<br>            <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>                <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://www/imooc.com&#x27;</span>,<br>                <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">pathRewrite</span>: &#123;<br>                    <span class="hljs-string">&#x27;./api&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>而main.js文件中，仍然是：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.defaults.baseURL = <span class="hljs-string">&#x27;/api&#x27;</span>;  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>起步</title>
    <link href="/2020/03/22/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%B5%B7%E6%AD%A5/"/>
    <url>/2020/03/22/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/%E8%B5%B7%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><ul><li><p><code>git config --list</code></p></li><li><p><code>git config --global user.name &quot;...&quot;</code></p></li><li><p><code>git config --global user.email &quot;...&quot;</code></p></li><li><p><code>git config --global credential.helper store</code></p></li><li><p><code>ssh-keygen -t rsa -C &quot;...&quot;</code></p></li></ul><h2 id="需求梳理"><a href="#需求梳理" class="headerlink" title="需求梳理"></a>需求梳理</h2><ul><li>熟悉文档、查看原型、读懂需求</li><li>了解前端设计稿-设计前端业务架构</li><li>了解后台接口文档-制定相关对接规范</li><li>协调资源</li><li>搭建前端架构</li></ul><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>推荐把大图片放在public文件夹里面，小图片放在assets文件夹里</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 链表</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>要存储多个元素，数组（或列表）可能是最常用的数据结构。<br> 每种语言都实现了数组。这种数据结构非常方便，提供了一个便利的<code>[]</code>语法来访问它的元素。<br> 然而，这种数据结构有一个缺点：在大多数语言中，数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素；<br> 尽管 JavaScript中的<code>Array</code>类方法可以帮我们做这些事，但背后的处理机制同样如此。</p><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。</p><p>下图展示了链表的结构:</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584279213258.png" alt="1584279213258"></p><p>相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。<a href="http://caibaojian.com/learn-javascript.html">·</a></p><p>数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点(表头)开始迭代列表直到找到所需的元素。</p><p>下面我们使用 JavaScript 创建一个链表类：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 链表节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.element = element<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 链表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span><br>        <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 追加元素</span><br>    <span class="hljs-function"><span class="hljs-title">append</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> Node(element)<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.head === <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.head = node<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            current = <span class="hljs-built_in">this</span>.head<br>            <span class="hljs-keyword">while</span>(current.next) &#123;<br>                current = current.next<br>            &#125;<br>            current.next = node<br>        &#125;<br>        <span class="hljs-built_in">this</span>.length++<br>    &#125;<br><br>    <span class="hljs-comment">// 任意位置插入元素</span><br>    <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">position, element</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-built_in">this</span>.length) &#123;<br>            <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> Node(element)<br>            <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.head<br>            <span class="hljs-keyword">let</span> previous = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">this</span>.head = node<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>                    previous = current<br>                    current = current.next<br>                &#125;<br>                node.next = current<br>                previous.next = node<br>            &#125;<br>            <span class="hljs-built_in">this</span>.length++<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 移除指定位置元素</span><br>    <span class="hljs-function"><span class="hljs-title">removeAt</span>(<span class="hljs-params">position</span>)</span> &#123;<br><br>        <span class="hljs-comment">// 检查越界值</span><br>        <span class="hljs-keyword">if</span> (position &gt; -<span class="hljs-number">1</span> &amp;&amp; position &lt; length) &#123;<br>            <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.head<br>            <span class="hljs-keyword">let</span> previous = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">this</span>.head = current.next<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>                    previous = current<br>                    current = current.next<br>                &#125;<br>                previous.next = current.next<br>            &#125;<br>            <span class="hljs-built_in">this</span>.length--<br>            <span class="hljs-keyword">return</span> current.element<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-comment">// 寻找元素下标</span><br>    <span class="hljs-function"><span class="hljs-title">findIndex</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.head<br>        <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            <span class="hljs-keyword">if</span> (element === current.element) &#123;<br>                <span class="hljs-keyword">return</span> index + <span class="hljs-number">1</span><br>            &#125;<br>            index++<br>            current = current.next<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除指定文档</span><br>    <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">this</span>. findIndex(element)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.removeAt(index)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.length<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length<br>    &#125;<br><br>    <span class="hljs-comment">// 转为字符串</span><br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.head<br>        <span class="hljs-keyword">let</span> string = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            string += <span class="hljs-string">` <span class="hljs-subst">$&#123;current.element&#125;</span>`</span><br>            current = current.next<br>        &#125;<br>        <span class="hljs-keyword">return</span> string<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>链表类的使用：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> linkedList = <span class="hljs-keyword">new</span> LinkedList()<br><br><span class="hljs-built_in">console</span>.log(linkedList)<br>linkedList.append(<span class="hljs-number">2</span>)<br>linkedList.append(<span class="hljs-number">6</span>)<br>linkedList.append(<span class="hljs-number">24</span>)<br>linkedList.append(<span class="hljs-number">152</span>)<br><br>linkedList.insert(<span class="hljs-number">3</span>, <span class="hljs-number">18</span>)<br><span class="hljs-built_in">console</span>.log(linkedList)<br><span class="hljs-built_in">console</span>.log(linkedList.findIndex(<span class="hljs-number">24</span>))<br></code></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584360838837.png" alt="1584360838837"></p><p>双向链表提供了两种迭代列表的方法:从头到尾，或者反过来。我们也可以访问一个特定节 点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表 起点，重新开始迭代。这是双向链表的一个优点。</p><p><strong>来实现一个双向链表类：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 链表节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.element = element<br>        <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span><br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双向链表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublyLinkedList</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span><br>        <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span><br>        <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 任意位置插入元素</span><br>    <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">position, element</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-built_in">this</span>.length)&#123;<br>            <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> Node(element)<br>            <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.head<br>            <span class="hljs-keyword">let</span> previous = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>            <span class="hljs-comment">// 首位</span><br>            <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!head)&#123;<br>                    <span class="hljs-built_in">this</span>.head = node<br>                    <span class="hljs-built_in">this</span>.tail = node<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    node.next = current<br>                    <span class="hljs-built_in">this</span>.head = node<br>                    current.prev = node<br>                &#125;<br>            <span class="hljs-comment">// 末位</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === <span class="hljs-built_in">this</span>.length) &#123;<br>                current = <span class="hljs-built_in">this</span>.tail<br>                current.next = node<br>                node.prev = current<br>                <span class="hljs-built_in">this</span>.tail = node<br>            <span class="hljs-comment">// 中位</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>                    previous = current<br>                    current = current.next<br>                &#125;<br>                node.next = current<br>                previous.next = node<br>                current.prev = node<br>                node.prev = previous<br>            &#125;<br>            <span class="hljs-built_in">this</span>.length++<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 移除指定位置元素</span><br>    <span class="hljs-function"><span class="hljs-title">removeAt</span>(<span class="hljs-params">position</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (position &gt; -<span class="hljs-number">1</span> &amp;&amp; position &lt; <span class="hljs-built_in">this</span>.length) &#123;<br>            <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.head<br>            <span class="hljs-keyword">let</span> previous = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br><br>            <span class="hljs-comment">// 首位</span><br>            <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">this</span>.head = <span class="hljs-built_in">this</span>.head.next<br>                <span class="hljs-built_in">this</span>.head.prev = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length === <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span><br>                &#125;<br><br>            <span class="hljs-comment">// 末位</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">this</span>.tail = <span class="hljs-built_in">this</span>.tail.prev<br>                <span class="hljs-built_in">this</span>.tail.next = <span class="hljs-literal">null</span><br><br>            <span class="hljs-comment">// 中位</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>                     previous = current<br>                     current = current.next<br>                &#125;<br>                previous.next = current.next<br>                current.next.prev = previous<br>         &#125;<br>         <span class="hljs-built_in">this</span>.length--<br>         <span class="hljs-keyword">return</span> current.element<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584361857501.png" alt="1584361857501"></p><p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev。</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584361877241.png" alt="1584361877241"></p><p>链表相比数组最重要的优点，那就是无需移动链表中的元素，就能轻松地添加和移除元素。因此，当你需要添加和移除很多元素 时，最好的选择就是链表，而非数组。</p><p>学习于：<a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构和算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 集合</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%9B%86%E5%90%88/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是由一组无序且唯一（不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。</p><p><strong>使用JavaScript创建一个集合类：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Set</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">has</span>(<span class="hljs-params">value</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.hasOwnProperty(value)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">value</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.has(value)) &#123;<br>            <span class="hljs-built_in">this</span>.items[value] = value<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;     <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">value</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.has(value)) &#123;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.items[value]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.items).length<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">values</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.items)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用集合类：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>set.add(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.log(set.values)  <span class="hljs-comment">// [&quot;1&quot;] </span><br><span class="hljs-built_in">console</span>.log(set.has(<span class="hljs-number">1</span>))  <span class="hljs-comment">// true </span><br><span class="hljs-built_in">console</span>.log(set.size) <span class="hljs-comment">// 1 </span><br>set.add(<span class="hljs-number">2</span>) <br><span class="hljs-built_in">console</span>.log(set.values)  <span class="hljs-comment">// [&quot;1&quot;, &quot;2&quot;] </span><br><span class="hljs-built_in">console</span>.log(set.has(<span class="hljs-number">2</span>))  <span class="hljs-comment">// true </span><br><span class="hljs-built_in">console</span>.log(set.size) <span class="hljs-comment">// 2 </span><br>set.remove(<span class="hljs-number">1</span>) <br><span class="hljs-built_in">console</span>.log(set.values) <span class="hljs-comment">// [&quot;2&quot;] </span><br>set.remove(<span class="hljs-number">2</span>) <br><span class="hljs-built_in">console</span>.log(set.values) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p><strong>对集合可以进行如下操作：</strong></p><ul><li>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</li><li>交集：对于给定的两个集合，返回一个包含两个集合中Р有元素的新集合。</li><li>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</li><li>子集：求证一个给定集合是否是另一集合的子集。</li></ul><p><strong>并集</strong></p><p>并集的数学概念：集合A和B的并集，表示为<code>A∪B</code>，定义如下：<code>A∪B = &#123; x | x∈A ∨ x∈B &#125;</code>，意思是x（元素）存在于A中，或x存在于B中。如图：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584363670338.png" alt="1584363670338"></p><p>我们基于刚才的 Set 类实现一个并集方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">union</span>(<span class="hljs-params">otherSet</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> unionSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>    <span class="hljs-built_in">this</span>.values.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> unionSet.add(<span class="hljs-built_in">this</span>.values[i]))<br>    otherSet.values.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> unionSet.add(otherSet.values[i]))<br>    <span class="hljs-keyword">return</span> unionSet<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>交集</strong></p><p>并集的数学概念：集合A和B的交集，表示为<code>A∩B</code>，定义如下：<code>A∩B = &#123; x | x∈A ∧ x∈B &#125;</code>，意思是x（元素）存在于A中，且x存在于B中。如图：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584363809538.png" alt="1584363809538"></p><p>我们基于刚才的 Set 类实现一个交集方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">intersection</span>(<span class="hljs-params">otherSet</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> intersectionSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>    <span class="hljs-built_in">this</span>.values.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (otherSet.has(v)) &#123;<br>            intersectionSet.add(v)<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> intersectionSet<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>差集</strong></p><p>差集的数学概念：集合A和B的差集，表示为<code>A-B</code>，定义如下：<code>A-B = &#123; x | x∈A ∧ x∉B &#125;</code>，意思是x（元素）存在于A中，且不x存在于B中。如图：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584363862018.png" alt="1584363862018"></p><p>我们基于刚才的 Set 类实现一个差集方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">difference</span>(<span class="hljs-params">otherSet</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> differenceSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>    <span class="hljs-built_in">this</span>.values.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!otherSet.has(v)) &#123;<br>            differenceSet.add(v)<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> differenceSet<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子集</strong></p><p>子集的数学概念：集合A是B的子集，或者说集合B包含了集合A，如图：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584363899399.png" alt="1584363899399"></p><p>我们基于刚才的 Set 类实现一个子集方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">subset</span>(<span class="hljs-params">otherSet</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.size &gt; otherSet.size) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.values.some(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> !otherSet.has(v))<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>学习于：<a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构与算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 队列</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%98%9F%E5%88%97/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种遵循先进先出 (FIFO / First In First Out) 原则的一组有序的项；队列在尾部添加新元素，并从头部移除元素。最新添加的元素必须排在队列的末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>    <span class="hljs-title">constructor</span> (<span class="hljs-params">items</span>) &#123;<br>        <span class="hljs-built_in">this</span>.items = items || []<br>    &#125;<br>    <span class="hljs-comment">//入队</span><br>    <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items.push(element)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">font</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>() &#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.items.length<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items.toString())<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用队列类：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue()<br><span class="hljs-built_in">console</span>.log(queue.isEmpty) <span class="hljs-comment">//true</span><br>queue.enqueue(<span class="hljs-string">&#x27;John&#x27;</span>)<br>queue.enqueue(<span class="hljs-string">&#x27;Jack&#x27;</span>)<br>queue.enqueue(<span class="hljs-string">&#x27;Camila&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(queue.size) <span class="hljs-comment">//3</span><br><span class="hljs-built_in">console</span>.log(queue.size) <span class="hljs-comment">//false</span><br>queue.dequeue()<br>queue.dequeue()<br>queue.print() <span class="hljs-comment">//&#x27;Camila&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。</p><p>实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级移除它们。</p><p>在下面示例中，我们将会在正确的位置添加元素，因此可以对它们使用默认的出列操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">element, priority</span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> queueElement = &#123; element, priority &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isEmpty) &#123;<br>            <span class="hljs-built_in">this</span>.items.push(queueElement)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> preIndex = <span class="hljs-built_in">this</span>.items.findIndex(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> queueElement.priority &lt; item.priority)<br>            <span class="hljs-keyword">if</span> (preIndex &gt; -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">this</span>.items.splice(preIndex, <span class="hljs-number">0</span>, queueElement)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.items.push(queueElement)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">front</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>()&#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优先队列的使用：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue()<br>priorityQueue.enqueue(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">2</span>)<br>priorityQueue.enqueue(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">1</span>)<br>priorityQueue.enqueue(<span class="hljs-string">&#x27;Camila&#x27;</span>, <span class="hljs-number">1</span>)<br>priorityQueue.enqueue(<span class="hljs-string">&#x27;Surmon&#x27;</span>, <span class="hljs-number">3</span>)<br>priorityQueue.enqueue(<span class="hljs-string">&#x27;skyRover&#x27;</span>, <span class="hljs-number">2</span>)<br>priorityQueue.enqueue(<span class="hljs-string">&#x27;司马萌&#x27;</span>, <span class="hljs-number">1</span>)<br>priorityQueue.print()<br><br><span class="hljs-built_in">console</span>.log(priorityQueue.isEmpty, priorityQueue.size) <span class="hljs-comment">// false 6</span><br></code></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>为充分利用向量空间，克服”假溢出”现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。这种循环队列可以以单链表、队列的方式来在实际编程应用中来实现。</p><p>下面我们基于首次实现的队列类，简单实现一个循环引用的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoopQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span></span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">items</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(items)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">getIndex</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">this</span>.items.length<br>        <span class="hljs-keyword">return</span> index &gt; length ? (index % length) : index<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">find</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.isEmpty ? <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.getIndex(index) :<span class="hljs-literal">null</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>访问一个循环队列：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> loopQueue = <span class="hljs-keyword">new</span> LoopQueue([<span class="hljs-string">&#x27;Surmon&#x27;</span>])<br>loopQueue.enqueue(<span class="hljs-string">&#x27;SkyRover&#x27;</span>)<br>loopQueue.enqueue(<span class="hljs-string">&#x27;Even&#x27;</span>)<br>loopQueue.enqueue(<span class="hljs-string">&#x27;Alice&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(loopQueue.size, loopQueue.isEmpty) <span class="hljs-comment">// 4 false</span><br><br><span class="hljs-built_in">console</span>.log(loopQueue.find(<span class="hljs-number">26</span>)) <span class="hljs-comment">// &#x27;Evan&#x27;</span><br><span class="hljs-built_in">console</span>.log(loopQueue.find(<span class="hljs-number">87651</span>)) <span class="hljs-comment">// &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p>学习于<a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构和算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 字典</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%AD%97%E5%85%B8/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>集合、字典、散列表都可以存储不重复的数据。字典和我们上面实现的集合很像，上面的集合中我们以<code>&#123; value: value &#125;</code>的形式存储数据，而字典是以<code>&#123; key: value &#125;</code>的形式存储数据，字典也称作映射。</p><p>简单说：<code>Object</code> 对象便是字典在 Javascript 中的实现。</p><p><strong>简单实现一个字典类：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dictionary</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">key, value</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items[key] = value<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[key]<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.items[key]<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">keys</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.items)<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">values</span>() &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        也可以使用ES7中的values方法</span><br><span class="hljs-comment">        return Object.values(this.items)</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-comment">// 在这里我们通过循环生成一个数组并输出</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.items).reduce(<span class="hljs-function">(<span class="hljs-params">r, c, i</span>) =&gt;</span> &#123;<br>            r.push(<span class="hljs-built_in">this</span>.items[c])<br>            <span class="hljs-keyword">return</span> r<br>        &#125;, [])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用字典类：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> dictionary = <span class="hljs-keyword">new</span> Dictionary()<br>dictionary.set(<span class="hljs-string">&#x27;Gandalf&#x27;</span>, <span class="hljs-string">&#x27;gandalf@email.com&#x27;</span>)<br>dictionary.set(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;johnsnow@email.com&#x27;</span>)<br>dictionary.set(<span class="hljs-string">&#x27;Tyrion&#x27;</span>, <span class="hljs-string">&#x27;tyrion@email.com&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(dictionary)<br><span class="hljs-built_in">console</span>.log(dictionary.keys)<br><span class="hljs-built_in">console</span>.log(dictionary.values)<br><span class="hljs-built_in">console</span>.log(dictionary.items)<br></code></pre></td></tr></table></figure><p>学习于：<a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构与算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 栈</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%A0%88/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一种遵从先进后出 (LIFO) 原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><p>在 JavaScript 中我们可以使用数组的原生方法实现一个栈/队列的功能，鉴于学习目的，我们使用类来实现一个栈：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;,<br>    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items.push(element)<br>    &#125;,<br>    <span class="hljs-comment">//出栈</span><br>    <span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.pop()<br>    &#125;,<br>    <span class="hljs-comment">//末位</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">peek</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length - <span class="hljs-number">1</span>]<br>    &#125;,<br>    <span class="hljs-comment">//是否为空</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>() &#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.items.length<br>    &#125;,<br>    <span class="hljs-comment">//尺寸</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;,<br>    <span class="hljs-comment">//清空栈</span><br>    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><span class="hljs-comment">//打印栈数据</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items.toString())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用栈类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//实例化一个栈</span><br><span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();<br><span class="hljs-built_in">console</span>.log(stack.isEmpty); <span class="hljs-comment">//true</span><br><span class="hljs-comment">//添加元素</span><br>stack.push(<span class="hljs-number">5</span>);<br>stack.push(<span class="hljs-number">8</span>);<br><span class="hljs-comment">//读取属性再添加</span><br><span class="hljs-built_in">console</span>.log(stack.peek); <span class="hljs-comment">//8</span><br>stack.push(<span class="hljs-number">11</span>);<br><span class="hljs-built_in">console</span>.log(stack.size) <span class="hljs-comment">//3</span><br><span class="hljs-built_in">console</span>.log(stack.isEmpty) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>学习于<a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构和算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 - 图</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%9B%BE/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点），任何二元关系都可以用图来表示。</p><p>一个图<code>G=(V, E)</code>由以下兀素组成：</p><ul><li>V: 一组顶点</li><li>E: 一组边，连接V中的顶点</li></ul><p>下图表示一个图:</p><p><img src="https://img-blog.csdnimg.cn/2020031721005420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-T6j4akhD-1584450013346)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584445277875.png)]"></p><p>由一条边连接在一起的顶点称为相邻顶点。比如，A和B是相邻的，A和D是相邻的，A和C 是相邻的，A和E不是相邻的。</p><p>一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3; E 和其他两个顶点相连，因此，E的度为2。</p><p>路径是顶点<code>v1, v2, ...vk</code>的一个连续序列，其中 vi 和 vi+1 是相邻的。以上图为例， 其中包含路径A B E I 和 A C D G。</p><p>简单路径要求不包含重复的顶点。举个例子，ADG是一条简单路径。除去最后一个顶点（因 为它和第一个顶点是同一个顶点），环也是一个简单路径，比如ADC A(最后一个顶点重新回到A )。</p><p>如果图中不存在环，则称该图是无坏的。如果图中每两个顶点间都存在路径，则该图是连通的。</p><h3 id="有向图和无向图"><a href="#有向图和无向图" class="headerlink" title="有向图和无向图"></a>有向图和无向图</h3><p>图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向：</p><p><img src="https://img-blog.csdnimg.cn/20200317210114487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8QXMce3h-1584450013369)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584445540939.png)]"></p><p>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的， 而A和B不是强连通的。</p><p>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加 权图的边被赋予了权值：</p><p><img src="https://img-blog.csdnimg.cn/20200317210138593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WSvmCLtu-1584450013372)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584445721483.png)]"></p><p>我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索 一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径， 以及环检测。</p><p>从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的 方式。图的正确表示法取决于待解决的问题和图的类型。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我 们用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则<code>array[i][j] ===1</code>，否则<code>array[i][j] === 0</code>,如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200317210159132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QqXWCYMf-1584450013376)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584445856364.png)]"></p><p>不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0,这意味着我们 浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有 一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的 数量可能会改变，而2维数组不太灵活。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶 点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是 散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。</p><p><img src="https://img-blog.csdnimg.cn/20200317210211617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-s1GHZrdI-1584450013383)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584445963798.png)]"></p><p>尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有 着不同的性质（例如，要找出顶点V和W是否相邻，使用邻接矩阵会比较快)。在接下来的示例中， 我们将会使用邻接表表示法。</p><h3 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h3><p>我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所 示，我们使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 <code>array[v][e] === 1</code>; 否则，<code>array [v][e] === 0</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200317210226519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-togZF3Vl-1584450013387)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584446742425.png)]"></p><p>关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。</p><h3 id="创建图类："><a href="#创建图类：" class="headerlink" title="创建图类："></a>创建图类：</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span>() </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vertices = []<br>        <span class="hljs-built_in">this</span>.adjList = <span class="hljs-keyword">new</span> Dictionary()<br>    &#125;<br><br>    <span class="hljs-comment">// 添加顶点</span><br>    <span class="hljs-function"><span class="hljs-title">addVertex</span>(<span class="hljs-params">v</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vertices.push(v)<br>        <span class="hljs-built_in">this</span>.adjList.set(v, [])<br>    &#125;<br><br>    <span class="hljs-comment">// 添加线</span><br>    <span class="hljs-function"><span class="hljs-title">addEdge</span>(<span class="hljs-params">v, w</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adjList.get(v).push(w)<br>        <span class="hljs-built_in">this</span>.adjList.get(w).push(v)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.vertices.reduce(<span class="hljs-function">(<span class="hljs-params">r, v, i</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.adjList.get(v).reduce(<span class="hljs-function">(<span class="hljs-params">r, w, i</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> r + <span class="hljs-string">`<span class="hljs-subst">$&#123;w&#125;</span> `</span><br>            &#125;, <span class="hljs-string">`<span class="hljs-subst">$&#123;r&#125;</span>\n<span class="hljs-subst">$&#123;v&#125;</span> =&gt; `</span>)<br>        &#125;, <span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用图类：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> Graph()<br><br>;[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> graph.addVertex(c))<br><br>graph.addEdge(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)<br>graph.addEdge(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(graph.toString())<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A =&gt; B C D </span><br><span class="hljs-comment">B =&gt; A E F </span><br><span class="hljs-comment">C =&gt; A D G </span><br><span class="hljs-comment">D =&gt; A C G H </span><br><span class="hljs-comment">E =&gt; B I </span><br><span class="hljs-comment">F =&gt; B </span><br><span class="hljs-comment">G =&gt; C D </span><br><span class="hljs-comment">H =&gt; D </span><br><span class="hljs-comment">I =&gt; E </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：</p><ul><li><p>广度优先搜索（Breadth-First Search，BFS)</p></li><li><p>深度优先搜索（Depth-First Search，DFS)</p></li></ul><p>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。</p><p>在实现算法之前，让我们来更好地理解一下图遍历的思想方法。</p><p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探 索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</p><p>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的 顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p><p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p><p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点 列表的数据结构。</p><ul><li><p>深度优先搜索：桟，通过将顶点存入桟中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</p></li><li><p>广度优先搜索 ：队列，通过将顶点存入队列中，最先入队列的顶点先被探索</p></li></ul><p><strong>广度优先搜索</strong></p><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访 问图的一层。简单说，就是先宽后深地访问顶点，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200317210249523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Rg8P6a7U-1584450013390)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584447758347.png)]"></p><p>以下是我们的方法实现的。</p><p>维护两个队列，分别用于存储已读和待读顶点，两者具有互斥性，即某顶点在访问时只会属于一种类型，本质是通过不断递归将相邻的顶点进行访问和维度标为已读。</p><p>让我们来实现广度优先搜索算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// breadth first search</span><br><span class="hljs-function"><span class="hljs-title">bfs</span>(<span class="hljs-params">v, callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> read = []<br>    <span class="hljs-keyword">const</span> adjList = <span class="hljs-built_in">this</span>.adjList<br>    <span class="hljs-keyword">let</span> pending = [v || <span class="hljs-built_in">this</span>.vertices[<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">const</span> readVertices = <span class="hljs-function"><span class="hljs-params">vertices</span> =&gt;</span> &#123;<br>        vertices.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            read.push(key)<br>            pending.shift()<br>            adjList.get(key).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (!pending.includes(v) &amp;&amp; !read.includes(v)) &#123;<br>                    pending.push(v)<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">if</span> (callback) callback(key)<br>            <span class="hljs-keyword">if</span> (pending.length) readVertices(pending)<br>        &#125;)<br>    &#125;<br>    readVertices(pending)<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们执行下面这段代码来测试一下这个算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">graph.bfs(graph.vertices[<span class="hljs-number">0</span>], <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Visited vertex: &#x27;</span> + value))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">Visited vertex: A<br>Visited vertex: B<br>Visited vertex: C<br>Visited vertex: D<br>Visited vertex: E<br>Visited vertex: F<br>Visited vertex: G<br>Visited vertex: H<br>Visited vertex: I<br></code></pre></td></tr></table></figure><p><strong>使用BFS寻找最短路径</strong></p><p>到目前为止，我们只展示了BFS算法的工作原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面这个问题。</p><p>给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计)。</p><p>对于给定顶点V，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改bfs方法以返回给我们一些信息：</p><ul><li>从 v 到 u 的距离 d[u]</li><li>前溯点 pred[u]，用来推导出从v到其他每个顶点u的最短路径</li></ul><p>让我们来看看改进过的广度优先方法的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">bfs</span>(<span class="hljs-params">v, callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> read = []<br>    <span class="hljs-keyword">const</span> distances = []<br>    <span class="hljs-keyword">const</span> predecessors = []<br>    <span class="hljs-keyword">const</span> adjList = <span class="hljs-built_in">this</span>.adjList<br>    <span class="hljs-keyword">const</span> pending = [v || <span class="hljs-built_in">this</span>.vertices[<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">const</span> readVertices = <span class="hljs-function"><span class="hljs-params">vertices</span> =&gt;</span> &#123;<br>        vertices.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            read.push(key)<br>            pending.shift()<br>            distances[key] = distances[key] || <span class="hljs-number">0</span><br>            predecessors[key] = predecessors[key] || <span class="hljs-literal">null</span><br>            adjList.get(key).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (!pending.includes(v) &amp;&amp; !read.includes(v)) &#123;<br>                    pending.push(v)<br>                    distances[v] = distances[key] + <span class="hljs-number">1</span><br>                    predecessors[v] = key<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">if</span> (callback) callback(key)<br>            <span class="hljs-keyword">if</span> (pending.length) readVertices(pending)<br>        &#125;)<br>    &#125;<br>    readVertices(pending)<br>    <span class="hljs-keyword">return</span> &#123; distances, predecessors &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">distances: [A: <span class="hljs-number">0</span>, <span class="hljs-attr">B</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">C</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">D</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">E</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">F</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">G</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">H</span>: <span class="hljs-number">2</span> ,工：<span class="hljs-number">3</span>]<br><span class="hljs-attr">predecessors</span>: [A: <span class="hljs-literal">null</span>, <span class="hljs-attr">B</span>: <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-attr">C</span>: <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-attr">D</span>: <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-attr">E</span>: <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-attr">F</span>: <span class="hljs-string">&quot; B&quot;</span>, <span class="hljs-attr">G</span>: <span class="hljs-string">&quot; C&quot;</span>, <span class="hljs-attr">H</span>: <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-attr">I</span>: <span class="hljs-string">&quot;E&quot;</span>]<br></code></pre></td></tr></table></figure><p>这意味着顶点A与顶点B、C和D的距离为1；与顶点E、F、G和H的距离为2；与顶点I的距离<br>通过前溯点数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">distance</span>(<span class="hljs-params">fromVertex</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> vertices = <span class="hljs-built_in">this</span>.vertices<br>    <span class="hljs-keyword">const</span> &#123; distances, predecessors &#125; = <span class="hljs-built_in">this</span>.bfs(fromVertex)<br>    vertices.forEach(<span class="hljs-function"><span class="hljs-params">toVertex</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!!distances[toVertex]) &#123;<br>            <span class="hljs-keyword">let</span> preVertex = predecessors[toVertex]<br>            <span class="hljs-keyword">let</span> slug = <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-keyword">while</span> (fromVertex !== preVertex) &#123;<br>                slug = <span class="hljs-string">`<span class="hljs-subst">$&#123;preVertex&#125;</span> - <span class="hljs-subst">$&#123;slug&#125;</span>`</span><br>                preVertex = predecessors[preVertex]<br>            &#125;<br>            slug = <span class="hljs-string">`<span class="hljs-subst">$&#123;fromVertex&#125;</span> - <span class="hljs-subst">$&#123;slug&#125;</span><span class="hljs-subst">$&#123;toVertex&#125;</span>`</span><br>            <span class="hljs-built_in">console</span>.log(slug)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行该代码段，我们会得到如下输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">graph.distance(graph.vertices[<span class="hljs-number">0</span>])<br><span class="hljs-comment">// 输出如下：</span><br><span class="hljs-comment">// A - B</span><br><span class="hljs-comment">// A - C</span><br><span class="hljs-comment">// A - D</span><br><span class="hljs-comment">// A - B - E</span><br><span class="hljs-comment">// A - B - F</span><br><span class="hljs-comment">// A - C - G</span><br><span class="hljs-comment">// A - D - H</span><br><span class="hljs-comment">// A - B - E - I</span><br></code></pre></td></tr></table></figure><p>这里，我们得到了从顶点A到图中其他顶点的最短路径（衡量标准是边的数量)。</p><p><strong>深度优先搜索</strong></p><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶 点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200317210313263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7R454VVM-1584450013395)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584449439749.png)]"></p><p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点V未访问，则访问该顶点V。</p><p>深度优先搜索算法核心是递归，普通的对象递归模型即可满足需求，对比已读顶点是否已完全覆盖即可。</p><p>深度优先算法的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// depth first search</span><br><span class="hljs-function"><span class="hljs-title">dfs</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> read = []<br>    <span class="hljs-keyword">const</span> adjList = <span class="hljs-built_in">this</span>.adjList<br>    <span class="hljs-keyword">const</span> readVertices = <span class="hljs-function"><span class="hljs-params">vertices</span> =&gt;</span> &#123;<br>        vertices.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (read.includes(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            read.push(key)<br>            <span class="hljs-keyword">if</span> (callback) callback(key)<br>            <span class="hljs-keyword">if</span> (read.length !== <span class="hljs-built_in">this</span>.vertices.length) &#123;<br>                readVertices(adjList.get(key))<br>            &#125;<br>        &#125;)<br>    &#125;<br>    readVertices(adjList.keys)<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们执行下面的代码段来测试一下df s方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">graph.dfs(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Visited vertex: &#x27;</span> + value))<br><br><span class="hljs-comment">// 输出如下：</span><br><span class="hljs-comment">// Visited vertex: A </span><br><span class="hljs-comment">// Visited vertex: B </span><br><span class="hljs-comment">// Visited vertex: E </span><br><span class="hljs-comment">// Visited vertex: I</span><br><span class="hljs-comment">// Visited vertex: F </span><br><span class="hljs-comment">// Visited vertex: C </span><br><span class="hljs-comment">// Visited vertex: D </span><br><span class="hljs-comment">// Visited vertex: G </span><br><span class="hljs-comment">// Visited vertex: H</span><br></code></pre></td></tr></table></figure><p>下图展示了该算法每一步的执行过程：</p><p><img src="https://img-blog.csdnimg.cn/20200317210344242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-a7r3Rli3-1584450013401)(C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584449527034.png)]"></p><p><strong>探索深度优先算法</strong></p><p>到目前为止，我们只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事 情，而不只是输出被访问顶点的顺序。</p><p>对于给定的图G，我们希望深度优先搜索算法遍历图G的所有节点，构建“森林”（有根树的 一个集合）以及一组源顶点（根)，并输出两个数组：发现时间和完成探索时间。我们可以修改 dfs方法来返回给我们一些信息：</p><ul><li>顶点 u 的发现时间 d[u]</li><li>当顶点 u 被标注为已读时，u 的完成探索时间</li><li>顶点 u 的前溯点 p[u]</li></ul><p>让我们来看看改进了的 DFS 方法的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// depth first search</span><br><span class="hljs-function"><span class="hljs-title">dfs</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> readTimer = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> read = []<br>    <span class="hljs-keyword">const</span> readTimes = []<br>    <span class="hljs-keyword">const</span> finishedTimes = []<br>    <span class="hljs-keyword">const</span> predecessors = []<br>    <span class="hljs-keyword">const</span> adjList = <span class="hljs-built_in">this</span>.adjList<br>    <span class="hljs-keyword">const</span> readVertices = <span class="hljs-function">(<span class="hljs-params">vertices, predecessor</span>) =&gt;</span> &#123;<br>        vertices.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            readTimer++<br>            <span class="hljs-keyword">if</span> (adjList.get(key).every(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> read.includes(v)) &amp;&amp; !finishedTimes[key]) &#123;<br>                finishedTimes[key] = readTimer<br>            &#125;<br>            <span class="hljs-keyword">if</span> (read.includes(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            readTimes[key] = readTimer<br>            read.push(key)<br>            <span class="hljs-keyword">if</span> (callback) callback(key)<br>            predecessors[key] = predecessors[key] || predecessor || <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">if</span> (read.length !== <span class="hljs-built_in">this</span>.vertices.length) &#123;<br>                readVertices(adjList.get(key), key)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    readVertices(adjList.keys)<br>    <span class="hljs-keyword">return</span> &#123; readTimes, finishedTimes, predecessors &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>深度优先算法背后的思想是什么？边是从最近发现的顶点 u 处被向外探索的。只有连接到未发现的顶点的边才会探索。当 u 所有的边都被探索了，该算法回退到 u 被发现的地方去探索其他的边。这个过程持续到我们发现了所有从原始顶点能够触及的顶点。如果还留有任何其他未被发现的顶点，我们对新源顶点重复这个过程，直到图中所有的顶点都被探索了。</p><p>对于改进过的深度优先搜索，有两点需要我们注意：</p><ul><li>时间（time）变量值的范围只可能在图顶点数量的一倍到两倍之间</li><li>对于所有的顶点 u，d[u] &lt; f[u] 意味着，发现时间的值比完成时间的值小，完成时所有顶点都已经被探索过了</li></ul><p>学习于：<a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构与算法学习</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 贪心算法</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p><strong>基本要素：</strong></p><ul><li><strong>贪心选择</strong>：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</li><li><strong>最优子结构</strong>：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</li></ul><p><strong>过程：</strong></p><ol><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每一子问题求解，得到子问题的局部最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><h3 id="（一）汽车加油问题"><a href="#（一）汽车加油问题" class="headerlink" title="（一）汽车加油问题"></a>（一）汽车加油问题</h3><p><strong>问题：</strong></p><p>一辆汽车加满油后可行驶 n公里。旅途中有若干个加油站。设计一个有效算法，指出应 在哪些加油站停靠加油，使沿途加油次数最少。</p><p><strong>输入格式:</strong><br>第一行有 2 个正整数n和 k（k&lt;=1000 )，表示汽车加满油后可行驶n公里，且旅途中有 k个加油站。 第二行有 k+1 个整数，表示第 k 个加油站与第k-1 个加油站之间的距离。 第 0 个加油站表示出发地，汽车已加满油。 第 k+1 个加油站表示目的地。</p><p><strong>输出格式:</strong><br>输出最少加油次数。如果无法到达目的地，则输出“No Solution!”。</p><p><strong>输入样例:</strong><br>7 7<br>1 2 3 4 5 1 6 6</p><p><strong>输出样例:</strong><br>4</p><p><strong>贪心性质分析：</strong><br>找到汽车满油量时可以行驶的最大路程范围内的最后一个加油站，加油后则继续用此方法前进。需要检查每一小段路程是否超过汽车满油量时的最大支撑路程。</p><p><strong>代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greedy</span>(<span class="hljs-params">n,k</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> arr =[];<br>        <span class="hljs-comment">//随机分配arr的每个数，即第i和i-1个加油站之间的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span> ;i &lt;=k;i++)&#123;<br>            arr[i] = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">10</span>+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(arr);<span class="hljs-comment">//5 8 6 1 9 10 8 4 3 6 9</span><br><br>        <span class="hljs-keyword">var</span>  num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;=k;j++)<br>        &#123;<br>            count+=arr[j];<br>            <span class="hljs-keyword">if</span>(count&gt;n)<br>            &#123;<br>                num++;<br>                count=arr[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;汽车最少要需要加油的次数为：&#x27;</span>+num);<span class="hljs-comment">//8</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(greedy(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><h3 id="（二）背包问题"><a href="#（二）背包问题" class="headerlink" title="（二）背包问题"></a>（二）背包问题</h3><p><strong>部分背包问题：</strong>固定容积的背包能放入物品的总最大价值</p><p>物品 A B C D<br>价格 50 220 60 60<br>尺寸 5 20 10 12<br>比率 10 11 6 5</p><p>按比例降序尽可能多放入物品</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greedy</span>(<span class="hljs-params">values, weights, capacity</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> returnValue = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> remianCapacity = capacity;<br>    <span class="hljs-keyword">var</span> sortArray = [];<br>    values.map(<span class="hljs-function">(<span class="hljs-params">cur, index</span>) =&gt;</span> &#123;<br>        sortArray.push(&#123;<br>            <span class="hljs-string">&#x27;value&#x27;</span>: values[index],<br>            <span class="hljs-string">&#x27;weight&#x27;</span>: weights[index],<br>            <span class="hljs-string">&#x27;ratio&#x27;</span>: values[index]/weights[index]<br>        &#125;)<br>    &#125;)<br>    sortArray.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> b.ratio &gt; a.ratio<br>    &#125;)<br>    <span class="hljs-built_in">console</span>.log(sortArray)<br>    sortArray.map(<span class="hljs-function">(<span class="hljs-params">cur, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">parseInt</span>(remainCapcity/cur.weight)<br>        <span class="hljs-built_in">console</span>.log(num)<br>        remainCapacity -= num*cur.weight<br>        returnValue += num*cur.value<br>    &#125;)<br>    <span class="hljs-keyword">return</span> returnValue<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（三）买卖股票的最佳时机"><a href="#（三）买卖股票的最佳时机" class="headerlink" title="（三）买卖股票的最佳时机"></a>（三）买卖股票的最佳时机</h3><h5 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h5><p>只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> maxP = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> minP = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i ++) &#123;<br>        <span class="hljs-keyword">if</span>(min &gt; prices[i]) &#123;<br>            min = prices[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            max = <span class="hljs-built_in">Math</span>.max(max, prices[i] - min)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h5><p>只要股票价格上涨，上涨的部分就是我的利润，可以理解为上涨期间第一天买入，然后一直持有到上涨最后一天即下跌前一天再卖出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (prices[i + <span class="hljs-number">1</span>] &gt; prices[i]) profit += prices[i + <span class="hljs-number">1</span>] - prices[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> profit;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>好文：</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1642122740570394361&wfr=spider&for=pc">小白带你学贪心算法！</a></p><p><a href="https://blog.csdn.net/m0_37686205/article/details/90115668">js实现—加油站问题(贪心算法)</a></p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 查找算法</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%20-%20%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h3 id="（一）顺序查找"><a href="#（一）顺序查找" class="headerlink" title="（一）顺序查找"></a>（一）顺序查找</h3><p><strong>说明：</strong></p><p>顺序查找适合于存储结构为顺序存储或链接存储的线性表。<br><strong>基本思想：</strong></p><p>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p><strong>复杂度分析：</strong>　</p><ul><li>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</li><li>当查找不成功时，需要n+1次比较，时间复杂度为O(n);</li><li>所以，顺序查找的时间复杂度为O(n)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SequenceSearch</span>(<span class="hljs-params">arr, value</span>) </span>&#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>               <span class="hljs-keyword">if</span> (arr[i] == value) &#123;<br>                   <span class="hljs-keyword">return</span> i;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="（二）二分查找"><a href="#（二）二分查找" class="headerlink" title="（二）二分查找"></a>（二）二分查找</h3><p><strong>说明：</strong></p><p>元素必须是有序的，如果是无序的则要先进行排序操作。<br><strong>基本思想：</strong></p><p>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。<br><strong>复杂度分析：</strong></p><p>最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；<br>注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 递归</span><br>       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch</span>(<span class="hljs-params">data, dest, start, end</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (start &gt; end) &#123; <span class="hljs-comment">// 新增否则找不到进入死循环了</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>           <span class="hljs-keyword">var</span> end = end || data.length - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">var</span> start = start || <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">var</span> mid = <span class="hljs-built_in">Math</span>.floor((start + end) / <span class="hljs-number">2</span>);<br>           <span class="hljs-comment">//var mid = parseInt(start+(end-start)/2);</span><br>           <span class="hljs-comment">//直接命中</span><br>           <span class="hljs-keyword">if</span> (data[mid] == dest) &#123;<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (data[mid] &gt; dest) &#123; <span class="hljs-comment">// 放左</span><br>               end = mid - <span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">return</span> binarySearch(data, dest, start, end);<br>           &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 放右</span><br>               start = mid + <span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">return</span> binarySearch(data, dest, start, end);<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br><br><span class="hljs-comment">// 非递归 用while</span><br>       <span class="hljs-comment">//代码中的判断条件必须是while (left &lt;= right)，</span><br>       <span class="hljs-comment">//否则的话判断条件不完整，比如：array[3] = &#123;1, 3, 5&#125;;</span><br>       <span class="hljs-comment">//待查找的键为5，此时在(low &lt; high)条件下就会找不到，因为low和high相等时，指向元素5，但是此时条件不成立，没有进入while()中</span><br>       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch2</span>(<span class="hljs-params">data, dest</span>) </span>&#123;<br>           <span class="hljs-keyword">var</span> end = data.length - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>               <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">Math</span>.floor((end + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>               <span class="hljs-keyword">if</span> (data[m] == dest) &#123;<br>                   <span class="hljs-keyword">return</span> m;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (data[m] &gt; dest) &#123;<br>                   end = m - <span class="hljs-number">1</span>;<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   start = m + <span class="hljs-number">1</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="（三）插值查找"><a href="#（三）插值查找" class="headerlink" title="（三）插值查找"></a>（三）插值查找</h3><p><strong>基本思想：</strong></p><p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。当然，差值查找也属于有序查找。</p><p>将<code> mid=start+1/2*(end-start)</code>，改进为：<code>mid=start+[(key-a[start])/(a[end]-a[start])]*(end-start)</code>，<br>注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。<br><strong>复杂度分析：</strong></p><p>查找成功或者失败的时间复杂度均为O(log2(log2n))。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InsertionSearch</span>(<span class="hljs-params">arr, val, start, end</span>) </span>&#123;<br>           <span class="hljs-keyword">var</span> end = end || data.length - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">var</span> start = start || <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">var</span> mid = start + (val - arr[start]) / (arr[end] - arr[start]) * (end - start);<br>           <span class="hljs-keyword">if</span> (arr[mid] == val) &#123;<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (arr[mid] &gt; val) &#123;<br>               <span class="hljs-keyword">return</span> InsertionSearch(arr, val, start, mid - <span class="hljs-number">1</span>);<br>           &#125;<br>           <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> InsertionSearch(arr, val, mid + <span class="hljs-number">1</span>, end);<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="（四）斐波那契查找"><a href="#（四）斐波那契查找" class="headerlink" title="（四）斐波那契查找"></a>（四）斐波那契查找</h3><p>斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。斐波那契查找也属于一种有序查找算法。<br>斐波那契数组的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">index</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span> || index == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> fib(index - <span class="hljs-number">1</span>) + fib(index - <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>基本思路：</strong></p><p>相对于折半查找，一般将待比较的key值与第mid=（start + end）/2位置的元素比较，比较结果分三种情况：</p><ul><li>相等，mid位置的元素即为所求</li><li><code>&gt;</code>，start = mid+1;</li><li><code>&lt;</code>，end = mid-1。</li></ul><p>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;<br>开始将k值与第F(k-1)位置的记录进行比较(及mid=start+F(k-1)-1),比较结果也分为三种</p><ul><li>相等，mid位置的元素即为所求</li><li><code>&gt;</code>，start=mid+1,k -= 2;<br>说明：start=mid+1说明待查找的元素在[mid+1,end]范围内，k-=2 说明范围[mid+1,end]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</li><li><code>&lt;</code>，end=mid-1,k -= 1。<br>说明：end=mid-1说明待查找的元素在[start,mid-1]范围内，k-=1 说明范围[start, mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params">array, value</span>) </span>&#123;<br>           <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>, end = array.length - <span class="hljs-number">1</span>, n = array.length - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">let</span> mid, k = <span class="hljs-number">0</span>;<br>           <span class="hljs-comment">//构建一个长度大于array数组的斐波那契数组</span><br>           <span class="hljs-keyword">var</span> F = [];<br>           F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>           F[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">2</span>; i &lt; end + <span class="hljs-number">5</span>; i++) &#123;<br>               F[i] = F[i - <span class="hljs-number">1</span>] + F[i - <span class="hljs-number">2</span>];<br>           &#125;<br>           <span class="hljs-keyword">while</span> (end &gt; F[k] - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//寻找第k项</span><br>               k++;<br>           &#125;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = end; i &lt; F[k] - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//补全有序数组</span><br>               array[i] = array[end];<br>           &#125;<br>           <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>               mid = start + F[k - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">if</span> (array[mid] &gt; value) &#123;<br>                   end = mid - <span class="hljs-number">1</span>;<br>                   k = k - <span class="hljs-number">1</span>; <span class="hljs-comment">//长度缩减为F[k-1]-1</span><br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[mid] &lt; value) &#123;<br>                   start = mid + <span class="hljs-number">1</span>;<br>                   k = k - <span class="hljs-number">2</span>; <span class="hljs-comment">//长度缩减为F[k-2]-1</span><br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">if</span> (m &lt;= n) <span class="hljs-comment">//相等则找到位置</span><br>                       <span class="hljs-keyword">return</span> mid;<br>                   <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">return</span> n; <span class="hljs-comment">//大于原始长度，则说明等于数组最后一项 </span><br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6  Proxy  和 Reflect</title>
    <link href="/2020/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20%20Proxy%20%20%E5%92%8C%20Reflect/"/>
    <url>/2020/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20%20Proxy%20%20%E5%92%8C%20Reflect/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6-Proxy-和-Reflect"><a href="#ES6-Proxy-和-Reflect" class="headerlink" title="ES6  Proxy 和 Reflect"></a>ES6  Proxy 和 Reflect</h1><h2 id="（一）Reflect"><a href="#（一）Reflect" class="headerlink" title="（一）Reflect"></a>（一）Reflect</h2><h4 id="Reflect是什么？"><a href="#Reflect是什么？" class="headerlink" title="Reflect是什么？"></a>Reflect是什么？</h4><p><strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler">proxy handlers</a>的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p><p>与大多数全局对象不同，<code>Reflect</code>不是一个构造函数。你不能将其与一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new运算符</a>一起使用，或者将<code>Reflect</code>对象作为一个函数来调用。<code>Reflect</code>的所有属性和方法都是静态的（就像<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math"><code>Math</code></a>对象）。</p><h4 id="为什么要使用Reflect？"><a href="#为什么要使用Reflect？" class="headerlink" title="为什么要使用Reflect？"></a>为什么要使用Reflect？</h4><ul><li><p><strong>更加有用的返回值：</strong></p></li><li><p><strong>函数操作</strong></p></li><li><p><strong>更加可靠的函数式执行方式</strong></p></li><li><p><strong>可变参数形式的构造函数</strong></p></li><li><p><strong>控制访问器或者读取器的this</strong></p></li><li><p><strong>避免直接访问 <code>__proto__</code></strong></p></li></ul><p><strong>详细见</strong>：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN Reflect</a></p><p><a href="https://www.cnblogs.com/diligenceday/p/5474126.html">ES6新特性：Javascript中的Reflect对象</a></p><h2 id="（二）Proxy"><a href="#（二）Proxy" class="headerlink" title="（二）Proxy"></a>（二）Proxy</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><p><code>target</code></p><p>用<code>Proxy</code>包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p></li><li><p><code>handler</code></p><p>一个对象，其属性是当执行一个操作时定义代理的行为的函数。</p></li></ul><p><strong>方法：</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable"><code>Proxy.revocable()</code></a> ：创建一个可撤销的<code>Proxy</code>对象。允许的属性一共 13 种，与 <code>Reflect</code> 的方法名一致</p><p><strong>handler对象的方法：</strong></p><p><a href="https://es6.ruanyifeng.com/#docs/proxy">阮一峰 Proxy</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN Proxy</a></p><p><strong>示例：</strong></p><p><a href="https://juejin.im/post/5a3cb0846fb9a044fb07f36c">使用 Javascript 原生的 Proxy 优化应用</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Storage封装</title>
    <link href="/2020/03/18/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/Storage%E5%B0%81%E8%A3%85/"/>
    <url>/2020/03/18/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/Storage%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Storage封装"><a href="#Storage封装" class="headerlink" title="Storage封装"></a>Storage封装</h1><p><strong>封装Storage的原因：</strong></p><ul><li>Storage本身有API，但是只是简单的key/value，不能存储更复杂的形式。</li><li>Storage只存储字符串，需要人工转换成json对象</li><li>Storage只能一次性清空，不能单个清空</li></ul><p><strong>封装方法</strong>：</p><ul><li>希望的session storage数据格式是：</li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584789505772.png" alt="1584789505772"></p><ul><li>在源代码src文件夹下新建storage文件夹，storage里新建index.js文件，index.js中的内容：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> STORAGE_KEY = <span class="hljs-string">&#x27;mall&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">getStorge</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">window</span>.sessionStorage.getItem(STORAGE_KEY) || <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">getItem</span>(<span class="hljs-params">key, module_name</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (module_name) &#123;<br>            <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.getItem(module_name);<br>            <span class="hljs-keyword">if</span> (val) &#123;<br>                <span class="hljs-keyword">return</span> val[key]<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getStorge()[key]<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">setItem</span>(<span class="hljs-params">key, value, module_name</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (module_name) &#123;<br>            <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.getItem(module_name);<br>            val[key] = value;<br>            <span class="hljs-built_in">this</span>.setItem(module_name,val)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.getStorge();<br>            val[key] = value;<br>            <span class="hljs-built_in">window</span>.sessionStorage.setItem(STORAGE_KEY, <span class="hljs-built_in">JSON</span>.stringify(val))<br>        &#125;<br><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params">key, module_name</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.getStorge();<br>        <span class="hljs-keyword">if</span> (module_name) &#123;<br>            <span class="hljs-keyword">if</span> (!val[module_name]) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">delete</span> val[module_name][key]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">delete</span> val[key]<br>        &#125;<br>        <span class="hljs-built_in">window</span>.sessionStorage.setItem(STORAGE_KEY, <span class="hljs-built_in">JSON</span>.stringify(val))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战:从零独立开发企业级电商系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新认识JavaScript面向对象 从ES5到ES6</title>
    <link href="/2020/03/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20%E4%BB%8EES5%E5%88%B0ES6/"/>
    <url>/2020/03/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20%E4%BB%8EES5%E5%88%B0ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="重新认识JavaScript面向对象-从ES5到ES6"><a href="#重新认识JavaScript面向对象-从ES5到ES6" class="headerlink" title="重新认识JavaScript面向对象: 从ES5到ES6"></a>重新认识JavaScript面向对象: 从ES5到ES6</h1><h2 id="一-重新认识面向对象"><a href="#一-重新认识面向对象" class="headerlink" title="一. 重新认识面向对象"></a>一. 重新认识面向对象</h2><h4 id="1-JavaScript是一门面向对象的语言"><a href="#1-JavaScript是一门面向对象的语言" class="headerlink" title="1. JavaScript是一门面向对象的语言"></a>1. JavaScript是一门面向对象的语言</h4><p>在说明JavaScript是一个面向对象的语言之前, 我们来探讨一下面向对象的三大基本特征:  <strong>封装</strong>, <strong>继承</strong>, <strong>多态</strong>。</p><p><strong>封装</strong></p><blockquote><p>把抽象出来的属性和对方法组合在一起, 且属性值被保护在内部, 只有通过特定的方法进行改变和读取称为封装</p></blockquote><p>我们以代码举例, 首先我们构造一个<code>Person</code>构造函数, 它有<code>name</code>和<code>id</code>两个属性, 并有一个<code>sayHi</code>方法用于打招呼:</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义Person构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, id</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.id = id;<br>&#125;<br><br><span class="hljs-comment">//在Person.prototype中加入方法</span><br>Person.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好, 我是&#x27;</span> +  <span class="hljs-built_in">this</span>.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们生成一个实例对象<code>p1</code>, 并调用<code>sayHi()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//实例化对象</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">1234</span>);<br><br><span class="hljs-comment">//调用sayHi方法</span><br>p1.sayHi();<br></code></pre></td></tr></table></figure><p>在上述的代码中, <code>p1</code>这个对象并不知道<code>sayHi()</code>这个方法是如何实现的, 但是仍然可以使用这个方法. 这其实就是<strong>封装</strong>. 你也可以实现对象属性的私有和公有, 我们在构造函数中声明一个<code>salary</code>作为私有属性, 有且只有通过<code>getSalary()</code>方法查询到薪资.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, id</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.id = id;<br>  <span class="hljs-keyword">let</span> salary = <span class="hljs-number">20000</span>;<br>  <span class="hljs-built_in">this</span>.getSalary = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pwd</span>) </span>&#123;<br>    pwd === <span class="hljs-number">123456</span> ? <span class="hljs-built_in">console</span>.log(salary) : <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;对不起, 你没有权限查看密码&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承</strong></p><blockquote><p>可以让某个类型的对象获得另一个类型的对象的属性和方法称为继承</p></blockquote><p>以刚才的<code>Person</code>作为父类构造器, 我们来新建一个子类构造器<code>Student</code>, 这里我们使用<code>call()</code>方法实现继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, id, subject</span>) </span>&#123;<br>  <span class="hljs-comment">//使用call实现父类继承</span><br>  Person.call(<span class="hljs-built_in">this</span>, name, id);<br>  <span class="hljs-comment">//添加子类的属性</span><br>  <span class="hljs-built_in">this</span>.subject = subject;<br>&#125;<br><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">1234</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>多态</strong></p><blockquote><p>同一操作作用于不同的对象产生不同的执行结果, 这称为多态</p></blockquote><p>JavaScript中函数没有重载， 所以JavaScript中的多态是靠函数覆盖实现的。</p><p>同样以刚才的<code>Person</code>构造函数为例, 我们为<code>Person</code>构造函数添加一个<code>study</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, id</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.id = id;<br>  <span class="hljs-built_in">this</span>.study = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">&#x27;在学习&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样, 我们新建一个<code>Student</code>和<code>Teacher</code>构造函数, 该构造函数继承<code>Person</code>, 并也添加<code>study</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.subject = subject;<br>  <span class="hljs-built_in">this</span>.study = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;在学习&#x27;</span> + <span class="hljs-built_in">this</span>.subject);<br>  &#125;<br>&#125;<br>Student.prototype = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">1234</span>);<br>Student.prototype.constructor = Student;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Teacher</span>(<span class="hljs-params">subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.subject = subject;<br>  <span class="hljs-built_in">this</span>.study = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;为了教学而学习&#x27;</span> + <span class="hljs-built_in">this</span>.subject);<br>  &#125;<br>&#125;<br>Teacher.prototype = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;老夫子&quot;</span>, <span class="hljs-number">4567</span>);<br>Teacher.prototype.constructor = Teacher;<br></code></pre></td></tr></table></figure><p>测试我们新建一个函数<code>doStudy</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doStudy</span>(<span class="hljs-params">role</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(role <span class="hljs-keyword">instanceof</span> Person) &#123;<br>    role.study();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们分别实例化<code>Student</code>和<code>Teacher</code>, 并调用<code>doStudy</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;前端开发&#x27;</span>);<br><span class="hljs-keyword">let</span> teacher = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&#x27;前端开发&#x27;</span>);<br><br>doStudy(student); <span class="hljs-comment">//阿辉在学习前端开发</span><br>doStudy(teacher); <span class="hljs-comment">//老夫子为了教学在学习前端开发</span><br></code></pre></td></tr></table></figure><p>对于同一函数<code>doStudy</code>， 由于参数的不同， 导致不同的调用结果，这就实现了多态.</p><p><strong>JavaScript的面向对象</strong><br> 从上面的分析可以论证出, JavaScript是一门面向对象的语言, 因为它实现了面向对象的所有特性. 其实, 面向对象仅仅是一个概念或者一个编程思想而已, 它不应该依赖于某个语言存在, 比如Java采用面向对象思想构造其语言, 它实现了类, 继承, 派生, 多态, 接口等机制. 但是这些机制，只是实现面向对象的一种手段， 而非必须。换言之， 一门语言可以根据自身特性选择合适的方式来实现面向对象。 由于大多数程序员首先学习的是Java, C++等高级编程语言， 因而先入为主的接受了“类”这个面向对象实际方式，所以习惯性的用类式面向对象语言中的概念来判断该语言是否是面向对象的语言。这也是很多有其他编程语言经验的人在学习JavaScript对象时，感觉到很困难的地方。</p><p>实际上， JavaScript是通过一种叫<strong>原型(prototype)<strong>的方式来实现面向对象编程的。下面我们就来讨论一下</strong>基于类(class-basesd)的面向对象</strong>和<strong>基于原型(protoype-based)的面向对象</strong>这两者的差别。</p><p><strong>基于类的面向对象</strong></p><p>在基于<strong>类</strong>的面向对象语言中（比如Java和C++）， 是构建在<strong>类(class)<strong>和</strong>实例(instance)<strong>上的。其中</strong>类</strong>定义了所有用于具有某一特征对象的属性。<strong>类</strong>是抽象的事物， 而不是其所描述的全部对象中的任何特定的个体。另一方面， 一个<strong>实例</strong>是一个<strong>类</strong>的实例化，是其中的一个成员。</p><p><strong>基于原型的面向对象</strong><br> 在基于<strong>原型</strong>的语言中（如JavaScript）并不存在这种区别：<strong>它只有对象！</strong>不论是构造函数(constructor)，实例(instance)，原型(prototype)本身都是对象。基于原型的语言具有所谓的原型对象的概念，新对象可以从中获得原始的属性。</p><p>所以，在JavaScript中有一个很有意思的<code>__proto__</code>属性（ES6以下是非标准属性）用于访问其原型对象， 你会发现，上面提到的构造函数，实例，原型本身都有<code>__proto__</code>指向原型对象。其最后顺着原型链都会指向<code>Object</code>这个构造函数，然而<code>Object</code>的原型对象的原型是<code>null</code>，不信， 你可以尝试一下<code>Object.prototype.__proto__ === null</code>为<code>true</code>。然而<code>typeof null === &#39;object&#39;</code>为<code>true</code>。到这里， 我相信你应该就能明白为什么JavaScript这类基于原型的语言中没有类和实例的区别， 而是<strong>万物皆对象！</strong></p><p><strong>差异总结</strong></p><table><thead><tr><th>基于类的（Java）</th><th>基于原型的（JavaScript）</th></tr></thead><tbody><tr><td>类和实例是不同的事物。</td><td>所有对象均为实例。</td></tr><tr><td>通过类定义来定义类；通过构造器方法来实例化类。</td><td>通过构造器函数来定义和创建一组对象。</td></tr><tr><td>通过 new 操作符创建单个对象。</td><td>相同</td></tr><tr><td>通过类定义来定义现存类的子类， 从而构建对象的层级结构</td><td>指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td></tr><tr><td>遵循类链接继承属性</td><td>遵循原型链继承属性</td></tr><tr><td>类定义指定类的所有实例的所有属性。无法在运行时动态添加属性</td><td>构造器函数或原型指定初始的属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。</td></tr></tbody></table><h2 id="二-ES5中的面向对象"><a href="#二-ES5中的面向对象" class="headerlink" title="二. ES5中的面向对象"></a>二. ES5中的面向对象</h2><blockquote><p>*这里的ES5并不特指ECMAScript 5， 而是代表ECMAScript 6 之前的ECMAScript！</p></blockquote><h4 id="一-ES5中对象的创建"><a href="#一-ES5中对象的创建" class="headerlink" title="(一) ES5中对象的创建"></a><strong>(一) ES5中对象的创建</strong></h4><p>在ES5中创建对象有两种方式， 第一种是使用对象字面量的方式， 第二种是使用构造函数的方式。该两种方法在特定的使用场景分别有其优点和缺点， 下面我们来分别介绍这两种创建对象的方式。</p><h5 id="1-使用对象字面量的方式"><a href="#1-使用对象字面量的方式" class="headerlink" title="1. 使用对象字面量的方式"></a><strong>1. 使用对象字面量的方式</strong></h5><p>我们通过对象字面量的方式创建两个<code>student</code>对象，分别是<code>student1</code>和<code>student2</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;阿辉&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>,<br>  <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;前端开发&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> student2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;阿傻&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>,<br>  <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;大数据开发&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码就是使用对象字面量的方式创建实例对象， 使用对象字面量的方式在创建单一简单对象的时候是非常方便的。但是，它也有其缺点：</p><ul><li>在生成多个实例对象时， 我们需要每次重复写<code>name</code>,<code>age</code>,<code>subject</code>属性，写起来特别的麻烦</li><li>虽然都是学生的对象， 但是看不出<code>student1</code>和<code>student2</code>之间有什么联系。</li></ul><p>为了解决以上两个问题， JavaScript提供了构造函数创建对象的方式。</p><h5 id="2-使用构造函数的方式"><a href="#2-使用构造函数的方式" class="headerlink" title="2. 使用构造函数的方式"></a><strong>2. 使用构造函数的方式</strong></h5><p>构造函数就其实就是一个普通的函数，当对构造函数使用<code>new</code>进行实例化时，会将其内部<code>this</code>的指向绑定实例对象上，下面我们来创建一个<code>Student</code>构造函数（构造函数约定使用大写开头，和普通函数做区分）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span> (<span class="hljs-params">name, age, subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age; <br>  <span class="hljs-built_in">this</span>.subject = subject;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我特意在构造函数中打印出<code>this</code>的指向。上面我们提到，构造函数其实就是一个普通的函数， 那么我们使用普通函数的调用方式尝试调用<code>Student</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Student(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>); <span class="hljs-comment">//window&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>采用普通方式调用<code>Student</code>时， <code>this</code>的指向是<code>window</code>。下面使用<code>new</code>来实例化该构造函数， 生成一个实例对象<code>student1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>); <span class="hljs-comment">//Student &#123;name: &quot;阿辉&quot;, age: 22, subject: &quot;前端开发&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>当我们采用<code>new</code>生成实例化对象<code>student1</code>时， <code>this</code>不再指向<code>window</code>, 而是指向的实例对象本身。这些， 都是<code>new</code>帮我们做的。上面的就是采用构造函数的方式生成实例对象的方式， 并且当我们生成其他实例对象时，由于都是采用<code>Student</code>这个构造函数实例化而来的， 我们能够清楚的知道各实例对象之间的联系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>);<br><span class="hljs-keyword">let</span> student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿傻&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;大数据开发&#x27;</span>);<br><span class="hljs-keyword">let</span> student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿呆&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;Python&#x27;</span>);<br><span class="hljs-keyword">let</span> student4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿笨&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;Java&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="二-ES5中对象的继承"><a href="#二-ES5中对象的继承" class="headerlink" title="(二) ES5中对象的继承"></a><strong>(二) ES5中对象的继承</strong></h4><h5 id="1-prototype的原型继承"><a href="#1-prototype的原型继承" class="headerlink" title="1. prototype的原型继承"></a><strong>1. prototype的原型继承</strong></h5><p><code>prototype</code>是JavaScript这类基于原型继承的核心， 只要弄明白了原型和原型链， 就基本上完全理解了JavaScript中对象的继承。下面我将着重的讲解为什么要使用<code>prototype</code>和使用<code>prototype</code>实现继承的方式。</p><p><strong>为什么要使用prototype？</strong></p><p>我们给之前的<code>Student</code>构造函数新增一个<code>study</code>方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span> (<span class="hljs-params">name, age, subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age; <br>  <span class="hljs-built_in">this</span>.subject = subject;<br>  <span class="hljs-built_in">this</span>.study = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我在学习&#x27;</span> + <span class="hljs-built_in">this</span>.subject);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来实例化<code>Student</code>构造函数， 生成<code>student1</code>和``student2<code>, 并分别调用其</code>study`方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>);<br><span class="hljs-keyword">let</span> student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿傻&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;大数据开发&#x27;</span>);<br><br>student1.study(); <span class="hljs-comment">//我在学习前端开发</span><br>student2.study(); <span class="hljs-comment">//我在学习大数据开发</span><br></code></pre></td></tr></table></figure><p>这样生成的实例对象表面上看没有任何问题， 但是其实是有很大的<strong>性能问题</strong>！我们来看下面一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(student1.study === student2.study); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>其实对于每一个实例对象<code>studentx</code>，其<code>study</code>方法的函数体是一模一样的，方法的执行结果只根据其实例对象决定（这就是多态），然而生成的每个实例都需要生成一个<code>study</code>方法去占用一份内存。这样是非常不经济的做法。新手可能会认为， 上面的代码中也就多生成了一个<code>study</code>方法， 对于内存的占用可以忽略不计。</p><p>现在我们应该知道应该将<code>study</code>方法挂载到<code>Student.prototype</code>原型对象上才是正确的写法，所有的<code>studentx</code>实例都能继承该方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span> (<span class="hljs-params">name, age, subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age; <br>  <span class="hljs-built_in">this</span>.subject = subject;<br>&#125;<br>Student.prototype.study = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我在学习&#x27;</span> + <span class="hljs-built_in">this</span>.subject);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们实例化<code>student1</code>和<code>student2</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>);<br><span class="hljs-keyword">let</span> student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿傻&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;大数据开发&#x27;</span>);<br><br>student1.study(); <span class="hljs-comment">//我在学习前端开发</span><br>student2.study(); <span class="hljs-comment">//我在学习大数据开发</span><br><br><span class="hljs-built_in">console</span>.log(student1.study === student2.study); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>从上面的代码我们可以看出， <code>student1</code>和<code>student2</code>的<code>study</code>方法执行结果没有发生变化，但是<code>study</code>本身指向了一个内存地址。这就是为什么我们要使用<code>prototype</code>进行挂载方法的原因。接下来我们来讲解一下如何使用<code>prototype</code>来实现继承。</p><h5 id="如何使用prototype实现继承？"><a href="#如何使用prototype实现继承？" class="headerlink" title="如何使用prototype实现继承？"></a><strong>如何使用prototype实现继承？</strong></h5><p>“学生”这个对象可以分为小学生， 中学生和大学生等。我们现在新建一个小学生的构造函数<code>Pupil</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pupil</span>(<span class="hljs-params">school</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.school = school;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如何让<code>Pupil</code>使用<code>prototype</code>继承<code>Student</code>呢? 其实我们只要将<code>Pupil</code>的<code>prototype</code>指向<code>Student</code>的一个实例即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Pupil.prototype = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小辉&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;小学义务教育课程&#x27;</span>);<br>Pupil.prototype.constructor = Pupil;<br><br><span class="hljs-keyword">let</span> pupil1 = <span class="hljs-keyword">new</span> Pupil(<span class="hljs-string">&#x27;北大附小&#x27;</span>);<br></code></pre></td></tr></table></figure><p>代码的第一行， 我们将<code>Pupil</code>的原型对象（<code>Pupil.prototype</code>）指向了<code>Student</code>的实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Pupil.prototype = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小辉&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;小学义务教育课程&#x27;</span>);<br></code></pre></td></tr></table></figure><p>代码的第二行也许有的读者会不能理解是什么意思。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Pupil.prototype.constructor = Pupil;<br></code></pre></td></tr></table></figure><p><code>Pupil</code>作为构造函数有一个<code>protoype</code>属性指向原型对象<code>Pupil.prototype</code>，而原型对象<code>Pupil.prototype</code>也有一个<code>constructor</code>属性指回它的构造函数<code>Pupil</code>。如下图所示：</p><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584425977636.png" alt="1584425977636"></p><p>然而， 当我们使用实例化<code>Student</code>去覆盖<code>Pupil.prototype后</code>， 如果没有第二行代码的情况下， <code>Pupil.prototype.constructor</code>指向了<code>Student</code>构造函数， 如下图所示：<br> <img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1584425996493.png" alt="1584425996493"></p><p>而且， <code>pupil1.constructor</code>会默认调用<code>Pupil.prototype.constructor</code>， 这个时候<code>pupil1.constructor</code>指向了<code>Student</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Pupil.prototype = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小辉&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;小学义务教育课程&#x27;</span>);<br><span class="hljs-keyword">let</span> pupil1 = <span class="hljs-keyword">new</span> Pupil(<span class="hljs-string">&#x27;北大附小&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(pupil1.constructor === Student); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>这明显是错误的， <code>pupil1</code>明明是用<code>Pupil</code>构造函数实例化出来的， 怎么其<code>constructor</code>指向了<code>Student</code>构造函数呢。所以， 我们就需要加入第二行， 修正其错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx">Pupil.prototype = new Student(&#x27;小辉&#x27;, 8, &#x27;小学义务教育课程&#x27;);<br><br>//修正constructor的指向错误<br>Pupil.prototype.constructor = Pupil;<br><br>let pupil1 = new Pupil(&#x27;北大附小&#x27;);<br><br>console.log(pupil1.constructor === Student); //false<br>console.log(pupil1.constructor === Pupil); //ture<br></code></pre></td></tr></table></figure><p>上面就是我们的如何使用<code>prototype</code>实现继承的例子， 需要特别注意的: <strong>如果替换了prototype对象， 必须手动将prototype.constructor重新指向其构造函数。</strong></p><h5 id="2-使用call和apply方法实现继承"><a href="#2-使用call和apply方法实现继承" class="headerlink" title="2. 使用call和apply方法实现继承"></a><strong>2. 使用call和apply方法实现继承</strong></h5><p>使用<code>call</code>和<code>apply</code>是我个人比较喜欢的继承方式， 因为只需要一行代码就可以实现继承。但是该方法也有其局限性，<code>call</code>和<code>apply</code>不能继承原型上的属性和方法， 下面会有详细说明。</p><p><strong>使用call实现继承</strong></p><p>同样对于上面的<code>Student</code>构造函数， 我们使用<code>call</code>实现<code>Pupil</code>继承<code>Student</code>的全部属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span> (<span class="hljs-params">name, age, subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age; <br>  <span class="hljs-built_in">this</span>.subject = subject;<br>&#125;<br><br><span class="hljs-comment">//子类构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pupil</span>(<span class="hljs-params">name, age, subject, school</span>) </span>&#123;<br>  <span class="hljs-comment">//使用call实现继承</span><br>  Student.call(<span class="hljs-built_in">this</span>, name, age, subject);<br>  <span class="hljs-built_in">this</span>.school = school;<br>&#125;<br><br><span class="hljs-comment">//实例化Pupil</span><br><span class="hljs-keyword">let</span> pupil2 = <span class="hljs-keyword">new</span> Pupil(<span class="hljs-string">&#x27;小辉&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;小学义务教育课程&#x27;</span>, <span class="hljs-string">&#x27;北大附小&#x27;</span>);<br></code></pre></td></tr></table></figure><p>需要注意的是， <code>call</code>和<code>apply</code>只能继承本地属性和方法， 而不能继承原型上的属性和方法，如下面的代码所示, 我们给<code>Student</code>挂载<code>study</code>方法，<code>Pupil</code>使用<code>call</code>继承<code>Student</code>后， 调用<code>pupil2.study()</code>会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span> (<span class="hljs-params">name, age, subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age; <br>  <span class="hljs-built_in">this</span>.subject = subject;<br>&#125;<br><span class="hljs-comment">//原型上挂载study方法</span><br>Student.prototype.study = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我在学习&#x27;</span> + <span class="hljs-built_in">this</span>.subject);<br>&#125;<br><br><span class="hljs-comment">//子类构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pupil</span>(<span class="hljs-params">name, age, subject, school</span>) </span>&#123;<br>  <span class="hljs-comment">//使用call实现继承</span><br>  Student.call(<span class="hljs-built_in">this</span>, name, age, subject);<br>  <span class="hljs-built_in">this</span>.school = school;<br>&#125;<br><br><span class="hljs-keyword">let</span> pupil2 = <span class="hljs-keyword">new</span> Pupil(<span class="hljs-string">&#x27;小辉&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;小学义务教育课程&#x27;</span>, <span class="hljs-string">&#x27;北大附小&#x27;</span>);<br><br><span class="hljs-comment">//报错</span><br>pupil2.study(); <span class="hljs-comment">//Uncaught TypeError: pupil2.study is not a function</span><br></code></pre></td></tr></table></figure><p><strong>使用apply实现继承</strong><br> 使用<code>apply</code>实现继承的方式和<code>call</code>类似， 唯一的不同只是参数需要使用数组的方法。下面我们使用<code>apply</code>来实现上面<code>Pupil</code>继承<code>Student</code>的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span> (<span class="hljs-params">name, age, subject</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age; <br>  <span class="hljs-built_in">this</span>.subject = subject;<br>&#125;<br><br><span class="hljs-comment">//子类构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pupil</span>(<span class="hljs-params">name, age, subject, school</span>) </span>&#123;<br>  <span class="hljs-comment">//使用applay实现继承</span><br>  Student.apply(<span class="hljs-built_in">this</span>, [name, age, subject]);<br>  <span class="hljs-built_in">this</span>.school = school;<br>&#125;<br><br><span class="hljs-comment">//实例化Pupil</span><br><span class="hljs-keyword">let</span> pupil2 = <span class="hljs-keyword">new</span> Pupil(<span class="hljs-string">&#x27;小辉&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;小学义务教育课程&#x27;</span>, <span class="hljs-string">&#x27;北大附小&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-其他继承方式"><a href="#3-其他继承方式" class="headerlink" title="3. 其他继承方式"></a><strong>3. 其他继承方式</strong></h5><p>JavaScript中的继承方式不仅仅只有上面提到的几种方法， 在《JavaScript高级程序设计》中， 还有实例继承，拷贝继承，组合继承，寄生组合继承等众多继承方式。在寄生组合继承中， 就很好的弥补了<code>call</code>和<code>apply</code>无法继承原型属性和方法的缺陷，是最完美的继承方法。这里就不详细的展开论述，感兴趣的可以自行阅读《JavaScript高级程序设计》。</p><h3 id="三-ES6中的面向对象"><a href="#三-ES6中的面向对象" class="headerlink" title="三. ES6中的面向对象"></a><strong>三. ES6中的面向对象</strong></h3><p>基于原型的继承方式，虽然实现了代码复用，但是行文松散且不够流畅，可阅读性差，不利于实现扩展和对源代码进行有效的组织管理。不得不承认，基于类的继承方式在语言实现上更健壮，且在构建可服用代码和组织架构程序方面具有明显的优势。所以，ES6中提供了基于类<code>class</code>的语法。但<code>class</code>本质上是ES6提供的一颗<strong>语法糖</strong>，正如我们前面提到的，<strong>JavaScript是一门基于原型的面向对象语言</strong>。</p><h4 id="一-ES6中对象的创建"><a href="#一-ES6中对象的创建" class="headerlink" title="(一) ES6中对象的创建"></a><strong>(一) ES6中对象的创建</strong></h4><p>我们使用ES6的<code>class</code>来创建<code>Student</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-comment">//构造方法</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age, subject</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.subject = subject;<br>  &#125;<br><br>  <span class="hljs-comment">//类中的方法</span><br>  <span class="hljs-function"><span class="hljs-title">study</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我在学习&#x27;</span> + <span class="hljs-built_in">this</span>.subject);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//实例化类</span><br><span class="hljs-keyword">let</span> student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;阿辉&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>);<br>student3.study(); <span class="hljs-comment">//我在学习前端开发</span><br></code></pre></td></tr></table></figure><p>上面的代码定义了一个<code>Student</code>类， 可以看到里面有一个<code>constructor</code>方法， 这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5中的构造函数<code>Student</code>， 对应的是E6中<code>Student</code>类中的<code>constructor</code>方法。</p><p><code>Student</code>类除了构造函数方法，还定义了一个<code>study</code>方法。需要特别注意的是，在ES6中定义类中的方法的时候，前面不需要加上<code>function</code>关键字，直接把函数定义进去就可以了。另外，方法之间不要用逗号分隔，加了会报错。而且，类中的方法全部是定义在原型上的，我们可以用下面的代码进行验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(student3.__proto__.study === Student.prototype.study); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(student3.hasOwnProperty(<span class="hljs-string">&#x27;study&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面的第一行的代码中, <code>student3.__proto__</code>是指向的原型对象，其中<code>Student.prototype</code>也是指向的原型的对象，结果为<code>true</code>就能很好的说明上面的结论： <strong>类中的方法全部是定义在原型上的</strong>。第二行代码是验证<code>student3</code>实例中是否有<code>study</code>方法，结果为<code>false</code>， 表明实例中没有<code>study</code>方法，这也更好的说明了上面的结论。其实，只要理解了<strong>ES5中的构造函数对应的是类中的constructor方法</strong>，就能推断出上面的结论。</p><h4 id="二-ES6中对象的继承"><a href="#二-ES6中对象的继承" class="headerlink" title="(二) ES6中对象的继承"></a><strong>(二) ES6中对象的继承</strong></h4><p>E6中<code>class</code>可以通过<code>extends</code>关键字来实现继承， 这比前面提到的ES5中使用原型链来实现继承， 要清晰和方便很多。下面我们使用ES6的语法来实现<code>Pupil</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pupil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age, subject, school</span>)</span> &#123;<br>    <span class="hljs-comment">//调用父类的constructor</span><br>    <span class="hljs-built_in">super</span>(name, age, subject); <br>    <span class="hljs-built_in">this</span>.school = school;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> pupil = <span class="hljs-keyword">new</span> Pupil(<span class="hljs-string">&#x27;小辉&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;小学义务教育课程&#x27;</span>, <span class="hljs-string">&#x27;北大附小&#x27;</span>);<br>pupil.study(); <span class="hljs-comment">//我在学习小学义务教育课程</span><br></code></pre></td></tr></table></figure><p>上面代码代码中， 我们通过了<code>extends</code>实现<code>Pupil</code>子类继承<code>Student</code>父类。需要特别注意的是，子类必须在<code>constructor</code>方法中<strong>首先调用super方法</strong>，否则实例化时会报错。这是因为子类没有自己的<code>this</code>对象， 而是继承父类的<code>this</code>对象，然后对其加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><p><a href="https://www.jianshu.com/p/2371055d0cc0">重新认识JavaScript面向对象: 从ES5到ES6</a> </p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript字符串</title>
    <link href="/2020/03/16/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/03/16/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript字符串"><a href="#JavaScript字符串" class="headerlink" title="JavaScript字符串"></a>JavaScript字符串</h1><p>JavaScript 字符串用于存储和处理文本。</p><ul><li><p>字符串可以是插入到引号中的任何字符。你可以使用单引号或双引号：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> carname = <span class="hljs-string">&quot;Volvo XC60&quot;</span>;<br><span class="hljs-keyword">var</span> carname = <span class="hljs-string">&#x27;Volvo XC60&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>可以使用索引位置来访问字符串中的每个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> character = carname[<span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure></li><li><p>可以在字符串中使用引号，字符串中的引号不要与字符串的引号相同:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> answer = <span class="hljs-string">&quot;It&#x27;s alright&quot;</span>;<br><span class="hljs-keyword">var</span> answer = <span class="hljs-string">&quot;He is called &#x27;Johnny&#x27;&quot;</span>;<br><span class="hljs-keyword">var</span> answer = <span class="hljs-string">&#x27;He is called &quot;Johnny&quot;&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>也可以在字符串添加转义字符来使用引号：</p><p> 反斜杠是一个<strong>转义字符</strong>。 转义字符将特殊字符转换为字符串字符：</p><p> 转义字符 () 可以用于转义撇号，换行，引号，等其他特殊字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;It\&#x27;s alright&#x27;</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-string">&quot;He is called \&quot;Johnny\&quot;&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>通常， JavaScript 字符串是原始值，可以使用字符创建： <code>var firstName = &quot;John&quot;</code></p><p>但我们也可以使用 new 关键字将字符串定义为一个对象： <code>var firstName = new String(&quot;John&quot;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;John&quot;</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><span class="hljs-keyword">typeof</span> x <span class="hljs-comment">// 返回 String</span><br><span class="hljs-keyword">typeof</span> y <span class="hljs-comment">// 返回 Object</span><br>(x === y) <span class="hljs-comment">// 结果为 false，因为 x 是字符串，y 是对象</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="字符串方法："><a href="#字符串方法：" class="headerlink" title="字符串方法："></a>字符串方法：</h3><table><thead><tr><th align="center">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>charAt()</code></td><td align="left">返回指定索引位置的字符</td></tr><tr><td align="center"><code>charCodeAt()</code></td><td align="left">返回指定索引位置字符的 Unicode 值</td></tr><tr><td align="center"><code>concat()</code></td><td align="left">连接两个或多个字符串，返回连接后的字符串</td></tr><tr><td align="center"><code>fromCharCode()</code></td><td align="left">将 Unicode 转换为字符串</td></tr><tr><td align="center"><code>indexOf()</code></td><td align="left">返回字符串中检索指定字符第一次出现的位置</td></tr><tr><td align="center"><code>lastIndexOf()</code></td><td align="left">返回字符串中检索指定字符最后一次出现的位置</td></tr><tr><td align="center"><code>localeCompare()</code></td><td align="left">用本地特定的顺序来比较两个字符串</td></tr><tr><td align="center"><code>match()</code></td><td align="left">找到一个或多个正则表达式的匹配。用来查找字符串中特定的字符，并且如果找到的话，则返回这个字符。</td></tr><tr><td align="center"><code>replace()</code></td><td align="left">替换与正则表达式匹配的子串</td></tr><tr><td align="center"><code>search()</code></td><td align="left">检索与正则表达式相匹配的值</td></tr><tr><td align="center"><code>slice()</code></td><td align="left">提取字符串的片断，并在新的字符串中返回被提取的部分</td></tr><tr><td align="center"><code>split()</code></td><td align="left">把字符串分割为子字符串数组</td></tr><tr><td align="center"><code>substr()</code></td><td align="left">从起始索引号提取字符串中指定数目的字符</td></tr><tr><td align="center"><code>substring()</code></td><td align="left">提取字符串中两个指定的索引号之间的字符</td></tr><tr><td align="center"><code>toLocaleLowerCase()</code></td><td align="left">根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td></tr><tr><td align="center"><code>toLocaleUpperCase()</code></td><td align="left">根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td></tr><tr><td align="center"><code>toLowerCase()</code></td><td align="left">把字符串转换为小写</td></tr><tr><td align="center"><code>toString()</code></td><td align="left">返回字符串对象值</td></tr><tr><td align="center"><code>toUpperCase()</code></td><td align="left">把字符串转换为大写</td></tr><tr><td align="center"><code>trim()</code></td><td align="left">移除字符串首尾空白</td></tr><tr><td align="center"><code>valueOf()</code></td><td align="left">返回某个字符串对象的原始值</td></tr><tr><td align="center"><code>toString()</code></td><td align="left">返回一个字符串。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;Hello world, welcome to the universe.&quot;</span>;<br><span class="hljs-keyword">var</span> n=str.indexOf(<span class="hljs-string">&quot;welcome&quot;</span>);<br><br><span class="hljs-built_in">document</span>.write(str.match(<span class="hljs-string">&quot;world&quot;</span>) + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br><span class="hljs-built_in">document</span>.write(str.match(<span class="hljs-string">&quot;World&quot;</span>) + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br><span class="hljs-built_in">document</span>.write(str.match(<span class="hljs-string">&quot;world!&quot;</span>));<br><br>str=<span class="hljs-string">&quot;Please visit Microsoft!&quot;</span><br><span class="hljs-keyword">var</span> n=str.replace(<span class="hljs-string">&quot;Microsoft&quot;</span>,<span class="hljs-string">&quot;Runoob&quot;</span>);<br><br><span class="hljs-keyword">var</span> txt=<span class="hljs-string">&quot;Hello World!&quot;</span>;       <span class="hljs-comment">// String</span><br><span class="hljs-keyword">var</span> txt1=txt.toUpperCase();   <span class="hljs-comment">// txt1 文本会转换为大写</span><br><span class="hljs-keyword">var</span> txt2=txt.toLowerCase();   <span class="hljs-comment">// txt2 文本会转换为小写</span><br><br>txt=<span class="hljs-string">&quot;a,b,c,d,e&quot;</span>   <span class="hljs-comment">// String</span><br>txt.split(<span class="hljs-string">&quot;,&quot;</span>);   <span class="hljs-comment">// 使用逗号分隔</span><br>txt.split(<span class="hljs-string">&quot; &quot;</span>);   <span class="hljs-comment">// 使用空格分隔</span><br>txt.split(<span class="hljs-string">&quot;|&quot;</span>);   <span class="hljs-comment">// 使用竖线分隔 </span><br></code></pre></td></tr></table></figure><p>学习自<a href="https://www.runoob.com/js/js-strings.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 class</title>
    <link href="/2020/03/15/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20class/"/>
    <url>/2020/03/15/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%20class/</url>
    
    <content type="html"><![CDATA[<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><p>传统的javascript中只有对象，没有类的概念。它是基于原型的面向对象语言。原型对象特点就是将自身的属性共享给新对象。</p><p>如果要生成一个对象实例，需要先定义一个构造函数，然后通过new操作符来完成。构造函数示例：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//函数名和实例化构造名相同且大写（非强制，但这么写有助于区分构造函数和普通函数）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age=age;<br>&#125;<br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我的名字叫&quot;</span> + <span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;今年&quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot;岁了&quot;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;laotie&quot;</span>,<span class="hljs-number">88</span>);<span class="hljs-comment">//通过构造函数创建对象，必须使用new 运算符</span><br><span class="hljs-built_in">console</span>.log(obj.say());<span class="hljs-comment">//我的名字叫laotie今年88岁了</span><br></code></pre></td></tr></table></figure><p>构造函数生成实例的执行过程：</p><ol><li>当使用了构造函数，并且new 构造函数(),后台会隐式执行new Object()创建对象;</li><li>将构造函数的作用域给新对象，（即new Object()创建出的对象），而函数体内的this就代表new Object()出来的对象。</li><li>执行构造函数的代码。</li><li>返回新对象（后台直接返回）;</li></ol><p>ES6引入了Class（类）这个概念，通过class关键字可以定义类。该关键字的出现使得其在对象写法上更加清晰，更像是一种面向对象的语言。如果将之前的代码改为ES6的写法就会是这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<span class="hljs-comment">//定义了一个名字为Person的类</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,age</span>)</span>&#123;<span class="hljs-comment">//constructor是一个构造方法，用来接收参数</span><br>        <span class="hljs-built_in">this</span>.name = name;<span class="hljs-comment">//this代表的是实例对象</span><br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//这是一个类的方法，注意千万不要加上function</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我的名字叫&quot;</span> + <span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;今年&quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot;岁了&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;laotie&quot;</span>,<span class="hljs-number">88</span>);<br><span class="hljs-built_in">console</span>.log(obj.say());<span class="hljs-comment">//我的名字叫laotie今年88岁了</span><br></code></pre></td></tr></table></figure><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ol><li><p>在类中声明方法的时候，千万不要给该方法加上function关键字</p></li><li><p>方法之间不要用逗号分隔，否则会报错</p></li><li><p><strong>class不存在变量提升</strong>，所以需要先定义再使用。因为ES6不会把类的声明提升到代码头部</p></li></ol><p>除了通过prototype属性对类添加方法，还可以通过Object.assign方法来为对象动态增加方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(Person.prototype,&#123;<br>    <span class="hljs-attr">getName</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;,<br>    <span class="hljs-attr">getAge</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;laotie&quot;</span>,<span class="hljs-number">88</span>);<br><span class="hljs-built_in">console</span>.log(obj.getName());<span class="hljs-comment">//laotie</span><br><span class="hljs-built_in">console</span>.log(obj.getAge());<span class="hljs-comment">//88</span><br></code></pre></td></tr></table></figure><h4 id="get-与-set-用法"><a href="#get-与-set-用法" class="headerlink" title="get 与 set 用法"></a>get 与 set 用法</h4><p>在 Class 内部可以使用get和set关键字， 对某个属性设置存值函数和取值函数， 拦截该属性的存取行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">prop</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title">prop</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> inst = <span class="hljs-keyword">new</span> MyClass();<br>inst.prop = <span class="hljs-number">123</span>;<br><span class="hljs-comment">// setter: 123</span><br>inst.prop<br><span class="hljs-comment">// &#x27;getter&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中， prop属性有对应的存值函数和取值函数， 因此赋值和读取行为都被自定义了。</p><p>学习自：</p><p><a href="https://www.jianshu.com/p/86267fab4878">es6中class类的全方面理解</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法目录</title>
    <link href="/2020/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9B%AE%E5%BD%95/"/>
    <url>/2020/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/104928951">栈</a>**：一种遵从先进后出 (LIFO) 原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/104928981">队列</a>**：与上相反，一种遵循先进先出 (FIFO / First In First Out) 原则的一组有序的项；队列在尾部添加新元素，并从头部移除元素。最新添加的元素必须排在队列的末尾。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/104929012">链表</a>**：存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的；每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针/链接）组成。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/104929093">集合</a>**：由一组无序且唯一（即不能重复）的项组成；这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/104929143">字典</a>**：以 [键，值] 对为数据形态的数据结构，其中键名用来查询特定元素，类似于 Javascript 中的<code>Object</code>。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/105126189">散列</a>**：根据关键码值（Key value）直接进行访问的数据结构；它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度；这个映射函数叫做散列函数，存放记录的数组叫做散列表。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/104929181">树</a>**：由 n（n&gt;=1）个有限节点组成一个具有层次关系的集合；把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的，基本呈一对多关系，树也可以看做是图的特殊形式。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/104930984">图</a>**：图是网络结构的抽象模型；图是一组由边连接的节点（顶点）；任何二元关系都可以用图来表示，常见的比如：道路图、关系图，呈多对多关系。</li><li>**<a href="https://blog.csdn.net/weixin_46124214/article/details/105184532">堆</a>**：<br>二叉堆本质上是一种完全二叉树，二叉堆的经典表示方法是使用一个数组表示。</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><a href="https://blog.csdn.net/weixin_46124214/article/details/104955903">排序算法</a></h4><ul><li><p><strong>冒泡排序</strong></p></li><li><p><strong>选择排序</strong></p></li><li><p><strong>插入排序</strong></p></li><li><p><strong>希尔排序</strong></p></li><li><p><strong>归并排序</strong></p></li><li><p><strong>快速排序</strong></p></li><li><p><strong>堆排序</strong></p></li><li><p><strong>计数排序</strong></p></li><li><p><strong>桶排序</strong></p></li><li><p><strong>基数排序</strong><br><img src="https://img-blog.csdnimg.cn/20200315192210454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200325123529183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a><a href="https://blog.csdn.net/weixin_46124214/article/details/104978186">查找算法</a></h4></li><li><p><strong>顺序查找</strong></p></li><li><p><strong>二分查找</strong></p></li><li><p><strong>插值查找</strong></p></li><li><p><strong>斐波那契查找</strong></p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><a href="https://blog.csdn.net/weixin_46124214/article/details/105019491"><strong>复杂度分析</strong></a></p></li><li><p><a href="https://blog.csdn.net/weixin_46124214/article/details/105342084"><strong>递归算法与分治算法</strong></a></p></li><li><p><a href="https://blog.csdn.net/weixin_46124214/article/details/105342149"><strong>回溯算法</strong></a></p></li></ul><ul><li><strong><a href="https://blog.csdn.net/weixin_46124214/article/details/105016279">贪心算法</a></strong></li><li><a href="https://blog.csdn.net/weixin_46124214/article/details/105342125"><strong>动态规划</strong></a></li></ul><h4 id="很赞的资料"><a href="#很赞的资料" class="headerlink" title="很赞的资料"></a>很赞的资料</h4><ul><li><a href="https://juejin.im/post/5d5b307b5188253da24d3cd1">前端该如何准备数据结构和算法？</a></li><li><a href="http://www.conardli.top/docs/">awesome-coding-js</a></li><li><a href="http://caibaojian.com/learn-javascript.html">JavaScript中的数据结构和算法学习</a></li><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html?tdsourcetag=s_pctim_aiomsg">十大经典排序算法（动图演示）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>props-model-vuex</title>
    <link href="/2020/03/15/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/props-model-vuex/"/>
    <url>/2020/03/15/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/props-model-vuex/</url>
    
    <content type="html"><![CDATA[<h3 id="props使用："><a href="#props使用：" class="headerlink" title="props使用："></a>props使用：</h3><p>不推荐使用数组的方式，对系统后续维护不利。</p><figure class="highlight prolog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs prolog">props:[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;list&#x27;</span>, <span class="hljs-string">&#x27;isVisible&#x27;</span>]<br></code></pre></td></tr></table></figure><p>推荐以下写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">props: &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>,<br><span class="hljs-attr">type</span>: &#123;<br><span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br><span class="hljs-comment">//这个值必须匹配下列字符串的一个</span><br><span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-string">&quot;danger&quot;</span>].includes(value);<br>&#125;<br>&#125;,<br>    <span class="hljs-attr">list</span>: &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>,<br><span class="hljs-comment">//对象或数组默认值必须从一个工厂函数获取</span><br>            <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> []<br>    &#125;，<br>    <span class="hljs-attr">isVisible</span>: &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">Boolean</span>,<br>            <span class="hljs-attr">default</span>:<span class="hljs-literal">false</span><br>    &#125;,<br>    <span class="hljs-attr">onChange</span>: &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">Function</span>,<br>            <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="v-model语法糖实现"><a href="#v-model语法糖实现" class="headerlink" title="v-model语法糖实现"></a>v-model语法糖实现</h3><p>index.vue中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">PersonalInfo</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;phoneInfo&quot;</span>/&gt;</span><br>//v-model方式和下列方式等效<br>        <span class="hljs-tag">&lt;<span class="hljs-name">PersonInfo</span></span><br><span class="hljs-tag"><span class="hljs-attr">:phone-info</span>=<span class="hljs-string">&quot;phoneInfo&quot;</span></span><br><span class="hljs-tag">@<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;val =&gt; (phoneInfo = val)&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br>         phoneInfo:&#123;&#123;phoneInfo&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> PersonalInfo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./PersonalInfo&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">        PersonalInfo</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-attr">phoneInfo</span>: &#123;</span><br><span class="javascript">                <span class="hljs-attr">areaCode</span>: <span class="hljs-string">&quot;+86&quot;</span>,</span><br><span class="javascript">                <span class="hljs-attr">phone</span>:<span class="hljs-string">&quot;&quot;</span></span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>personalInfo.vue文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">           <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;phoneInfo.phone&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;手机号&quot;</span></span><br><span class="hljs-tag">           @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;handlePhoneChange&quot;</span></span><br><span class="hljs-tag">     /&gt;</span>                                    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;PersonalInfo&quot;</span>,</span><br><span class="javascript">    <span class="hljs-attr">model</span>: &#123;</span><br><span class="javascript">        <span class="hljs-attr">prop</span>:<span class="hljs-string">&quot;phoneInfo&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">event</span>:<span class="hljs-string">&quot;change&quot;</span></span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="javascript">        <span class="hljs-attr">phoneInfo</span>:<span class="hljs-built_in">Object</span></span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">handleAreaCodeChange</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;change&quot;</span>, &#123;</span><br><span class="javascript">                ...this.phoneInfo,</span><br><span class="javascript">                <span class="hljs-attr">areaCode</span>:e.target.value</span><br><span class="javascript">            &#125;);</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">handlePhoneChange</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;change&quot;</span>, &#123;</span><br><span class="javascript">                ...this.phoneInfo,</span><br><span class="javascript">                <span class="hljs-attr">phone</span>:e.target.value</span><br><span class="javascript">            &#125;);</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="min-Vuex实现"><a href="#min-Vuex实现" class="headerlink" title="min-Vuex实现"></a>min-Vuex实现</h3><p>在min-vuex.js中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> Store = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Store</span> (<span class="hljs-params">options = &#123;&#125;</span>) </span>&#123;<br><span class="hljs-keyword">const</span> &#123;state = &#123;&#125;, mutations = &#123;&#125;&#125; = options;<br><span class="hljs-built_in">this</span>._vm = <span class="hljs-keyword">new</span> Vue(&#123;<br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">$$state</span>: state<span class="hljs-comment">//通过把state放入new Vue(&#123;&#125;)的data选项里，使state变成响应式数据</span><br>&#125;,<br>&#125;)<br><span class="hljs-built_in">this</span>._mutations = mutations;<br>&#125;<br><br>Store.prototype.commit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, payload</span>) </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>._mutations[type]) &#123;<br><span class="hljs-built_in">this</span>._mutations[type](<span class="hljs-built_in">this</span>.state, payload)<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">Object</span>.defineProperties(Store.prototype, &#123;<br><span class="hljs-attr">state</span>: &#123;<br><span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._vm._data.$$state;<br>&#125;<br>&#125;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;Store&#125;<br></code></pre></td></tr></table></figure><p>在main.js中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./min-vuex&#x27;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br>Vue.use(Vuex);<br>Vue.config.productionTip = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">count</span>:<span class="hljs-number">0</span>,<br>    &#125;,<br>    <span class="hljs-attr">mutations</span>: &#123;<br>        <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state</span>)</span> &#123;<br>            state.count++<br>        &#125;<br>    &#125;,<br>&#125;)<br>Vue.prototype.$store = store;<br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>App.vue中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>&#123;&#123;count&#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$store.commit(&#x27;increment&#x27;)&quot;</span>&gt;</span>count++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;app&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">computed</span>:&#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">count</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式</title>
    <link href="/2020/03/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/03/12/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript设计模式"><a href="#JavaScript设计模式" class="headerlink" title="JavaScript设计模式"></a>JavaScript设计模式</h1><p><strong>设计模式</strong>代码经验的总结，是可重用的用于解决软件设计中一般问题的方案。<br>设计模式都是面向对象的。</p><p>学习设计模式，有助于写出可复用和可维护性高的程序。</p><h3 id="常用的12种设计模式："><a href="#常用的12种设计模式：" class="headerlink" title="常用的12种设计模式："></a>常用的12种设计模式：</h3><ul><li><hr><p><strong><a href="#jump1">工厂模式</a></strong></p></li><li><p><strong><a href="#jump2">单例模式</a></strong></p></li><li><p><strong><a href="#jump3">原型模式</a></strong></p></li><li><p><strong><a href="#jump4">适配器模式</a></strong></p></li><li><p><strong><a href="#jump5">代理模式</a></strong></p></li><li><p><strong><a href="#jump6">策略模式</a></strong></p></li><li><p><strong><a href="#jump7">迭代器模式</a></strong></p></li><li><p><strong><a href="#jump8">观察者模式</a></strong></p></li><li><p><strong><a href="#jump9">发布-订阅模式</a></strong></p></li><li><p><strong><a href="#jump10">命令模式</a></strong></p></li><li><p><strong><a href="#jump11">组合模式</a></strong></p></li><li><p><strong><a href="#jump12">建造者模式</a></strong></p></li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li><p><strong>单一职责原则（SRP）</strong></p><p>一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。</p><p>应该把对象或方法划分成较小的粒度。</p></li><li><p><strong>最少知识原则（LKP）</strong></p><p>一个软件实体应当 尽可能少地与其他实体发生相互作用 </p><p>应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p></li><li><p><strong>开放-封闭原则（OCP）</strong></p><p>软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改</p><p>当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p></li></ul><h2 id="（一）工厂模式"><a href="#（一）工厂模式" class="headerlink" title="（一）工厂模式"></a><span id="jump1">（一）工厂模式</span></h2><h4 id="1-什么是工厂模式？"><a href="#1-什么是工厂模式？" class="headerlink" title="1. 什么是工厂模式？"></a>1. 什么是工厂模式？</h4><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><p>工厂模式是用来创建对象的一种最常用的设计模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。</p><p>工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。</p><h4 id="2-工厂模式目的？"><a href="#2-工厂模式目的？" class="headerlink" title="2. 工厂模式目的？"></a>2. 工厂模式目的？</h4><p><strong>工厂模式</strong>的目的是为了创建对象，它通常在类或者类的静态方法中实现，具有以下目标：</p><ul><li>当创建相似对象时执行重复操作</li><li>当编译时不知道具体类型的情况下，为工厂客户提供一个创建对象的接口</li></ul><p>与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。</p><h4 id="3-工厂模式使用场景？"><a href="#3-工厂模式使用场景？" class="headerlink" title="3. 工厂模式使用场景？"></a>3. 工厂模式使用场景？</h4><p>那么什么时候使用工厂模式呢，以下几种情景下工厂模式特别有用：</p><ul><li>对象的构建十分复杂</li><li>需要依赖具体环境创建不同实例</li><li>处理大量具有相同属性的小对象</li></ul><p>什么时候不该用工厂模式：<br>不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去。</p><h4 id="4-详细内容与例子可学习："><a href="#4-详细内容与例子可学习：" class="headerlink" title="4. 详细内容与例子可学习："></a>4. 详细内容与例子可学习：</h4><p><a href="https://www.jianshu.com/p/11918dd0f694">从ES6重新认识JavaScript设计模式(二): 工厂模式</a></p><p><a href="https://segmentfault.com/a/1190000012422198">JS工厂模式</a></p><p><a href="https://www.cnblogs.com/TomXu/archive/2012/02/23/2353389.html">设计模式之工厂模式</a></p><h2 id="（二）单例模式"><a href="#（二）单例模式" class="headerlink" title="（二）单例模式"></a><span id="jump2">（二）单例模式</span></h2><h4 id="1-什么是单例模式"><a href="#1-什么是单例模式" class="headerlink" title="1. 什么是单例模式?"></a>1. 什么是单例模式?</h4><p>限制类实例化次数只能一次，一个类只有一个实例，并提供一个访问它的全局访问点。</p><h4 id="2-单例模式的目的？"><a href="#2-单例模式的目的？" class="headerlink" title="2. 单例模式的目的？"></a>2. 单例模式的目的？</h4><p>通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p><h4 id="3-单例模式使用场景？"><a href="#3-单例模式使用场景？" class="headerlink" title="3. 单例模式使用场景？"></a>3. 单例模式使用场景？</h4><p>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。在JavaScript开发中，单例模式的用途同样非常广泛。试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗用单例模式来创建。</p><h4 id="4-单例模式的特点？"><a href="#4-单例模式的特点？" class="headerlink" title="4. 单例模式的特点？"></a>4. 单例模式的特点？</h4><ul><li><p>类只有一个实例</p></li><li><p>全局可访问该实例</p></li><li><p>自行实例化（主动实例化）</p></li><li><p>可推迟初始化，即延迟执行（与静态类/对象的区别）</p></li></ul><p>JavaScript 是一门非正规面向对象的语言，并没有类的定义。而单例模式要求一个 “唯一” 和 “全局访问” 的对象，在 JavaScript 中类似全局对象，刚好满足单例模式的两个特点：“唯一” 和 “可全局访问”。虽然它不是正规的单例模式，但不可否认确实具备类单例模式的特点。</p><h5 id="使用全局变量会有以下问题："><a href="#使用全局变量会有以下问题：" class="headerlink" title="使用全局变量会有以下问题："></a>使用全局变量会有以下问题：</h5><ul><li><p>命名空间污染（变量名冲突）</p></li><li><p>维护时不方便管控（容易不小心覆盖）</p></li></ul><h5 id="全局变量问题折中的应对方案："><a href="#全局变量问题折中的应对方案：" class="headerlink" title="全局变量问题折中的应对方案："></a>全局变量问题折中的应对方案：</h5><ul><li><p>使用命名空间</p></li><li><p>闭包封装私有变量（利用函数作用域）</p></li><li><p>ES6的 const/symbol</p></li></ul><p>虽然全局变量可以实现单例，但因其自身的问题，不建议在实际项目中将其作为单例模式的应用，特别是中大型项目的应用中，全局变量的维护该是考虑的成本。</p><h4 id="5-单例模式优缺点："><a href="#5-单例模式优缺点：" class="headerlink" title="5. 单例模式优缺点："></a>5. 单例模式优缺点：</h4><p><strong>优点：</strong></p><ul><li>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。</li><li>灵活性<br>因为类控制了实例化过程，所以类可以灵活更改实例化过程。</li></ul><p><strong>缺点：</strong></p><ul><li>开销<br>虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。</li><li>可能的开发混淆<br>使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。</li><li>就是不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li></ul><h4 id="6-单例模式的思路："><a href="#6-单例模式的思路：" class="headerlink" title="6. 单例模式的思路："></a>6. 单例模式的思路：</h4><p>一个类能返回一个对象的引用（并且永远是同一个）和一个获得该实例的方法（静态方法，通常使用 getInstance 名称）。</p><p>那么当我们调用这个方法时，如果类持有的引用不为空就返回该引用，否者就创建该类的实例，并且将实例引用赋值给该类保持的那个引用再返回。同时将该类的构造函数定义为私有方法，避免其他函数使用该构造函数来实例化对象，只通过该类的静态方法来得到该类的唯一实例</p><h4 id="7-详细内容与例子可学习："><a href="#7-详细内容与例子可学习：" class="headerlink" title="7. 详细内容与例子可学习："></a>7. 详细内容与例子可学习：</h4><p><a href="https://www.jianshu.com/p/5386936acfec">从ES6重新认识JavaScript设计模式(一): 单例模式</a></p><p><a href="https://juejin.im/post/5d11bcdcf265da1b94215726">JavaScript 设计模式（一）：单例模式</a></p><p><a href="https://www.cnblogs.com/TomXu/archive/2012/02/20/2352817.html">深入理解JavaScript系列（25）：设计模式之单例模式</a></p><h2 id="（三）原型模式？"><a href="#（三）原型模式？" class="headerlink" title="（三）原型模式？"></a><span id="jump3">（三）原型模式？</span></h2><h4 id="1-什么是原型模式？"><a href="#1-什么是原型模式？" class="headerlink" title="1. 什么是原型模式？"></a>1. 什么是原型模式？</h4><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h4 id="2-原型模式的实现"><a href="#2-原型模式的实现" class="headerlink" title="2. 原型模式的实现"></a>2. 原型模式的实现</h4><p>对于原型模式，我们可以利用JavaScript特有的原型继承特性去创建对象的方式，也就是创建的一个对象作为另外一个对象的prototype属性值。原型对象本身就是有效地利用了每个构造器创建的对象，例如，如果一个构造函数的原型包含了一个name属性，那通过这个构造函数创建的对象都会有这个属性。</p><p>在现有的文献里查看原型模式的定义，没有针对JavaScript的，你可能发现很多讲解的都是关于类的，但是现实情况是基于原型继承的JavaScript完全避免了类（class）的概念。我们只是简单从现有的对象进行拷贝来创建对象。</p><p>真正的原型继承是作为最新版的ECMAScript5标准提出的，使用<code>Object.create</code>方法来创建这样的对象，该方法创建指定的对象，其对象的prototype有指定的对象（也就是该方法传进的第一个参数对象），也可以包含其他可选的指定属性。例如<code>Object.create(prototype, optionalDescriptorObjects)</code>，下面的例子里也可以看到这个用法：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 因为不是构造函数，所以不用大写</span><br><span class="hljs-keyword">var</span> someCar = &#123;    <br>    <span class="hljs-attr">drive</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;,    <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;马自达 3&#x27;</span><br>&#125;;<br><span class="hljs-comment">// 使用Object.create创建一个新车x</span><br><span class="hljs-keyword">var</span> anotherCar = <span class="hljs-built_in">Object</span>.create(someCar);<br>notherCar.name = <span class="hljs-string">&#x27;丰田佳美&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Object.create运行你直接从其它对象继承过来，使用该方法的第二个参数，你可以初始化额外的其它属性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vehicle = &#123;    <br>    <span class="hljs-attr">getModel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;车辆的模具是：&#x27;</span> + <span class="hljs-built_in">this</span>.model);    <br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> car = <span class="hljs-built_in">Object</span>.create(vehicle, &#123;    <br>    <span class="hljs-string">&#x27;id&#x27;</span>: &#123;        <br>        <span class="hljs-attr">value</span>: MY_GLOBAL.nextId(),        <br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 默认writable:false, configurable:false </span><br>    &#125;,    <br>    <span class="hljs-string">&#x27;model&#x27;</span>: &#123;        <br>        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;福特&#x27;</span>,        <br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>    <br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里，可以在Object.create的第二个参数里使用对象字面量传入要初始化的额外属性，其语法与<code>Object.defineProperties</code>或<code>Object.defineProperty</code>方法类型。它允许您设定属性的特性，例如enumerable, writable 或 configurable。</p><p><strong>学习摘自：</strong></p><p><a href="https://www.cnblogs.com/TomXu/archive/2012/04/16/2436460.html">深入理解JavaScript系列（42）：设计模式之原型模式</a></p><h2 id="（四）适配器模式"><a href="#（四）适配器模式" class="headerlink" title="（四）适配器模式"></a><span id="jump4">（四）适配器模式</span></h2><h4 id="1-什么是适配器模式？"><a href="#1-什么是适配器模式？" class="headerlink" title="1. 什么是适配器模式？"></a>1. 什么是适配器模式？</h4><p>**适配器模式(Adapter)**：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h4 id="2-适配器模式使用场景？"><a href="#2-适配器模式使用场景？" class="headerlink" title="2. 适配器模式使用场景？"></a>2. 适配器模式使用场景？</h4><p>在前端开发中，我们可能会遇见这样的场景：当我们试图调用某个模块或者对象的接口时，却发现这个<strong>接口的格式不符合我们的需求</strong>。这时有两种解决办法：第一种是修改原来的接口实现，但如果原来的代码很复杂，例如是一个库或框架，更改原代码就显得很不现实了。所以这时就需要使用今天所讲的第二种办法：创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要使用适配器即可。</p><p>前端项目中，适配器模式的使用场景一般有以下三种情况：库的适配、参数的适配和数据的适配。下面将以在项目中的实际例子来说明。</p><h5 id="ES6中的适配器模式"><a href="#ES6中的适配器模式" class="headerlink" title="ES6中的适配器模式"></a>ES6中的适配器模式</h5><ul><li> <strong>库的适配</strong></li></ul><p>  项目上线前通常会要求前端开发者在页面中会接入统计网页数据用的SDK，这些SDK能够采集用户的信息和网页行生成可视化的图表和表格，来帮助网站运营人员和产品经理更好的根据用户行为来提升网页质量。</p><ul><li><p><strong>参数的适配</strong></p><p>有的情况下一个方法可能需要传入多个参数。</p></li><li><p><strong>数据的适配</strong></p><p>数据的适配在前端中是最为常见的场景，这时适配器在解决前后端的数据依赖上有着重要的意义。通常服务器端传递的数据和我们前端需要使用的数据格式是不一致的，特别是在在使用一些UI框架时，框架所规定的数据有着固定的格式。所以，这个时候我们就需要对后端的数据格式进行适配。</p></li></ul><h4 id="3-详细内容与示例见："><a href="#3-详细内容与示例见：" class="headerlink" title="3. 详细内容与示例见："></a>3. 详细内容与示例见：</h4><p><a href="https://www.jianshu.com/p/2701e7e59e69">从ES6重新认识JavaScript设计模式(四): 适配器模式</a></p><p><a href="https://juejin.im/post/5d1321a7f265da1b802055e5">JavaScript 设计模式（四）：适配者模式</a></p><h2 id="（五）代理模式"><a href="#（五）代理模式" class="headerlink" title="（五）代理模式"></a><span id="jump5">（五）代理模式</span></h2><h4 id="1-什么是代理模式？"><a href="#1-什么是代理模式？" class="headerlink" title="1. 什么是代理模式？"></a>1. 什么是代理模式？</h4><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>（当客户不方便直接访问一个 对象或者不满足需要的时候，提供一个替身对象 来控制对这个对象的访问，客户实际上访问的是 替身对象。</p><p>替身对象对请求做出一些处理之后， 再把请求转交给本体对象</p><p>代理和本体的接口具有一致性，本体定义了关键功能，而代理是提供或拒绝对它的访问，或者在访问本体之前做一 些额外的事情。）</p><h4 id="2-代理模式使用场景？"><a href="#2-代理模式使用场景？" class="headerlink" title="2. 代理模式使用场景？"></a>2. 代理模式使用场景？</h4><p>利用ES6中的<code>Proxy</code>实现前端中3种代理模式的使用场景，分别是：</p><p><strong>缓存代理</strong>、<strong>验证代理</strong>、<strong>实现私有属性</strong>。</p><p>ES6所提供<code>Proxy</code>构造函数能够让我们轻松的使用代理模式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><p><code>Proxy</code>构造函数传入两个参数，第一个参数<code>target</code>表示所要代理的对象，第二个参数<code>handler</code>也是一个对象用来设置对所代理的对象的行为。如果想知道<code>Proxy</code>的具体使用方法，可参考阮一峰的<a href="http://es6.ruanyifeng.com/#docs/proxy">《 ECMAScript入门 - Proxy 》</a>。</p><h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>缓存代理可以将一些开销很大的方法的运算结果进行缓存，再次调用该函数时，若参数一致，则可以直接返回缓存中的结果，而不用再重新进行运算。例如在采用后端分页的表格时，每次页码改变时需要重新请求后端数据，我们可以将页码和对应结果进行缓存，当请求同一页时就不用在进行ajax请求而是直接返回缓存中的数据。</p><h5 id="验证代理"><a href="#验证代理" class="headerlink" title="验证代理"></a>验证代理</h5><p><code>Proxy</code>构造函数第二个参数中的<code>set</code>方法，可以很方便的验证向一个对象的传值。我们以一个传统的登陆表单举例，该表单对象有两个属性,分别是<code>account</code>和<code>password</code>，每个属性值都有一个简单和其属性名对应的验证方法</p><h5 id="实现私有属性"><a href="#实现私有属性" class="headerlink" title="实现私有属性"></a>实现私有属性</h5><p>代理模式还有一个很重要的应用是实现访问限制。总所周知，JavaScript是没有私有属性这一个概念的，通常私有属性的实现是通过函数作用域中变量实现的，虽然实现了私有属性，但对于可读性来说并不好。</p><p>私有属性一般是以<code>_</code>下划线开头，通过<code>Proxy</code>构造函数中的第二个参数所提供的方法，我们可以很好的去限制以<code>_</code>开头的属性的访问。</p><h4 id="3-使用代理模式的意义"><a href="#3-使用代理模式的意义" class="headerlink" title="3. 使用代理模式的意义"></a>3. 使用代理模式的意义</h4><ul><li><p>遵循“单一职责原则”，面向对象设计中鼓励将不同的职责分布到细粒度的对象中，<code>Proxy</code> 在原对象的基础上进行了功能的衍生而又不影响原对象，符合松耦合高内聚的设计理念</p></li><li><p>遵循“开放-封闭原则”，代理可以随时从程序中去掉，而不用对其他部分的代码进行修改，在实际场景中，随着版本的迭代可能会有多种原因不再需要代理，那么就可以容易的将代理对象换成原对象的调用</p></li></ul><h4 id="4-详细内容与例子见："><a href="#4-详细内容与例子见：" class="headerlink" title="4. 详细内容与例子见："></a>4. 详细内容与例子见：</h4><p><a href="https://www.jianshu.com/p/d791a84c5733">从ES6重新认识JavaScript设计模式(五): 代理模式和Proxy</a></p><h2 id="（六）策略模式"><a href="#（六）策略模式" class="headerlink" title="（六）策略模式"></a><span id="jump6">（六）策略模式</span></h2><h4 id="1-什么是策略模式？"><a href="#1-什么是策略模式？" class="headerlink" title="1. 什么是策略模式？"></a>1. 什么是策略模式？</h4><p>定义一系列的算法，把它们一个个封装起来，并使它们可以替换。</p><p><strong>栗子：</strong></p><p>诸葛给刘备的锦囊妙计，遇到任何困难都有应对计策。策略模式实现的也是类似的场景。</p><p>给喜欢的女生买冰淇淋，事先不了解其喜好，只能集齐各种味道，总会命中。就是比较 “费钱”，这也是策略模式的缺点，需事先考虑所有应对场景。</p><h4 id="2-策略模式特点？"><a href="#2-策略模式特点？" class="headerlink" title="2. 策略模式特点？"></a>2. 策略模式特点？</h4><ul><li><p>策略类：算法封装成独立的函数/对象</p></li><li><p>环境类：根据不同参数调用对应的策略函数/对象执行</p></li></ul><h4 id="3-策略模式实现："><a href="#3-策略模式实现：" class="headerlink" title="3. 策略模式实现："></a>3. 策略模式实现：</h4><p>将算法的使用和算法的实现分离开来。</p><p><strong>实现方式：</strong></p><p>一个基于策略模式的程序至少由两部分组成，</p><p>第一个部分是一组策略类 Strategies（可变），策略类封装类具体的算法，并负责具体的计算过程。</p><p>第二个部分是环境类 Context（不变）， Context 接收客户的请求，随后把请求委托给某一个策略类。</p><p><strong>例子：</strong></p><p>假设我们一个开发团队，人员组成包括（开发组长，后端，前端，测试）。开发组长领取开发任务（不变），但具体的任务执行人员可根据类型划分（可变）。</p><p>比如开发任务有以下几项：</p><ul><li><p>优化服务器缓存（后端任务）</p></li><li><p>优化首屏加载速度（前端任务）</p></li><li><p>完成系统并发测试（测试任务）</p></li></ul><p>开发组长会根据任务类型，分发到对应的开发人员头上，组长不承担具体开发任务。所以每一个开发人员就承担 Strategy 的作用（独立的任务执行），而组长拥有并可支配所有开发人员的资源，充当 Context 的角色。团队每一个开发人员<strong>“组合”</strong>起来就是一个 Strategies 类（执行开发任务）。 这个 Strategies 是可变的，如果说后续开发任务需要安卓的、IOS的支持，只要添加安卓、IOS开发人员配置即可（可扩展）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 策略类（开发人员）</span><br><span class="hljs-keyword">var</span> Strategies = &#123;<br>    <span class="hljs-string">&quot;backend&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;进行后端任务：&#x27;</span>, task);<br>    &#125;,<br>    <span class="hljs-string">&quot;frontend&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;进行前端任务：&#x27;</span>, task);<br>    &#125;,<br>    <span class="hljs-string">&quot;testend&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;进行测试任务：&#x27;</span>, task);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//  环境类（开发组长）</span><br><span class="hljs-keyword">var</span> Context = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, task</span>) </span>&#123;<br>    <span class="hljs-keyword">typeof</span> Strategies[type] === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; Strategies[type](task);<br>&#125;<br><br><span class="hljs-comment">// 若没有使用策略模式的组长...</span><br><span class="hljs-keyword">var</span> Context = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, task</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;backend&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 把后端给我叫来</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;frontend&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 把前端给我叫来</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;testend&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 把测试给我叫来</span><br>    &#125;<br>&#125;<br><br>Context(<span class="hljs-string">&#x27;backend&#x27;</span>, <span class="hljs-string">&#x27;优化服务器缓存&#x27;</span>);<br>Context(<span class="hljs-string">&#x27;frontend&#x27;</span>, <span class="hljs-string">&#x27;优化首页加载速度&#x27;</span>);<br>Context(<span class="hljs-string">&#x27;testend&#x27;</span>, <span class="hljs-string">&#x27;完成系统并发测试&#x27;</span>);<br></code></pre></td></tr></table></figure><p>JavaScript 中，函数作为“一等公民“，也称“一等对象”。JavaScript 中 ”高阶函数“ 应用中，函数可被作为变量或参数进行传递或调用。因此在 JavaScript 中，我们可将算法封装成独立的函数，并将它作为参数传递给另一个函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装独立的函数</span><br><span class="hljs-keyword">var</span> backend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;进行后端任务：&#x27;</span>, task);<br>&#125;;<br><span class="hljs-keyword">var</span> frontend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;进行前端任务：&#x27;</span>, task);<br>&#125;;<br><span class="hljs-keyword">var</span> testend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;进行测试任务：&#x27;</span>, task);<br>&#125;;<br><br><span class="hljs-comment">//  环境类（开发组长）</span><br><span class="hljs-keyword">var</span> Context = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, task</span>) </span>&#123;<br>    <span class="hljs-keyword">typeof</span> func === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; func(task);<br>&#125;<br><br>Context(backend, <span class="hljs-string">&#x27;优化服务器缓存&#x27;</span>);<br>Context(frontend, <span class="hljs-string">&#x27;优化首页加载速度&#x27;</span>);<br>Context(testend, <span class="hljs-string">&#x27;完成系统并发测试&#x27;</span>);<br></code></pre></td></tr></table></figure><p>少了 Strategies 策略类的外层包裹，函数更加独立，并不妨碍其调用。使用函数替代策略类方式，正是我们日常开发中经常用到的 “隐形” 策略模式。</p><h4 id="4-策略模式适用场景："><a href="#4-策略模式适用场景：" class="headerlink" title="4. 策略模式适用场景："></a>4. 策略模式适用场景：</h4><ul><li><p>多重条件语句判断，执行对应的算法场景</p></li><li><p>表单校验（validator)</p></li></ul><h4 id="5-策略模式优缺点："><a href="#5-策略模式优缺点：" class="headerlink" title="5. 策略模式优缺点："></a>5. 策略模式优缺点：</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li><p>利用组合、委托、多态的技术和思想，避免多重条件选择语句 <code>if...else/switch...case</code>；</p></li><li><p>复用性更高，算法函数可在系统其它地方使用；</p></li><li><p>支持设计模式 “开发-封闭原则“ ，算法封装在独立的 Strategy 中，易于维护和扩展；</p></li><li><p>策略模式使用 “组合和委托” 来让 Context 拥有执行算法的能力，一种替换对象继承的可行方案</p></li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li><p>增加了许多策略类或对象（开发人员职能划分明确，人员成本有所增加）；</p></li><li><p>必须了解各个 Strategy 的不同点，违反 “最少知识原则”（组长手底下有对应的开发人员，才不用自己那么苦逼）</p></li></ul><p><strong>摘自好文：</strong></p><p><a href="https://juejin.im/post/5d11bd7ff265da1b8811e9c2">JavaScript 设计模式（二）：策略模式</a></p><h2 id="（七）迭代器模式"><a href="#（七）迭代器模式" class="headerlink" title="（七）迭代器模式"></a><span id="jump7">（七）迭代器模式</span></h2><h4 id="1-什么是迭代器模式？"><a href="#1-什么是迭代器模式？" class="headerlink" title="1. 什么是迭代器模式？"></a>1. 什么是迭代器模式？</h4><p>迭代器模式是指一种顺序访问一个聚合对象中的各个元素，而不需要暴露该对象</p><p>的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><p>简单理解（白话理解）：统一 “集合” 型数据结构的遍历接口，实现可循环遍历获取集合中各数据项（不关心数据项中的数据结构）。</p><p><strong>栗子：</strong></p><p>清单 TodoList。每日清单有学习类、生活类、工作类、运动类等项目，清单列表只管罗列，不管类别。</p><h4 id="2-迭代器模式特点："><a href="#2-迭代器模式特点：" class="headerlink" title="2. 迭代器模式特点："></a>2. 迭代器模式特点：</h4><ul><li><p>访问一个聚合对象的内容而无需暴露它的内部表示。</p></li><li><p>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</p></li><li><p>遍历的同时更改迭代器所在的集合结构可能会导致问题</p></li></ul><h4 id="3-使用场景："><a href="#3-使用场景：" class="headerlink" title="3. 使用场景："></a>3. 使用场景：</h4><p>不同数据结构类型的 “数据集合”，需要对外提供统一的遍历接口，而又不暴露或修改内部结构时，可应用迭代器模式实现。</p><h4 id="4-迭代器模式实现"><a href="#4-迭代器模式实现" class="headerlink" title="4. 迭代器模式实现"></a>4. 迭代器模式实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 统一遍历接口实现</span><br><span class="hljs-keyword">var</span> each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, callBack</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>    <span class="hljs-comment">// 将值，索引返回给回调函数callBack处理</span><br>    <span class="hljs-keyword">if</span> (callBack(i, arr[i]) === <span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 中止迭代器，跳出循环</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 外部调用</span><br>each([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 返回false中止each</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log([index, value]);<br>&#125;)<br><br><span class="hljs-comment">// 输出：[0, 1]  [1, 2]  [2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>“迭代器模式的核心，就是实现统一遍历接口。”</strong></p><h4 id="5-迭代器模式细分"><a href="#5-迭代器模式细分" class="headerlink" title="5. 迭代器模式细分"></a>5. 迭代器模式细分</h4><ul><li>内部迭代器 （jQuery 的 $.each / for…of)</li><li>外部迭代器 （ES6 的 yield)</li></ul><h5 id="内部迭代器："><a href="#内部迭代器：" class="headerlink" title="内部迭代器："></a>内部迭代器：</h5><p>内部迭代器: 内部定义迭代规则，控制整个迭代过程，外部只需一次初始调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// jQuery 的 $.each（跟上文each函数实现原理类似）</span><br>$.each([<span class="hljs-string">&#x27;Angular&#x27;</span>, <span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Vue&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log([index, value]);<br>&#125;);<br><br><span class="hljs-comment">// 输出：[0, Angular]  [1, React]  [2, Vue]</span><br>复制代码<br></code></pre></td></tr></table></figure><p>优点：调用方式简单，外部仅需一次调用 缺点：迭代规则预先设置，欠缺灵活性。无法实现复杂遍历需求（如: 同时迭代比对两个数组）</p><h5 id="外部迭代器："><a href="#外部迭代器：" class="headerlink" title="外部迭代器："></a>外部迭代器：</h5><p>外部迭代器： 外部显示（手动）地控制迭代下一个数据项</p><p>借助 ES6 新增的 <code>Generator</code> 函数中的 <code>yield*</code> 表达式来实现外部迭代器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 的 yield 实现外部迭代器</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generatorEach</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, value] <span class="hljs-keyword">of</span> arr.entries()) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-built_in">console</span>.log([index, value]);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> each = generatorEach([<span class="hljs-string">&#x27;Angular&#x27;</span>, <span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Vue&#x27;</span>]);<br>each.next();<br>each.next();<br>each.next();<br><br><span class="hljs-comment">// 输出：[0, &#x27;Angular&#x27;]  [1, &#x27;React&#x27;]  [2, &#x27;Vue&#x27;]</span><br>复制代码<br></code></pre></td></tr></table></figure><p>优点：灵活性更佳，适用面广，能应对更加复杂的迭代需求 缺点：需显示调用迭代进行（手动控制迭代过程），外部调用方式较复杂</p><p><strong>参考好文：</strong></p><p><a href="https://juejin.im/post/5d1a1adde51d45778f076d8c">JavaScript 设计模式（五）：迭代器模式</a></p><h2 id="（八）观察者模式"><a href="#（八）观察者模式" class="headerlink" title="（八）观察者模式"></a><span id="jump8">（八）观察者模式</span></h2><h4 id="1-什么是观察者模式？"><a href="#1-什么是观察者模式？" class="headerlink" title="1. 什么是观察者模式？"></a>1. 什么是观察者模式？</h4><p>观察者模式：定义了对象间一种一对多的依赖关系（一个目标者，即：被观察者，多个观察者），当目标对象 Subject 的状态发生改变时，所有依赖它的对象 Observer 都会得到通知。</p><h4 id="2-观察者模式特征"><a href="#2-观察者模式特征" class="headerlink" title="2. 观察者模式特征"></a>2. 观察者模式特征</h4><ul><li><p>一个目标者（被观察者）对象 <code>Subject</code>，拥有方法：添加 / 删除 / 通知 <code>Observer</code>；</p></li><li><p>多个观察者对象 <code>Observer</code>，拥有方法：接收 <code>Subject</code> 状态变更通知并处理；</p></li><li><p>目标对象 <code>Subject</code> 状态变更时，通知所有 <code>Observer</code>。</p></li></ul><p><code>Subject</code> 添加一系列 <code>Observer</code>， <code>Subject</code> 负责维护与这些 <code>Observer</code> 之间的联系，“你对我有兴趣，我更新就会通知你”。</p><h4 id="3-观察者模式的实现"><a href="#3-观察者模式的实现" class="headerlink" title="3. 观察者模式的实现"></a>3. 观察者模式的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 目标者类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.observers = [];  <span class="hljs-comment">// 观察者列表</span><br>  &#125;<br>  <span class="hljs-comment">// 添加</span><br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">observer</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.observers.push(observer);<br>  &#125;<br>  <span class="hljs-comment">// 删除</span><br>  <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">observer</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> idx = <span class="hljs-built_in">this</span>.observers.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === observer);<br>    idx &gt; -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">this</span>.observers.splice(idx, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 通知</span><br>  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> observer <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.observers) &#123;<br>      observer.update();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 观察者类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-comment">// 目标对象更新时触发的回调</span><br>  <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`目标者通知我更新了，我是：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化目标者</span><br><span class="hljs-keyword">let</span> subject = <span class="hljs-keyword">new</span> Subject();<br><br><span class="hljs-comment">// 实例化两个观察者</span><br><span class="hljs-keyword">let</span> obs1 = <span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;前端开发者&#x27;</span>);<br><span class="hljs-keyword">let</span> obs2 = <span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;后端开发者&#x27;</span>);<br><br><span class="hljs-comment">// 向目标者添加观察者</span><br>subject.add(obs1);<br>subject.add(obs2);<br><br><span class="hljs-comment">// 目标者通知更新</span><br>subject.notify();  <br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 目标者通知我更新了，我是前端开发者</span><br><span class="hljs-comment">// 目标者通知我更新了，我是后端开发者</span><br></code></pre></td></tr></table></figure><h4 id="4-观察者模式优缺点："><a href="#4-观察者模式优缺点：" class="headerlink" title="4. 观察者模式优缺点："></a>4. 观察者模式优缺点：</h4><p><strong>优点：</strong></p><ul><li><p>目标者与观察者，功能耦合度降低，专注自身功能逻辑；</p></li><li><p>观察者被动接收更新，时间上解耦，实时接收目标者更新状态。</p></li></ul><p><strong>缺点：</strong></p><p>观察者模式虽然实现了对象间依赖关系的低耦合，但却不能对事件通知进行细分管控，如 “筛选通知”，“指定主题事件通知” 。</p><p>比如上面的例子，仅通知 “前端开发者” ？观察者对象如何只接收自己需要的更新通知？上例中，两个观察者接收目标者状态变更通知后，都执行了 <code>update()</code>，并无区分。</p><p>“00后都在追求个性的时代，我能不能有点不一样？”，这就引出我们的下一个模式。进阶版的观察者模式。“发布订阅模式”，部分文章对两者是否一样都存在争议。</p><p>仅代表个人观点：两种模式很类似，但是还是略有不同，就是多了个第三者，因 JavaScript 非正规面向对象语言，且函数回调编程的特点，使得 “发布订阅模式” 在 JavaScript 中代码实现可等同为 “观察模式”。</p><p><strong>摘自好文：</strong></p><p><a href="https://juejin.im/post/5d25a2316fb9a07f04207010">JavaScript 设计模式（六）：观察者模式与发布订阅模式</a></p><h2 id="（九）发布订阅模式（Publisher-amp-amp-Subscriber）"><a href="#（九）发布订阅模式（Publisher-amp-amp-Subscriber）" class="headerlink" title="（九）发布订阅模式（Publisher &amp;&amp; Subscriber）"></a><span id="jump9">（九）发布订阅模式（Publisher &amp;&amp; Subscriber）</span></h2><h4 id="1-什么是发布订阅模式？"><a href="#1-什么是发布订阅模式？" class="headerlink" title="1. 什么是发布订阅模式？"></a>1. 什么是发布订阅模式？</h4><p>发布订阅模式：基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。</p><p>发布订阅模式与观察者模式的不同，“第三者” （事件中心）出现。目标对象并不直接通知观察者，而是通过事件中心来派发通知。</p><h4 id="2-发布订阅模式的实现"><a href="#2-发布订阅模式的实现" class="headerlink" title="2. 发布订阅模式的实现"></a>2. 发布订阅模式的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 事件中心</span><br><span class="hljs-keyword">let</span> pubSub = &#123;<br>  <span class="hljs-attr">list</span>: &#123;&#125;,<br>  <span class="hljs-attr">subscribe</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn</span>) </span>&#123;   <span class="hljs-comment">// 订阅</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.list[key]) &#123;<br>      <span class="hljs-built_in">this</span>.list[key] = [];<br>    &#125;<br>    <span class="hljs-built_in">this</span>.list[key].push(fn);<br>  &#125;,<br>  <span class="hljs-attr">publish</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, ...arg</span>) </span>&#123;  <span class="hljs-comment">// 发布</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> fn <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.list[key]) &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, ...arg);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">unSubscribe</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn</span>) </span>&#123;     <span class="hljs-comment">// 取消订阅</span><br>    <span class="hljs-keyword">let</span> fnList = <span class="hljs-built_in">this</span>.list[key];<br>    <span class="hljs-keyword">if</span> (!fnList) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (!fn) &#123;<br>      <span class="hljs-comment">// 不传入指定取消的订阅方法，则清空所有key下的订阅</span><br>      fnList &amp;&amp; (fnList.length = <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      fnList.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (item === fn) &#123;<br>          fnList.splice(index, <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 订阅</span><br>pubSub.subscribe(<span class="hljs-string">&#x27;onwork&#x27;</span>, <span class="hljs-function"><span class="hljs-params">time</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`上班了：<span class="hljs-subst">$&#123;time&#125;</span>`</span>);<br>&#125;)<br>pubSub.subscribe(<span class="hljs-string">&#x27;offwork&#x27;</span>, <span class="hljs-function"><span class="hljs-params">time</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`下班了：<span class="hljs-subst">$&#123;time&#125;</span>`</span>);<br>&#125;)<br>pubSub.subscribe(<span class="hljs-string">&#x27;launch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">time</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`吃饭了：<span class="hljs-subst">$&#123;time&#125;</span>`</span>);<br>&#125;)<br><br><span class="hljs-comment">// 发布</span><br>pubSub.publish(<span class="hljs-string">&#x27;offwork&#x27;</span>, <span class="hljs-string">&#x27;18:00:00&#x27;</span>); <br>pubSub.publish(<span class="hljs-string">&#x27;launch&#x27;</span>, <span class="hljs-string">&#x27;12:00:00&#x27;</span>);<br><br><span class="hljs-comment">// 取消订阅</span><br>pubSub.unSubscribe(<span class="hljs-string">&#x27;onwork&#x27;</span>);<br></code></pre></td></tr></table></figure><p>发布订阅模式中，订阅者各自实现不同的逻辑，且只接收自己对应的事件通知。实现你想要的 “不一样”。</p><h4 id="3-发布订阅发布的应用"><a href="#3-发布订阅发布的应用" class="headerlink" title="3. 发布订阅发布的应用"></a>3. 发布订阅发布的应用</h4><h5 id="DOM-事件监听也是-“发布订阅模式”-的应用："><a href="#DOM-事件监听也是-“发布订阅模式”-的应用：" class="headerlink" title="DOM 事件监听也是 “发布订阅模式” 的应用："></a>DOM 事件监听也是 “发布订阅模式” 的应用：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> loginBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;#loginBtn&#x27;</span>);<br><br><span class="hljs-comment">// 监听回调函数（指定事件）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我被点击了&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 添加事件监听</span><br>loginBtn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, notifyClick);<br><span class="hljs-comment">// 触发点击, 事件中心派发指定事件</span><br>loginBtn.click();             <br><br><span class="hljs-comment">// 取消事件监听</span><br>loginBtn.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, notifyClick);<br>复制代码<br></code></pre></td></tr></table></figure><p>发布订阅的通知顺序：</p><ol><li>先订阅后发布时才通知（常规）</li><li>订阅后可获取过往以后的发布通知 （QQ离线消息，上线后获取之前的信息）</li></ol><h5 id="流行库的应用："><a href="#流行库的应用：" class="headerlink" title="流行库的应用："></a>流行库的应用：</h5><ul><li><p>jQuery 的 <code>on</code> 和 <code>trigger</code>，<code>$.callback()</code>;</p></li><li><p>Vue 的双向数据绑定;</p></li><li><p>Vue 的父子组件通信 <code>$on/$emit</code></p></li></ul><h5 id="jQuery-的-Callback-："><a href="#jQuery-的-Callback-：" class="headerlink" title="jQuery 的 $.Callback()："></a>jQuery 的 $.Callback()：</h5><p>jQuery 的 $.Callback() 更像是观察者模式的应用，不能更细粒度管控。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyHim</span>(<span class="hljs-params">value</span>) </span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;He say &#x27;</span> + value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyHer</span>(<span class="hljs-params">value</span>) </span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;She say &#x27;</span> + value);<br>&#125;<br><br>$cb = $.Callbacks();    <span class="hljs-comment">// 声明一个回调容器：订阅列表 </span><br><br>$cb.add(notifyHim);     <span class="hljs-comment">// 向回调列表添加回调：订阅</span><br>$cb.add(notifyHer);     <span class="hljs-comment">// 向回调列表添加回调：订阅</span><br><br>$cb.fire(<span class="hljs-string">&#x27;help&#x27;</span>);       <span class="hljs-comment">// 调用所有回调： 发布</span><br></code></pre></td></tr></table></figure><h2 id="（十）命令模式"><a href="#（十）命令模式" class="headerlink" title="（十）命令模式"></a><span id="jump10">（十）命令模式</span></h2><h4 id="1-什么是命令模式？"><a href="#1-什么是命令模式？" class="headerlink" title="1. 什么是命令模式？"></a>1. 什么是命令模式？</h4><p>命令模式：请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p>例子：客户下单，订单记录了客户购买的产品，仓库根据订单给客户备货。</p><h4 id="2-命令模式的特点"><a href="#2-命令模式的特点" class="headerlink" title="2. 命令模式的特点"></a>2. 命令模式的特点</h4><p>命令模式由三种角色构成：</p><ul><li>发布者 <code>invoker</code>（发出命令，调用命令对象，不知道如何执行与谁执行）；</li><li>接收者 <code>receiver</code> (提供对应接口处理请求，不知道谁发起请求）；</li><li>命令对象 <code>command</code>（接收命令，调用接收者对应接口处理发布者的请求）。</li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585012888355.png" alt="1585012888355"></p><p>发布者 <code>invoker</code> 和接收者 <code>receiver</code> 各自独立，将请求封装成命令对象 <code>command</code> ，请求的具体执行由命令对象 <code>command</code> 调用接收者 <code>receiver</code> 对应接口执行。</p><p>命令对象 <code>command</code> 充当发布者 <code>invoker</code> 与接收者 <code>receiver</code> 之间的连接桥梁（中间对象介入）。实现发布者与接收之间的解耦，对比过程化请求调用，命令对象 <code>command</code> 拥有更长的生命周期，接收者 <code>receiver</code> 属性方法被封装在命令对象 <code>command</code> 属性中，使得程序执行时可任意时刻调用接收者对象 <code>receiver</code> 。因此 <code>command</code> 可对请求进行进一步管控处理，如实现延时、预定、排队、撤销等功能。</p><h4 id="3-命令模式的实现"><a href="#3-命令模式的实现" class="headerlink" title="3. 命令模式的实现"></a>3. 命令模式的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;  <span class="hljs-comment">// 接收者类</span><br>  <span class="hljs-function"><span class="hljs-title">execute</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;接收者执行请求&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span> </span>&#123;   <span class="hljs-comment">// 命令对象类</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">receiver</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.receiver = receiver;<br>  &#125;<br>  execute () &#123;    <span class="hljs-comment">// 调用接收者对应接口执行</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;命令对象-&gt;接收者-&gt;对应接口执行&#x27;</span>);<br>    <span class="hljs-built_in">this</span>.receiver.execute();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;   <span class="hljs-comment">// 发布者类</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">command</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.command = command;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">invoke</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-comment">// 发布请求，调用命令对象</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;发布者发布请求&#x27;</span>);<br>    <span class="hljs-built_in">this</span>.command.execute();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> warehouse = <span class="hljs-keyword">new</span> Receiver();       <span class="hljs-comment">// 仓库</span><br><span class="hljs-keyword">const</span> order = <span class="hljs-keyword">new</span> Command(warehouse);   <span class="hljs-comment">// 订单</span><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Invoker(order);      <span class="hljs-comment">// 客户</span><br>client.invoke();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">  发布者发布请求</span><br><span class="hljs-comment">  命令对象-&gt;接收者-&gt;对应接口执行</span><br><span class="hljs-comment">  接收者执行请求</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="4-命令模式应用场景"><a href="#4-命令模式应用场景" class="headerlink" title="4. 命令模式应用场景"></a>4. 命令模式应用场景</h4><p>有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。需要一种松耦合的方式来设计程序，使得发送者和接收者能够消除彼此之间的耦合关系。</p><ul><li><p>不关注执行者，不关注执行过程；</p></li><li><p>只要结果，支持撤销请求、延后处理、日志记录等。</p></li></ul><h4 id="5-命令模式的优缺点"><a href="#5-命令模式的优缺点" class="headerlink" title="5. 命令模式的优缺点"></a>5. 命令模式的优缺点</h4><p><strong>优点：</strong></p><ul><li>发布者与接收者实现解耦；</li><li>可扩展命令，对请求可进行排队或日志记录。（支持撤销，队列，宏命令等功能）。</li></ul><p><strong>缺点：</strong></p><ul><li>额外增加命令对象，非直接调用，存在一定开销。</li></ul><p><strong>学习并摘自：</strong></p><p><a href="https://juejin.im/post/5d2ad5eb6fb9a07f0b03f0ea">JavaScript设计模式（七）：命令模式</a></p><h2 id="（十一）组合模式"><a href="#（十一）组合模式" class="headerlink" title="（十一）组合模式"></a><span id="jump11">（十一）组合模式</span></h2><h4 id="1-什么是组合模式？"><a href="#1-什么是组合模式？" class="headerlink" title="1. 什么是组合模式？"></a>1. 什么是组合模式？</h4><p>组合模式：又叫 “部分整体” 模式，将对象组合成树形结构，以表示 “部分-整体” 的层次结构。通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>栗子：</strong>文件目录，DOM 文档树</p><h4 id="2-组合模式的特点"><a href="#2-组合模式的特点" class="headerlink" title="2. 组合模式的特点"></a>2. 组合模式的特点</h4><ul><li>表示 “部分-整体” 的层次结构，生成 “树叶型” 结构；</li><li>一致操作性，树叶对象对外接口保存一致（操作与数据结构一致）；</li><li>自上而下的的请求流向，从树对象传递给叶对象；</li><li>调用顶层对象，会自行遍历其下的叶对象执行。</li></ul><p><img src="C:\Users\lin\AppData\Roaming\Typora\typora-user-images\1585013770931.png" alt="1585013770931"></p><h4 id="3-组合模式的实现"><a href="#3-组合模式的实现" class="headerlink" title="3. 组合模式的实现"></a>3. 组合模式的实现</h4><p>树对象和叶对象接口统一，树对象增加一个缓存数组，存储叶对象。执行树对象方法时，将请求传递给其下叶对象执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 树对象 - 文件目录</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CFolder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.files = [];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">file</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.files.push(file);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">scan</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> file <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.files) &#123;<br>            file.scan();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 叶对象 - 文件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CFile</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">file</span>)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;文件下面不能再添加文件&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">scan</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`开始扫描文件：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> mediaFolder = <span class="hljs-keyword">new</span> CFolder(<span class="hljs-string">&#x27;娱乐&#x27;</span>);<br><span class="hljs-keyword">let</span> movieFolder = <span class="hljs-keyword">new</span> CFolder(<span class="hljs-string">&#x27;电影&#x27;</span>);<br><span class="hljs-keyword">let</span> musicFolder = <span class="hljs-keyword">new</span> CFolder(<span class="hljs-string">&#x27;音乐&#x27;</span>);<br><br><span class="hljs-keyword">let</span> file1 = <span class="hljs-keyword">new</span> CFile(<span class="hljs-string">&#x27;钢铁侠.mp4&#x27;</span>);<br><span class="hljs-keyword">let</span> file2 = <span class="hljs-keyword">new</span> CFile(<span class="hljs-string">&#x27;再谈记忆.mp3&#x27;</span>);<br>movieFolder.add(file1);<br>musicFolder.add(file2);<br>mediaFolder.add(movieFolder);<br>mediaFolder.add(musicFolder);<br>mediaFolder.scan();<br><br><span class="hljs-comment">/* 输出:</span><br><span class="hljs-comment">开始扫描文件：钢铁侠.mp4</span><br><span class="hljs-comment">开始扫描文件：再谈记忆.mp3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>CFolder</code> 与 <code>CFile</code> 接口保持一致。执行 <code>scan()</code> 时，若发现是树对象，则继续遍历其下的叶对象，执行 <code>scan()</code>。</p><h4 id="4-组合模式误区规避"><a href="#4-组合模式误区规避" class="headerlink" title="4. 组合模式误区规避"></a>4. 组合模式误区规避</h4><ul><li><p><strong>组合不是继承，树叶对象并不是父子对象</strong></p><p>组合模式的树型结构是一种 HAS-A（聚合）的关系，而不是 IS-A 。树叶对象能够合作的关键，是它们对外保持统一接口，而不是叶对象继承树对象的属性方法，两者之间不是父子关系。</p></li><li><p><strong>叶对象操作保持一致性</strong></p><p>叶对象除了与树对象接口一致外，操作也必须保持一致性。一片叶子只能生在一颗树上。调用顶层对象时，每个叶对象只能接收一次请求，一个叶对象不能从属多个树对象。</p></li><li><p><strong>叶对象实现冒泡传递</strong></p><p>请求传递由树向叶传递，如果想逆转传递过程，需在叶对象中保留对树对象的引用，冒泡传递给树对象处理。</p></li><li><p><strong>不只是简单的子集遍历</strong></p><p>调用对象的接口方法时，如果该对象是树对象，则会将请求传递给叶对象，由叶对象执行方法，以此类推。不同于迭代器模式，迭代器模式遍历并不会做请求传导。</p></li></ul><h4 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h4><ul><li>优化处理递归或分级数据结构（文件系统 - 目录文件管理）；</li><li>与其它设计模式联用，如与命令模式联用实现 “宏命令”。</li></ul><h4 id="6-组合模式优缺点"><a href="#6-组合模式优缺点" class="headerlink" title="6. 组合模式优缺点"></a>6. 组合模式优缺点</h4><p><strong>优点：</strong></p><ul><li>忽略组合对象和单个对象的差别，对外一致接口使用；</li><li>解耦调用者与复杂元素之间的联系，处理方式变得简单。</li></ul><p><strong>缺点：</strong></p><ul><li>树叶对象接口一致，无法区分，只有在运行时方可辨别；</li><li>包裹对象创建太多，额外增加内存负担。</li></ul><p><strong>学习摘自：</strong></p><p><a href="https://juejin.im/post/5d2d33226fb9a07f070e5e03">JavaScript设计模式（八）：组合模式</a></p><p><a href="https://www.jianshu.com/p/9c3f55e47399">https://www.jianshu.com/p/9c3f55e47399</a>)</p><h2 id="（十二）建造者模式"><a href="#（十二）建造者模式" class="headerlink" title="（十二）建造者模式"></a><span id="jump12">（十二）建造者模式</span></h2><h4 id="1-什么是建造者模式？"><a href="#1-什么是建造者模式？" class="headerlink" title="1. 什么是建造者模式？"></a>1. 什么是建造者模式？</h4><p>**建造者模式(Builder)**是将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p><p>建造者模式的特点是分步构建一个复杂的对象，可以用不同组合或顺序建造出不同意义的对象，通常使用者并不需要知道建造的细节，通常使用<strong>链式调用</strong>来进行建造过程，最后调用<code>build</code>方法来生成最终对象。</p><p>同样作为创建型的设计模式，需要注意和工厂模式的区别，工厂虽然也是创建对象，但怎样创建无所谓，<strong>工厂模式关注的是创建的结果</strong>；而建造者模式不仅得到了结果，同时也<strong>参与了创建的具体过程</strong>，适合用来创建一个复杂的复合对象。</p><h4 id="2-建造者模式的实现"><a href="#2-建造者模式的实现" class="headerlink" title="2. 建造者模式的实现"></a>2. 建造者模式的实现</h4><p> <strong>ES6中的建造者模式：</strong></p><p>假设一个出版社的书籍后台录入系统的业务场景，书籍有四个必填信息，分别是：书名，作者，价格，分类；我们希望创建一个书籍对象返回给后端。下面我们来一步一步深入使用ES6的语法结合建造者模式创建对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//书籍建造者类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookBuilder</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.author = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.price = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.category = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">withName</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">withAuthor</span>(<span class="hljs-params">author</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.author = author;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">withPrice</span>(<span class="hljs-params">price</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.price = price;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">withCategory</span>(<span class="hljs-params">category</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.category = category;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">build</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-built_in">this</span>.name,<br>      <span class="hljs-attr">author</span>: <span class="hljs-built_in">this</span>.author,<br>      <span class="hljs-attr">prices</span>: <span class="hljs-built_in">this</span>.price,<br>      <span class="hljs-attr">category</span>: <span class="hljs-built_in">this</span>.category<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//调用建造者类</span><br><span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> BookBuilder()<br>  .withName(<span class="hljs-string">&quot;高效能人士的七个习惯&quot;</span>)<br>  .withAuthor(<span class="hljs-string">&#x27;史蒂芬·柯维&#x27;</span>)<br>  .withPrice(<span class="hljs-number">51</span>)<br>  .withCategory(<span class="hljs-string">&#x27;励志&#x27;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>上面就通过<code>BookBuilder</code>这个创建者类的写法和调用方法，但是仅仅是一个4个属性的对象，我们使用了如此多的代码去创建，这远比直接在<code>constructor</code>传递参数创建对象要复杂得多。这是由于在创建的过程中，我们有太多的<code>withxxxx</code>方法。我们其实可以自动创建这类<code>withxxxx</code>方法以简化代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//书籍建造者类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookBuilder</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.author = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.price = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.category = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <br>    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> withName = <span class="hljs-string">`with<span class="hljs-subst">$&#123;key.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase()&#125;</span><span class="hljs-subst">$&#123;key.substring(<span class="hljs-number">1</span>)&#125;</span>`</span>;<br>      <span class="hljs-built_in">this</span>[withName] = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>[key] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <br>  <span class="hljs-comment">//调用建造者</span><br>  <span class="hljs-function"><span class="hljs-title">build</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> keysNoWithers = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>[key] !== <span class="hljs-string">&#x27;function&#x27;</span>);<br><br>    <span class="hljs-keyword">return</span> keysNoWithers.reduce(<span class="hljs-function">(<span class="hljs-params">returnValue, key</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...returnValue,<br>        [key]: <span class="hljs-built_in">this</span>[key]<br>      &#125;<br>    &#125;, &#123;&#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> BookBuilder()<br>  .withName(<span class="hljs-string">&quot;高效能人士的七个习惯&quot;</span>)<br>  .withAuthor(<span class="hljs-string">&#x27;史蒂芬·柯维&#x27;</span>)<br>  .withPrice(<span class="hljs-number">51</span>)<br>  .withCategory(<span class="hljs-string">&#x27;励志&#x27;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>上面的<code>BookBuilder</code>这个类和第一个例子的效果一样，但是长度确减少不少，在有更多属性的时候，减少的代码量会更为明显。我们将所有的建造方法<code>withxxxx</code>在<code>constructor</code>调用时自动被创建，这里我们使用了一些ES6的新语法：<code>Object.keys</code>获取对象属性数组，<code>...</code>的合并对象的语法。</p><p>虽然该写法在阅读起来会比第一个方法难以理解，但是这样写法的真正作用在于，当我们需要许多的建造者类时，我们可以将上面自动创建<code>withxxx</code>和<code>build</code>的代码提取为一个父类。在创建其他建造者类时继承该父类，这使得在创建多个建造者类时变得十分容易。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseBuilder</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> withName = <span class="hljs-string">`with<span class="hljs-subst">$&#123;key.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase()&#125;</span><span class="hljs-subst">$&#123;key.substring(<span class="hljs-number">1</span>)&#125;</span>`</span>;<br>      <span class="hljs-built_in">this</span>[withName] = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>[key] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">build</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> keysNoWithers = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>[key] !== <span class="hljs-string">&#x27;function&#x27;</span>);<br><br>    <span class="hljs-keyword">return</span> keysNoWithers.reduce(<span class="hljs-function">(<span class="hljs-params">returnValue, key</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...returnValue,<br>        [key]: <span class="hljs-built_in">this</span>[key]<br>      &#125;<br>    &#125;, &#123;&#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//子类1: 书籍建造者类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseBuilder</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br><br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.author = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.price = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.category = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <br>    <span class="hljs-built_in">super</span>.init();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//子类2: 印刷厂建造者类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">printHouseBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseBuilder</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br><br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.location = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.quality = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-built_in">super</span>.init();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//调用书籍建造者类</span><br><span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> BookBuilder()<br>  .withName(<span class="hljs-string">&quot;高效能人士的七个习惯&quot;</span>)<br>  .withAuthor(<span class="hljs-string">&#x27;史蒂芬·柯维&#x27;</span>)<br>  .withPrice(<span class="hljs-number">51</span>)<br>  .withCategory(<span class="hljs-string">&#x27;励志&#x27;</span>)<br>  .build();<br><br><br><span class="hljs-comment">//调用印刷厂建造类</span><br><span class="hljs-keyword">const</span> printHouse = <span class="hljs-keyword">new</span> printHouseBuilder()<br>  .withName(<span class="hljs-string">&#x27;新华印刷厂&#x27;</span>)<br>  .withLocation(<span class="hljs-string">&#x27;北京海淀区&#x27;</span>)<br>  .withQuality(<span class="hljs-string">&#x27;A&#x27;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>建造者模式的使用有且只适合创建极为复杂的对象。在前端的实际业务中，在没有这类极为复杂的对象的创建时，还是应该直接使用对象字面或工厂模式等方式创建对象。</p><p><strong>学习摘于：</strong></p><p><a href="https://www.jianshu.com/p/be61fcc47a2f">从ES6重新认识JavaScript设计模式(三): 建造者模式</a></p><p><strong>以上内容为零碎资料和以下好文的学习笔记</strong>：</p><p><a href="https://www.jianshu.com/nb/23500380">ES6设计模式</a></p><p><a href="https://juejin.im/user/597950e0f265da3e292a3e46/posts">以乐为名的专栏</a></p><p><a href="https://www.cnblogs.com/imwtr/p/9451129.html">JavaScript中常见的十五种设计模式</a></p><p><a href="https://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nodejs相关知识点</title>
    <link href="/2020/02/21/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nodejs%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/02/21/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nodejs%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>NodeJs 就是运行在服务端的 JavaScript。</p><h4 id="NodeJs事件驱动-事件循环"><a href="#NodeJs事件驱动-事件循环" class="headerlink" title="NodeJs事件驱动/事件循环:"></a>NodeJs事件驱动/事件循环:</h4><ul><li>每个NodeJs进程只有一个主线程在执行程序代码，形成一个<strong>执行栈</strong>（<strong>execution context stack</strong>)。</li><li>主线程之外，还维护了一个”<strong>事件队列</strong>“（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到<code>Event Queue</code>之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。</li><li>主线程代码执行完毕完成后，然后通过<code>Event Loop</code>，也就是<strong>事件循环机制</strong>，开始到<code>Event Queue</code>的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从<strong>线程池</strong>中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交<code>Event Loop</code>处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。</li><li>主线程不断重复上面的第三步。</li></ul><h4 id="NodeJs特点："><a href="#NodeJs特点：" class="headerlink" title="NodeJs特点："></a>NodeJs特点：</h4><ul><li>它是一个Javascript运行环境</li><li> 依赖于Chrome V8引擎进行代码解释</li><li> 事件驱动</li><li> 非阻塞I/O</li><li> 轻量、可伸缩，适于实时数据交互应用</li><li> 单进程，单线程</li></ul><h4 id="NodeJs的优缺点："><a href="#NodeJs的优缺点：" class="headerlink" title="NodeJs的优缺点："></a>NodeJs的优缺点：</h4><p>优点：</p><ul><li><p>高并发；</p></li><li><p>适合I/O密集型应用。</p></li></ul><p>缺点：</p><ul><li><p>不适合CPU密集型应用，只支持单核CPU，不能充分利用CPU；</p></li><li><p>单进程，单线程，一旦代码某处出现bug，整个系统都崩溃；</p></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p>我们所看到的nodeJs单线程只是一个js主线程，本质上的异步操作还是由线程池完成的，node将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的I/O操作，从而实现异步非阻塞I/O，这便是node单线程和事件驱动的精髓之处了。</p></li><li><p>NodeJs所谓的单线程，只是主线程是单线程，所有的网络请求或者异步任务都交给了内部的线程池去实现，本身只负责不断的往返调度，由事件循环不断驱动事件执行。</p></li><li><p>NodeJs之所以单线程可以处理高并发的原因，得益于libuv层的事件循环机制，和底层线程池实现。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(8) 正则表达式的模式匹配</title>
    <link href="/2020/02/17/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(8)%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2020/02/17/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(8)%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="第-10-章-正则表达式的模式匹配"><a href="#第-10-章-正则表达式的模式匹配" class="headerlink" title="第 10 章 正则表达式的模式匹配"></a>第 10 章 正则表达式的模式匹配</h1><p>正则表达式是一个描述字符串模式的对象。</p><p>JavaScript的<code>RegExp</code>类表示正则表达式，String和RegExp都定义了方法，后者使用正则表达式进行强大的模式匹配和文本与替换功能。</p><h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>JavaScript中正则表达式用RegExp对象表示，可以使用<code>RegExp()</code>构造函数来创建RegExp对象，不过RegExp对象更多的是通过一种特殊的直接量语法来创建。就像通过引号包裹字符的方式来定义字符串直接量一样，正则表达式直接量定义为包含在一堆斜杆（<code>/</code>）之间的字符。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/s$/</span>; <br><span class="hljs-comment">//这段代码创建一个新的RegExp对象，并将它赋值给变量pattern。这个特殊的RegExp对象用来匹配所有以字母&quot;s&quot;结尾的字符串。</span><br><span class="hljs-comment">//用构造函数RegExp（）也可以定义个与之等价的正则表达式，代码如下：</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;s$&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>RegExp直接量和对象的创建</strong>：</p><p>就像字符串和数字一样，程序中每个取值相同的原始类型直接量均表示相同的值，这是显而易见。程序运行每次遇到对象直接量（初始化表达式）诸如{}和[]的时候都会创建新对象。比如，如果在循环中写<code>var a = []</code>，则每次遍历都会创建一个新的空数组。</p><p>正则表达式直接量则与此不同，ECMAScript5规定 同一段代码所表示的正则表达式直接量的每次运算都返回新对象。</p><h2 id="直接量字符"><a href="#直接量字符" class="headerlink" title="直接量字符"></a>直接量字符</h2><p><strong>字符                                 匹配</strong></p><p><code>字母和数字字符</code>            自身</p><p><code>\o</code>                                NUL字符</p><p><code>\t</code>                                制表符</p><p><code>\n</code>                                换行符</p><p><code>\v</code>                                垂直制表符</p><p><code>\f</code>                                换页符</p><p><code>\r    </code>                                回车符</p><p><code>\xnn</code>                            由十六进制数<code>nn</code>指定的拉丁字符</p><p><code>\uxxxx    </code>                        由十六进制数<code>xxxx</code>指定的Unicode字符</p><p><code>\cX    </code>                             控制字符<code>^X</code></p><h2 id="正则表达式的字符类："><a href="#正则表达式的字符类：" class="headerlink" title="正则表达式的字符类："></a>正则表达式的字符类：</h2><p><strong>字符                     匹配</strong></p><p><code>[...]    </code>             方括号内的任意字符                                </p><p><code>[^...]</code>           不在方括号内的任意字符</p><p><code>.    </code>                      除换行符和其他Unicode行终止符之外的任意字符</p><p><code>\w    </code>                    任何ASCII字符组成的单词，等价于<code>[a-zA-Z0-9]</code></p><p><code>\W    </code>                    任何不是ASCII字符组成的单词，等价于<code>[^a-zA-Z0-9]</code></p><p><code>\s    </code>                    任何Unicode空白符</p><p><code>\S</code>                    任何非Unicode空白符的字符，注意<code>\w</code>和<code>\S</code>不同</p><p><code>\d    </code>                    任何ASCII数字，等价于<code>[0-9]</code></p><p><code>\D</code>                    除了ASCII数字之外的任何字符，等价于<code>[^0-9]</code></p><p><code>[\b]</code>                退格直接量</p><h2 id="正则表达式的重复字符语法："><a href="#正则表达式的重复字符语法：" class="headerlink" title="正则表达式的重复字符语法："></a>正则表达式的重复字符语法：</h2><p><strong>字符               含义</strong></p><p><code>&#123;n, m&#125;</code>        匹配前一项至少n次，但不能超过m次</p><p><code>&#123;n, &#125;</code>          匹配前一项n次或更多次</p><p><code>&#123;n&#125;</code>              匹配前一项n次</p><p><code>?</code>                  匹配前一项0次或者1次，也就是说前一项是可选的</p><p><code>+</code>                  匹配前一项1次或者多次，等价于{1, }</p><p><code>*</code>                  匹配前一项0次或多次，等价于{0, }</p><h2 id="非贪婪的重复"><a href="#非贪婪的重复" class="headerlink" title="非贪婪的重复"></a>非贪婪的重复</h2><p>只须在待匹配的字符后跟随一个问号即可：“<code>？？</code>”、“<code>+？</code>”、“<code>*？</code>”或“<code>&#123;1,5&#125;？</code>”。</p><h2 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h2><p><strong>字符                含义</strong></p><p><code>|    </code>                        选择，匹配的是该符号左边的子表达式或者右边的子表达式。若左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。</p><p><code>(...)    </code>                组合，将几个项组合为一个单元，这个单元可通过 “<code>*</code>”、“<code>+</code>”、“<code>？</code>”和“<code>|</code>”等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用。</p><p><code>(?:...)</code>            只组合，把项组合到一个单元，但不记忆与该组相匹配的字符。</p><p><code>\n</code>                        和第n个分组第一次匹配到字符相匹配，组是圆括号中的子表达式（也可能是嵌套的）。组索引是从左到右的左括号，“<code>（？：</code>”形式的分组不编码。</p><h2 id="指定匹配位置"><a href="#指定匹配位置" class="headerlink" title="指定匹配位置"></a>指定匹配位置</h2><p><strong>字符                 含义</strong></p><p><code>^        </code>                    匹配字符串的开头，在多行检索中，匹配一行的开头</p><p><code>$</code>                    匹配字符串的结尾，在多行检索中，匹配一行的结尾</p><p><code>\b</code>                  匹配一个单词的边界，简言之，就是位于字符<code>\w</code>和<code>\W</code>之间的位置，或者位于字符<code>\w</code>和字符串的开头或者结尾之间的位置。（<code>[\b]</code>匹配的是退格符）</p><p><code>\B    </code>                 匹配非单词边界的位置</p><p><code>(?=p)    </code>            零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符</p><p><code>(?!p)    </code>            零宽负向先行断言，要求接下来的字符不与p匹配</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p><strong>字符            含义</strong></p><p><code>i</code>                执行不区分大小写的匹配</p><p><code>g</code>                执行一个全局匹配，即找到所有的匹配，而不是在找到第一个之后就停止</p><p><code>m</code>                多行匹配模式，<code>^</code>匹配一行的开头和字符串的开头，<code>$</code>匹配行的结束和字符串的结束</p><h2 id="用于模式匹配的String方法"><a href="#用于模式匹配的String方法" class="headerlink" title="用于模式匹配的String方法"></a>用于模式匹配的String方法</h2><p>String支持4种正则表达式的方法。</p><h4 id="search"><a href="#search" class="headerlink" title="search() :"></a><code>search()</code> :</h4><p>它的参数是一个正则表达式，返回一个与子匹配的子串的起始位置，如果找不到匹配的子串，它将返回-1 。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;JavaScript&quot;</span>.search(<span class="hljs-regexp">/script/i</span>); <span class="hljs-regexp">//</span>返回值为<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>如果search()的参数不是正则表达式，则首先会通过RegExp构造函数将它转换成正则表达式，search()方法不支持全局检索，因为它忽略正则表达式参数中的修饰符g。</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace() :"></a><code>replace()</code> :</h4><p>它的第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。</p><p>该方法会调用它的字符串进行检索，使用指定的模式来匹配。</p><p>如果正则表达式中设置了修饰符g，那么源字符串中所有与模式匹配的子串都将替换成第二个参数指定的字符串；如果不带修饰符g则只替换所匹配的第一个子串。</p><p>如果replace()的第一个参数是字符串而不是正则表达式，则replace()将直接搜索这个字符串，而不是像search()一样首先通过RegExp()将它转换为正则表达式。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>将文本中所有javascript统一替换为<span class="hljs-string">&quot;JavaScript&quot;</span>:<br>text.replace(<span class="hljs-regexp">/javacsript/gi</span>，<span class="hljs-string">&quot;JavaScript&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果在替换字符串中出现了$数字，那么replace()将用与指定子表达式相匹配的文本来替换这两个字符。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>将一个字符串中的英文引号替换为中文半角引号：<br><span class="hljs-regexp">//</span>一段引用文本起始于引号，结束与引号<br><span class="hljs-regexp">//</span>中间的内容区域不能包含引号<br>var quote = <span class="hljs-regexp">/&quot;([^&quot;]*)&quot;/g</span>;<br><span class="hljs-regexp">//</span>用中文半角引号替换英文引号，同时要保持引号之间的内容没有被修改<br>text.replace(quote, <span class="hljs-string">&#x27;“$1”&#x27;</span>);<br></code></pre></td></tr></table></figure><p>replace()方法的第二个参数可以是函数，该函数能够动态地计算替换字符串。</p><h4 id="match"><a href="#match" class="headerlink" title="match() :"></a><code>match()</code> :</h4><p>它的唯一参数就是一个正则表达式，返回的是一个由匹配结果组成的数组。</p><p>如果该正则表达式设置了修饰符g，则该方法返回的数组包含字符串中所有匹配结果。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-string">&quot;1 plus 2 equals 3&quot;</span>.match(<span class="hljs-regexp">/\d+/g</span><span class="hljs-regexp">/) /</span>/返回[<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>]<br></code></pre></td></tr></table></figure><p>如果这个正则表达式没有设置修饰符g,match()就不会进行全局检索，它只检索第一个匹配。但即使match()执行的不是全局检索，它也返回一个数组。在这种情况下，数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果match()返回一个数组a，那么a[0]存放的是完整的匹配，a[1]存放的则是与第一个用圆括号括起来的表达式相匹配的子串，以此类推。为了和方法replace()保持一致，a[n]存放的是$n的内容。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> url = /(\w+):\/\/([\w.]+)\/(\S*)/;<br><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Visit my blog at http://www.example.com/~david&quot;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = text.match(url);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> != null) &#123;<br><span class="hljs-keyword">var</span> fullurl = <span class="hljs-literal">result</span>[<span class="hljs-number">0</span>]; //包含<span class="hljs-string">&quot;http://www.example.com/~david&quot;</span><br><span class="hljs-keyword">var</span> protocol = <span class="hljs-literal">result</span>[<span class="hljs-number">1</span>]; //包含<span class="hljs-string">&quot;http&quot;</span><br><span class="hljs-keyword">var</span> host = <span class="hljs-literal">result</span>[<span class="hljs-number">2</span>]; //包含<span class="hljs-string">&quot;www.example.com&quot;</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-literal">result</span>[<span class="hljs-number">3</span>]; //包含<span class="hljs-string">&quot;~david&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="split"><a href="#split" class="headerlink" title="split() :"></a><code>split()</code> :</h4><p>这个方法用以调用它的字符串拆分为一个子串组成的数组，使用的分隔符是split()的参数。</p><p>split()方法的参数也可以是一个正则表达式。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;123,456,789&quot;</span>.split(<span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-regexp">//</span>返回[<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-string">&quot;789&quot;</span>];<br><br><span class="hljs-regexp">//</span>指定分隔符，允许两边可以留有任意多的空白符：<br><span class="hljs-string">&quot;1, 2, 3, 4, 5&quot;</span>.split(<span class="hljs-regexp">/\s*,\*/</span>); <span class="hljs-regexp">//</span>返回[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h2><p><code>RegExp()</code>构造函数带有两个字符串参数，其中第二个参数是可选的，RegExp()用以创建新的RegExp对象。</p><p>第一个参数包容正则表达式的主体部分，也就是正则表达式直接量中两条斜线之间的文本。第二个参数是可选的，如果提供第二个参数，它就指定正则表达式的修饰符。不过只能传入修饰符g, i, m 或者它们的组合。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//全局匹配字符串中的5个数字，注意这里使用了&quot;\\&quot;，而不是&quot;\&quot;</span><br><span class="hljs-keyword">var</span> zipcode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;\\d&#123;5&#125;&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec() :"></a><code>exec()</code> :</h4><p>参数是一个字符串。该方法对一个指定的字符串执行一个正则表达式，简言之，就是在一个字符串中执行匹配检索。如果它没有任何匹配，就返回null，但如果它找到了一个匹配，它就返回一个数组。这个数组的第一个元素包含的与正则表达式相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。属性index包含了发生匹配的字符串位置，属性input引用的是正在检索的字符串。</p><p>不管正则表达式是否具有全局修饰符g，exec()都会返回一样的数组。</p><p>当调用exec()的正则表达式对象具有修饰符g时，它将当前正则表达式对象的lastIndex属性设置为紧挨着匹配字符串位置。当同一个正则表达式第二次调用exec()时，它将从lastIndex属性所指示的字符处开始检索。如果exec()没有发现任何匹配结果，它会将lastIndex重置为0。</p><h4 id="test"><a href="#test" class="headerlink" title="test() :"></a><code>test()</code> :</h4><p>它的参数是一个字符串，用test()对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回true：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/java/i</span>;<br>pattern.test(<span class="hljs-string">&quot;JavaScript&quot;</span>); <span class="hljs-comment">//返回true</span><br></code></pre></td></tr></table></figure><p>调用test()和调用exec()等价，当exec()的返回结果不是null时，test()返回true。由于这种等价性，当一个全局正则表达式调用方法test()时，它的行为和exec()相同。（在lastIndex上也相同）</p><p>与exec()和test()不同，String方法search()、replace()和match()并不会用到lastIndex属性。实际上，String方法只是简单地将lastIndex属性重置为0。如果让一个带有修饰符g的正则表达式对多个字符串执行exec()或test()，要么在每个字符串中找出所有的匹配以便将lastIndex自动重置为零，要么显示将lastIndex手动设置为0(当最后一次检索失败时需要手动设置lastIndex)。如果忘了手动设置lastIndex的值，那么下一次对新字符串进行检索时，执行检索的起始位置可能就不是字符串的开始位置，而可能是任意位置（由lastIndex决定）。当然，如果RegExp不带有修饰符g，则不必担心会发生这种情况。</p>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(7) 类和模块</title>
    <link href="/2020/02/16/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(7)%20%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
    <url>/2020/02/16/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(7)%20%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="第9章-类和模块"><a href="#第9章-类和模块" class="headerlink" title="第9章 类和模块"></a>第9章 类和模块</h1><p>在JavaScript中，类的实现是基于其原型继承机制。如果两个实例都从同一个原型对象上继承了属性，就说它们是同一个类的实例。如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化。</p><p>JavaScript中类的一个重要特性是“动态可继承”。</p><h2 id="类和原型"><a href="#类和原型" class="headerlink" title="类和原型"></a>类和原型</h2><p>在JavaScript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。</p><p><code>inherit（）</code>这个函数返回一个新创建的对象，后者继承自某个对象。如果定义了一个原型对象，然后通过<code>inherit（）</code>函数创建一个继承自它的对象，这样就定义了一个JavaScript类。通常，类的实例还需要进一步初始化，通常是通过定义一个函数来创建并初始化这个新对象。</p><p>一个简单的JavaScript类：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//实现一个能表示值的范围的类</span><br><span class="hljs-comment">//这个工厂方法返回一个新的“范围对象”</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) </span>&#123;<br><span class="hljs-comment">//使用inherit（）函数来创建对象，这个对象继承自在下面定义的原型对象</span><br><span class="hljs-comment">//原型对象作为函数的一个属性存储，并定义所有“范围对象”所共享的方法</span><br><span class="hljs-keyword">var</span> r = inherit(range.methods);<br><span class="hljs-comment">//存储新的“范围对象”的起始位置和结束位置（状态）</span><br><span class="hljs-comment">//这两个属性是不可继承的，每个对象都拥有唯一的属性</span><br>r.from = <span class="hljs-keyword">from</span>;<br>r.to = to;<br><span class="hljs-comment">//返回新创建的对象</span><br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-comment">//原型对象定义方法，这些方法为每个范围对象所继承</span><br>range.methods = &#123;<br><span class="hljs-comment">//如果x在范围内，则返回true，否则返回false</span><br><span class="hljs-comment">//这个方法可以比较数字范围，也可以比较字符串和日期</span><br><span class="hljs-attr">includes</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="hljs-built_in">this</span>.to; &#125;,<br>&#125;<br><span class="hljs-comment">//对于范围内的每个整数都调用一次f</span><br><span class="hljs-comment">//这个方法只可用做数字范围</span><br><span class="hljs-attr">foreach</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>) </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">this</span>.from); x &lt;= <span class="hljs-built_in">this</span>.to; f(x));<br>&#125;,<br><span class="hljs-comment">//返回表示这个范围的字符串</span><br><span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">this</span>.from + <span class="hljs-string">&quot;...&quot;</span> + <span class="hljs-built_in">this</span>.to + <span class="hljs-string">&quot;)&quot;</span>;&#125;<br>&#125;;<br><br><span class="hljs-comment">//这里是使用“范围对象”的一些例子</span><br><span class="hljs-keyword">var</span> r = range(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//创建一个范围对象</span><br>r.includes(<span class="hljs-number">2</span>); <span class="hljs-comment">//true,2在这个范围内</span><br>r.foreach(<span class="hljs-built_in">console</span>/log); <span class="hljs-comment">//输出1 2 3</span><br><span class="hljs-built_in">console</span>.log(r); <span class="hljs-comment">//输出(1...3)</span><br></code></pre></td></tr></table></figure><h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><p>调用构造函数的一个重要特征是，构造函数的<code>prototype</code>属性被用来做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员。</p><p>对上一节中“范围类”做了修改，使用构造函数代替工厂函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//不是值的范围的类的另一种实现：</span><br><span class="hljs-comment">//这是构造函数，用以初始化创建的“范围对象”</span><br><span class="hljs-comment">//注意，这里并没有创建并返回一个对象，仅仅是初始化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Range</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) </span>&#123;<br><span class="hljs-comment">//存储“范围对象”的起始位置和结束位置（状态）</span><br><span class="hljs-comment">//这两个属性是不可继承的，每个对象都拥有唯一的属性</span><br><span class="hljs-built_in">this</span>.from = <span class="hljs-keyword">from</span>;<br><span class="hljs-built_in">this</span>.to = to;<br>&#125;<br><br><span class="hljs-comment">//所有的“范围对象”都继承自这个对象</span><br><span class="hljs-comment">//注意，属性的名字必须是&quot;prototype&quot;</span><br>Range.prototype = &#123;<br><span class="hljs-comment">//如果x在范围内，则返回true，否则返回false</span><br><span class="hljs-comment">//这个方法可以比较数字范围，也可以比较字符串和日期范围</span><br><span class="hljs-attr">includes</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="hljs-built_in">this</span>.to; &#125;,<br>&#125;<br><span class="hljs-comment">//对于范围内的每个整数都调用一次f</span><br><span class="hljs-comment">//这个方法只可用做数字范围</span><br><span class="hljs-attr">foreach</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>) </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">this</span>.from); x &lt;= <span class="hljs-built_in">this</span>.to; f(x));<br>&#125;,<br><span class="hljs-comment">//返回表示这个范围的字符串</span><br><span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">this</span>.from + <span class="hljs-string">&quot;...&quot;</span> + <span class="hljs-built_in">this</span>.to + <span class="hljs-string">&quot;)&quot;</span>;&#125;<br>&#125;;<br><span class="hljs-comment">//这里是使用“范围对象”的一些例子</span><br><span class="hljs-keyword">var</span> r = range(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//创建一个范围对象</span><br>r.includes(<span class="hljs-number">2</span>); <span class="hljs-comment">//true,2在这个范围内</span><br>r.foreach(<span class="hljs-built_in">console</span>/log); <span class="hljs-comment">//输出1 2 3</span><br><span class="hljs-built_in">console</span>.log(r); <span class="hljs-comment">//输出(1...3)</span><br></code></pre></td></tr></table></figure><p>两种写法一个非常重要的区别，就是原型对象的命名。在第一段示例代码中，原型是<code>range.methods</code>。在第二段示例代码中的原型是<code>Range.prototype</code>，这是一个强制的命名。对<code>Range()</code>构造的调用会自动使用<code>Range.prototype</code>作为新的Range对象的原型。</p><h4 id="1-构造函数和类的标识"><a href="#1-构造函数和类的标识" class="headerlink" title="1. 构造函数和类的标识"></a>1. 构造函数和类的标识</h4><p><img src="https://img-blog.csdnimg.cn/20200218085134606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-constructor属性"><a href="#2-constructor属性" class="headerlink" title="2. constructor属性"></a>2. constructor属性</h4><p>任何JavaScript函数都可以用做构造函数，并且调用构造函数是需要用到一个<code>prototype</code>属性的。因此，每个JavaScript函数（ECMASCript5中的<code>Function.bind（）</code>方法返回的函数除外）都自动拥有一个<code>prototype</code>属性。这个属性是一个对象，这个对象包含唯一一个不可枚举属性<code>constructor</code>。<code>constructor</code>属性的值是一个函数对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;; <span class="hljs-comment">// 这是一个函数对象</span><br><span class="hljs-keyword">var</span> p = F.prototype; <span class="hljs-comment">// 这是F相关联的原型对象</span><br><span class="hljs-keyword">var</span> c = p.constructor; <span class="hljs-comment">// 这是与原型相关的函数</span><br>c === F <span class="hljs-comment">// true，对于任意函数F.prototype.constructor == F</span><br></code></pre></td></tr></table></figure><h2 id="类的扩充"><a href="#类的扩充" class="headerlink" title="类的扩充"></a>类的扩充</h2><p>JavaScript中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。这意味着我们可以通过给原型对象添加新方法来扩充JavaScript类。</p><h2 id="类和类型"><a href="#类和类型" class="headerlink" title="类和类型"></a>类和类型</h2><p>下面介绍三种用以检测任意对象的技术：<code>instanceof</code>运算符，<code>constructor</code>属性，以及构造函数的名字。</p><h4 id="1-instanceof"><a href="#1-instanceof" class="headerlink" title="1. instanceof"></a>1. <code>instanceof</code></h4><p><code>instanceof</code>运算符的左操作数是待检测其类的对象，右操作数是定义类的构造函数。</p><p>如果<code>o</code>继承自<code>c.prototype</code>，则表达式<code>o instanceof c</code>值为<code>true</code>。这里的继承可以不是直接继承，如果<code>o</code>所继承的对象继承自另一个对象，后一个对象继承自<code>c.prototype</code>，这个表达式的运算结果也是<code>true</code>。</p><p><code>instanceof</code>运算符实际上是检测了对象的继承关系，而不是检测创建对象的构造函数。</p><p>那如果想检测对象的原型链上是否存在某个特定的原型对象，有没有不使用构造函数作为中介的方法？ 有！</p><p>可以使用<code>isPrototypeOf()</code>方法。比如，可以通过如下代码来检测对象r是否是之前说过的“范围类”的成员：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">range</span>.methods.isPrototypeOf(r); //<span class="hljs-built_in">range</span>.<span class="hljs-built_in">method</span>是原型<br></code></pre></td></tr></table></figure><p><code>instanceof</code>运算符和<code>isPrototypeOf()</code>方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。</p><h4 id="2-constructor属性-1"><a href="#2-constructor属性-1" class="headerlink" title="2. constructor属性"></a>2. constructor属性</h4><p>另一种识别对象是否属于某个类的方法是使用<code>constructor</code>属性。</p><p>在JavaScript中并非所有对象都包含<code>constructor</code>属性。</p><h4 id="3-构造函数的名称"><a href="#3-构造函数的名称" class="headerlink" title="3. 构造函数的名称"></a>3. 构造函数的名称</h4><p>使用<code>instanceof</code>运算符和<code>constructor</code>属性来检测对象所属的类有一个主要的问题，在多个执行上下文中存在构造函数的多个副本的时候，这两种函数看起来一模一样的，但它们是互相独立的对象，因此彼此也不相等。</p><p>一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。</p>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(5) 数组</title>
    <link href="/2020/02/13/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(5)%20%E6%95%B0%E7%BB%84/"/>
    <url>/2020/02/13/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(5)%20%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-数组"><a href="#第七章-数组" class="headerlink" title="第七章 数组"></a>第七章 数组</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h4 id="1-数组直接量"><a href="#1-数组直接量" class="headerlink" title="1. 数组直接量"></a>1. 数组直接量</h4><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> empty = []; <span class="hljs-comment">//没有元素的数组</span><br><span class="hljs-keyword">var</span> primes = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]; <span class="hljs-comment">//有5个数值的数组</span><br><span class="hljs-keyword">var</span> misc = [<span class="hljs-number">1.1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;a&quot;</span>]; <span class="hljs-comment">//有3个不同类型的元素的数组</span><br><span class="hljs-comment">//数组直接量中的值不一定要是常量，可以是任意的表达式</span><br><span class="hljs-keyword">var</span> base = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">var</span> table = [base, base+<span class="hljs-number">1</span>, base+<span class="hljs-number">2</span>, base+<span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> b = [[<span class="hljs-number">1</span>,&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>&#125;],[<span class="hljs-number">2</span>,&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">4</span>&#125;]];<br></code></pre></td></tr></table></figure><p>如果省略数组直接量中某个值，省略的元素将被赋予<code>undefined</code>值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> count = [<span class="hljs-number">1</span>,,<span class="hljs-number">3</span>]; <span class="hljs-comment">//数组有3个元素，中间的那个元素值为undefined</span><br><span class="hljs-keyword">var</span> underfs = [,,]; <span class="hljs-comment">//数组有2个元素，都是undefined</span><br></code></pre></td></tr></table></figure><p>数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</p><h4 id="2-调用构造函数Array-创建数组"><a href="#2-调用构造函数Array-创建数组" class="headerlink" title="2. 调用构造函数Array()创建数组"></a>2. 调用构造函数Array()创建数组</h4><ul><li><p>调用时没有参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br></code></pre></td></tr></table></figure><p>该方法创建一个没有任何元素的数组，等同于数组直接量[]。</p></li><li><p>调用时有一个数值参数，它指定长度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>该技术创建指定长度的数组。</p></li><li><p>显式指定两个或多个数组元素或者数组的一个非数值元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;testing,testing&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="数组元素的读和写"><a href="#数组元素的读和写" class="headerlink" title="数组元素的读和写"></a>数组元素的读和写</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&quot;world&quot;</span>];<span class="hljs-comment">//一个元素的数组开始</span><br><span class="hljs-keyword">var</span> value = a[<span class="hljs-number">0</span>]; <span class="hljs-comment">//读</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">3.14</span>; <span class="hljs-comment">//写</span><br>i = <span class="hljs-number">2</span>;<br>a[i] = <span class="hljs-number">3</span>;<br>a[i + <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>a[a[i]] = a[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>数组的特别之处在于，当使用小于<code>2^32</code>的非负数作为属性名时数组会自动维护其<code>length</code>属性值。</p><p>所有的索引都是属性名，但只有在<code>0-(2^32-2)</code>之间的整数属性名才是数组的索引。</p><p>所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的<code>length</code>属性值。</p><p>可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负数，它就只能当做常规的对象属性，而非数组的索引。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>[-<span class="hljs-number">1</span>.<span class="hljs-number">23</span>] = true; //这将创建一个名为“-<span class="hljs-number">1</span>.<span class="hljs-number">23</span>”的属性<br><span class="hljs-attribute">a</span>[<span class="hljs-string">&quot;1000&quot;</span>] = <span class="hljs-number">0</span>; // 这是数组的第<span class="hljs-number">1001</span>个元素<br><span class="hljs-attribute">a</span>[<span class="hljs-number">1</span>.<span class="hljs-number">000</span>] // 和a[<span class="hljs-number">1</span>]相等<br></code></pre></td></tr></table></figure><p>实际上数组索引仅仅是对象属性名的一种特殊类型，这意味着JavaScript数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到<code>undefined</code>值。类似于对象，对于对象同样存在这种情况。</p><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>稀疏数组就是包括从<code>0</code>开始的不连续索引的数组。</p><p>通常，数组的<code>length</code>属性值代表数组中元素的个数。如果数组是稀疏的，<code>length</code>属性值大于元素的个数。</p><p>可以用<code>Array()</code>构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 数组没有元素，但是a.length是5</span><br>a = []; <span class="hljs-comment">//创建一个空数组，length = 0</span><br>a[<span class="hljs-number">1000</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//赋值添加一个元素，但是设置length为1001</span><br></code></pre></td></tr></table></figure><p>也可以用<code>delete</code>操作符来产生稀疏数组。</p><p>注意，当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为<code>undefined</code>。这和数组元素根本不存在是有一些微妙的区别。可以用in操作符检测两者之间的区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a1 = [,,,]; <span class="hljs-comment">//数组是[undefined,undefined,undefined]</span><br><span class="hljs-keyword">var</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//该数组根本没有元素</span><br><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> a1 <span class="hljs-comment">//true：a1在索引0处有一个元素</span><br><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> a2 <span class="hljs-comment">//false：a2在索引0处没有元素</span><br></code></pre></td></tr></table></figure><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>为了维持“在数组中肯定找不到一个元素的索引值大于或等于它的长度。”这条规则，数组有两个特殊的行为。</p><ul><li><p>如果为严格数组元素赋值，它的索引i大于或等于现有数组的长度，<code>length</code>属性的值将设置为i+1。</p></li><li><p>设置length属性为严格小于当前长度的非负整数n时，当前索引大于或等于n的元素将从中删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]; <span class="hljs-comment">//从5个元素的数组开始</span><br>a.length = <span class="hljs-number">3</span>; <span class="hljs-comment">//现在a为[1,2,3]</span><br>a.length = <span class="hljs-number">0</span>; <span class="hljs-comment">//删除所有的元素，a为[]</span><br>a.length = <span class="hljs-number">5</span>; <span class="hljs-comment">//长度为5，但是没有元素，就像new Array(5)</span><br></code></pre></td></tr></table></figure></li></ul><p>在ECMAScript 5 中可以用<code>Object.defineProperty（）</code>让数组的<code>length</code>属性变成只读的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-built_in">Object</span>.definedProperty(a,<span class="hljs-string">&quot;length&quot;</span>,&#123;<span class="hljs-attr">writable</span>:<span class="hljs-literal">false</span>&#125;);<span class="hljs-comment">//让length属性只读</span><br>a.length = <span class="hljs-number">0</span>; <span class="hljs-comment">//a不会改变</span><br></code></pre></td></tr></table></figure><h2 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h2><h4 id="1-添加"><a href="#1-添加" class="headerlink" title="1. 添加"></a>1. 添加</h4><ul><li><p>最简单的方法：为新索引赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [] <span class="hljs-comment">//开始是一个空数组</span><br>a[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;zero&quot;</span>; <span class="hljs-comment">//然后向其中添加元素</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>使用<code>push()</code>方法在数组末尾增加一个或多个元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a = []; <span class="hljs-comment">//开始是一个空数组</span><br>a.push(<span class="hljs-string">&quot;zero&quot;</span>) <span class="hljs-comment">//在末尾添加一个元素。a = [&quot;zero&quot;]</span><br>a.push(<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>); <span class="hljs-comment">//再添加两个元素。a = [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>unshift（）</code>方法在数组首部插入一个元素，并且将其他元素依次移到更高的索引处</p></li></ul><h4 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h4><ul><li><p>可以像删除对象属性一样使用<code>delete</code>运算符来删除数组元素。注意删除一个数组元素使用<code>delete</code>不会修改数组的<code>length</code>属性，也不会将元素从高索引处移下来填充已删除属性的空白。如果从数组删除一个元素，它就变成稀疏数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">delete</span> a[<span class="hljs-number">1</span>]; <span class="hljs-comment">//a在索引1的位置不再有元素</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">in</span> a <span class="hljs-comment">//false：数组索引1并未在数组中定义</span><br>a.length <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>pop（）</code>方法，减少长度1并返回被删除元素的值。</p></li><li><p><code>shift（）</code>方法，从数组头部删除一个元素，所有元素下移到比当前索引低1的地方。</p></li></ul><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><ul><li><p>使用<code>for</code>循环是遍历数组元素最常用的方法</p><p>如果数组不是稠密的，或者存在不合法数据，在使用数组元素之前应该先检测它们。</p><p>如果想要排除<code>null</code>，<code>undefined</code>和不存在的元素。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i ++) &#123;<br><span class="hljs-keyword">if</span>(!a[i]) contine;<span class="hljs-comment">//跳出null，undefined和不存在的元素。 </span><br><span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想跳出<code>undefined</code>和不存在的元素，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br><span class="hljs-keyword">if</span> (a[i] == <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳出undefined + 不存在的元素</span><br><span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果想只跳出不存在的元素，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i ++) &#123;<br><span class="hljs-keyword">if</span>(!(i <span class="hljs-keyword">in</span> a)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//跳出不存在的元素</span><br><span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用<code>forEach()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]; <span class="hljs-comment">//这是需要遍历的数组</span><br><span class="hljs-keyword">var</span> sumOfSquares = <span class="hljs-number">0</span>; <span class="hljs-comment">//要得到数据的平方和</span><br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-comment">//把每个元素传递给此函数</span><br>sumOfSquares += x*x; <span class="hljs-comment">//平方相加</span><br>&#125;);<br>sumOfSquares <span class="hljs-comment">//55 : 1+4+9+16+25</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>JavaScript不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次[]操作即可。</p><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>下面主要介绍ECMAScript 3中的一些方法。</p><h4 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. <code>join()</code></h4><p>Array.join()方法将数组中所有元素都转化为字符串并连接在一起，<strong>返回最后生成的字符串</strong>。</p><p>可以指定一个可选的字符串在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。（<strong>不改变原数组</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-comment">//创建一个包含三个元素的数组</span><br>a.join(); <span class="hljs-comment">//“1,2,3”</span><br>a.join(<span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">//“1 2 3”</span><br>a.join(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//“123”</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//长度为10的空数组</span><br>b.join(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">//‘---------’九个连字符组成的字符串</span><br></code></pre></td></tr></table></figure><p><code>Array.join()</code>方法是<code>String.split（）</code>方法的逆向操作，<code>String.split（）</code>是将字符串分割成若干块来创建一个数组。</p><h4 id="2-reverse"><a href="#2-reverse" class="headerlink" title="2. reverse()"></a>2.<code> reverse()</code></h4><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，<strong>返回逆序的数组</strong>。</p><p>它采取的是替换；也就是它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们。（<strong>会改变原数组</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a.reverse().join <span class="hljs-comment">//“3，2,1”，并且现在的a是[3,2,1]</span><br></code></pre></td></tr></table></figure><h4 id="3-sort"><a href="#3-sort" class="headerlink" title="3. sort()"></a>3. <code>sort()</code></h4><p><code>Array.sort()</code>方法将数组中是元素排序并返回排序后的数组。</p><p>当不带参数调用<code>sort()</code>时，数组元素以字母顺序排序。（<strong>改变原数组</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;cherry&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>);<br>a.sort();<br><span class="hljs-keyword">var</span> s = a.json(<span class="hljs-string">&quot;, &quot;</span>);<span class="hljs-comment">//s == &quot;apple,banana,cherry&quot;</span><br></code></pre></td></tr></table></figure><p>如果数组包含<code>undefined</code>元素，它们会被排到数组的尾部。<br><img src="https://img-blog.csdnimg.cn/20200215210556376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020021521061293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-concat"><a href="#4-concat" class="headerlink" title="4. concat()"></a>4.<code> concat()</code></h4><p><code>Array.concat()</code>方法<strong>创建并返回一个新数组</strong>，它的元素包括调用<code>concat()</code>的原始数组的元素和<code>concat()</code>的每个参数。如果只想参数中，任何一个自身是数组，则连接的是数组的元素，而非数组本身。（<strong>不改变原数组</strong>）</p><p><code>concat()</code>不会递归扁平化数组的数组,也不会修改调用的数组.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a.concat(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//返回[1,2,3,4,5]</span><br>a.concat([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//[1,2,3,4,5]</span><br>a.concat([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]) <span class="hljs-comment">//[1,2,3,4,5,6,7]</span><br>a.concat(<span class="hljs-number">4</span>,[<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]])<span class="hljs-comment">//[1,2,3,4,5,[6,7]]</span><br></code></pre></td></tr></table></figure><h4 id="5-slice"><a href="#5-slice" class="headerlink" title="5. slice()"></a>5. <code>slice()</code></h4><p><code>Array.slice()</code>方法<strong>返回指定数组的一个片段或子数组</strong>。</p><p>它的两个参数分别指定了片段的开始和结束位置。</p><p>返回的数组包含：第一个参数指定的位置和所有到但不包含第二个参数指定的位置之间的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数出现负数，它表示相对于数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而参数-3指定了倒数第三个元素。注意，<code>slice()</code>不会修改调用的数组。（<strong>不改变原数组</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>a.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//返回[1,2,3]</span><br>a.slice(<span class="hljs-number">3</span>); <span class="hljs-comment">//[4,5]</span><br>a.slice(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>);<span class="hljs-comment">//[2,3,4]</span><br>a.slice(-<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>);<span class="hljs-comment">//[3]</span><br></code></pre></td></tr></table></figure><h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice()"></a>6. <code>splice()</code></h4><p><code>Array.splice()</code>方法是在数组中插入或删除元素的通用方法。不同于<code>slice()</code>和<code>concat()</code>，<code>splice()</code>会修改调用的数组。（<strong>改变原数组</strong>）<br><img src="https://img-blog.csdnimg.cn/20200215210631971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="7-push-和pop"><a href="#7-push-和pop" class="headerlink" title="7. push()和pop()"></a>7. <code>push()</code>和<code>pop()</code></h4><p><code>push()</code>方法在数组尾部添加一个或多个元素，并<strong>返回新的长度</strong>。</p><p><code>pop()</code>方法则相反：它删除数组的最后一个元素，减少数组长度并<strong>返回它删除的值</strong>。</p><p>注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。</p><p>组合使用<code>push()</code>和<code>pop()</code>能够用JavaScript数组实现先进后退的栈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> stack = []; <span class="hljs-comment">// stack:[]</span><br>stack.push(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// stack:[1,2] 返回2</span><br>stack.pop(); <span class="hljs-comment">// stack:[1] 返回2</span><br>stack.push(<span class="hljs-number">3</span>); <span class="hljs-comment">// stack[1,3] 返回2</span><br>stack.pop(); <span class="hljs-comment">// stack[1] 返回3</span><br>stack.push([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]); <span class="hljs-comment">// stack[1,[4,5]] 返回2</span><br>stack.pop(); <span class="hljs-comment">// stack:[1] 返回[4,5]</span><br>stack.pop(); <span class="hljs-comment">// stack:[] 返回1</span><br></code></pre></td></tr></table></figure><h4 id="8-unshift-和shift"><a href="#8-unshift-和shift" class="headerlink" title="8. unshift()和shift()"></a>8. <code>unshift()</code>和<code>shift()</code></h4><p><code>unshift()</code>和<code>shift()</code>方法的行为非常类似于<code>push()</code>和<code>pop()</code>，不一样的是：</p><p><code>unshift()</code>和<code>shift()</code>是在数组的头部进行元素的插入和删除操作。</p><p><code>unshift()</code>在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获取足够的空间，最后<strong>返回数组新的长度</strong>。</p><p><code>shift()</code>删除数组的第一个元素并<strong>返回它删除的值</strong>，然后所有随后元素下移一个位置来填补数组头部的空缺。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = []; <span class="hljs-comment">// a:[]</span><br>a.unshift(<span class="hljs-number">1</span>); <span class="hljs-comment">// a:[1] 返回：1</span><br>a.unshift(<span class="hljs-number">22</span>); <span class="hljs-comment">// a:[22,1] 返回：2</span><br>a.shift(); <span class="hljs-comment">// a:[1] 返回：22</span><br>a.unshift(<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]); <span class="hljs-comment">// a:[3,[4,5],1] 返回：3</span><br>a.shift(); <span class="hljs-comment">//a:[[4,5],1] 返回：3</span><br>a.shift(); <span class="hljs-comment">//a:[1] 返回：[4,5]</span><br>a.shift(); <span class="hljs-comment">//a:[] 返回：1</span><br></code></pre></td></tr></table></figure><p>当使用多个参数调用<code>unshift()</code>时它的行为令人惊讶。参数是一次插入的，(就像<code>splice()</code>方法)而非一次一个插入。这意味着最终的数组中插入的元素的顺序和她们在参数列表中顺序一致。而假如是一次一个地插入，它们的顺序应该是反过来。</p><h4 id="9-toString-和LocaleString"><a href="#9-toString-和LocaleString" class="headerlink" title="9. toString()和LocaleString()"></a>9. <code>toString()</code>和<code>LocaleString()</code></h4><p>数组和其他JavaScript对象一样拥有<code>toString()</code>方法。</p><p>针对数组，该方法将其每个元素转化为字符串(如有必要将调用元素的<code>toString（）</code>方法)并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].toString() <span class="hljs-comment">// 生成&#x27;1,2,3&#x27;</span><br>[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>].toString() <span class="hljs-comment">//生成&#x27;a,b,c&#x27;</span><br>[<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>]].toString() <span class="hljs-comment">//生成&#x27;1,2,c&#x27;</span><br></code></pre></td></tr></table></figure><p><code>toLocaleString（）</code>是<code>toString（</code>）方法的本地化版本。</p><p>它调用元素的<code>toLocaleString（）</code>方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。</p><h2 id="ECMAScript5中的数组方法"><a href="#ECMAScript5中的数组方法" class="headerlink" title="ECMAScript5中的数组方法"></a>ECMAScript5中的数组方法</h2><p>先对ECMAScript 5 中的数组方法做一个概述：</p><p>首先，大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。</p><p>在大多数情况下，调用提供的函数使用三个参数：数组元素，元素的索引和数组本身。通常，只需要第一个参数值，可以忽略后两个参数。</p><p>大多数ECMAScript5 数组方法的第一个参数是一个函数，第二个参数是可选的。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数传递进去的第二个参数作为它的this关键字来使用。</p><p>被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。</p><p>ECMAScript5中的数组方法都包含修改它们调用的原始数组。当然，传递给这些方法的函数是可以修改数组的。</p><h4 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach()"></a>1. <code>forEach()</code></h4><p><code>forEach()</code>方法从头到尾遍历数组，为每个元素调用指定的函数。</p><p>传递的函数作为<code>forEach()</code>的第一个参数。然后<code>forEach()</code>使用三个参数调用该函数：数组元素，元素的索引和数组本身。如果只关心数组元素的值，可以编写只有一个参数的函数，额外的参数将忽略：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]; <span class="hljs-comment">//要求和的数组</span><br><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;sun += value;&#125;);<br>sum <span class="hljs-comment">//15</span><br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v,i,a</span>)</span>&#123;a[i] = v + <span class="hljs-number">1</span>&#125;);<br>data <span class="hljs-comment">//[2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><p>注意，<code>forEach()</code>无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把<code>forEach()</code>方法放在一个<code>try</code>块中，并能抛出一个异常。如果<code>forEach()</code>调用的函数抛出<code>foreach.break</code>异常，循环会提前终止。</p><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. <code>map()</code></h4><p><code>map()</code> 方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。</p><p>（<strong>不改变原数组</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b = a.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> x*x;&#125;); <span class="hljs-comment">//b 是[1,4,9]</span><br></code></pre></td></tr></table></figure><p>传递给<code>map()</code>函数的调用和传递给<code>forEach()</code>的函数调用方式一样。</p><p>但传递给<code>map()</code>的函数应该有返回值。<code>map()</code>返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p><h4 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter()"></a>3. <code>filter()</code></h4><p><code>filter()</code>方法返回数组元素是调用数组元素的子集。</p><p>传递的函数是用来逻辑判定的：该函数返回<code>true</code>或<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br>smallvalue = a.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> x&lt;<span class="hljs-number">3</span>&#125;); <span class="hljs-comment">//[2,1]</span><br>everyother = a.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x,i</span>)</span>&#123;<span class="hljs-keyword">return</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//[5,3,1]</span><br></code></pre></td></tr></table></figure><p>注意，<code>filter()</code>会跳过稀疏数组中缺少的元素，它的返回值总是稠密的。</p><p>为了压缩稀疏数组的空缺，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> dense = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;);<br></code></pre></td></tr></table></figure><p>压缩空缺并删除<code>undefined</code>和<code>null</code>元素，可以这样使用<code>filter()</code>:</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">a = a.filter(functi<span class="hljs-meta">on(</span><span class="hljs-meta">x</span>)&#123;<span class="hljs-meta">return</span> <span class="hljs-meta">x</span> !== undefined <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-meta">x</span> != <span class="hljs-meta">null</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="4-every-和some"><a href="#4-every-和some" class="headerlink" title="4. every()和some()"></a>4. <code>every()</code>和<code>some()</code></h4><p><code>every()</code>和<code>some()</code>方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false。</p><p><code>every()</code>方法：当且仅当数组中所有元素调用判定函数都返回<code>true</code>，它才返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>a.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> x&lt;<span class="hljs-number">10</span>&#125;) <span class="hljs-comment">//true 所有值&lt;10</span><br>a.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span> === <span class="hljs-number">0</span>&#125;) <span class="hljs-comment">// false:不是所有值都是偶数</span><br></code></pre></td></tr></table></figure><p><code>some()</code>方法：当数组中至少有一个元素调用判定函数返回<code>true</code>，它就返回<code>true</code>；并且当且仅当所有元素调用判定都返回<code>false</code>，它才返回<code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>a.som(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span> === <span class="hljs-number">0</span>;&#125;) <span class="hljs-comment">//true，a包含偶数值</span><br>a.some(<span class="hljs-built_in">isNaN</span>) <span class="hljs-comment">//false，a不包含非数组元素</span><br></code></pre></td></tr></table></figure><p>注意，一旦<code>every()</code>和<code>some()</code>确认该返回什么值它们就会停止遍历数组元素。</p><p>在空数组上调用时，<code>every()</code>返回<code>true</code>,<code>some()</code>返回<code>false</code>。</p><h4 id="5-reduce-和reduceRight"><a href="#5-reduce-和reduceRight" class="headerlink" title="5. reduce()和reduceRight()"></a>5. <code>reduce()</code>和<code>reduceRight()</code></h4><p><code>reduce()</code>和<code>reduceRight()</code>方法使用指定的函数元素进行组合，生成单个值。</p><p><code>reduce()</code>需要两个参数，第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简的值。第二个（可选）的参数是一个传递给函数的初始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> sum = a.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>) </span>&#123;<span class="hljs-keyword">return</span> x+y&#125;,<span class="hljs-number">0</span>); <span class="hljs-comment">//数组求和</span><br><span class="hljs-keyword">var</span> product = a.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>) </span>&#123;<span class="hljs-keyword">return</span> x*y&#125;,<span class="hljs-number">1</span>); <span class="hljs-comment">//数组求积</span><br><span class="hljs-keyword">var</span> max = a.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>) </span>&#123;<span class="hljs-keyword">return</span> (x&gt;y)?x:y&#125;); <span class="hljs-comment">//求最大值</span><br></code></pre></td></tr></table></figure><p><code>reduce()</code>使用的函数和<code>map()</code>和<code>forEach()</code>使用的函数不同。在第一次调用函数中，第一个参数是一个初始值，它就是传递给<code>reduce()</code>的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。</p><p>在上面代码的第一个例子中，第一次调用化简函数的参数是0和1,。将两者相加并返回1.再次调用时的参数是1和2，他返回3.然后它计算3+3=6,6+4=10，最后10+5=15。<code>reduce()</code>就返回这个值。</p><p>上面代码第三个例子，调用<code>reduce()</code>时只有一个参数：没有指定初始值。当不指定初始化值调用<code>reduce()</code>时，它将使用数组的第一个元素作为其初始化值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。</p><p>在空数组上，不带初始值参数调用<code>reduce()</code>将导致类型错误异常。如果调用它的时候只有一个值—数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值—<code>reduce()</code>只是简单地返回那个值而不会调用化简函数。</p><p><code>reduceRight()</code>的工作原理和<code>reduce()</code>一样，不同的是他按照数组索引从高到低（从右到左）处理数组，而不是从低到高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-comment">//计算2^(3^4)。乘方操作的优先顺序是从右到左</span><br><span class="hljs-keyword">var</span> big = a.reduceRight(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator,value</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(value,accumulator);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="6-indexOf-和lastIndexOf"><a href="#6-indexOf-和lastIndexOf" class="headerlink" title="6. indexOf()和lastIndexOf()"></a>6.<code> indexOf()</code>和<code>lastIndexOf()</code></h4><p><code>indexOf()</code>和<code>lastIndexOf()</code>搜索这个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。</p><p><code>indexOf()</code>从头至尾搜索，而<code>lastIndexOf()</code>则反向搜索。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>];<br>a.indexOf(<span class="hljs-number">1</span>) <span class="hljs-comment">//1,a[1]是1</span><br>a.lastIndexOf(<span class="hljs-number">1</span>) <span class="hljs-comment">//3，a[3]是1</span><br>a.indexOf(<span class="hljs-number">3</span>) <span class="hljs-comment">//-1，没有值为3的元素</span><br></code></pre></td></tr></table></figure><p><code>indexOf()</code>和<code>lastIndexOf()</code>方法的第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索。如果省略该参数，<code>indexOf()</code>从头开始搜索，而<code>lastIndexOf()</code>从末尾开始搜索。第二个参数也可以是负数，它代表相对数组末尾的偏移量。</p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>在ECMAScript5中，可以使用<code>Array.isArray()</code>函数判断严格未知的对象是否为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.isArray([]) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">Array</span>.isArray(&#123;&#125;) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="作为数组的字符串"><a href="#作为数组的字符串" class="headerlink" title="作为数组的字符串"></a>作为数组的字符串</h2><p>在ECMAScript5 中，字符串的行为类似于只读的数组。除了用<code>charAt()</code>方法来访问单个的字符以外，还可以使用方括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = test;<br>s.charAt(<span class="hljs-number">0</span>) <span class="hljs-comment">// &quot;t&quot;</span><br>s[<span class="hljs-number">1</span>] <span class="hljs-comment">//&quot;e&quot;</span><br></code></pre></td></tr></table></figure><p>当然，针对字符串的<code>typeof</code>操作符仍然返回”<code>string</code>“，但是如果给<code>Array.isArray()</code>传递字符串，它将返回<code>false</code>。</p><p>字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如<code>push()</code>,<code>sort()</code>,<code>reverse()</code>和<code>splice()</code>等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。</p>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(4) 对象</title>
    <link href="/2020/02/13/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(4)%20%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/02/13/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(4)%20%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-对象"><a href="#第六章-对象" class="headerlink" title="第六章 对象"></a>第六章 对象</h1><p>对象是一种复合值：它将很多值聚合在一起，可通过名字访问这些值。</p><p>JavaScript对象是动态的，可以新增属性也可以删除属性。</p><p>对象也可以看做属性的无序集合，每个属性都是一个名/值对。属性名是字符串。</p><p>属性包括名字和值。属性名可以包括空字符在内的任意字符串，但对象不能存在同名的属性。值可以是任意JavaScript值，或者可以是一个<code>getter</code>或<code>setter</code>函数。</p><p><strong>除了名字和值之外。每个属性还有一些与之相关的值，称为“属性特性”</strong>：</p><ul><li>可写：表明是否可以设置该属性的值。</li><li>可枚举：表明是否可以通过<code>for/in</code>循环返回该属性。</li><li>可配置：表明是否可以删除或修改该属性。</li></ul><p><strong>除了包括属性之外，每个对象还拥有三个相关的对象特性</strong>：</p><ul><li>对象的原型：指向另外一个对象，本对象的属性继承自它的原型对象。</li><li>对象的类：是一个标识对象类型的字符串。</li><li>对象的扩展：标记指明了是否可以向该对象添加新属性。</li></ul><p><strong>用下面这些术语来对三类JavaScript对象和两类属性作区分</strong>：</p><ul><li>内置对象：是由ECMAScript规范定义的对象或类。例如，数组，函数，日期和正则表达式都是内置对象。</li><li>宿主对象：是由JavaScript解释器所嵌入的宿主环境（比如web浏览器）定义的。客户端JavaScript中表示网页结构的HTMLElement对象均是宿主对象。既然宿主环境定义的方法可以当成普通的JavaScript函数对象，那么宿主对象也可以当成内置对象。</li><li>自定义对象：是由运行中的JavaScript代码创建的对象。</li><li>自有属性是直接在对象中定义的属性。</li><li>继承属性：是在对象的原型对象中定义的属性。</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>可以通过对象直接量，关键字<code>new</code>和<code>Object.create（）</code>函数来创建对象。</p><h4 id="1-对象直接量"><a href="#1-对象直接量" class="headerlink" title="1. 对象直接量"></a>1. 对象直接量</h4><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">var empty = &#123;&#125;; <span class="hljs-regexp">//</span>没有任何属性的对象<br>var point1 = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>&#125;; <span class="hljs-regexp">//</span>两个属性<br>var point2 = &#123; x: point.x, y: point.y + <span class="hljs-number">1</span> &#125;; <span class="hljs-regexp">//</span>更复杂的值<br>var book = &#123;<br><span class="hljs-string">&quot;main title&quot;</span>: <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-regexp">//</span>属性名字里有空格，必须用字符串表示<br><span class="hljs-string">&quot;sub-title&quot;</span>: <span class="hljs-string">&quot;The Definitive Cuide&quot;</span>; <span class="hljs-regexp">//</span>属性名字里有连字符，必须用字符串表示<br><span class="hljs-string">&quot;for&quot;</span>: <span class="hljs-string">&quot;all audience&quot;</span>; <span class="hljs-regexp">//</span>“<span class="hljs-keyword">for</span>”是保留字，因此必须用引号<br>author: &#123; <span class="hljs-regexp">//</span>这个属性的值是一个对象<br>firstname: <span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-regexp">//</span>注意，这里的属性名都没有引号<br>surname: <span class="hljs-string">&quot;Flanage&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。</p><h4 id="2-通过new创建对象"><a href="#2-通过new创建对象" class="headerlink" title="2. 通过new创建对象"></a>2. 通过new创建对象</h4><p><code>new</code>运算符创建并初始化一个新对象。关键字<code>new</code>后面跟随一个函数调用。</p><p>这里的函数称做构造函数，构造函数用以初始化一个新创建的对象。</p><p>JavaScript语言核心中的原始类型都包含内置构造函数。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>(); <span class="hljs-comment">//创建一个空对象，和&#123;&#125;一样</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(); <span class="hljs-comment">//创建一个空数组，和[]一样</span><br><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-type">Date</span>(); <span class="hljs-comment">//创建一个表示当前时间的Date对象</span><br><span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> <span class="hljs-type">RegExp</span>(<span class="hljs-string">&quot;js&quot;</span>); <span class="hljs-comment">//创建一个可以进行模式匹配的RegExp</span><br></code></pre></td></tr></table></figure><h4 id="3-原型"><a href="#3-原型" class="headerlink" title="3. 原型"></a>3. 原型</h4><p>每一个JavaScript对象都和另一个对象相关联。“另一个”对象就是我们熟知的原型。每一个对象都从原型继承属性。</p><p>所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过JavaScript代码<code>Object.prototype</code>获得对原型对象的引用。</p><p>通过关键字new和构造函数创建的对象的原型就是构造函数的<code>prototype</code>属性的值。</p><p>因此，同使用{}创建对象一样，通过<code>new Object()</code>创建的对象也继承自<code>Object.prototype</code>。</p><p>通过<code>new Array()</code>创建的对象的原型就是<code>Array.prototype</code>，通过<code>new Date()</code>创建的对象的原型就是<code>Date.prototype</code>。</p><p>没有原型的对象为数不多，<code>Object.prototype</code>就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。</p><p>所有的内置构造函数，都具有一个继承自<code>Object.prototype</code>的原型。例如，<code>Date.prototype</code>的属性继承自<code>Object.protype</code>，因此由new Date()创建的Date对象的属性同时继承自<code>Date.prototype</code>和<code>Object.prototype</code>。这一系列链接的原型对象就是所谓的“原型链”</p><h4 id="4-Object-create"><a href="#4-Object-create" class="headerlink" title="4. Object.create()"></a>4. Object.create()</h4><p>它创建一个新对象，其中第一个参数是这个对象的原型，<code>Object.create()</code>提供第二个可选参数，用以对对象的属性进行进一步描述。</p><p><code>Object.create()</code>是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> o<span class="hljs-number">1</span> = Object.create(&#123;x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>&#125;); //o<span class="hljs-number">1</span>继承了属性x和y<br></code></pre></td></tr></table></figure><p>可以通过传入参数<code>null</code>来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如<code>toString()</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">null</span>); <span class="hljs-comment">//o2不继承任何属性和方法</span><br></code></pre></td></tr></table></figure><p>如果想创建一个普通的对象（比如通过<code>&#123;&#125;</code>或<code>new Object()</code>创建的对象），需要传入<code>Object.prototype</code>:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var o3 = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(<span class="hljs-keyword">Object</span>.prototype);//o3和&#123;&#125;和<span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>()一样<br></code></pre></td></tr></table></figure><h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><p>可以通过点（<code>.</code>）或方括号（<code>[]</code>）运算符来获取属性的值。</p><p>对于点（<code>.</code>）来说，右侧必须是一个以属性名称命名的简单标识符。</p><p>对于方括号(<code>[]</code>)，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> author = book.author; <span class="hljs-comment">//得到book的“author”属性</span><br><span class="hljs-keyword">var</span> name = author.surname <span class="hljs-comment">//得到author的“surname”属性</span><br><span class="hljs-keyword">var</span> title = book[<span class="hljs-string">&quot;main title&quot;</span>] <span class="hljs-comment">//得到book的“main title”</span><br></code></pre></td></tr></table></figure><p>和查询属性值的写法一样，通过点和方括号也可以创建属性或给属性赋值。但需要将它们放在赋值表达式的左侧：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">book.edition = <span class="hljs-number">6</span><span class="hljs-comment">;</span><br>book[<span class="hljs-string">&quot;main title&quot;</span>] = <span class="hljs-string">&quot;ECMAScript&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="1-作为关联数组的对象"><a href="#1-作为关联数组的对象" class="headerlink" title="1. 作为关联数组的对象"></a>1. 作为关联数组的对象</h4><p>下面两个JavaScript表达式的值相同：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">object</span><span class="hljs-selector-class">.property</span><br><span class="hljs-selector-tag">object</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;property&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>其中第二种语法使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串引索而不是数字索引。这种数组就是我们所说的关联数组。</p><p>JavaScript对象都是关联数组。</p><h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h4><p>JavaScript对象具有“自有属性”，也有一些属性是从原型对象继承而来的。</p><p>假设要查询对象o的属性x，如果o中不存在，那么将会继续在o的原型对象中查询属性x。如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。</p><p>可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">var o = &#123;&#125; <span class="hljs-regexp">//</span>o从Object.prototype继承对象的方法<br>o.x = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span>给o定义一个属性x<br>var a = inherit(o); <span class="hljs-regexp">//</span> a继承o和Object.prototype<br>a.y = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span> 给a定义一个属性y<br>var b = inherit(a); <span class="hljs-regexp">//</span> 给b定义一个属性z<br>b.z = <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span><br>var s = b.toString(); <span class="hljs-regexp">//</span> toString继承自Object.protoype<br>b.x + b.y <span class="hljs-regexp">//</span><span class="hljs-number">3</span> ,x和y分别继承自o和a<br></code></pre></td></tr></table></figure><p>假设给对象的属性x赋值，如果o中已经有属性x，那么这个赋值操作只改变这个已有属性x的值。如果o中不存在属性x，那么赋值操作给o添加一个新属性x。如果之前o继承自属性x，那么这个继承的属性就被创建的同名属性覆盖了。</p><p>属性赋值操作首先检查原型链，以此判定是否允许赋值操作。如果o继承自一个只读属性，那么赋值操作是不允许的。如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有属性赋值，而不会去修改原型链。</p><p>在JavaScript中，只有在查询时才会体会到继承的存在，而设置属性则和继承无关，这是JavaScript的一个重要特性，该特性让程序员可以有选择地覆盖继承的属性。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">var unitcircle = &#123;r: <span class="hljs-number">1</span>&#125;; <span class="hljs-regexp">//</span> 一个用来继承的对象<br>var c = inherit(unitcircle); <span class="hljs-regexp">//</span>c继承属性r<br>c.x = <span class="hljs-number">1</span>;c.y = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span>c定义两个属性<br>c.r = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span>c覆盖继承来的属性<br>unitcircle.r; <span class="hljs-regexp">//</span><span class="hljs-number">1</span> ， 原型对象没有修改<br></code></pre></td></tr></table></figure><h4 id="3-属性访问错误"><a href="#3-属性访问错误" class="headerlink" title="3. 属性访问错误"></a>3. 属性访问错误</h4><p>属性访问并不总是返回或设置一个值。</p><p>查询一个不存在的属性并不会报错，如果在对象o自身的属性或继承的属性均未找到属性x，属性访问表达式o.x返回undefined。</p><p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null和undefined值都没有属性，因此查询这些值的属性会报错。给null和undefined设置属性也会报类型错误。</p><p>给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性，但让人颇感意外的是，这些设置属性的失败操作不会报错。<br><img src="https://img-blog.csdnimg.cn/20200213210259170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p><code>delete</code>运算符可以删除对象的属性。它的操作数应当是一个属性访问表达式。</p><p><code>delete</code>只是断开属性和宿主对象的联系，而不会去操作属性中的属性：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">delete</span> book.author; <span class="hljs-regexp">//</span>book不再有属性author<br><span class="hljs-keyword">delete</span> book[<span class="hljs-string">&quot;main title&quot;</span>]; <span class="hljs-regexp">//</span>book也不再有属性<span class="hljs-string">&quot;main title&quot;</span><br></code></pre></td></tr></table></figure><p><code>delete</code>运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响所有继承自这个原型的对象。）<br><img src="https://img-blog.csdnimg.cn/20200213210316728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200213210328298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><p>我们经常会检测集合中成员的所属关系—–判断某个属性是否在于某个对象中。可以</p><h4 id="1-in运算符"><a href="#1-in运算符" class="headerlink" title="1. in运算符"></a>1. in运算符</h4><p>通过<code>in</code>运算符，<code>hasOwnPreperty()</code>和<code>propertyIsEnumerable()</code>方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">var o = &#123; x: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-string">&quot;x&quot;</span> <span class="hljs-keyword">in</span> o; <span class="hljs-regexp">//</span>true ， “x”是o的属性<br><span class="hljs-string">&quot;y&quot;</span> <span class="hljs-keyword">in</span> o; <span class="hljs-regexp">//</span>false，“y”不是o的属性<br><span class="hljs-string">&quot;toString&quot;</span> <span class="hljs-keyword">in</span> o; <span class="hljs-regexp">//</span>true，o继承toString属性<br></code></pre></td></tr></table></figure><h4 id="2-hasOwnProperty-方法"><a href="#2-hasOwnProperty-方法" class="headerlink" title="2. hasOwnProperty()方法"></a>2. hasOwnProperty()方法</h4><p>用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">var o = &#123;x: <span class="hljs-number">1</span>&#125;<br>o.hasOwnProperty(<span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-regexp">//</span>true：有一个自有属性x<br>o.hasOwnProperty(<span class="hljs-string">&quot;y&quot;</span>); <span class="hljs-regexp">//</span>false：o中不存在属性y<br>o.hasOwnProperty(<span class="hljs-string">&quot;toString&quot;</span>); <span class="hljs-regexp">//</span> false:toString是继承属性<br></code></pre></td></tr></table></figure><h4 id="3-propertyIsEnumerable-方法"><a href="#3-propertyIsEnumerable-方法" class="headerlink" title="3. propertyIsEnumerable()方法"></a>3. propertyIsEnumerable()方法</h4><p>是<code>hasOwnProperty()</code>方法的增强版，只有检测到是自有属性且这个属性的可枚举性为<code>true</code>时，它才返回<code>true</code>。</p><p>某些内置属性是不可枚举的。通常由JavaScript代码创建的属性都是可枚举的，除法在ECMAScript中使用严格特殊的方法来改变属性的可枚举性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var o = <span class="hljs-keyword">inherit</span>(&#123;y: <span class="hljs-number">2</span>&#125;);<br>o.x = <span class="hljs-number">1</span>;<br>o.property<span class="hljs-constructor">IsEnumerable(<span class="hljs-string">&quot;x&quot;</span>)</span>; <span class="hljs-comment">//true,o有一个可枚举的自有属性</span><br>o.property<span class="hljs-constructor">IsEnumerable(<span class="hljs-string">&quot;y&quot;</span>)</span>; <span class="hljs-comment">//false，y是继承来的</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype.property<span class="hljs-constructor">IsEnumerable(<span class="hljs-string">&quot;toString&quot;</span>)</span>; <span class="hljs-comment">//false，不可枚举</span><br></code></pre></td></tr></table></figure><h4 id="4-“！-”"><a href="#4-“！-”" class="headerlink" title="4. “！==”"></a>4. “！==”</h4><p>可以用来判断严格属性是否是<code>undefined</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">var o = &#123;x:<span class="hljs-number">1</span>&#125;<br>o.x !== undefined; <span class="hljs-regexp">//</span>true<br>o.y !== undefined; <span class="hljs-regexp">//</span>false:o中没有属性y<br>o.toString !== undefined; <span class="hljs-regexp">//</span>true:o继承了toString属性<br><br><span class="hljs-regexp">//</span>注意：<br>var o = &#123; x: undefined &#125; <span class="hljs-regexp">//</span>属性被显式赋值为undefined<br>o.x !== undefined <span class="hljs-regexp">//</span>false，属性存在，但为undefined<br>o.y !== undefined <span class="hljs-regexp">//</span>false，属性不存在<br><span class="hljs-string">&quot;x&quot;</span> <span class="hljs-keyword">in</span> o <span class="hljs-regexp">//</span>true<br><span class="hljs-string">&quot;y&quot;</span> <span class="hljs-keyword">in</span> o <span class="hljs-regexp">//</span>false<br><span class="hljs-keyword">delete</span> o.x; <span class="hljs-regexp">//</span>删除了属性x<br><span class="hljs-string">&quot;x&quot;</span> <span class="hljs-keyword">in</span> o <span class="hljs-regexp">//</span>false<br></code></pre></td></tr></table></figure><h2 id="属性getter和setter"><a href="#属性getter和setter" class="headerlink" title="属性getter和setter"></a>属性getter和setter</h2><p>在ECMAScript5中，属性值可以用一个或两个方法替代，这两个方法就是<code>getter</code>和<code>setter</code>。由<code>getter</code>和<code>setter</code>定义的属性称做“存取器属性”，它不同于“数据属性”，数据属性只有一个简单的值。<br><img src="https://img-blog.csdnimg.cn/20200213210652284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200213210527535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>JavaScript把<code>getter</code>和<code>setter</code>函数当做对象的方法来调用，也就是说，在函数体内的this指向表示这个点的对象。</p><p>和数据属性一样，存取器属性是可以继承的。</p><p>因此可以将上述代码中的对象p当做另一个“点”的原型。可以给新对象定义它的x和y属性，但r和theta属性是继承来的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">var q = inherit(p); <span class="hljs-regexp">//</span>创建一个继承getter和setter的新对象<br>q.x = <span class="hljs-number">1</span>,q.y = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span>给q添加两个属性<br>console.log(q.r); <span class="hljs-regexp">//</span>可以使用继承的存取器属性<br>console.log(q.theta);<br></code></pre></td></tr></table></figure><h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><p>除了包含名字和值外，属性还包含一些标识它们可写，可枚举和可配置的特性。</p><p>在ECMAScript3中无法设置这些特性，所有通过ECMASCript3的程序创建的属性都是可写的，可枚举的和可配置的，且无法对这些特性做修改。下面讲述ECMAScript5中查询和设置这些特性的API。</p><p>可以通过这些API给原型对象添加方法，并将它们设置成不可枚举的，让他们看起来更像内置方法。还可以通过这些API给对象定义不能修改或删除的属性，借此“锁定”这个对象。</p><h2 id="对象的三个属性"><a href="#对象的三个属性" class="headerlink" title="对象的三个属性"></a>对象的三个属性</h2><p>每个对象都有与之对应的原型（prototype），类（class）和可拓展性（extensible attribute）。</p><h4 id="1-原型属性"><a href="#1-原型属性" class="headerlink" title="1. 原型属性"></a>1. 原型属性</h4><p>对象的原型属性是用来继承属性的。</p><p>想要检测一个对象是否是另一个对象的原型（或处于原型链中），请使用<code>isPrototypeOf（）</code>方法。</p><p>例如，可以使用<code>p.isPrototypeOf(o)</code>来检测p是否是o的原型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var p = &#123;x: <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//定义一个原型对象</span><br>var o = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(p); <span class="hljs-comment">// 使用这个原型创建一个对象</span><br>p.is<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">o</span>)</span> <span class="hljs-comment">// true：o继承自p</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype.is<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">o</span>)</span> <span class="hljs-comment">//true：p继承自Object.prototype</span><br></code></pre></td></tr></table></figure><h4 id="2-类属性"><a href="#2-类属性" class="headerlink" title="2. 类属性"></a>2. 类属性</h4><h4 id="3-可扩展性"><a href="#3-可扩展性" class="headerlink" title="3. 可扩展性"></a>3. 可扩展性</h4><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><p>所有JavaScript对象都从<code>Object.prototype</code>继承属性（除了那些不通过原型显式创建的对象）。这些继承属性主要是方法。</p><p>下面将对定义在<code>Object.prototype</code>里的对象方法展开讲解，这些方法非常好用而且使用广泛，但一些特定的类会重写这些方法。</p><h4 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1. toString()方法"></a>1. toString()方法</h4><p><code>toString（）</code>方法没有参数，它将返回一个表示这个方法的对象值的字符串。</p><p>在需要将对象转换为字符串的时候，JavaScript都会调用这个方法。比如，当使用“+”运算符连接一个字符串和一个对象时或者希望使用字符串的方法中使用了对象时都会调用<code>toString（）</code>。</p><p>默认的<code>toString（）</code>方法的返回值带有的信息量很少。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> s = &#123;x: <span class="hljs-number">1</span>,y: <span class="hljs-number">1</span>&#125;.toString();<br></code></pre></td></tr></table></figure><p>因此很多类都带有自定义的<code>toString（）</code>。</p><h4 id="2-toLocaleString（）方法"><a href="#2-toLocaleString（）方法" class="headerlink" title="2. toLocaleString（）方法"></a>2. toLocaleString（）方法</h4><p><img src="https://img-blog.csdnimg.cn/20200213210507919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-toJSON（）方法"><a href="#3-toJSON（）方法" class="headerlink" title="3. toJSON（）方法"></a>3. toJSON（）方法</h4><p><img src="https://img-blog.csdnimg.cn/20200213210455448.png" alt="在这里插入图片描述"></p><h4 id="4-valueOf-方法"><a href="#4-valueOf-方法" class="headerlink" title="4. valueOf()方法"></a>4. valueOf()方法</h4><p><img src="https://img-blog.csdnimg.cn/20200213210444408.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库操作</title>
    <link href="/2020/02/12/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/02/12/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><code>select 字段名 from 表名；</code>查询指定字段</p>]]></content>
    
    
    <categories>
      
      <category>项目开发常用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(3) 语句</title>
    <link href="/2020/02/12/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(3)%20%E8%AF%AD%E5%8F%A5/"/>
    <url>/2020/02/12/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(3)%20%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章  语句"></a>第五章  语句</h1><p>JavaScript语句以分号结束。</p><p>表达式计算出一个值，但语句用来执行以使某件事发生。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><code>if</code>语句在程序执行过程中创建一条分支，并且可以使用<code>else if</code>来处理多条分支。然而当所有的分支都依赖于同一个表达式的值时，<code>else if</code>并不是最佳解决方案。</p><p><code>switch</code>语句正适合处理这种情况。</p><p>语法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">switch</span><span class="hljs-params">(expression)</span></span> &#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure><p> 例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">switch(n) &#123;<br>case <span class="hljs-number">1</span>: <span class="hljs-regexp">//</span> 如果 n === <span class="hljs-number">1</span>，从这里开始执行<br><span class="hljs-regexp">//</span> 执行代码块 <span class="hljs-number">1</span><br><span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> 停止执行switch语句<br>case <span class="hljs-number">2</span>: <span class="hljs-regexp">//</span> 如果 n === <span class="hljs-number">3</span>，从这里执行<br><span class="hljs-regexp">//</span> 执行代码块<span class="hljs-number">2</span><br><span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> 在这里停止执行switch语句<br>case <span class="hljs-number">3</span>: <span class="hljs-regexp">//</span> 如果 n === <span class="hljs-number">3</span>，从这里执行<br><span class="hljs-regexp">//</span> 执行代码块<span class="hljs-number">3</span><br><span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span>在这里停止执行switch语句<br>default:<span class="hljs-regexp">//</span>如果所有的条件都不匹配<br><span class="hljs-regexp">//</span> 执行代码块<span class="hljs-number">4</span><br><span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span>在这里停止执行switch语句<br>&#125;<br></code></pre></td></tr></table></figure><p>这里“相同”是按照“===”运算符进行比较。</p><p><code>case</code>关键字后除了跟随的是数字和字符串直接量，ECMAScript标准允许每个<code>case</code>关键字跟随任意的表达式。</p><p>在前面例子中，“<code>default：</code>”标签出现在<code>switch</code>末尾，位于所有<code>case</code>标签之后，这是最合理最常见的写法，实际上，“<code>default：</code>”标签可以放置在<code>switch</code>语句内的任何地方。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>JavaScript有4种循环语句：<code>while</code>，<code>do/while</code>，<code>for</code>和<code>for/in</code>。</p><h4 id="1-while"><a href="#1-while" class="headerlink" title="1. while"></a>1. while</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> ( <span class="hljs-regexp">//</span> 逻辑条件) &#123;<br><span class="hljs-regexp">//</span> 循环体<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code>循环流程图：<br><img src="https://img-blog.csdnimg.cn/20200213135037103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-do-while"><a href="#2-do-while" class="headerlink" title="2. do/while"></a>2. do/while</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-regexp">//</span> 循环体<br>&#125; <span class="hljs-keyword">while</span> ( <span class="hljs-regexp">//</span> 逻辑条件)<br></code></pre></td></tr></table></figure><p><code>do/while</code>循环流程图：<br><img src="https://img-blog.csdnimg.cn/20200213135051988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-for"><a href="#3-for" class="headerlink" title="3. for"></a>3. for</h4><p>语法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> ( 表达式<span class="hljs-number">1</span>; 表达式<span class="hljs-number">2</span>; 表达式<span class="hljs-number">3</span>) &#123;<br><span class="hljs-regexp">//</span>循环体<br>&#125;<br></code></pre></td></tr></table></figure><p>表达式1只在循环开始之前执行一次。</p><p>有些循环比较复杂，循环中的一次迭代会改变多个变量。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">var</span> i,j;<br><span class="hljs-attribute">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">10</span>; <span class="hljs-attribute">i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-attribute">i</span> ++, j --) &#123;<br><span class="hljs-attribute">sum</span> += i*j;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for</code>循环流程图：<br><img src="https://img-blog.csdnimg.cn/2020021313511593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-for-in"><a href="#4-for-in" class="headerlink" title="4. for/in"></a>4. for/in</h4><p><code>for/in</code>它和常规的<code>for</code>循环完全是不同的一类循环。</p><p>语法：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">variable</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br><span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>variable</code>通常是一个变量名，也可以是一个可以产生左值的表达式或者通过<code>var</code>语句声明的变量，总之必须是一个适用于赋值表达式左侧的值。</p><p><code>object</code>是一个表达式，这个表达式的计算结果是一个对象。</p><p><code>for/in</code>循环通常是用来更方便地遍历对象属性成员：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span>(var p <span class="hljs-keyword">in</span> o) &#123; <span class="hljs-regexp">//</span>将属性名字赋值给变量p<br>console.log(o[p]); <span class="hljs-regexp">//</span>输出每一个属性的值<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>跳转语句使得JavaScript的执行可以从一个位置跳转到另一个位置。</p><p><code>break</code>语句是跳转到循环或者其他语句的结束。</p><p><code>continue</code>语句是终止本次循环的执行并开始下一次循环的执行。</p><p><code>return</code>语句让解释器跳出函数体的执行，并提供本次调用的返回值。</p><p><code>throw</code>语句触发或者“抛出”一个异常，它与<code>try/catch/finally</code>语句一同使用的，这些语句指定了处理异常的代码逻辑。</p><h4 id="1-throw语句"><a href="#1-throw语句" class="headerlink" title="1. throw语句"></a>1. throw语句</h4><p>异常：是当发生了某种情况或错误时产生的一个信号。</p><p>抛出异常：就是用信号通知发生了错误或异常状况。</p><p>捕获异常：指处理这个信号，即采用必要的手段从异常中恢复。</p><p>在JavaScript中，当产生运行时错误或者程序使用<code>throw</code>语句时就会显示地抛出异常。使用<code>try/catch/finally</code>语句可以捕获异常。</p><p><code>throw</code>语法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">throw expression<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>expression</code>的值可以是任意类型的。可以抛出一个代表错误的数字，或者包含可读的错误消息的字符串。当JavaScript解释器抛出异常的时候通常采用<code>Error</code>类型和其子类型。一个<code>Error</code>对象有一个<code>name</code>属性表示错误类型，一个<code>message</code>属性用来存放传递给构造函数的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">x</span>) </span>&#123;<br><span class="hljs-comment">//如果输入参数是非法的，则抛出一个异常</span><br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;x不能是负数&quot;</span>);<br><span class="hljs-comment">//否则，计算出一个值，并正常地返回它</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> f = <span class="hljs-number">1</span>; x &gt; <span class="hljs-number">1</span>; f *= x, x --);<br><span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure><p>当抛出异常时，JavaScript解释器会立即停止当前正在执行的逻辑，并跳至就近的异常处理程序。异常处理程序是用<code>try/catch/finally</code></p><h4 id="2-try-catch-finally"><a href="#2-try-catch-finally" class="headerlink" title="2. try/catch/finally"></a>2. try/catch/finally</h4><p><code>try</code>从句定义了需要处理的异常所在的代码块。</p><p><code>catch</code>从句跟随在try从句之后，当try块内某处发生异常时，调用catch内的代码逻辑。</p><p><code>finally</code>中放置清理代码，不管try块中是否产生异常，finally块内的逻辑总是会执行。</p><p>下面的代码说明了<code>try/catch/finally</code>的语法和使用目的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">try &#123;<br><span class="hljs-regexp">//</span>通常来件，这里的代码会从头执行到尾而不会产生任何问题，<br><span class="hljs-regexp">//</span>但有时会抛出一个异常，要么是由throw语句直接抛出异常<br><span class="hljs-regexp">//</span>要么是通常调用一个方法间接抛出异常<br>&#125;<br>catch(e) &#123;<br><span class="hljs-regexp">//</span>当且仅当try语句块抛出异常，才会执行这里的代码<br><span class="hljs-regexp">//</span>这里可以通过局部变量e来获得Error对象或者抛出的其他值的引用<br><span class="hljs-regexp">//</span>这里的代码可以基于某种原因处理这个异常。也可以忽略这个异常<br><span class="hljs-regexp">//</span>还可以通过throw语句重新抛出异常<br>&#125;<br>finally &#123;<br><span class="hljs-regexp">//</span>不管try语句块是否抛出异常，这里的逻辑总是执行，终止try语句块的方式有：<br><span class="hljs-regexp">//</span>正常终止，执行完语句块的最后一条语句<br><span class="hljs-regexp">//</span>通过<span class="hljs-keyword">break</span>，<span class="hljs-keyword">continue</span>或return语句终止<br><span class="hljs-regexp">//</span>抛出一个异常，异常被catch从句捕获<br><span class="hljs-regexp">//</span>抛出一个异常，异常未被捕获，继续向上传播<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他语句类型"><a href="#其他语句类型" class="headerlink" title="其他语句类型"></a>其他语句类型</h2><h4 id="1-with语句"><a href="#1-with语句" class="headerlink" title="1. with语句"></a>1. with语句</h4><p>with语句用于临时扩展作用域链，它具有如下的语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">with</span> (<span class="hljs-keyword">object</span>)<br><span class="hljs-keyword">statement</span><br></code></pre></td></tr></table></figure><p>这条语句将<code>object</code>添加到作用域的头部，然后执行<code>statement</code>，最后把作用域链恢复到原始状态。</p><p>在严格模式中，是禁止使用<code>with</code>语句，并且在非严格模式里也是不推荐使用<code>with</code>语句，尽可能避免使用<code>with</code>语句。那些使用with语句的JavaScript代码非常难于<code>with</code>语句，并且同没有使用<code>with</code>语句的代码相比，它运行得更慢。</p><p>在对象嵌套层次很深的时候通常会使用<code>with</code>语句来简化代码编写。</p><p>例如：在客户端JavaScript中，可能会使用类似下面这种表达式来访问一个HTML表单中元素：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">document<span class="hljs-selector-class">.forms</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.address</span>.value<br></code></pre></td></tr></table></figure><p>如果这种表达式在代码中多次出现，则可以使用<code>with</code>语句将form对象添加至作用域链的顶层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params"><span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>]</span>)</span> &#123;<br><span class="hljs-comment">//直接访问表单元素，例如</span><br>name.value = <span class="hljs-string">&quot;&quot;</span>;<br>address.value = <span class="hljs-string">&quot;&quot;</span>;<br>email.value = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法减少了大量的输入，不用再为每个属性名添加<code>document.forms[0]</code>前缀。这个对象临时挂载在作用域上，当JavaScript需要解析诸如<code>address</code>的标识符时，就会自动在这个对象中查找。当然，不使用<code>with</code>语句的等价代码可以写成这样：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var f = document.forms[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br>f.name.value = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>f.address.value = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>f.email.value = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>不用忘记，只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用它。</p><h4 id="2-debugger语句"><a href="#2-debugger语句" class="headerlink" title="2. debugger语句"></a>2. debugger语句</h4><p><code>debugger</code>语句通常什么也不做。然而调试程序可用并运行的时候，JavaScript解释器将会（非必需）以调试模式运行。实际上，这条语句用来产生一个断点，JavaScript代码的执行会停止在断点的位置，这时候使用调试器输出变量的值，检查调用栈等。</p><h4 id="3-“use-strict”"><a href="#3-“use-strict”" class="headerlink" title="3. “use strict”"></a>3. “use strict”</h4><p>“<code>use strict</code>“是一条指令。指令不是语句。</p><p>“<code>user strict</code>”指令和普通的语句之间有两个重要的区别。<br><img src="https://img-blog.csdnimg.cn/20200213135346438.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200213135414399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200213135428218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200213135445756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(2) 表达式和运算符</title>
    <link href="/2020/02/11/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(2)%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2020/02/11/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(2)%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-表达式和运算符"><a href="#第四章-表达式和运算符" class="headerlink" title="第四章  表达式和运算符"></a>第四章  表达式和运算符</h1><h2 id="1-属性访问表达式"><a href="#1-属性访问表达式" class="headerlink" title="1.  属性访问表达式"></a>1.  属性访问表达式</h2><p>两种语法：</p><ul><li>expression . identifier</li><li>expression [ expression ]</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">var o = &#123; x: <span class="hljs-number">1</span>, y: &#123; z :<span class="hljs-number">3</span> &#125; &#125;; <span class="hljs-regexp">//</span>一个示例对象<br>var a = [ o, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] ]; <span class="hljs-regexp">//</span> 一个包含中国对象的示例数组<br>o.x <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>o.y.z <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br>o[<span class="hljs-string">&quot;x&quot;</span>] <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>a[<span class="hljs-number">1</span>] <span class="hljs-regexp">//</span> <span class="hljs-number">4</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-string">&quot;1&quot;</span>] <span class="hljs-regexp">//</span> <span class="hljs-number">6</span><br>a[<span class="hljs-number">0</span>].x <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><p>下表是按照运算符的优先级排序，前面的运算符优先级要高于后面的运算符优先级。</p><p>被水平线分割开来的运算符具有不同的优先级。</p><p>标题为A的列表示运算符的结合性，L（从左到右）或R（从右到左）</p><p>标题为N的列表操作数的个数。</p><p>标题为“类型”的列表表示期望的操作数类型，以及运算符的结构类型（在“–&gt;”符合之后）<br><img src="https://img-blog.csdnimg.cn/20200211223146809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>左值：指表达式只能出现在赋值运算符的左侧。</p><p>在JavaScript中，变量，对象属性，数组均是左值。</p><p>ECMAScript规范允许内置函数返回一个左值，但自定义的函数则不能返回左值。</p><p>需要注意的是，属性访问表达式和调用表达式的优先级要比上标列出的所有运算符都要高。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">typeof</span> my.<span class="hljs-built_in">function</span>[x](y)<br></code></pre></td></tr></table></figure><p>尽管typeof是优先级最高的运算符之一，但typeof也是在两次属性访问和函数调用之后执行的。</p><h4 id="运算符的结合性"><a href="#运算符的结合性" class="headerlink" title="运算符的结合性"></a>运算符的结合性</h4><p>减法运算符具有从左到右的结合性</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">w</span> = x - y - z<span class="hljs-comment">;</span><br>//和这段代码一样：<br><span class="hljs-attribute">w</span> = ((x - y) -z)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>反过来讲，下面这个表达式：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">x</span> = ~-y;<br><span class="hljs-attr">w</span> = <span class="hljs-attr">x</span> = <span class="hljs-attr">y</span> = z;<br><span class="hljs-attr">q</span> = a ? b: c ? d: e ? f: g;<br>//上面代码和下面一样：<br><span class="hljs-attr">x</span> = ~(-y);<br><span class="hljs-attr">w</span> = (<span class="hljs-attr">x</span> = (<span class="hljs-attr">y</span> = z));<br><span class="hljs-attr">q</span> = a ? b: (c ? d: (e ? f: g));<br></code></pre></td></tr></table></figure><p>因为一元操作符，赋值和三元体检运算符都具有从右到左的结合性。</p><h2 id="3-算法运算符"><a href="#3-算法运算符" class="headerlink" title="3. 算法运算符"></a>3. 算法运算符</h2><p>基本的算法运算符是<code> *</code> ，<code>/</code>，<code>%</code>，<code>+</code>，<code>-</code>。</p><p>除<code> +</code>运算符以外，剩下4个运算符都不难，只是在必要时将操作数转换为数字，然后求积商余数和差。所有那些无法转换为数字的操作树都转换为NaN，如果操作树是NaN值，算术运算的结果也是NaN。</p><h4 id="“-”-运算符："><a href="#“-”-运算符：" class="headerlink" title="“/” 运算符："></a>“<code>/</code>” 运算符：</h4><p>在JavaScript中，所有的数字都是浮点数，除法运算的结果也是浮点型，比如5/2的结果是2.5，而不是2.除数为0的运算结果为正无穷大或负无穷大，而0/0的结果是NaN，所有这些运算均不含报错。</p><h4 id="“-”-运算符：-1"><a href="#“-”-运算符：-1" class="headerlink" title="“ % ” 运算符："></a>“<code> %</code> ” 运算符：</h4><p>结果的符号和第一个操作数的符号保持一致。5%2 = 1，-5%2 = -1。求余运算符的操作符通常都是整数，但也适用于浮点数，比如6.5%2.1 = 0.2。</p><h4 id="“-”-运算符：-2"><a href="#“-”-运算符：-2" class="headerlink" title="“ + ” 运算符："></a>“<code> +</code> ” 运算符：</h4><p>如果其中一个操作数是字符串或者转换为字符串的对象，另一个操作数将会转换为字符串，加法将进行字符串的连接操作。</p><p>从技术上讲，加法操作符的行为表现为：</p><ul><li>如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类型，日期对象通过<code>toString()</code>方法执行转换，其他对象则通过<code>valueOf()</code>方法执行转换。由于多数对象不具备可用的<code>valueOf()</code>方法，因此它们会通过<code>toString()</code>方法来执行转换。</li><li>在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串连接。</li><li>否则，两个操作数都将转换为数字，然后进行加法操作</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> <span class="hljs-regexp">//</span><span class="hljs-number">3</span><br><span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-regexp">//</span><span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-number">2</span> <span class="hljs-regexp">//</span><span class="hljs-string">&quot;12&quot;</span>,数字转换为字符串后做加法<br><span class="hljs-number">1</span> + &#123;&#125; <span class="hljs-regexp">//</span><span class="hljs-string">&quot;1[object Object]&quot;</span>,对象转换为字符串后进行字符串连接<br>true + true <span class="hljs-regexp">//</span><span class="hljs-number">2</span> 布尔值转换为数字后做加法<br><span class="hljs-number">2</span> + null <span class="hljs-regexp">//</span><span class="hljs-number">2</span> ,null转换为<span class="hljs-number">0</span>后做加法<br><span class="hljs-number">2</span> + undefined <span class="hljs-regexp">//</span>NaN,undefined转换为NaN后做加法<br></code></pre></td></tr></table></figure><p>需要特别注意的是，当加法运算符和字符串和数字一起使用时，需要考虑加法结合性对运算顺序的影响。也就是说，运算结果是依赖于运算符顺序的，比如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ <span class="hljs-number">2</span> + <span class="hljs-string">&quot; blind mice&quot;</span>; //<span class="hljs-string">&quot;3 blind mice&quot;</span><br><span class="hljs-symbol">1 </span>+ (<span class="hljs-number">2</span> + <span class="hljs-string">&quot; blind mice&quot;</span>); //<span class="hljs-string">&quot;12 blind mice&quot;</span><br></code></pre></td></tr></table></figure><h4 id="一元算术运算符"><a href="#一元算术运算符" class="headerlink" title="一元算术运算符"></a>一元算术运算符</h4><ul><li><p>递增（<code>++</code>）：</p><p>运算符将操作数转换为数字，然后给数字加1</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> i = <span class="hljs-number">1</span>,j = ++<span class="hljs-number">1</span>;//i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span><br><span class="hljs-attribute">var</span> i = <span class="hljs-number">1</span>,j = i ++; //i=<span class="hljs-number">2</span>,j=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>需要注意的是，表达式<code>++x</code>并不总和<code>x = x + 1</code>完全一样，“<code>++</code>”运算符从不进行字符串连接操作，它总是会将操作数转换为数字并增1。</p></li></ul><h2 id="4-关系表达式"><a href="#4-关系表达式" class="headerlink" title="4. 关系表达式"></a>4. 关系表达式</h2><h4 id="相等和不等运算符"><a href="#相等和不等运算符" class="headerlink" title="相等和不等运算符"></a>相等和不等运算符</h4><p><img src="https://img-blog.csdnimg.cn/20200211223301673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211223311757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211223324498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符的操作数可能是任意类型。然而，只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换，类型转换规则如下：<br><img src="https://img-blog.csdnimg.cn/2020021122334297.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211223355941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200211223410928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h4><p><code>in</code>运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">var point = &#123;x:<span class="hljs-number">1</span>,y:<span class="hljs-number">1</span>&#125;<br><span class="hljs-string">&quot;x&quot;</span> <span class="hljs-keyword">in</span> point <span class="hljs-regexp">//</span>true<br><span class="hljs-string">&quot;z&quot;</span> <span class="hljs-keyword">in</span> point <span class="hljs-regexp">//</span>false<br><span class="hljs-string">&quot;toString&quot;</span> <span class="hljs-keyword">in</span> point <span class="hljs-regexp">//</span>true :对象继承了toString（）方法<br><br>var data = [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-string">&quot;0&quot;</span> <span class="hljs-keyword">in</span> data <span class="hljs-regexp">//</span>true:数组包含元素“<span class="hljs-number">0</span>”<br><span class="hljs-number">1</span> <span class="hljs-keyword">in</span> data <span class="hljs-regexp">//</span>true :数字转换为字符串<br><span class="hljs-number">3</span> <span class="hljs-keyword">in</span> data <span class="hljs-regexp">//</span>false :没有引索为<span class="hljs-number">3</span>的元素<br></code></pre></td></tr></table></figure><h4 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h4><p><code>instanceof</code>希望左操作数是一个对象，右操作数标识对象的类。JavaScript中对象的类是通过初始化它们的构造函数来定义的，这样的话，instanceof的右操作数应当是一个函数。</p><p>如果左侧的对象是右侧类的实例，则表达式返回true，否则返回false。<br><img src="https://img-blog.csdnimg.cn/20200211223448376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-赋值表达式"><a href="#5-赋值表达式" class="headerlink" title="5. 赋值表达式"></a>5. 赋值表达式</h2><p>JavaScript使用“<code>=</code>”运算符来给变量或者属性赋值。</p><p>“<code>=</code>”具有非常低的优先级，通常在一个较长的表达式中用到一条赋值语句的值的时候，需要补充圆括号以保证正确的运算顺序。</p><p>赋值操作符的结合性是从右到左，也就是说，如果一个表达式中出现了多个赋值运算符，运算顺序是从右到左。因此，可以通常如下方式对多个变量赋值：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">i</span> = j = k = <span class="hljs-number">0</span><span class="hljs-comment">; //把三个变量初始化为0</span><br></code></pre></td></tr></table></figure><h2 id="6-其他运算符"><a href="#6-其他运算符" class="headerlink" title="6. 其他运算符"></a>6. 其他运算符</h2><h4 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（<code>?:</code>）</h4><p>条件运算符是JavaScript中唯一的一个三元运算符。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">x</span> : -<span class="hljs-keyword">x</span> //求<span class="hljs-keyword">x</span>的绝对值<br></code></pre></td></tr></table></figure><p>条件运算符的操作数可以是任意类型，第一个操作数当成布尔值，如果它是正值，那么将计算第二个操作数，并返回其计算结果。否则，如果第一个操作数是假值，那么将计算第三个操作数，并返回其计算结果。第二个和第三个操作数总是会计算其中之一，不可能两者同时执行。</p><h4 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a><code>typeof</code>运算符</h4><p>下表列出了任意值在<code>typeof</code>运算符后的返回值：<br><img src="https://img-blog.csdnimg.cn/20200212150457148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a><code>delete</code>运算符</h4><p><code>delete</code>是一元操作数符，它用来删除对象属性或者数组元素。就像赋值，递增，递减运算符一样，<code>delete</code>也是具有副作用，它是用来做删除操作的，不是用来返回一个值的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">var o = &#123; x: <span class="hljs-number">1</span>,y: <span class="hljs-number">2</span> &#125;; <span class="hljs-regexp">//</span>定义一个对象<br><span class="hljs-keyword">delete</span> o.x; <span class="hljs-regexp">//</span> 删除一个属性<br><span class="hljs-string">&quot;x&quot;</span> <span class="hljs-keyword">in</span> o <span class="hljs-regexp">//</span>false，这个属性在对象中不再存在<br><br>var a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 定义一个数组<br><span class="hljs-keyword">delete</span> a[<span class="hljs-number">2</span>]; <span class="hljs-regexp">//</span> 删除最后一个数组元素<br><span class="hljs-number">2</span> <span class="hljs-keyword">in</span> a; <span class="hljs-regexp">//</span> false，元素<span class="hljs-number">2</span>在数组中已经不再存在了<br>a.length <span class="hljs-regexp">//</span><span class="hljs-number">3</span> ,注意长度并没有改变，尽管上一行代码删除了这个元素，但删除操作数留下了一个“洞”，实际上并没有修改数组的长度，因此数组a的长度仍然是<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>需要注意的是，删除属性或者数组元素不仅仅是设置了一个<code>undefined</code>的值，当删除一个属性是，这个属性将不再存在。读取一个不存在的属性将返回<code>undefined</code>，但是可以通过<code>in</code>运算符来检测这个属性是否在对象中存在。</p><p><code>delete</code>希望它的操作数是一个左值，如果它不是左值，那么<code>delete</code>将不进行如何操作同时返回<code>true</code>。否则，<code>delete</code>将试图删除这个指定的左值。如果删除成功，<code>delete</code>将返回<code>true</code>。然而并不是所有属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过<code>var</code>语句声明的变量不能删除。同样，通过<code>function</code>语句定义的函数和函数参数也不能删除。</p><p>在严格模式下，如果<code>delete</code>的操作数是非法的，比如变量，函数和函数参数，<code>delete</code>操作将抛出一个语法错误异常，只有操作数是一个属性访问表达式的时候它才会正常工作。在严格模式下，<code>delete</code>删除不可配置的属性时会抛出一个类型错误异常。在非严格模式下，这些<code>delete</code>操作都不会报错，只是简单地返回<code>false</code>，以表明操作数不能执行删除操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">var o = &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">delete</span> <span class="hljs-number">0</span>.x; <span class="hljs-regexp">//</span>删除一个对象属性，返回true<br>typeof q.x; <span class="hljs-regexp">//</span>属性不存在，会“undefined”<br><span class="hljs-keyword">delete</span> o.x; <span class="hljs-regexp">//</span>删除不存在的属性，返回true<br><span class="hljs-keyword">delete</span> o; <span class="hljs-regexp">//</span>不能删除通过var声明的变量，返回false<br><span class="hljs-regexp">//</span>在严格模式下，将抛出一个异常<br><span class="hljs-keyword">delete</span> <span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>参数不是左值，返回true<br>this.x = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span>给全局定义一个属性，这里没有使用var<br><span class="hljs-keyword">delete</span> x; <span class="hljs-regexp">//</span>试图删除它，在非严格模式下返回true<br><span class="hljs-regexp">//</span>在严格模式下回抛出异常<br>x; <span class="hljs-regexp">//</span>运行时错误，没有定义x<br></code></pre></td></tr></table></figure><h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title=",逗号运算符"></a><code>,</code>逗号运算符</h4><p>逗号表达式是二元运算符，它的操作数可以是任意类型。</p><p>它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i</span> = <span class="hljs-number">0</span>, j = i, k = <span class="hljs-number">2</span>;//计算结果是<span class="hljs-number">2</span>，它和下面的代码基本是等价的：<br><span class="hljs-attribute">i</span> = <span class="hljs-number">0</span>; j = <span class="hljs-number">1</span>; k = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>总是会计算左侧的表达式，但计算结果忽略。</p>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(1) 类型,值和变量</title>
    <link href="/2020/02/10/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(1)%20%E7%B1%BB%E5%9E%8B,%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/"/>
    <url>/2020/02/10/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(1)%20%E7%B1%BB%E5%9E%8B,%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-词法结构"><a href="#第2章-词法结构" class="headerlink" title="第2章  词法结构"></a>第2章  词法结构</h1><p>JavaScript标识符必须以字母，下划线，美元符开始，后续的字符可以是字母，数字，下划线或美元符。</p><p>常见保留字：</p><p><code>break    delete    function    return    typeof    case    do    if    swicth    var    catch    else    in    this    void    continue    false    instanceof    throw    while    debugger    finally    new    true    </code></p><p>JavaScript预定义了很多全局变量和函数，应当避免把它们的名字用做变量名和函数名：</p><p><code>arguments    encodeURI        Infinity    Number    RegExp    Array    encodeURIComonent    isFinite    Object    String    Date    eval    JSON    parseInt    TypeError    decodeURI    EvalError    Math    RangeError    undefined    decodeURIComponent    Function    NaN    ReferrnceError    URIError</code></p><h1 id="第3章-类型，值和变量"><a href="#第3章-类型，值和变量" class="headerlink" title="第3章  类型，值和变量"></a>第3章  类型，值和变量</h1><p>JavaScript数据类型分为两类：原始类型  和 对象类型</p><p>原始类型包括：数字，字符串 ，布尔值，<code>null</code>，<code>undefined</code></p><p>特殊的对象：函数，数组   </p><p>JavaScript定义的几种类：数组（<code>Array</code>）类，函数（<code>Function</code>）类，日期（<code>Date</code>）类，正则（<code>RegExp</code>）类，错误（<code>Error</code>）类</p><h3 id="1-JavaScript中的算术运算"><a href="#1-JavaScript中的算术运算" class="headerlink" title="1. JavaScript中的算术运算"></a>1. JavaScript中的算术运算</h3><p>JavaScript不区分整数值和浮点数值，所有数字均用64位的浮点数值表示。</p><p>十六进制的直接量以“<code>0x</code>”或“<code>0X</code>”为前缀</p><p>八进制的直接量以“<code>0</code>”为前缀</p><p>JavaScript中算术运算在溢出，下溢，被零整除时不会报错。</p><p>被零整除时，只是简单返回无穷大（<code>Infinity</code>）或负无穷大（<code>-Infinity</code>）。</p><p>零除零是没有意义的，这种整除结果是非数字，用<code>NaN</code>表示。</p><p>非数字<code>NaN</code>：它和任何值都不相等，包括自身，也就是说没有方法通过<code>x == NaN</code>来判断变量x是否是<code>NaN</code>。相反应当使用<code>x ！= x</code>来判断，当且仅当x为<code>NaN</code>时，表达式结果为<code>true</code>。函数<code>isNaN()</code>作用与此相似，如果参数为<code>NaN</code>或者是一个非数字值，则返回<code>true</code>。JavaScript中有一个类似的函数<code>isFinite()</code>，在参数不是<code>NaN</code>，<code>Infinity</code>，或<code>-Infinity</code>的时候返回<code>true</code>。</p><p>负零值同样有些特别，它和正零值相等。</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">var zero = <span class="hljs-number">0</span>;<br>var negz = -<span class="hljs-number">0</span>;<br>zero === negz; <span class="hljs-regexp">//</span>true    <br><span class="hljs-number">1</span><span class="hljs-regexp">/zero === 1/</span>negz;  <span class="hljs-regexp">//</span> false  正无穷大 和 负无穷大 不相等<br></code></pre></td></tr></table></figure><h3 id="2-浮点数直接量"><a href="#2-浮点数直接量" class="headerlink" title="2. 浮点数直接量"></a>2. 浮点数直接量</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">var x = <span class="hljs-string">.3</span> - <span class="hljs-string">.2</span>;<br>var y = <span class="hljs-string">.2</span> - <span class="hljs-string">.1</span>;<br>x === y; <span class="hljs-string">//false</span>;<br>x == <span class="hljs-string">.1</span>; <span class="hljs-string">//false</span>;<br>y == <span class="hljs-string">.1</span>; <span class="hljs-string">//true</span>;<br></code></pre></td></tr></table></figure><h3 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h3><p>将加法（+）运算符用于数字，表示两树相加。但将它用于字符串，则表示字符串连接，将第二个字符串拼接在第一个之后。</p><p>JavaScript中字符串是固定不变的，类似<code>replace()</code>和<code>toUpperCase()</code>的方法都返回新字符串，原字符串并没有发生改变。</p><h3 id="4-布尔值"><a href="#4-布尔值" class="headerlink" title="4. 布尔值"></a>4. 布尔值</h3><p>任意JavaScript的值都可以转换为布尔值。</p><p><code>undefined</code>，<code>null</code>，<code>0</code>，<code>-0</code>，<code>NaN</code>，“``”这些值会被转换成<code>false</code>。</p><p>其他所有值，包括所有对象（数组）都会转换成true。</p><h3 id="5-null，undefined"><a href="#5-null，undefined" class="headerlink" title="5. null，undefined"></a>5. null，undefined</h3><p>对<code>null</code>执行<code>typeof</code>运算，结果返回字符串“<code>object</code>”。</p><p><code>undefined</code>不是关键字，对其进行<code>typeof</code>运算，返回“<code>undefined</code>”</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">//true</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span> <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="6-全局对象"><a href="#6-全局对象" class="headerlink" title="6. 全局对象"></a>6. 全局对象</h3><p>当JavaScript解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性：</p><ul><li>全局属性，比如<code>undefined</code>，<code>Infinity</code>，<code>NaN</code></li><li>全局函数，比如<code>isNAN()</code>, <code>parseInt()</code>, <code>eval()</code></li><li>构造函数，比如<code>Date()</code>, <code>RegExp()</code>, <code>String()</code>, <code>Object()</code>和<code>Array（）</code></li><li>全局对象，比如<code>Math</code>, <code>JSON</code></li></ul><h3 id="7-不可变的原始值和可变的对象引用"><a href="#7-不可变的原始值和可变的对象引用" class="headerlink" title="7. 不可变的原始值和可变的对象引用"></a>7. 不可变的原始值和可变的对象引用</h3><p>JavaScript中原始值（<code>null</code>，<code>undefined</code>，数字，布尔值，字符串）与对象（包括数组和函数）有着根本区别。</p><ul><li><p>原始值是不可更改的；任何方法都无法更改一个原始值。</p></li><li><p>原始值的比较是值的比较：只有在它们值相等时才相等。如果比较两个单独的字符串，并且仅当它们的长度相等且每个索引的字符都相等时，JavaScript才认为它们相等。</p></li><li><p>对象和原始值不同，它们是可变的，它们的值是可修改的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">var o = &#123; x : <span class="hljs-number">1</span> &#125;; <span class="hljs-regexp">//</span>定义一个对象<br>o.x = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span> 通过修改对象属性值来更改对象<br>o.y = <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 在此更改这个对象，给它增加一个新属性<br><br>var a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 数组也是可修改的<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span> 更改数组的一个属性<br>a[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span> 给数组增加一个新元素<br></code></pre></td></tr></table></figure></li><li><p>对象的比较并非值的比较，即使两个对象包含同样的属性及相同的值，它们也是不相等的。各个索引元素相等的两个数组也不相等。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">var <span class="hljs-attr">o</span> = &#123; x : <span class="hljs-number">1</span> &#125;,<span class="hljs-attr">p</span> = &#123; x : <span class="hljs-number">1</span> &#125;; <br><span class="hljs-attr">o</span> === p; //<span class="hljs-literal">false</span>:两个单独的对象永不相等<br>var <span class="hljs-attr">a</span> = [],<span class="hljs-attr">b</span> = []; //两个空数组<br><span class="hljs-attr">a</span> === b; //<span class="hljs-literal">false</span>：两个单独的数组永不相等<br></code></pre></td></tr></table></figure><p>通常将对象称为引用类型。对象值都是引用，对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">var <span class="hljs-keyword">a</span> = [];<span class="hljs-comment"> // 定义一个引用空数组的变量a</span><br>var b = <span class="hljs-keyword">a</span>;<span class="hljs-comment"> // 变量b引用同一个数组</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment"> // 通过变量b来修改引用的数组</span><br><span class="hljs-keyword">a</span>[<span class="hljs-number">0</span>]<span class="hljs-comment"> // 1；变量a也会修改</span><br><span class="hljs-keyword">a</span> === b<span class="hljs-comment"> // true；a和b引用同一个数组，因此它们相等</span><br></code></pre></td></tr></table></figure><p>将对象赋值给一个变量，仅仅是赋值的引用值，对象本身并没有复制一次。</p></li></ul><h3 id="8-类型转换"><a href="#8-类型转换" class="headerlink" title="8. 类型转换"></a>8. 类型转换</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">10</span> + <span class="hljs-string">&quot; object&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;10 object&quot;</span>;数字<span class="hljs-number">10</span>转换成字符串<br><span class="hljs-string">&quot;7&quot;</span>*<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-number">28</span>；两个字符串均转换为数字<br>var n = <span class="hljs-number">1</span> - <span class="hljs-string">&quot;x&quot;</span>; <span class="hljs-regexp">//</span> NaN；字符串“x”无法转换为数字<br>n + <span class="hljs-string">&quot;object&quot;</span> <span class="hljs-regexp">//</span> “NaN object”；NaN转换为字符串“NaN”<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200211193306621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><h4 id="转换和相等性"><a href="#转换和相等性" class="headerlink" title="转换和相等性"></a>转换和相等性</h4><p>JavaScript可以做灵活的类型转换，因此“==”相等运算符也随相等的含义灵活多变。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">null</span> == undefined //<span class="hljs-literal">true</span><br><span class="hljs-attr">&quot;0&quot;</span> == <span class="hljs-number">0</span> //<span class="hljs-literal">true</span> 比较前字符串转换成数字<br><span class="hljs-attr">0</span> == <span class="hljs-literal">false</span> //<span class="hljs-literal">true</span> 在比较之前布尔值转换成数字<br><span class="hljs-attr">&quot;0&quot;</span> == <span class="hljs-literal">false</span> //<span class="hljs-literal">true</span>在比较前字符串都转换成数字<br></code></pre></td></tr></table></figure><p>注意，一个值转换为另一个值并不意味着两个值相等。</p></li><li><h4 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h4><p>做显示类型转换最简单的方法是使用<code>Boolean（）</code>，<code>Number（）</code>，<code>String（）</code>，<code>Object（）</code>函数。</p><p>需要注意，除<code>null</code>或<code>undefined</code>外的任何值都具有<code>toString（）</code>方法，这个方法执行结果通常和<code>String（）</code>方法的返回借一致。还需要注意，如果把<code>null</code>，<code>undefined</code>转换为对象，则会抛出一个类型错误。</p><p>JavaScript中某些运算会做隐式的类型转换，如果“+”运算符的一个操作数是字符串，它将把另一个操作数转换为字符串。一元“！”将其操作数转换为布尔值并取反等。</p></li><li><h4 id="对象转换为原始值"><a href="#对象转换为原始值" class="headerlink" title="对象转换为原始值"></a>对象转换为原始值</h4><ul><li><p>对象到布尔值的转换：所有对象都转换为<code>true</code></p></li><li><p>对象到字符串的转换：<br><img src="https://img-blog.csdnimg.cn/20200211193331335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211193342967.png" alt="在这里插入图片描述"></p></li><li><p>对象转换为数字：<br><img src="https://img-blog.csdnimg.cn/20200211193400325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="9-变量作用域"><a href="#9-变量作用域" class="headerlink" title="9. 变量作用域"></a>9. 变量作用域</h3></li></ul></li><li><h4 id="函数作用域和声明提前"><a href="#函数作用域和声明提前" class="headerlink" title="函数作用域和声明提前"></a>函数作用域和声明提前</h4><p>JavaScript函数作用域是指在函数内声明的所有变量在函数体始终是可见的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">o</span>) </span>&#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//i在整个函数体内是有定义的</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o == <span class="hljs-string">&quot;object&quot;</span>) &#123;<br><span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">//j在函数内是有定义的，不仅仅是在这个代码段内</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k =<span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; k ++) &#123; <span class="hljs-comment">//k在函数体内是有定义的，不仅仅是在循环内</span><br><span class="hljs-built_in">console</span>.log(k); <span class="hljs-comment">//输出数字0-9</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(k);<span class="hljs-comment">//k已经定义了，输出10</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(j);<span class="hljs-comment">//j已经定义了，但可能没有初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var scope = <span class="hljs-string">&quot;global&quot;</span>;<br><span class="hljs-keyword">function</span> f() &#123;<br>console.log(scope);<span class="hljs-regexp">//</span>输出<span class="hljs-string">&quot;undefined&quot;</span>,而不是<span class="hljs-string">&quot;global&quot;</span><br>var scope = <span class="hljs-string">&quot;local&quot;</span>;<span class="hljs-regexp">//</span>变量在这里赋初始值，但是变量本身在函数体内任何地方均是有定义的<br>console.log(scope);<span class="hljs-regexp">//</span>输出<span class="hljs-string">&quot;local&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="作为属性的变量"><a href="#作为属性的变量" class="headerlink" title="作为属性的变量"></a>作为属性的变量</h4><p>当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。</p><p>当使用<code>var</code>声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过<code>delete</code>运算删除。如果没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量，以这种方式创建的变量是正常的可配置值属性，并可以删除它们。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var truevar = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 声明一个不可删除的全局变量<br>fakevar1 = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span> 创建全局对象的一个可删除的属性<br>this.fakevar2 = <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span>同上<br><span class="hljs-keyword">delete</span> truevar <span class="hljs-regexp">//</span> false：变量并没有被删除<br><span class="hljs-keyword">delete</span> fakevar <span class="hljs-regexp">//</span>true：变量被删除<br><span class="hljs-keyword">delete</span> this.fakevar2 <span class="hljs-regexp">//</span>true：变量被删除<br></code></pre></td></tr></table></figure></li><li><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>全局变量在程序中始终都是有定义的，局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入之执行上下文</title>
    <link href="/2020/02/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <url>/2020/02/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript深入之执行上下文-举例说明"><a href="#JavaScript深入之执行上下文-举例说明" class="headerlink" title="JavaScript深入之执行上下文(举例说明)"></a>JavaScript深入之执行上下文(举例说明)</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span><span class="hljs-params">()</span></span>&#123;     <br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;     <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;        <br><span class="hljs-keyword">return</span> scope;     <br>&#125;     <br><span class="hljs-keyword">return</span> f(); <br>&#125; <br>checkscope();<br></code></pre></td></tr></table></figure><p>执行过程如下：</p><ol><li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    globalContext<br>]<span class="hljs-comment">;复制代码</span><br></code></pre></td></tr></table></figure><ol start="2"><li>全局上下文初始化</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">global</span>Context = &#123;<br>    VO: [<span class="hljs-keyword">global</span>, scope, checkscope],<br>    Scope: [<span class="hljs-keyword">global</span>Context.VO],<br>    this: <span class="hljs-keyword">global</span>Context.VO<br>&#125;复制代码<br></code></pre></td></tr></table></figure><ol start="2"><li>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscope.<span class="hljs-string">[[scope]]</span> = [<br>  globalContext.VO<br>];复制代码<br></code></pre></td></tr></table></figure><ol start="3"><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>]<span class="hljs-comment">;复制代码</span><br></code></pre></td></tr></table></figure><ol start="4"><li>checkscope 函数执行上下文初始化：<ol><li>复制函数 [[scope]] 属性创建作用域链，</li><li>用 arguments 创建活动对象，</li><li>初始化活动对象，即加入形参、函数声明、变量声明，</li><li>将活动对象压入 checkscope 作用域链顶端。</li></ol></li></ol><p>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">checkscopeContext</span> = <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">AO</span>: <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">arguments</span>: <span class="hljs-string">&#123;</span><br>            <span class="hljs-attr">length</span>: <span class="hljs-string">0</span><br>        <span class="hljs-attr">&#125;,</span><br>        <span class="hljs-attr">scope</span>: <span class="hljs-string">undefined,</span><br>        <span class="hljs-attr">f</span>: <span class="hljs-string">reference to function f()&#123;&#125;</span><br>    <span class="hljs-attr">&#125;,</span><br>    <span class="hljs-attr">Scope</span>: <span class="hljs-string">[AO, globalContext.VO],</span><br>    <span class="hljs-attr">this</span>: <span class="hljs-string">undefined</span><br><span class="hljs-attr">&#125;复制代码</span><br></code></pre></td></tr></table></figure><ol start="5"><li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    fContext,<br>    checkscopeContext,<br>    globalContext<br>]<span class="hljs-comment">;复制代码</span><br></code></pre></td></tr></table></figure><ol start="6"><li>f 函数执行上下文初始化, 以下跟第 4 步相同：<ol><li>复制函数 [[scope]] 属性创建作用域链</li><li>用 arguments 创建活动对象</li><li>初始化活动对象，即加入形参、函数声明、变量声明</li><li>将活动对象压入 f 作用域链顶端</li></ol></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">fContext</span> = <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">AO</span>: <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">arguments</span>: <span class="hljs-string">&#123;</span><br>            <span class="hljs-attr">length</span>: <span class="hljs-string">0</span><br>        <span class="hljs-attr">&#125;</span><br>    <span class="hljs-attr">&#125;,</span><br>    <span class="hljs-attr">Scope</span>: <span class="hljs-string">[AO, checkscopeContext.AO, globalContext.VO],</span><br>    <span class="hljs-attr">this</span>: <span class="hljs-string">undefined</span><br><span class="hljs-attr">&#125;复制代码</span><br></code></pre></td></tr></table></figure><ol start="7"><li><p>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p></li><li><p>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p></li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>]<span class="hljs-comment">;复制代码</span><br></code></pre></td></tr></table></figure><ol start="9"><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    globalContext<br>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入之作用域链</title>
    <link href="/2020/02/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2020/02/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript深入之作用域链"><a href="#JavaScript深入之作用域链" class="headerlink" title="JavaScript深入之作用域链"></a>JavaScript深入之作用域链</h1><p>当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>今天重点讲讲作用域链。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p><strong>函数的作用域在函数定义的时候就决定了。</strong></p><p>这是因为<strong>函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，</strong>但是注意：[[scope]] 并不代表完整的作用域链！</p><p>举个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">foo.<span class="hljs-string">[[scope]]</span> = [<br>  globalContext.VO<br>];<br><br>bar.<span class="hljs-string">[[scope]]</span> = [<br>    fooContext.AO,<br>    globalContext.VO<br>];<br></code></pre></td></tr></table></figure><h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p><strong>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</strong></p><p>这时候执行上下文的作用域链，我们命名为 Scope：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Scope = [AO].<span class="hljs-built_in">concat</span>(<span class="hljs-string">[[Scope]]</span>);复制代码<br></code></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h3 id="捋一捋"><a href="#捋一捋" class="headerlink" title="捋一捋"></a>捋一捋</h3><p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">&#x27;local scope&#x27;</span>;<br>    <span class="hljs-keyword">return</span> scope2;<br>&#125;<br>checkscope();复制代码<br></code></pre></td></tr></table></figure><p>执行过程如下：</p><p>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscope.<span class="hljs-string">[[scope]]</span> = [<br>    globalContext.VO<br>];复制代码<br></code></pre></td></tr></table></figure><p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>]<span class="hljs-comment">;复制代码</span><br></code></pre></td></tr></table></figure><p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscopeContext = &#123;<br>    Scope: checkscope.<span class="hljs-string">[[scope]]</span>,<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">checkscopeContext</span> = <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">AO</span>: <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">arguments</span>: <span class="hljs-string">&#123;</span><br>            <span class="hljs-attr">length</span>: <span class="hljs-string">0</span><br>        <span class="hljs-attr">&#125;,</span><br>        <span class="hljs-attr">scope2</span>: <span class="hljs-string">undefined</span><br>    <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;复制代码</span><br></code></pre></td></tr></table></figure><p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">checkscopeContext</span> = <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">AO</span>: <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">arguments</span>: <span class="hljs-string">&#123;</span><br>            <span class="hljs-attr">length</span>: <span class="hljs-string">0</span><br>        <span class="hljs-attr">&#125;,</span><br>        <span class="hljs-attr">scope2</span>: <span class="hljs-string">undefined</span><br>    <span class="hljs-attr">&#125;,</span><br>    <span class="hljs-attr">Scope</span>: <span class="hljs-string">[AO, [[Scope]]]</span><br><span class="hljs-attr">&#125;复制代码</span><br></code></pre></td></tr></table></figure><p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscopeContext = &#123;<br>    AO: &#123;<br>        arguments: &#123;<br>            length: <span class="hljs-number">0</span><br>        &#125;,<br>        scope2: <span class="hljs-string">&#x27;local scope&#x27;</span><br>    &#125;,<br>    Scope: [AO, <span class="hljs-string">[[Scope]]</span>]<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    globalContext<br>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入之变量对象</title>
    <link href="/2020/02/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/02/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript深入之变量对象"><a href="#JavaScript深入之变量对象" class="headerlink" title="JavaScript深入之变量对象"></a>JavaScript深入之变量对象</h1><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><p>因为不同执行上下文下的变量对象稍有不同，来看全局上下文下的变量对象和函数上下文下的变量对象。</p><h4 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h4><p><strong>全局对象</strong>是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</p><p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p><p>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p><ul><li><p>可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino">console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">this</span>);复制代码<br></code></pre></td></tr></table></figure></li><li><p>全局对象是由 Object 构造函数实例化的一个对象。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);复制代码<br></code></pre></td></tr></table></figure></li><li><p>预定义了一堆，嗯，一大堆函数和属性。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 都能生效</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">random</span>());<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">this</span>.Math.<span class="hljs-built_in">random</span>());复制代码<br></code></pre></td></tr></table></figure></li><li><p>作为全局变量的宿主。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);复制代码<br></code></pre></td></tr></table></figure></li><li><p>客户端 JavaScript 中，全局对象有 window 属性指向自身。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a);<br><br><span class="hljs-built_in">this</span>.<span class="hljs-built_in">window</span>.b = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.b);<br></code></pre></td></tr></table></figure></li></ul><p>全局上下文中的变量对象就是全局对象。</p><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当进入执行上下文时，这时候还没有执行代码</p><p>变量对象会包括：</p><ul><li><p>函数的所有形参 (如果是函数上下文)</p><ul><li><p>由名称和对应值组成的一个变量对象的属性被创建</p></li><li><p>没有实参，属性值设为 undefined</p></li></ul></li><li><p>函数声明</p><ul><li><p>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</p></li><li><p>如果变量对象已经存在相同名称的属性，则完全替换这个属性</p></li></ul></li><li><p>变量声明</p><ul><li><p>由名称和对应值（undefined）组成一个变量对象的属性被创建；</p></li><li><p>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</p></li></ul></li></ul><p>举个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(a)</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br><br>  b = <span class="hljs-number">3</span>;<br><br>&#125;<br><br>foo(<span class="hljs-number">1</span>);复制代码<br></code></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">AO</span> = <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">arguments</span>: <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">0</span>: <span class="hljs-string">1,</span><br>        <span class="hljs-attr">length</span>: <span class="hljs-string">1</span><br>    <span class="hljs-attr">&#125;,</span><br>    <span class="hljs-attr">a</span>: <span class="hljs-string">1,</span><br>    <span class="hljs-attr">b</span>: <span class="hljs-string">undefined,</span><br>    <span class="hljs-attr">c</span>: <span class="hljs-string">reference to function c()&#123;&#125;,</span><br>    <span class="hljs-attr">d</span>: <span class="hljs-string">undefined</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim">AO = &#123;<br>    <span class="hljs-keyword">argument</span><span class="hljs-variable">s:</span> &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>        length: <span class="hljs-number">1</span><br>    &#125;,<br>    <span class="hljs-variable">a:</span> <span class="hljs-number">1</span>,<br>    <span class="hljs-variable">b:</span> <span class="hljs-number">3</span>,<br>    <span class="hljs-keyword">c</span>: reference <span class="hljs-keyword">to</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span><span class="hljs-params">()</span>&#123;&#125;,</span><br>    d: reference <span class="hljs-keyword">to</span> FunctionExpression <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><p>练习：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(foo);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>会打印函数，而不是 undefined 。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    console.log(a);</span></span><br><span class="hljs-comment"><span class="hljs-function">    a = 1;</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span>;</span> <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    a = 1;</span></span><br><span class="hljs-comment"><span class="hljs-function">    console.log(a);</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">bar</span><span class="hljs-params">()</span>;</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript权威指南》学习笔记(6) 函数</title>
    <link href="/2020/02/09/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(6)%20%E5%87%BD%E6%95%B0/"/>
    <url>/2020/02/09/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(6)%20%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><h4 id="1-函数定义表达式"><a href="#1-函数定义表达式" class="headerlink" title="1. 函数定义表达式"></a>1. 函数定义表达式</h4><p>函数定义表达式定义一个JavaScript函数。表达式的值是这个新定义的函数。</p><p>一个典型的函数定义表达式包含关键字<code>function</code>，跟随其后的是一对圆括号，括号内是一个逗号分割的列表，列表含有0个或多个标识符（参数名），然后再随后是一个由花括号包裹的JavaScript代码段（函数体），例如：</p><figure class="highlight sas"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sas">var square = functi<span class="hljs-meta">on(</span><span class="hljs-meta">x</span>) &#123; <span class="hljs-meta">return</span> <span class="hljs-meta">x</span> <span class="hljs-comment">* x ;</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-函数声明语句"><a href="#2-函数声明语句" class="headerlink" title="2. 函数声明语句"></a>2. 函数声明语句</h4><p>语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcname</span><span class="hljs-params">([arg1[,arg2[<span class="hljs-rest_arg">...,arn</span>]]])</span> </span>&#123;<br><br>statements<br><br>&#125;<br></code></pre></td></tr></table></figure><p>funcname是要声明的函数的名称的标识符。函数名之后的圆括号中是参数列表，参数之间使用逗号分隔。当调用函数时，这些标识符则是指传入函数的实参。</p><p>函数声明语句通常出现在JavaScript代码的最顶层，也可以嵌套在其他函数体内。但在嵌套时，函数声明只能出现在所嵌套函数的顶部。也就是说，函数定义不能出现在<code>if</code>语句，<code>while</code>循环或其他任何语句中，正是由于声明位置的这种限制，ECMAScript标准规范中没有将函数声明归类为真正的语句。有一些JavaScript实现的确允许在出现语句的地方都可以进行函数声明，但是不同的实现在细节处理方式上有很大差别，因此将函数声明放在其他语句内的做法并不具备可移植性。</p><h4 id="3-以上二者区别"><a href="#3-以上二者区别" class="headerlink" title="3. 以上二者区别"></a>3. 以上二者区别</h4><p>尽管函数声明语句和函数定义表达式包含相同的函数名，但二者仍然不同。</p><ul><li><p>两种方式都创建了新的函数对象，但函数声明语句中的函数名是一个变量名，变量指向函数对象。</p><p>和通过<code>var</code>声明变量一样，函数定义表达式中函数被显示地“提前”到了脚本或函数的顶部。因此他它们在整个脚本和函数内都是可见的。</p></li><li><p>使用<code>var</code>的话，只有变量声明提前了—–变量的初始化代码仍然在原来的位置。</p><p>然而使用函数声明语句的话，函数名称和函数体均被提前：脚本中所有函数和函数中所有嵌套的函数都会在当前上下文中其他代码之前声明。也就是说，可以在声明一个JavaScript函数之前调用它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br><br>&#125;<br><br>foo();  <span class="hljs-comment">// foo1</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br><br>&#125;<br><br>foo(); <span class="hljs-comment">// foo2</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br><br>&#125;<br><br>foo();  <span class="hljs-comment">// foo2</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br><br>&#125;<br><br>foo(); <span class="hljs-comment">// foo2</span><br></code></pre></td></tr></table></figure><ul><li><p>函数声明语句可以出现在全局代码里或者内嵌在其他函数中，但它们不能出现在循环，条件判断，或者<code>try</code>/<code>catch</code>/<code>finally</code>以及<code>with</code>语句中。</p><p>而函数定义表达式可以出现在JavaScript代码的任何地方。</p></li></ul></li></ul><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>有四种方式来调用JavaScript函数：</p><ul><li>作为函数</li><li>作为方法</li><li>作为构造函数</li><li>通过它们的<code>call()</code>，和<code>apply()</code>间接调用</li></ul><h4 id="1-函数调用："><a href="#1-函数调用：" class="headerlink" title="1. 函数调用："></a>1. 函数调用：</h4><p>对于普通的函数调用，函数的返回值成为调用表达式的值。如果该函数返回是因为解释器到达结尾，返回值就是<code>undefined</code>。如果函数返回是因为解释器执行到一条<code>return</code>语句，返回值就是<code>return</code>之后的表达式，如果<code>return</code>语句没有值，则返回<code>undefined</code>。</p><p>根据ECMAScript3和非严格的ECMAScript5对函数调用的规定，调用上下文是全局对象，然而，在严格模式下，调用上下文则是<code>undefined</code>。</p><p>以函数形式调用的函数通常不使用this关键字。不过，‘’<code>this</code>‘’可以用来判断当前是否是严格模式。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">//定义并调用一个函数来确定当前脚本运行时是否为严格模式</span><br><span class="hljs-keyword">var</span> strict = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>;&#125;());<br></code></pre></td></tr></table></figure><h4 id="2-方法调用："><a href="#2-方法调用：" class="headerlink" title="2. 方法调用："></a>2. 方法调用：</h4><p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。</p><p>但是方法调用和函数调用有一个重要的区别，即：调用上下文。</p><p>和变量不同，关键字<code>this</code>没有作用域的限制，嵌套函数不会从调用它的函数中继承<code>this</code>。如果嵌套函数作为方法调用，其<code>this</code>的值指向调用它的对象。如果嵌套函数作为函数调用，其值不是全局对象就是<code>undefined</code>。</p><p>很多人误以为调用嵌套函数时<code>this</code>会指向调用外层函数的上下文。</p><p>如果你想访问这个外部函数的<code>this</code>值，需要将this的值保存在一个变量里，这个变量和内部函数都在同一个作用域内。通常使用<code>self</code>来保存<code>this</code>，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br><span class="hljs-attr">m</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === o); <span class="hljs-comment">//true</span><br>f();<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === o); <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(self === o); <span class="hljs-comment">//true</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-构造函数调用"><a href="#3-构造函数调用" class="headerlink" title="3. 构造函数调用"></a>3. 构造函数调用</h4><p>函数或者方法之前带有关键字<code>new</code>，它就构成构造函数调用。</p><p>如果构造函数没有形参，JavaScript构造函数调用的语法是允许省略实参和圆括号的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">//上面代码等效于：</span><br><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;<br></code></pre></td></tr></table></figure><p>构造函数调用创建一个新的对象，并使用这个新对象作为调用上下文。</p><p>构造函数通常不使用<code>return</code>关键字，它们通常初始化新对象，当构造函数的函数执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式使用<code>return</code>语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用<code>return</code>语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p><h4 id="4-间接调用"><a href="#4-间接调用" class="headerlink" title="4. 间接调用"></a>4. 间接调用</h4><p><code>call()</code>和<code>apply()</code>可以用来间接调用函数。</p><p>两个方法都允许显式指定调用所需的<code>this</code>值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。</p><p>两个方法都可以指定调用的实参。<code>call()</code>方法使用它自有的实参列表作为函数的实参，<code>apply()</code>方法则要求以数组形式传入参数。</p><h2 id="函数的实参和形参"><a href="#函数的实参和形参" class="headerlink" title="函数的实参和形参"></a>函数的实参和形参</h2><p>JavaScript中函数定义并未指定函数形参的类型，函数调用也未对传入的实参做任何类型检查。实际上，JavaScript函数调用甚至不继承传入形参的个数。</p><p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。</p><h4 id="1-可变长的实参列表：实参对象"><a href="#1-可变长的实参列表：实参对象" class="headerlink" title="1. 可变长的实参列表：实参对象"></a>1. 可变长的实参列表：实参对象</h4><p>当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有方法直接获得未命名值的引用。</p><p>参数对象解决了这个问题。在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。</p><p>假设定义了函数f，它的实参只有一个x。如果调用这个函数时传入两个实参，第一个实参可以通过参数名x来获得，也可以通过arguments[0]来得到。第二个实参只能通过arguments[1]来得到。</p><p>和真正的数组一样，arguments也包含一个length属性，用以标识其所包含元素的个数。因此，如果调用函数f()时传入两个参数，arguments.length的值就是2。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">function</span> <span class="hljs-built_in">max</span>(<span class="hljs-comment">/*...*/</span>) &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">max</span> = Number.NEGATIVE_INFINITY;<br><span class="hljs-comment">//遍历实参，查找并记住最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;arguments.length; i ++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arguments.length; i ++) &#123;<br><span class="hljs-built_in">max</span> = arguments[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> largest = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">//10000</span><br></code></pre></td></tr></table></figure><p>类似这种函数可以接收任意个数的实参，这种函数也称为“不定实参函数”</p><p>不定实参函数的实参个数不能为零。</p><p>arguments并不是真正的数组，它是一个实参对象。每个实参对象都包含以数字为索引的一组元素以及length属性，但它毕竟不是真正的数组。可以这样理解：它是一个对象，只是碰巧具有以数字为索引的属性。</p><h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>在JavaScript中，函数不仅仅是一种语法，也是值。也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另一个函数等。</p><p>先看一个函数定义：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">x*x</span>; &#125;<br></code></pre></td></tr></table></figure><p>这个定义创建一个新的函数对象，并将其赋值给变量square。函数的名字实际上看不见的，它仅仅是变量的名字，这个变量只带对象。</p><p>函数还可以赋值给其他的变量，并且仍可以正常工作：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var s = square<span class="hljs-comment">;</span><br>square(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span><br>s(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>函数同样可以赋值给对象的属性：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> o = &#123; square: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x ;&#125; &#125;;<br><span class="hljs-keyword">var</span> y = o.square(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>函数甚至不需要带名字，当把他们赋值给数组元素时：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = [ <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x ;&#125;, <span class="hljs-number">20</span> ];<br>a[<span class="hljs-number">0</span>](a[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 400</span><br></code></pre></td></tr></table></figure><h2 id="自定义函数属性"><a href="#自定义函数属性" class="headerlink" title="自定义函数属性"></a>自定义函数属性</h2><p>JavaScript中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。</p><p>当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方法就是给函数定义属性，而不是定义全局变量。。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>初始化函数对象的计数器属性<br><span class="hljs-regexp">//</span>由于函数声明被提前，因此这里是可以在函数声明之前给它的成员赋值的<br>uniqueInteger.counter = <span class="hljs-number">0</span>;<br><span class="hljs-regexp">//</span>每次调用这个函数都会返回一个不同的整数<br><span class="hljs-regexp">//</span>它使用严格属性来记住下一次将要返回的值<br><span class="hljs-keyword">function</span> unqueInteger() &#123;<br>return uniqueInteger.counter++; <span class="hljs-regexp">//</span>先返回计数器的值，然后计数器自增<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>详细看：<a href="https://blog.csdn.net/weixin_46124214/article/details/103817601%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%E4%B8%BA%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9%E3%80%82">https://blog.csdn.net/weixin_46124214/article/details/103817601，以下内容为补充内容。</a></p><p>很多人以为函数执行结束后，与之相关的作用域链似乎也不存在了，但在JavaScript中并非如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(counter++);<br>&#125;<br>&#125;());<br>a();<span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>这段代码定义了一个立即调用的函数，以为整个函数的返回值赋值给变量a，而这个函数返回另一个函数，这是一个嵌套函数，嵌套的函数是可以访问作用域内的变量的。但外部函数返回之后，其他任务代码都无法访问counter变量，只有内部的函数才能访问它。</p><p>像counter一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链，看一个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> &#123;<br>count: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> n++; &#125;;<br>reset: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123; n = <span class="hljs-number">0</span>;&#125;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> c = counter(), d= counter();<span class="hljs-comment">//创建两个计数器</span><br>c.count()<span class="hljs-comment">//0</span><br>d.count()<span class="hljs-comment">//0</span><br>c.reset()<span class="hljs-comment">//reset()和count()方法都可以访问私有变量n，共享状态</span><br>c.count()<span class="hljs-comment">//0，因为什么重置了c</span><br>d.count()<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>count()和reset()两个方法都可以访问私有变量n.</p><p>每次调用counter()都会创建一个新的作用域和一个新的私有变量。因此，如果调用counter()两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的count()或reset()不会影响到另一个对象。</p><h2 id="函数属性，方法和构造函数"><a href="#函数属性，方法和构造函数" class="headerlink" title="函数属性，方法和构造函数"></a>函数属性，方法和构造函数</h2><p>在JavaScript程序中，函数是值。对函数执行<code>typeof</code>运输会返回字符串“function”，但是函数是JavaScript中特殊的对象。</p><p>接下来着重介绍函数属性和方法以及Function()构造函数。</p><h4 id="1-length属性"><a href="#1-length属性" class="headerlink" title="1. length属性"></a>1. length属性</h4><p>在函数体里，<code>arguments.length</code>表示传入函数的实参的个数。</p><p>而函数本身的length属性则是有着不同含义。函数的length属性是只读属性，它代表函数实参的数量，这里的参数指的是“形参”而非‘’‘实参’，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。</p><p><code>arguments.length</code>：实际传入的实参个数</p><p><code>arguments.callee.length</code>：期望传入的实参个数</p><h4 id="2-prototype属性"><a href="#2-prototype属性" class="headerlink" title="2. prototype属性"></a>2. prototype属性</h4><p>每个函数都包含一个<code>prototype</code>属性，这个属性是指向一个对象的引用，这个对象称做“原型对象”。每一个函数都包含不同的对象原型。当将函数用做构造函数的时候，新创建的对象会从原型对象上继承属性。</p><h4 id="3-call-方法和apply-方法"><a href="#3-call-方法和apply-方法" class="headerlink" title="3. call()方法和apply()方法"></a>3. call()方法和apply()方法</h4><p><code>call()</code>和<code>apply()</code>的第一个实参是要调用用函数的母对象，它是调用上下文，在函数体通过<code>this</code>来获得对它的引用。</p><p>ECMAScript5 的严格模式中，<code>call()</code>和<code>apply()</code>的第一个实参都会变成<code>this</code>的值，哪怕传入的实参是原始值甚至是<code>null</code>或<code>undefined</code>。</p><p>在ECMAScript3和非严格模式中，传入的<code>null</code>和<code>undefined</code>都会被全局对象代替，而其他原始值则会被相应的包装对象所替代。</p><p>要想以对象o的方法来调用函数f()，可以这样使用<code>call()</code>和<code>apply()</code>:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">f.call(o)<span class="hljs-comment">;</span><br>f.apply(o)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>对<code>call()</code>来说，第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。</p><p>比如，以对象o的方法的形式调用函数f()，并传入两个参数,可以使用这样的代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>.call(o,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><code>apply()</code>方法和<code>call()</code>类似，但传入实参的形式和<code>call()</code>有所不同，它的实参都放入一个数组中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>.apply(o,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><h4 id="4-bind-方法"><a href="#4-bind-方法" class="headerlink" title="4. bind()方法"></a>4. bind()方法</h4><p>这个方法的主要作用就是将函数绑定至某个对象。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + y;&#125;<span class="hljs-comment">//这个是待绑定的函数</span><br><span class="hljs-keyword">var</span> o = &#123; x :<span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//将要绑定的对象</span><br><span class="hljs-keyword">var</span> g = f.bind(o);<span class="hljs-comment">//通过调用g(x)来调用o.f(x)</span><br>g(<span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>当函数f()上调用<code>bind()</code>方法并传入一个对象o作为参数，这个方法将返回一个新的函数。</p><p>（以函数调用的方式）调用新的函数将会把原始的函数f（）当做o的方法来调用。</p><p>ECMAScript5 中<code>bind()</code>方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用：除了第一个实参之外，传入bind()的实参也会绑定至<code>this</code>，这个附带的应用是一种常见的函数式编程技术。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x,y)</span> </span>&#123; <span class="hljs-keyword">return</span> x + y&#125;;<span class="hljs-comment">//返回两个实参的和值</span><br><span class="hljs-comment">//创建一个类似sum的新函数，但this的值绑定到null</span><br><span class="hljs-comment">//并且第一个参数绑定到1，这个新的函数期望只传入一个实参</span><br><span class="hljs-keyword">var</span> succ = sum.bind(<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>);<br>succ(<span class="hljs-number">2</span>)<span class="hljs-comment">//3：x绑定到1，并传入2作为实参y</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(y,z)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x +y +z &#125;;<span class="hljs-comment">//另外一个做累加计算的函数</span><br><span class="hljs-keyword">var</span> g = f.bind(&#123;x: <span class="hljs-number">1</span>&#125;,<span class="hljs-number">2</span>);<span class="hljs-comment">//绑定this和y</span><br>g(<span class="hljs-number">3</span>)<span class="hljs-comment">//6 ：this.x绑定到1，y绑定到2，z绑定到3</span><br></code></pre></td></tr></table></figure><h4 id="5-Function-构造函数"><a href="#5-Function-构造函数" class="headerlink" title="5. Function()构造函数"></a>5. Function()构造函数</h4><p>不管是通过函数定义语句函数函数直接量表达式，函数的定义都要使用function关键字。但函数还可以通过Function()构造函数来定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>(<span class="hljs-params"><span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;return x*y&quot;</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体。它可以包含任意的JavaScript语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，织须给构造函数简单传入一个字符串—-函数体即可。</p><p>注意，Function（）构造函数并不需要通过传入实参以指定函数名。就像函数直接量一样，Function()构造函数创建一个匿名函数。</p><p>关于Function（）构造函数有几点需要特别注意：</p><ul><li><p>Function（）构造函数允许JavaScript在运行时动态地创建并编译函数。</p></li><li><p>每次调用Function（）构造函数都会解析函数体，并创建新的函数对象。</p></li><li><p>Function所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行。正如下面代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>(<span class="hljs-params"><span class="hljs-string">&quot;return scope&quot;</span></span>)</span>; <span class="hljs-comment">//无法捕捉局部作用域</span><br>&#125;<br><span class="hljs-comment">//这一行代码返回global，因为通过Function()构造函数</span><br><span class="hljs-comment">// 所返回的函数使用的不是局部作用域</span><br>construcFunction()(); <span class="hljs-comment">//&quot;global&quot;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>《JavaScript权威指南》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(13)</title>
    <link href="/2020/02/09/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)/"/>
    <url>/2020/02/09/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)/</url>
    
    <content type="html"><![CDATA[<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>凡是真正有价值的性能优化，必定是从端到端的业务场景建立体系来考虑的。</p><p>性能体系的建立可以分成以下几部分：</p><ul><li>现状评估和建立指标；</li><li>技术方案；</li><li>执行；</li><li>结果评估和监控。</li></ul><h2 id="1-现状评估和建立指标"><a href="#1-现状评估和建立指标" class="headerlink" title="1. 现状评估和建立指标"></a>1. 现状评估和建立指标</h2><p>要想做好性能优化，正确地评估现状和建立指标是最关键的一步。</p><p>作为一个工程师，指标又要考虑两个因素：</p><ul><li>对用户来说，什么样的性能指标能更好地评估它的体验？</li><li>对公司来说，什么样的指标会影响业务价值呢？</li></ul><p>性能问题可以分成很多方面，最重要的几个点是：</p><ul><li>页面加载性能；</li><li>动画与操作性能；</li><li>内存、电量消耗。</li></ul><p>注意，这里我们仅仅是对“性能”两个字的分析和解读，在对大量的用户数据分析后，我们发现，其实这三部分中，“页面加载性能”跟用户的流失率有非常强的关联性，而用户流失率，正是公司业务非常看重的指标。</p><p>因此，在开始阶段，我们决定把性能优化的重点放在页面加载性能上。</p><p>那么，用什么指标来衡量页面加载性能呢？最容易想到的方案是“用户平均加载时间”，事实上，我们在相当长的一段时间，也都是在使用用户平均加载时间作为性能指标。</p><p>但是，很快我们发现，这个指标有严重的问题：</p><ul><li>当加载时间低于一定数字，用户体感差别不大了，我们经过一定的研究，认为这个数字大约是 1 秒；</li><li>少数超长时间加载的用户（如 2G），会极大影响整个指标，即指标不能反映大多数用户的体验。</li></ul><p>于是，基于以上分析，我们设计了一个新的指标——<strong>秒开率</strong>，即一秒之内打开的用户占用户总量的百分比。</p><h2 id="2-技术方案"><a href="#2-技术方案" class="headerlink" title="2. 技术方案"></a>2. 技术方案</h2><p>有了指标，我们就有了优化的目标，就到了技术出场的环节了。</p><p>以加载过程为例，来讲解一下。首先我们要简单分析一下，从输入 URL 后按下回车，到底发生了什么。我们必须理解几件事：</p><ul><li>从域名到 IP 地址，需要用 DNS 协议查询；</li><li>HTTP 协议是用 TCP 传输的，所以会有 TCP 建立连接过程；</li><li>如果使用 HTTPS，还有 HTTPS 交换证书；</li><li>每个网页还有图片等请求。</li></ul><p>最终设计的技术方案大约可以这样划分：<br><img src="https://img-blog.csdnimg.cn/20200210133928401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里涉及的并不仅仅是前端技术，有服务端、客户端、设计师团队，所以要想做好性能优化，绝对不能把自己限制在局部的视角，必须是整个业务一起考虑，才能有良好的收效。</p><h2 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h2><p>执行也不简单，如果说方案主要靠技术，那么执行就是靠工程实施了。</p><p>根据公司的实际情况，工程实施可能有不同的程度，我把工程水平从低到高分成三个阶段：</p><ul><li><p>纯管理；</p><p>纯行政管理，是由经理用纯粹的管理手段来执行方案，比如说，作为前端团队的 Leader，可以组织会议，要求整个团队使用我们前面谈的技术方案。但是纯行政管理有一些问题，一方面，需要的行政资源不一定有，比如我没法强制让后端团队配合我，另一方面，纯粹的管理方式，团队本身的体验并不好，也不利于团队成长，最重要的是，纯粹管理方式容易造成执行不到位。这样的执行方式多数出现在非技术岗位。</p></li><li><p>制度化；</p><p>制度化执行方式是用规则代替人的命令，指定责任人，通过培训、checklist、定期 review 等具体措施来保证实施。制度化执行可以极大地减轻管理工作量，一般现代互联网公司都会采用类似的方式。但是制度化执行方式还有很大成分是依靠人的主动性的，对程序员来说，还有更好的方式：自动化。</p></li><li><p>自动化。</p><p>自动化的方式是在一些重要的操作路径上设置规则，针对我们的性能优化，有两个点适合做这件事：一个是把开发好的页面发布上线，另一个是开发好的页面 URL投放到首页等处的链接。</p></li></ul><h2 id="4-结果评估和监控"><a href="#4-结果评估和监控" class="headerlink" title="4. 结果评估和监控"></a>4. 结果评估和监控</h2><p>做线上监控，分两个部分：</p><ul><li>数据采集；</li><li>数据展现。</li></ul><p>数据采集部分，同样需要发布平台或者开发工具来配合，对性能数据来说，Performance API 非常好用，它是浏览器记录的性能数据，一般来说，我们用统一的代码把它上传到服务器端就够用了。<br>数据的展现部分就比较自由了，可以用不同的数据可视化方案来展现性能数据，没有一定之规。一般的数据监控平台，会提供报警机制，对性能来说，报警需求不是特别强烈，但是也可以设置一些条件，针对秒开率特别低的网页报警。<br>有了监控，再配合一定制度，就可以保障整个团队产出的性能了，要注意，性能不是一个静态的事情，指标需要不断优化，技术方案还需要不断随着技术发展迭代，制度、自动化工具也需要不断改进，最终的监控平台产品也不能不做新需求，所以性能应该成为一个团队的日常工作的一部分，持续进行。</p><h1 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h1><p>考虑工具的时候同样要遵循基本规则：现状与指标、方案、实施、结果和监控。</p><h2 id="1-工具体系的目标"><a href="#1-工具体系的目标" class="headerlink" title="1. 工具体系的目标"></a>1. 工具体系的目标</h2><p>工具链是一系列互相配合的工具，能够协作完成开发任务</p><p>工具体系的“元问题”，即：我们对工具本身的要求是什么？</p><ul><li><p>考虑到工程行为都是团队合作，我们对工具最基本的要求就是：<strong>版本一致</strong>。只有整个团队的工具版本一致，至少要做到避免大版本差异，才能做到互相接手代码时，团队成员能够正确的使用工具开发。</p></li><li><p>工具体系的另一个重要需求是：<strong>避免冲突</strong>。一些工具可能互相没有干扰，比如 Yeoman 和 gulp，有一些工具则由社区设计了配合方案，比如 webpack 和 babel，有一些工具，则存在着根本性冲突，如 gulp 和 grunt。</p></li></ul><h2 id="2-工具体系的设计"><a href="#2-工具体系的设计" class="headerlink" title="2. 工具体系的设计"></a>2. 工具体系的设计</h2><p>要想设计一个工具链，需要整理一下前端开发大约要做哪些事：</p><ul><li>初始化项目；</li><li>运行和调试；</li><li>测试（单元测试）；</li><li>发布。</li></ul><p>那么，一个前端项目的工具链，大约就会包含这些功能。一个典型的社区项目工具链可能就类似下面这样：</p><ul><li>Yeoman</li><li>webpack</li><li>ava/nyc</li><li>aws-cli</li></ul><p>但是，这显然不够，我们还需要一种机制，保证团队使用的工具版本一致：</p><ul><li>轻量级的做法是，在项目初始化模板中定义 npm script 并且在 npm dev-dependency 中规定它的版本号。</li><li>重量级的做法是，开发一个包装工具，在命令行中不直接使用命令，而使用包装过的命令。</li></ul><p>同时，统一的命令行入口，意味着整个团队不需要互相学习工具链，就可以接手别人的项目开发。<br>在稍微大一些的团队内部，往往会需要不止一种开发模式，如移动开发和桌面开发，这样，所需要的工具链也不一样，因此我们需要多条工具链。</p><h2 id="3-工具体系的执行"><a href="#3-工具体系的执行" class="headerlink" title="3. 工具体系的执行"></a>3. 工具体系的执行</h2><p>工具体系的结果虽然是软性的，也不能完全不做监控。<br>纯粹的社区方案比较难做到监控，但是如果我们使用了前面提到的统一命令行入口包装，那么就可以做一些简单的统计工作了。<br>一般来说，以下指标跟开发者体验较为相关：</p><ul><li>调试 / 构建次数；</li><li>构建平均时长；</li><li>使用的工具版本；</li><li>发布次数。</li></ul><h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><p>持续集成：是指在软件开发过程中，以定期或者实时的方式，集成所有人的工作成果，做统一的构建和测试。</p><p>与持续集成相对的做法是：独立开发各个模块，在软件开发的最终阶段才做集成。</p><p>持续集成的优势是及早处理集成阶段的问题，使软件质量和开发进度可控。</p><h2 id="1-持续集成总论"><a href="#1-持续集成总论" class="headerlink" title="1. 持续集成总论"></a>1. 持续集成总论</h2><p>传统软件的持续集成主要有以下措施。</p><ul><li>daily build：每日构建，开发者每天提交代码到代码仓库，构建一个可运行的版本。</li><li>build verification test（BVT）：构建验证测试，每日构建版本出来后，运行一组自动化的测试用例，保证基本功能可用。</li></ul><p>对于前端来说，有一些现实的区别：</p><ul><li>前端代码按页面自然解耦，大部分页面都是单人开发；</li><li>前端构建逻辑简单，一般开发阶段都保证构建成功，不需要构建；</li><li>前端代码一般用于开发界面，测试自动化成本极高；</li><li>前端页面跳转，是基于 url，没有明确的产品边界。</li></ul><p>基于以上分析，传统的持续集成方案放在前端，要么不需要，要么不适用，要么实施成本高，因此我们不能套用传统的持续集成理论，而需要重新思考前端领域的持续集成体系。</p><h2 id="2-持续集成的目标"><a href="#2-持续集成的目标" class="headerlink" title="2. 持续集成的目标"></a>2. 持续集成的目标</h2><p>每日构建不需要，前端构建验证测试成本过高难以实施，那么我们是不是可以有一些代替的措施呢？<br>首先我们要确定前端持续集成的目标，我们回到持续集成的根本理念，</p><ul><li>一是要及早集成代码形成可测试的版本，</li><li>二是通过一定的测试来验证提交的代码的有效性。</li></ul><h2 id="3-持续集成的方案"><a href="#3-持续集成的方案" class="headerlink" title="3. 持续集成的方案"></a>3. 持续集成的方案</h2><p>前端的持续集成的措施应该是这样的：</p><ul><li>预览环境，代替每日构建，前端每次（或指定次）提交代码到仓库都同步到预览环境，保证预览环境总是可用；</li><li>规则校验，代替构建验证测试，通过数据采集（如前面提到的性能数据）和代码扫描，保证提交的代码满足一定的质量要求。</li></ul><h4 id="预览环境"><a href="#预览环境" class="headerlink" title="预览环境"></a>预览环境</h4><p>前端代码发布到线上生产环境需要有线上的机器和域名，而预览环境同样需要机器和域名，不过，只需要在公司内网即可</p><p>所以建立预览环境的第一步就是申请机器和域名，我们需要运维协助，在预览环境的机器上部署 Web 应用服务器。</p><p>有了预览环境的机器，下一步就是建立预览环境发布机制。预览环境的机器发布流程应该跟线上发布保持一致，这样可以最大程度降低成本和降低心智负担。</p><h4 id="规则校验"><a href="#规则校验" class="headerlink" title="规则校验"></a>规则校验</h4><p>规则校验可以分成三种措施：</p><ul><li><p>页面结构扫描；</p><p>页面结构扫描可以使用无头浏览器（如 phantomjs）配合一些 JavaScript 代码编写的规则来完成。</p></li><li><p>运行时数据采集；</p><p>运行时数据采集，可以通过在页面插入公共 js 文件的方式来完成，最基本的是用 Performance API 来采集性能数据，用 window.onerror 来采集 js 错误。</p></li><li><p>代码扫描。</p><p>代码扫描，社区有一些现成的方案，比如 JSHint，你可以根据实际需要，选择社区方案或者自研。</p></li></ul><h2 id="4-持续集成的实施"><a href="#4-持续集成的实施" class="headerlink" title="4. 持续集成的实施"></a>4. 持续集成的实施</h2><p>持续集成的实施，是必须严格做到自动化和制度化的。</p><h2 id="5-持续集成的结果"><a href="#5-持续集成的结果" class="headerlink" title="5. 持续集成的结果"></a>5. 持续集成的结果</h2><p>持续集成机制的建立本身就可以视为一种结果，它能够让整个团队的代码质量有一个基本的保障，提前发现问题，统一代码风格，从而带来开发体验和效率的提升。<br>此外，持续集成的结果也能够以数据的方式呈现出整个开发团队的健康状态，这是管理者会非常关注的一个点。</p><h1 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h1><p>绕前端架构的几个核心问题：</p><h2 id="1-组件化"><a href="#1-组件化" class="headerlink" title="1. 组件化"></a>1. 组件化</h2><p>现行的组件化方案，目前有五种主流选择：</p><ul><li><p>Web Component；</p><p>Web Component 是 W3C 推行的规范，理论上是未来的选项；但是实际上这份标准的状态堪忧，Shadow DOM 的设计比较复杂，一般的前端掌握起来都比较困难。</p></li><li><p>Vue；</p><p>Vue ，由华人程序员尤小右开发和维护。它有两个主要特点，一个是比较符合原本的JS/CSS/HTML 书写习惯；另一个是它绑定了 MVVM 模式，直接确定了 UI 架构，通过 DSL 的支持，数据交互非常简洁。</p></li><li><p>React；</p><p>是 Facebook 推行的新一代 Web 框架。它利用 JSX 模式，把 HTML、CSS 和 JS 都放进了 JS 文件中，对于不喜欢 CSS 和 HTML 的前端工程师来说，是很理想的。它还可以迁移到 React Native，直接编写简单的客户端应用。</p></li><li><p>Angular；</p><p>是 Google 推出的 Web 框架，它是比较标准的 MVVM 模式。Angular 曾经因为大版本兼容性而饱受诟病，目前它的核心竞争力是与 TypeScript 结合得较好。</p></li><li><p>自研。</p></li></ul><h2 id="2-兼容性和适配性"><a href="#2-兼容性和适配性" class="headerlink" title="2. 兼容性和适配性"></a>2. 兼容性和适配性</h2><p>前端开发的特有问题就是兼容性，到了移动时代，需要面对不同的机型，我们又需要解决适配性问题。兼容性问题到 2011 年左右都是前端的主旋律，但是在之后，随着现代浏览器的逐渐普及，兼容性问题逐渐减小，所以我们这里就不多谈兼容性问题了。</p><p>适配问题主要适配的是屏幕的三个要素：</p><ul><li>单位英寸像素数（Pixel Per Inch，PPI）：现实世界的一英寸内像素数，决定了屏幕的显示质量</li><li>设备像素比率（Device Pixel Ratio，DPR）：物理像素与逻辑像素（px）的对应关系</li><li>分辨率（Resolution）：屏幕区域的宽高所占像素数</li></ul><h2 id="3-单页应用"><a href="#3-单页应用" class="headerlink" title="3. 单页应用"></a>3. 单页应用</h2><p>单页应用是把多个页面的内容实现在同一个实际页面内的技术，因为失去了页面的天然解耦，所以就要解决耦合问题。也就是说，我们要在一个“物理页面”内，通过架构设计来实现若干个“逻辑页面”。<br>逻辑页面应该做到独立开发和独立发布，一种思路是，每个逻辑页面一个 JS，用一个 SPA 框架加载 JS 文件。<br>从交互的角度，这并不困难，但是，这里还有一个隐性需求：保持前进后退历史。<br>一般来说，前进后退历史使用 URL 的 Hash 部分来控制，但是 onhashchange 事件并没有提供前进或者后退信息，目前还没有完美的解决方案，只能牺牲一部分体验。实现单页应用的逻辑页面发布需要改造发布系统，在工程上，这也是一个比较大的挑战。</p>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(12)</title>
    <link href="/2020/02/09/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/"/>
    <url>/2020/02/09/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器：一个浏览器是如何工作的？"><a href="#浏览器：一个浏览器是如何工作的？" class="headerlink" title="浏览器：一个浏览器是如何工作的？"></a>浏览器：一个浏览器是如何工作的？</h1><h1 id="一：网络通讯"><a href="#一：网络通讯" class="headerlink" title="一：网络通讯"></a>一：网络通讯</h1><p>所需要了解的浏览器工作原理只是它的大致过程。</p><p>来共同思考一下。一个浏览器到底是如何工作的。<br>实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。<br>这个过程是这样的：</p><ol><li>浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</li><li>把请求回来的 HTML 代码经过解析，构建成 DOM 树；</li><li>计算 DOM 树上的 CSS 属性；</li><li>最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；</li><li>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</li><li>合成之后，再绘制到界面上。<br><img src="https://img-blog.csdnimg.cn/2020020912362387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p>开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。<br>从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。</p><p>首先是网络通讯的部分：</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>浏览器首先要做的事就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议（实际上这个过程之前还有 DNS 查询，不过这里就不详细展开了。）</p><p>HTTP 标准由 IETF 组织制定。</p><p>HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。</p><p>HTTP 是纯粹的文本协议，它是规定了使用TCP 协议来传输文本格式的一个应用层协议。</p><h4 id="HTTP-协议格式"><a href="#HTTP-协议格式" class="headerlink" title="HTTP 协议格式"></a>HTTP 协议格式</h4><p><img src="https://img-blog.csdnimg.cn/20200209123640659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="HTTP-Method（方法）"><a href="#HTTP-Method（方法）" class="headerlink" title="HTTP Method（方法）"></a>HTTP Method（方法）</h4><p>首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的操作类型。方法有以下几种定义：</p><ul><li>GET</li><li>POST</li><li>HEAD</li><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li></ul><p>浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。<br>HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起<br>PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。<br>CONNECT 现在多用于 HTTPS 和 WebSocket。<br>OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。</p><h4 id="HTTP-Status-code（状态码）和-Status-text（状态文本）"><a href="#HTTP-Status-code（状态码）和-Status-text（状态文本）" class="headerlink" title="HTTP Status code（状态码）和 Status text（状态文本）"></a>HTTP Status code（状态码）和 Status text（状态文本）</h4><p>常见的状态码有以下几种：</p><ul><li><p>1xx：临时回应，表示客户端请继续。</p></li><li><p>2xx：请求成功。</p><ul><li> 200：请求成功。</li></ul></li><li><p>3xx：</p><ul><li><p>301&amp;302：永久性与临时性跳转。</p></li><li><p>304：跟客户端缓存没有更新。</p></li></ul></li><li><p>4xx：客户端请求错误。</p><ul><li>403：无权限。</li><li>404：表示请求的页面不存在。</li><li>418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）</li></ul></li><li><p>5xx：服务端请求错误。</p><ul><li>500：服务端错误。</li><li>503：服务端暂时性错误，可以一会再试。</li></ul></li></ul><p>对我们前端来说：</p><ul><li>1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。</li><li>2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。</li><li>3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。<br>304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。</li></ul><h4 id="HTTP-Head-HTTP-头"><a href="#HTTP-Head-HTTP-头" class="headerlink" title="HTTP Head (HTTP 头)"></a>HTTP Head (HTTP 头)</h4><p>HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头。<br>在 HTTP 标准中，有完整的请求 / 响应头规定。</p><ul><li> <strong>Request Header</strong>：<br><img src="https://img-blog.csdnimg.cn/20200209123702415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li> <strong>Response Header</strong>：<br><img src="https://img-blog.csdnimg.cn/20200209123719808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="HTTP-Request-Body"><a href="#HTTP-Request-Body" class="headerlink" title="HTTP Request Body"></a>HTTP Request Body</h4><p>HTTP 请求的 body 主要用于提交表单场景。实际上，http 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是：</p><ul><li>application/json</li><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/xml</li></ul><p>我们使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用multipart/form-data。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。</p><p>HTTPS 有两个作用：</p><ul><li>确定请求的目标服务端身份，</li><li>保证传输的数据不会被网络中间节点窃听或者篡改。</li></ul><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h2><p>HTTP 2 是 HTTP 1.1 的升级版本。<br>HTTP 2.0 最大的改进有两点：</p><ul><li><p>支持服务端推送</p><p>服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。</p></li><li><p>支持 TCP 连接复用。</p><p>TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(11)</title>
    <link href="/2020/02/08/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/"/>
    <url>/2020/02/08/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-替换型元素"><a href="#HTML-替换型元素" class="headerlink" title="HTML 替换型元素"></a>HTML 替换型元素</h1><p>一个网页，它是由多个文件构成的，在之前，已经学过了一种引入文件的方案：链接。</p><p>另一种引入文件的方式了。替换型元素是把文件的内容引入，替换掉自身位置的一类标签。</p><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p>script 标签是为数不多的既可以作为替换型标签，又可以不作为替换型标签的元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello world!&quot;</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个例子中，我们展示了两种 script 标签的写法，一种是直接把脚本代码写在 script 标签之间，另一种是把代码放到独立的 js 文件中，用 src 属性引入。<br>这两种写法是等效的。这种等效性可以帮助你理解替换型元素的“替换”是怎么一回事</p><p><strong>凡是替换型元素，都是使用 src 属性来引用文件的，</strong>而链接型元素是使用 href 标签的，我们用 link 标签引入 CSS 文件，当然就是用 href 标签啦</p><p> style 标签并非替换型元素，不能使用 src 属性</p><h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><p>的替换型标img 标签的作用是引入一张图片。这个标签是没有办法像 script 标签那样作为非替换型标签来使用的，它必须有 src 属性才有意义。</p><p>img 标签可以使用 width 和 height 指定宽度和高度。也可以只指定其中之一。如果从性能的角度考虑，建议你同时给出图片的宽高，因为替换型元素加载完文件后，如果尺寸发生变换，会触发重排。</p><p>img 标签还有一组重要的属性，那就是 srcset 和 sizes，它们是 src 属性的升级，这两个属性的作用是在不同的屏幕大小和特性下，使用不同的图片源。</p><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a>picture</h2><p>picture 元素可以根据屏幕的条件为其中的 img 元素提供不同的源，它的基本用法如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;image-wide.png&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 600px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image-narrow.png&quot;</span>&gt;</span><br>&lt;/picture<br></code></pre></td></tr></table></figure><p>picture 元素的设计跟 audio 和 video 保持了一致（稍后我会为你讲解这两个元素），它跟 img 搭配 srcset 和 sizes 不同，它使用 source 元素来指定图片源，并且支持多个。<br>这里的 media 属性是 media query，跟 CSS 的 @media 规则一致。</p><h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><p>video 标签跟 img 标签类似，也是使用 src 属性来引入源文件的，不过，我想应该是考虑到了各家浏览器支持的视频格式不同，现在的video 标签跟 picture 元素一样，也是提倡使用 source 的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br> You browser does not support video.<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>video 中还支持一种标签：track。</p><p>track 是一种播放时序相关的标签，它最常见的用途就是字幕。track 标签中，必须使用 srclang 来指定语言，此外，track 具有 kind 属性，共有五种。</p><ul><li>subtitles：就是字幕了，不一定是翻译，也可能是补充性说明</li><li>captions：报幕内容，可能包含演职员表等元信息，适合听障人士或者没有打开声音的人了解音频内容</li><li>descriptions：视频描述信息，适合视障人士或者没有视频播放功能的终端打开视频时了解视频内尔用</li><li>chapters：用于浏览器视频内容。</li></ul><p>metadata：给代码提供的元信息，对普通用户不可见。<br>一个完整的 video 标签可能会包含多种 track 和多个 source，这些共同构成了一个视频播放所需的全部信息。</p><h2 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h2><p>跟 picture 和 video 两种标签一样，audio 也可以使用 source 元素来指定源文件。我们看一下例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;song.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;song.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You browser does not support audio.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>这个标签能够嵌入一个完整的网页</p><p>不过，在移动端，iframe 受到了相当多的限制，它无法指定大小，里面的内容会被完全平铺到父级页面上。<br>同时很多网页也会通过 http 协议头禁止自己被放入 iframe 中。<br>iframe 标签也是各种安全问题的重灾区。opener、window.name、甚至 css 的 opacity 都是黑客可以利用的漏洞。</p><h1 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h1><p>今天的 HTML 仍然有 SGML 的不少影子</p><p>HTML 作为 SGML 的子集，它遵循 SGML 的基本语法：包括标签、转义等。</p><p>DTD 的全称是 Document Type Defination，也就是文档类型定义。SGML 用 DTD 来定义每一种文档类型，HTML 属于 SGML，在HTML5 出现之前，HTML 都是使用符合 SGML 规定的 DTD。</p>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(10)</title>
    <link href="/2020/02/08/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/"/>
    <url>/2020/02/08/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-元信息类标签"><a href="#HTML-元信息类标签" class="headerlink" title="HTML 元信息类标签"></a>HTML 元信息类标签</h1><p>所谓元信息，是指描述自身的信息，元信息类标签，就是 HTML 用于描述文档自身的一类标签，它们通常出现在 head标签中，一般都不会在页面被显示出来（与此相对，其它标签，如语义类标签，描述的是业务）</p><p>元信息多数情况下是给浏览器、搜索引擎等机器阅读的，有时候这些信息会在页面之外显示给用户，有时候则不会。</p><p>元信息类标签数量不多，逐一为你介绍一下。</p><h4 id="head-标签"><a href="#head-标签" class="headerlink" title="head 标签"></a>head 标签</h4><p><code>head</code> 标签本身并不携带任何信息，它主要是作为盛放其它语义类标签的容器使用。</p><p><code>head</code> 标签规定了自身必须是<code>html</code>标签中的第一个标签，它的内容必须包含一个<code> title</code>，并且最多只能包含一个<code> base</code>。如果文档作为<code> iframe</code>，或者有其他方式指定了文档标题时，可以允许不包含<code> title</code> 标签。</p><h4 id="title-标签"><a href="#title-标签" class="headerlink" title="title 标签"></a>title 标签</h4><p><code>title</code> 标签表示文档的标题</p><p>考虑到 <code>title</code> 作为元信息，可能会被用在浏览器收藏夹、微信推送卡片、微博等各种场景，这时侯往往是上下文缺失的，所以title 应该是完整地概括整个网页内容的。<br>而 <code>h1</code>-<code>h6 </code>则仅仅用于页面展示，它可以默认具有上下文，并且有链接辅助，所以可以简写，即便无法概括全文，也不会有很大的影响。</p><h4 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h4><p><code>base </code>标签实际上是个历史遗留标签。它的作用是给页面上所有的 URL 相对地址提供一个基础。<br><code>base</code> 标签最多只有一个，它改变全局的链接地址，它是一个非常危险的标签，容易造成跟 JavaScript 的配合问题，所以在实际开发中，我比较建议你使用JavaScript 来代替 base 标签。</p><h4 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h4><p><code>meta</code> 标签是一组键值对，它是一种通用的元信息表示标签。</p><p>在<code>head</code>中可以出现任意多个<code>meta </code>标签。一般的<code> meta</code> 标签由 <code>name </code>和 <code>content </code>两个属性来定义。<code>name</code> 表示元信息的名，<code>content </code>则用于表示元信息的值。</p><p><code>meta</code> 标签还有一些变体，主要用于简化书写方式或者声明自动化行为。下面挑几种重点的内容来分别讲解一下。</p><h4 id="具有-charset-属性的-meta"><a href="#具有-charset-属性的-meta" class="headerlink" title="具有 charset 属性的 meta"></a>具有 charset 属性的 meta</h4><p>从 HTML5 开始，为了简化写法，<code>meta </code>标签新增了<code> charset</code> 属性。添加了<code> charset</code> 属性的 <code>meta</code> 标签无需再有<code> name</code> 和<code> content</code>。</p><p><code>charset</code> 型<code> meta</code> 标签非常关键，它描述了 HTML 文档自身的编码形式。因此，我建议这个标签放在 <code>head </code>的第一个。</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure><p>这样，浏览器读到这个标签之前，处理的所有字符都是 ASCII 字符，众所周知，ASCII 字符是 UTF-8 和绝大多数字符编码的子集，所以，在读到<code> meta</code> 之前，浏览器把文档理解多数编码格式都不会出错，这样可以最大限度地保证不出现乱码。<br>一般情况下，http 服务端会通过 http 头来指定正确的编码方式，但是有些特殊的情况如使用 file 协议打开一个 HTML 文件，则没有 http 头，这种时候，charset meta 就非常重要了。</p><h4 id="具有-http-equiv-属性的-meta"><a href="#具有-http-equiv-属性的-meta" class="headerlink" title="具有 http-equiv 属性的 meta"></a>具有 http-equiv 属性的 meta</h4><p>具有 <code>http-equiv </code>属性的<code>meta</code>标签，表示执行一个命令，这样的<code>meta</code>标签可以不需要 <code>name</code> 属性了。</p><p>例如，下面一段代码，相当于添加了 <code>content-type</code> 这个<code> http</code> 头，并且指定了 <code>http </code>编码方式。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;content-type&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>除了<code> content-type</code>，还有以下几种命令：</p><ul><li><code>content-language</code> 指定内容的语言；</li><li><code>default-style</code> 指定默认样式表；</li><li><code>refresh</code> 刷新；</li><li><code>set-cookie</code> 模拟 http 头 set-cookie，设置 cookie；</li><li><code>x-ua-compatible</code> 模拟 http 头 x-ua-compatible，声明 ua 兼容性；</li><li><code>content-security-policy</code>模拟 http 头 content-security-policy，声明内容安全策略。</li></ul><h4 id="name-为-viewport-的-meta"><a href="#name-为-viewport-的-meta" class="headerlink" title="name 为 viewport 的 meta"></a>name 为 viewport 的 meta</h4><p>实际上，<code>meta</code> 标签可以被自由定义，只要写入和读取的双方约定好 <code>name </code>和<code>content</code>的格式就可以了</p><p> <code>name </code>为 <code>viewport</code> 的 <code>meta</code>，它没有在 HTML 标准中定义，却是移动端开发的事实标准。</p><p>这类<code> meta</code> 的 <code>name</code> 属性为 <code>viewport</code>，它的 <code>content</code> 是一个复杂结构，是用逗号分隔的键值对，键值对的格式是 <code>key=value</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=500, initial-scale=1&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这里只指定了两个属性，宽度和缩放，实际上 <code>viewport</code> 能控制的更多，它能表示的全部属性如下：</p><ul><li><code>width</code>：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。</li><li><code>height</code>：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。</li><li><code>initial-scale</code>：初始缩放比例。</li><li><code>minimum-scale</code>：最小缩放比例。</li><li><code>maximum-scale</code>：最大缩放比例。</li><li><code>user-scalable</code>：是否允许用户缩放。</li></ul><h4 id="其它预定义的-meta"><a href="#其它预定义的-meta" class="headerlink" title="其它预定义的 meta"></a>其它预定义的 meta</h4><p><code>application-name</code>：如果页面是 Web application，用这个标签表示应用名称。</p><ul><li><code>author:</code> 页面作者。</li><li><code>description</code>：页面描述，这个属性可能被用于搜索引擎或者其它场合。</li><li><code>generator</code>: 生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta。</li><li><code>keywords</code>: 页面关键字，对于 SEO 场景非常关键。</li><li><code>referrer</code>: 跳转策略，是一种安全考量。</li><li><code>theme-color</code>: 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）。</li></ul><h1 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a>HTML 链接</h1><p>链接是 HTML 中的一种机制，它是 HTML 文档和其它文档或者资源的连接关系，在 HTML 中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。<br>链接的家族中有 a 标签、area 标签和 link 标签。<br><img src="https://img-blog.csdnimg.cn/20200208132044472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200208132054577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="link-标签"><a href="#link-标签" class="headerlink" title="link 标签"></a>link 标签</h2><p>有些<code>link</code>标签也是元信息类标签的一种。在很多时候，它也是不会对浏览器产生任何效果的。</p><p><code>link </code>标签会生成一个链接，它可能生成超链接，也可能生成外部资源链接。</p><p>这意味着多数浏览器中，这些 <code>link </code>标签不产生任何作用。但是，这些<code> link</code> 标签能够被搜索引擎和一些浏览器插件识别，从而产生关键性作用。另外一些<code> link</code> 标签则会把外部的资源链接到文档中，也就是说，会实际下载这些资源，并且做出一些处理，比如我们常见的用<code> link</code> 标签引入样式表。</p><h4 id="超链接类-link-标签"><a href="#超链接类-link-标签" class="headerlink" title="超链接类 link 标签"></a>超链接类 link 标签</h4><p>超链接型<code>link</code>标签是一种被动型链接，在用户不操作的情况下，它们不会被主动下载。</p><p><code>link </code>标签具有特定的<code>rel</code>属性，会成为特定类型的<code> link</code> 标签。产生超链接的<code> link</code> 标签包括：具有<code>rel=“canonical”</code>的 <code>link</code>、具有 <code>rel=&quot;alternate&quot;</code>的 <code>link</code>、具有<code>rel=“prev” rel=&quot;next&quot;</code>的 <code>link</code> 等等。</p><ul><li><h5 id="canonical-型-link"><a href="#canonical-型-link" class="headerlink" title="canonical 型 link"></a>canonical 型 link</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;canonical&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这个标签提示页面它的主 URL，在网站中常常有多个 URL 指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个<code> link</code> 会提示搜索引擎保留哪一个URL</p></li><li><h5 id="alternate-型-link"><a href="#alternate-型-link" class="headerlink" title="alternate 型 link"></a>alternate 型 link</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种<code> link</code> 通常也是提供给搜索引擎来使用的。</p></li><li><p>其它超链接类的<code> link</code></p><p>其它超链接类<code> link</code> 标签都表示一个跟当前文档相关联的信息，可以把这样的 <code>link</code> 标签视为一种带链接功能的<code>meta</code>标签</p><ul><li><code>rel=“author” </code>链接到本页面的作者，一般是 mailto: 协议</li><li><code>rel=“help” </code>链接到本页面的帮助页</li><li><code>rel=“license” </code>链接到本页面的版权信息页</li><li><code>rel=“search”</code> 链接到本页面的搜索页面（一般是站内提供搜索时使用）</li></ul></li></ul><h4 id="外部资源类-link-标签"><a href="#外部资源类-link-标签" class="headerlink" title="外部资源类 link 标签"></a>外部资源类 link 标签</h4><p>外部资源型 <code>link </code>标签会被主动下载，并且根据 <code>rel </code>类型做不同的处理。外部资源型的标签包括：具有<code> icon</code> 型的 <code>link</code>、预处理类 <code>link</code>、<code>modulepreload </code>型的 <code>link</code>、<code>stylesheet</code>、<code>pingback</code>。</p><h4 id="icon-型-link"><a href="#icon-型-link" class="headerlink" title="icon 型 link"></a>icon 型 link</h4><p>这类链接表示页面的<code> icon</code>。多数浏览器会读取 <code>icon</code> 型 <code>link</code>，并且把页面的<code>icon</code>展示出来。<br><code>icon </code>型 <code>link </code>是唯一一个外部资源类的元信息 <code>link</code>，其它元信息类 link 都是超链接，这意味着，<code>icon</code> 型<code> link</code> 中的图标地址默认会被浏览器下载和使用。<br>如果没有指定这样的<code> link</code>，多数浏览器会使用域名根目录下的 favicon.ico，即使它并不存在，所以从性能的角度考虑，建议一定要保证页面中有 <code>icon </code>型的<code> link</code>。<br>只有<code>icon</code>型<code> link</code> 有有效的<code>sizes</code>属性，HTML 标准允许一个页面出现多个<code> icon</code> 型 <code>link</code>，并且用<code>sizes</code>指定它适合的 <code>icon</code> 尺寸。</p><h4 id="预处理类-link"><a href="#预处理类-link" class="headerlink" title="预处理类 link"></a>预处理类 link</h4><p>导航到一个网站需要经过 `dns ``查询域名、建立连接、传输数据、加载进内存和渲染等一系列的步骤。</p><p>预处理类 <code>link</code> 标签就是允许我们控制浏览器，提前针对一些资源去做这些操作，以提高性能（当然如果你乱用的话，性能反而更差）。</p><p>下面我来列一下这些<code>link</code>类型：</p><ul><li><code>dns-prefetch</code> 型 link 提前对一个域名做 dns 查询，这样的 link 里面的 href 实际上只有域名有意义。</li><li><code>preconnect </code>型 link 提前对一个服务器建立 tcp 连接。</li><li><code>prefetch </code>型 link 提前取 href 指定的 url 的内容。</li><li><code>preload </code>型 link 提前加载 href 指定的 url。</li><li><code>prerender</code> 型 link 提前渲染 href 指定的 url。</li></ul><h4 id="modulepreload-型的-link"><a href="#modulepreload-型的-link" class="headerlink" title="modulepreload 型的 link"></a>modulepreload 型的 link</h4><p><code>modulepreload</code> 型<code> link</code> 的作用是预先加载一个 JavaScript 的模块。这可以保证 JS 模块不必等到执行时才加载。<br>这里的所谓加载，是指完成下载并放入内存，并不会执行对应的 JavaScript。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;modulepreload&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;modulepreload&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;helpers.js&quot;</span>&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;modulepreload&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;irc.js&quot;</span>&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;modulepreload&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;fog-machine.js&quot;</span>&gt;<br>&lt;script <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这个例子来自 HTML 标准，我们假设 app.js 中有<code> import “irc”</code> 和 <code>import “fog-machine”</code>, 而 irc.js 中有<code> import “helpers”</code>。这段代码使用 moduleload 型<br><code>link </code>来预加载了四个 js 模块。<br>尽管，单独使用<code>script </code>标签引用 app.js 也可以正常工作，但是我们通过加入对四个 JS 文件的 <code>link</code> 标签，使得四个 JS 文件有机会被并行地下载，这样提高了性能。</p><h4 id="stylesheet-型-link"><a href="#stylesheet-型-link" class="headerlink" title="stylesheet 型 link"></a>stylesheet 型 link</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;xxx.css&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>基本用法是从一个 CSS 文件创建一个样式表。这里 <code>type</code> 属性可以没有，如果有，必须是”<code>text/css</code>“才会生效。</p><h4 id="pingback-型-link"><a href="#pingback-型-link" class="headerlink" title="pingback 型 link"></a>pingback 型 link</h4><p>这样的<code> link</code> 表示本网页被引用时，应该使用的 pingback 地址，这个机制是一份独立的标准，遵守 pingback 协议的网站在引用本页面时，会向这个 pingback url发送一个消息。</p><h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><p><code>a </code>标签“anchor”的缩写，它是锚点的意思，所谓锚点，实际上也是一种比喻的用法，古代船舶用锚来固定自己的位置，避免停泊时被海浪冲走，所以<code>anchor</code>标签的意思也是标识文档中的特定位置。</p><p><code>a</code> 标签其实同时充当了链接和目标点的角色，当 <code>a</code> 标签有<code> href</code> 属性时，它是链接，当它有 <code>name</code> 时，它是链接的目标。</p><p>具有<code>href</code>的 <code>a </code>标签跟一些 <code>link</code> 一样，会产生超链接，也就是在用户不操作的情况下，它们不会被主动下载的被动型链接。</p><p>重点的内容是，<code>a</code> 标签也可以有<code>rel</code>属性，我们来简单了解一下，首先是跟 <code>link </code>相同的一些 <code>rel</code>，包括下面的几种：</p><ul><li><code>alternate</code></li><li><code>author</code></li><li><code>help</code></li><li><code>license</code></li><li><code>next</code></li><li><code>prev</code></li><li><code>search</code></li></ul><p>这些跟<code>link</code>语义完全一致，不同的是，<code>a </code>标签产生的链接是会实际显示在网页中的，而 <code>link</code> 标签仅仅是元信息。</p><p><code>a </code>标签独有的 <code>rel </code>类型：</p><ul><li><code>tag </code>表示本网页所属的标签；</li><li><code>bookmark </code>到上级章节的链接。</li></ul><p><code>a </code>标签还有一些辅助的<code>rel</code>类型，用于提示浏览器或者搜索引擎做一些处理：</p><ul><li><code>nofollow</code> 此链接不会被搜索引擎索引；</li><li><code>noopener</code> 此链接打开的网页无法使用 opener 来获得当前页面的窗口；</li><li><code>noreferrer</code> 此链接打开的网页无法使用referrer 来获得当前页面的 url；</li><li><code>opener</code> 打开的网页可以使用 window.opener 来访问当前页面的 window 对象，这是 a`标签的默认行为。</li></ul><p><code>a </code>标签基本解决了在页面中插入文字型和整张图片超链接的需要，但是如果我们想要在图片的某个区域产生超链接，那么就要用到另一种标签了——<code>area </code>标签。</p><h2 id="area-标签"><a href="#area-标签" class="headerlink" title="area 标签"></a>area 标签</h2><p><code>area</code> 标签与<code> a</code>标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接。<br><code>area </code>标签支持的<code>rel</code>与<code> a</code>完全一样</p><p><code>area</code> 是整个<code>html</code>规则中唯一支持非矩形热区的标签，它的 <code>shape</code> 属性支持三种类型。</p><ul><li>圆形：<code>circle</code> 或者 <code>circ</code>，<code>coords</code> 支持三个值，分别表示中心点的 x,y 坐标和圆形半径 r。</li><li>矩形：<code>rect</code> 或者 <code>rectangle</code>，<code>coords </code>支持两个值，分别表示两个对角顶点 x1，y1 和 x2，y2。</li><li>多边形：<code>poly </code>或者<code> polygon</code>，<code>coords</code> 至少包括 6 个值，表示多边形的各个顶点。</li></ul><p>因为<code> area</code> 设计的时间较早，所以不支持含有各种曲线的路径，但是它也是唯一一个支持了非矩形触发区域的元素，所以，对于一些效果而言，<code>area </code>是必不可少的。<code>area </code>必须跟<code>img</code>和 <code>map </code>标签配合使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br> Please select a shape:<br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;shapes.png&quot;</span> <span class="hljs-attr">usemap</span>=<span class="hljs-string">&quot;#shapes&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;shapes&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">rect</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;50,50,100,100&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- the hole in the red box --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">rect</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;25,25,125,125&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;red.html&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Red box.&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">circle</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;200,75,50&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;green.html&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Green circle.&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">poly</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;325,25,262,125,388,125&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;blue.html&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Blue triangle.&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">poly</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;yellow.html&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Yellow star.&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(9)</title>
    <link href="/2020/02/07/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)/"/>
    <url>/2020/02/07/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的文法：JavaScript语法-2"><a href="#JavaScript-的文法：JavaScript语法-2" class="headerlink" title="JavaScript 的文法：JavaScript语法(2):"></a>JavaScript 的文法：JavaScript语法(2):</h1><p>JavaScript 遵循了一般编程语言的‘语句 - 表达式’结构，多数编程语言都是这样设计的。</p><p>脚本，或者模块都是由语句列表构成的，这次，就来一起了解一下语句。<br>在 JavaScript 标准中，把语句分成了两种：声明和语句，不过，这里的区分逻辑比较奇怪，所以，这里winter按照他的思路整理一下：</p><ul><li><strong>普通语句</strong>：<br><img src="https://img-blog.csdnimg.cn/20200207195815375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200207195827323.png" alt="在这里插入图片描述"></li><li><strong>声明型语句</strong>：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200207195843126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="普通语句"><a href="#普通语句" class="headerlink" title="普通语句"></a>普通语句</h2><h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>简单理解，语句块就是一对大括号：</p><figure class="highlight llvm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs llvm">&#123;<br> var <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y<span class="hljs-comment">;</span><br> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br> y <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>语句块的意义和好处在于：让我们可以把多行语句视为同一行语句，这样，<code>if</code>、<code>for</code> 等语句定义起来就比较简单了。不过，我们需要注意的是，语句块会产生作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br> <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 报</span><br></code></pre></td></tr></table></figure><p>这里我们的<code>let</code>声明，仅仅对语句块作用域生效，于是我们在语句块外试图访问语句块内的变量 x 就会报错。</p><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p>空语句就是一个独立的分号，实际上没什么。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">；<br></code></pre></td></tr></table></figure><p>空语句的存在仅仅是从语言设计完备性的角度考虑，允许插入多个分号而不抛出错</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><code>if</code> 语句是条件语句。</p><p><code>if </code>语句的作用是，在满足条件时执行它的内容语句，这个语句可以是一个语句块，这样就可以实现有条件地执行多个语句了。<br><code>if </code>语句还有 <code>else </code>结构，用于不满足条件时执行，一种常见的用法是，利用语句的嵌套能力，把 <code>if </code>和<code>else</code>连写成多分支条件判</p><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h4><p><code>for in</code> 循环枚举对象的属性，这里体现了属性的 enumerable 特征。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> o = &#123; a: <span class="hljs-number">10</span>, b: <span class="hljs-number">20</span>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">o</span>, <span class="hljs-string">&quot;c&quot;</span>, &#123;<span class="hljs-params">enumerable</span>:<span class="hljs-params">false</span>, <span class="hljs-params">value</span>:30&#125;)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p <span class="hljs-keyword">in</span> o)<br> console.log(p);<br></code></pre></td></tr></table></figure><p>这段代码中，我们定义了一个对象 o，给它添加了不可枚举的属性 c，之后我们用 for in 循环枚举它的属性，我们会发现，输出时得到的只有 a 和 b。<br>如果我们定义 c 这个属性时，enumerable 为 <code>true</code>，则 <code>for in </code>循环中也能枚举到它</p><h4 id="try-语句和-throw-语句"><a href="#try-语句和-throw-语句" class="headerlink" title="try 语句和 throw 语句"></a>try 语句和 throw 语句</h4><p><code>try </code>语句和<code> throw</code> 语句用于处理异常。它们是配合使用的，所以我们就放在一起讲了。在大型应用中，异常机制非常重要。</p><p>一般来说，<code>throw </code>用于抛出异常，但是单纯从语言的角度，我们可以抛出任何值，也不一定是异常逻辑，但是为了保证语义清晰，不建议用 <code>throw </code>表达任何非异常<br>逻辑。<br><code>try</code> 语句用于捕获异常，用<code>throw</code>抛出的异常，可以在<code>try</code>语句的结构中被处理掉：<code>try </code>部分用于标识捕获异常的代码段，<code>catch </code>部分则用于捕获异常后做一些处理，而 <code>finally</code> 则是用于执行后做一些必须执行的清理工作。<br><code>catch </code>结构会创建一个局部的作用域，并且把一个变量写入其中，需要注意，在这个作用域，不能再声明变量 e 了，否则会出错。<br>在<code> catch</code> 中重新抛出错误的情况非常常见，在设计比较底层的函数时，常常会这样做，保证抛出的错误能被理解。<br><code>finally </code>语句一般用于释放资源，它一定会被执行，我们在前面的课程中已经讨论过一些<code>finally</code>的特征，即使在<code>try</code>中出现了 <code>return</code>，<code>finally </code>中的语句也一定要被执行。</p><h4 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h4><p><code>debugger</code> 语句的作用是：通知调试器在此断点。在没有调试器挂载时，它不产生任何效果。</p><h2 id="声明型语句"><a href="#声明型语句" class="headerlink" title="声明型语句"></a>声明型语句</h2><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>var 声明语句是古典的 JavaScript 中声明变量的方式。而现在，在绝大多数情况下，<code>let </code>和 <code>const</code> 都是更好的选择。</p><p>它是一种预处理机制。</p><p>如果我们仍然想要使用 <code>var</code>，的个人建议是，把它当做一种“保障变量是局部”的逻辑，遵循以下三条规则：</p><ul><li>声明同时必定初始化；</li><li>尽可能在离使用的位置近处声明；</li><li>不要在意重复声明。</li></ul><h4 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h4><p><code>let </code>和 <code>const</code>的作用范围是<code> if、for</code> 等结构型语句。</p><p><code>let</code> 和 <code>const</code> 声明虽然看上去是执行到了才会生效，但是实际上，它们还是会被预处理。如果当前作用域内有声明，就无法访问到外部的变</p><h4 id="class-声明"><a href="#class-声明" class="headerlink" title="class 声明"></a>class 声明</h4><p><code>class </code>最基本的用法只需要 <code>class </code>关键字、名称和一对大括号。它的声明特征跟 <code>const </code>和<code>let</code>类似，都是作用于块级作用域，预处理阶段则会屏蔽外部变量</p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数声明使用 <code>function </code>关键。</p><h1 id="JavaScript-的文法：JavaScript语法-3"><a href="#JavaScript-的文法：JavaScript语法-3" class="headerlink" title="JavaScript 的文法：JavaScript语法(3):"></a>JavaScript 的文法：JavaScript语法(3):</h1><p>在语句部分，讲到了很多种语句类型，但是，其实最终产生执行效果的语句不多。</p><p>事实上，真正能干活的就只有表达式语句，其它语句的作用都是产生各种结构，来控制表达式语句执行，或者改变表达式语句的意义。</p><h2 id="什么是表达式语句"><a href="#什么是表达式语句" class="headerlink" title="什么是表达式语句"></a>什么是表达式语句</h2><p>表达式语句实际上就是一个表达式，它是由运算符连接变量或者直接量构成的</p><p>一般来说，我们的表达式语句要么是函数调用，要么是赋值，要么是自增、自减，否则表达式计算的结果没有任何意义。</p><p>但是从语法上，并没有这样的限制，任何合法的表达式都可以当做表达式语句使用。比如<code>a + b;</code></p><p>下面来了解下都有哪些表达式，从粒度最小到粒度最大了解一下</p><h2 id="PrimaryExpression-主要表达"><a href="#PrimaryExpression-主要表达" class="headerlink" title="PrimaryExpression 主要表达"></a>PrimaryExpression 主要表达</h2><p>表达式的原子项：<code>Primary Expression</code>。它是表达式的最小单位，它所涉及的语法结构也是优先级最高的。</p><p><code>Primary Expression</code> 包含了各种“直接量”，直接量就是直接用某种语法写出来的具有特定类型的值。</p><ul><li><p>简单回顾直接量。比如，用 <code>null </code>关键字获取 <code>null </code>值，这个用法就是 <code>null </code>直接量。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-number">123</span><span class="hljs-comment">;</span><br>null<span class="hljs-comment">;</span><br>true<br>false<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>除这些之外，JavaScript 还能够直接量的形式定义对象，针对函数、类、数组、正则表达式等特殊对象类型，JavaScript 提供了语法层面的支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(&#123;&#125;);<br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br>(<span class="hljs-class"><span class="hljs-keyword">class</span></span>&#123; &#125;);<br>[];<br><span class="hljs-regexp">/abc/g</span><br></code></pre></td></tr></table></figure></li><li><p>需要注意，在语法层面，<code>function</code>、<code>&#123;</code>和 <code>class</code> 开头的表达式语句 与 声明语句有语法冲突，所以，我们要想使用这样的表达式，必须加上括号来回避语法冲突。</p><p>在 JavaScript 标准中，这些结构有的被称作直接量（Literal），有的被称作表达式（**Expression），在我看来，把它们都理解成直接量比较合适。</p></li><li><p><code>Primary Expression</code>还可以是<code> this</code> 或者变量，在语法上，把变量称作“标识符引用”。</p></li><li><p>任何表达式加上圆括号，都被认为是 <code>Primary Expression</code>，这个机制使得圆括号成为改变运算优先顺序的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(<span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>) <br></code></pre></td></tr></table></figure></li></ul><p>这就是<code>Primary Expression</code>的几种形式了，接下来，讲讲由 <code>Primary Expression</code> 构成的更复杂的表达式：<code>Member Expression</code>。</p><h2 id="MemberExpression-成员表达式"><a href="#MemberExpression-成员表达式" class="headerlink" title="MemberExpression 成员表达式"></a>MemberExpression 成员表达式</h2><ul><li><p><code>Member Expression </code>通常是用于访问对象成员的。它有几种形式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">a.b<span class="hljs-comment">;</span><br>a[<span class="hljs-string">&quot;b&quot;</span>]<span class="hljs-comment">;</span><br>new.target<span class="hljs-comment">;</span><br>super.b<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>前面两种用法都很好理解，就是用标识符的属性访问和用字符串的属性访问。而 <code>new.target </code>是个新加入的语法，用于判断函数是否是被 <code>new </code>调用，<code>super</code> 则是构造函数中，用于访问父类的属性的语法。</p></li><li><p>从名字就可以看出，<code>Member Expression </code>最初设计是为了属性访问的，不过从语法结构需要，以下两种在 JavaScript 标准中当做<code> Member Expression</code>:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">f<span class="hljs-string">`a<span class="hljs-subst">$&#123;b&#125;</span>c`</span>;<br></code></pre></td></tr></table></figure><p>这是一个是带函数的模板，这个带函数名的模板表示把模板的各个部分算好后传递给一个</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">new</span> <span class="hljs-keyword">Cls</span>()<br></code></pre></td></tr></table></figure><p>另一个是带参数列表的 <code>new </code>运算，注意，不带参数列表的<code>new</code>运算优先级更低，不属于 <code>Member Expression</code></p></li></ul><p>实际上，这两种被放入 <code>Member Expression</code>，仅仅意味着它们跟属性运算属于同一优先级，没有任何语义上的关联。接下来我们看看 <code>Member Expression </code>能组成什么。</p><h2 id="NewExpression-NEW-表达式"><a href="#NewExpression-NEW-表达式" class="headerlink" title="NewExpression NEW 表达式"></a>NewExpression NEW 表达式</h2><p>这种非常简单，<code>Member Expression </code>加上 <code>new</code> 就是<code> New Expression</code>（当然，不加<code> new</code> 也可以构成 <code>New Expression</code>，JavaScript 中默认独立的高优先级表达式都可以构成低优先级表达式）。</p><p>这里的 <code>New Expression</code> 特指没有参数列表的表达式。我们看个稍微复杂的例子：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Cls</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="CallExpression-函数调用表达"><a href="#CallExpression-函数调用表达" class="headerlink" title="CallExpression 函数调用表达"></a>CallExpression 函数调用表达</h2><p>除了 <code>New Expression</code>，<code>Member Expression</code> 还能构成 <code>Call Expression</code>。它的基本形式是 <code>Member Expression </code>后加一个括号里的参数列表，或者我们可以用上<code>super</code> 关键字代替 <code>Member Expression</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span>(c);<br><span class="hljs-selector-tag">super</span>();<br></code></pre></td></tr></table></figure><p>这看起来很简单，但是它有一些变体。比如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span>(c)(d)(e);<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span>(c)<span class="hljs-selector-attr">[3]</span>;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span>(c)<span class="hljs-selector-class">.d</span>;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span>(c)`<span class="hljs-selector-tag">xyz</span>`;<br></code></pre></td></tr></table></figure><p>这些变体的形态，跟 <code>Member Expression </code>几乎是一一对应的。实际上，我们可以理解为，<code>Member Expression</code> 中的某一子结构具有函数调用，那么整个表达式就成为了一个<code> Call Expression。</code><br>而 <code>Call Expression</code> 就失去了比<code>New Expression</code>优先级高的特性，这是一个主要的区分。</p><h2 id="LeftHandSideExpression-左值表达式"><a href="#LeftHandSideExpression-左值表达式" class="headerlink" title="LeftHandSideExpression 左值表达式"></a>LeftHandSideExpression 左值表达式</h2><p><code>New Expression </code>和 <code>Call Expression </code>统称 <code>LeftHandSideExpression</code>，左值表达式</p><p>们直观地讲，左值表达式就是可以放到等号左边的表达式。JavaScript 语法则是下面这样。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">a() = b<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>左值表达式最经典的用法是用于构成赋值表。</p><h2 id="AssignmentExpression-赋值表达式"><a href="#AssignmentExpression-赋值表达式" class="headerlink" title="AssignmentExpression 赋值表达式"></a>AssignmentExpression 赋值表达式</h2><p>AssignmentExpression 赋值表达式也有多种形态，最基本的当然是使用等号赋值：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = b<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个等号是可以嵌套的：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">a</span> = <span class="hljs-attr">b</span> = <span class="hljs-attr">c</span> = d<br></code></pre></td></tr></table></figure><p>这样的连续赋值，是右结合的，它等价于下面这种：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">a</span> = (<span class="hljs-attr">b</span> = (<span class="hljs-attr">c</span> = d)<br></code></pre></td></tr></table></figure><p>当然，这并非一个很好的代码风格，我们讲解语法是为了让你理解这样的用法，而不是推荐你这样写代码。</p><p>赋值表达式的使用，还可以结合一些运算符，例如：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">a +</span>=<span class="hljs-string"> b;</span><br></code></pre></td></tr></table></figure><h1 id="JavaScript-的文法：JavaScript语法-4"><a href="#JavaScript-的文法：JavaScript语法-4" class="headerlink" title="JavaScript 的文法：JavaScript语法(4):"></a>JavaScript 的文法：JavaScript语法(4):</h1><p>其中关于赋值表达式，讲完了它的左边部分，而留下了它右边部分，那么，来详细讲解。</p><p>在一些通用的计算机语言设计理论中，能够出现在赋值表达式右边的叫做：右值表达式（RightHandSideExpression），而在 JavaScript 标准中，规定了在等号右边表达式叫做条件表达式（ConditionalExpression），不过，在 JavaScript 标准中，从未出现过右值表达式字样。</p><p>JavaScript 标准也规定了左值表达式同时都是条件表达式（也就是右值表达式），此外，左值表达式也可以通过跟一定的运算符组合，逐级构成更复杂的结构，直到成为右值表达式。</p><h2 id="更新表达式-UpdateExpression"><a href="#更新表达式-UpdateExpression" class="headerlink" title="更新表达式 UpdateExpression"></a>更新表达式 UpdateExpression</h2><p>左值表达式搭配 ++ – 运算符，可以形成更新表达式。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">-- a</span><br>++ <span class="hljs-keyword">a</span><br><span class="hljs-keyword">a</span> <span class="hljs-comment">--</span><br><span class="hljs-keyword">a</span> ++<br></code></pre></td></tr></table></figure><p>更新表达式会改变一个左值表达式的值。分为前后自增，前后自减一共四种。</p><h2 id="一元运算表达式-UnaryExpressio"><a href="#一元运算表达式-UnaryExpressio" class="headerlink" title="一元运算表达式 UnaryExpressio"></a>一元运算表达式 UnaryExpressio</h2><p>更新表达式搭配一元运算符，可以形成一元运算表达式</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">delete</span> <span class="hljs-keyword">a</span>.b<br>void <span class="hljs-keyword">a</span><br>typeof <span class="hljs-keyword">a</span><br>- <span class="hljs-keyword">a</span><br>~ <span class="hljs-keyword">a</span><br>! <span class="hljs-keyword">a</span><br>await <span class="hljs-keyword">a</span><br></code></pre></td></tr></table></figure><p>他的特点就是一个更新表达式搭配了一个一元运算符。</p><h2 id="乘方表达式-ExponentiationExpressio"><a href="#乘方表达式-ExponentiationExpressio" class="headerlink" title="乘方表达式 ExponentiationExpressio"></a>乘方表达式 ExponentiationExpressio</h2><p>乘方表达式也是由更新表达式构成的。它使用<code>**</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">++i ** <span class="hljs-number">30</span><br><span class="hljs-number">2</span> ** <span class="hljs-number">30</span> <span class="hljs-regexp">//</span> 正确<br>-<span class="hljs-number">2</span> ** <span class="hljs-number">30</span> <span class="hljs-regexp">//</span> 报<br></code></pre></td></tr></table></figure><p>例子中，-2 这样的一元运算表达式，是不可以放入乘方表达式的，如果需要表达类似的逻辑，必须加括号。</p><p>我们需要注意一下结合性，** 运算是右结合的，这跟其它正常的运算符（也就是左结合运算符）都不一样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">4</span> ** <span class="hljs-number">3</span> **<span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span>以上它是这样被运算的：<br><span class="hljs-number">4</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>)<br><span class="hljs-regexp">//</span>而不是这样被运算的<br>(<span class="hljs-number">4</span> ** <span class="hljs-number">3</span>) ** <br></code></pre></td></tr></table></figure><h2 id="乘法表达式-MultiplicativeExpression"><a href="#乘法表达式-MultiplicativeExpression" class="headerlink" title="乘法表达式 MultiplicativeExpression"></a>乘法表达式 MultiplicativeExpression</h2><p>乘方表达式可以构成乘法表达式，用乘号或者除号、取余符号连接就可以了，我们看看例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>乘法表达式有三种运算符：<code>*</code>,<code>/</code>,<code>%</code></p><p>它们分别表示乘、除和取余。它们的优先级是一样的，所以统一放在乘法运算表达式中。</p><h2 id="加法表达式-AdditiveExpression"><a href="#加法表达式-AdditiveExpression" class="headerlink" title="加法表达式 AdditiveExpression"></a>加法表达式 AdditiveExpression</h2><p>加法表达式有加号和减号两种运算符。</p><p>加法表达式是由乘法表达式用加号或者减号连接构成的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> * c<br></code></pre></td></tr></table></figure><h2 id="移位表达式-ShiftExpression"><a href="#移位表达式-ShiftExpression" class="headerlink" title="移位表达式 ShiftExpression"></a>移位表达式 ShiftExpression</h2><p>移位表达式由加法表达式构成，移位是一种位运算，分成三种：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&lt;&lt; 向左移位<br><span class="hljs-meta">&gt;&gt;</span> 向右移位<br>&gt;&gt;&gt; 无符号向右<br></code></pre></td></tr></table></figure><p>移位运算把操作数看做二进制表示的整数，然后移动特定位数。所以左移 n 位相当于乘以 2 的 n 次方，右移 n 位相当于除以 2 取整 n次。</p><h2 id="关系表达式-RelationalExpression"><a href="#关系表达式-RelationalExpression" class="headerlink" title="关系表达式 RelationalExpression"></a>关系表达式 RelationalExpression</h2><p>移位表达式可以构成关系表达式，这里的关系表达式就是大于、小于、大于等于、小于等于等运算符号连接，统称为关系运算。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;=</span><br><span class="hljs-attribute">&gt;</span>=<br><span class="hljs-attribute">&lt;</span><br><span class="hljs-attribute">&gt;</span><br>instanceof<br>in<br></code></pre></td></tr></table></figure><p>需要注意，这里的 &lt;= 和 &gt;= 关系运算，完全是针对数字的，所以 &lt;= 并不等价于 &lt; 或 ==。例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">null</span> &lt;= <span class="hljs-literal">undefined</span><br><span class="hljs-comment">//false</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span><br><span class="hljs-comment">//tru</span><br></code></pre></td></tr></table></figure><h2 id="相等表达式-EqualityExpression"><a href="#相等表达式-EqualityExpression" class="headerlink" title="相等表达式 EqualityExpression"></a>相等表达式 EqualityExpression</h2><p>在语法上，相等表达式是由关系表达式用相等比较运算符（如<code> ==</code>）连接构成的。所以我们可以像下面这段代码一样使用，而不需要加括号：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">a <span class="hljs-keyword">instanceof</span> <span class="hljs-string">&quot;object&quot;</span> == <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>相等表达式由四种运算符和关系表达式构成，我们来看一下运算符:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">==<br><span class="hljs-section">!=</span><br><span class="hljs-section">===</span><br>!=<br></code></pre></td></tr></table></figure><p>类型不同的变量比较时==运算只有三条规则：</p><ul><li>undefined 与 null 相等；</li><li>字符串和 bool 都转为数字再比较；</li><li>对象转换成 primitive 类型再比较。</li></ul><p>这样我们就可以理解一些不太符合直觉的例子了，比如:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-literal">false</span> == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-comment">//true</span><br><span class="hljs-literal">true</span> == <span class="hljs-string">&#x27;true&#x27;</span><span class="hljs-comment">// false</span><br>[<span class="hljs-meta"></span>] == <span class="hljs-number">0</span> <span class="hljs-comment">//true</span><br>[<span class="hljs-meta"></span>] == <span class="hljs-literal">false</span> <span class="hljs-comment">//true</span><br><span class="hljs-keyword">new</span> Boolean(<span class="hljs-string">&#x27;false&#x27;</span>) == <span class="hljs-literal">false</span> <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>这里不太符合直觉的有两点：</p><ul><li>一个是即使字符串与 boolean 比较，也都要转换成数字；</li><li>二是对象如果转换成了 primitive 类型跟等号另一边类型恰好相同，则不需要转换成数字</li></ul>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(8)</title>
    <link href="/2020/02/07/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)/"/>
    <url>/2020/02/07/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的文法：JavaScript语法-1"><a href="#JavaScript-的文法：JavaScript语法-1" class="headerlink" title="JavaScript 的文法：JavaScript语法(1):"></a>JavaScript 的文法：JavaScript语法(1):</h1><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><h4 id="自动插入分号规则"><a href="#自动插入分号规则" class="headerlink" title="自动插入分号规则"></a>自动插入分号规则</h4><p>自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。</p><ul><li>要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</li><li>有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</li><li>源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</li></ul><h4 id="no-LineTerminator-here-规则"><a href="#no-LineTerminator-here-规则" class="headerlink" title="no LineTerminator here 规则"></a>no LineTerminator here 规则</h4><p>![`](<a href="https://img-blog.csdnimg.cn/20200207164919589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20200207164919589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70</a>)</p><h1 id="JavaScript语法-2-："><a href="#JavaScript语法-2-：" class="headerlink" title="JavaScript语法(2)："></a>JavaScript语法(2)：</h1><h2 id="脚本和模块"><a href="#脚本和模块" class="headerlink" title="脚本和模块"></a>脚本和模块</h2><ol><li><p>在 ES5 和之前的版本中，就只有一种源文件类型，就只有脚本。</p></li><li><p>在 ES6 引入了模块机制开始的，JavaScript 有两种源文件，一种叫做脚本，一种叫做模块。</p></li><li><p>脚本是可以由浏览器或者 node 环境引入执行的，而模块只能由 JavaScript 代码用 <code>import </code>引入执行。</p></li><li><p>从概念上，我们可以认为脚本具有主动性的 JavaScript 代码段，是控制宿主完成一定任务的代码；而模块是被动性的 JavaScript 代码段，是等待被调用的库。</p></li><li><p>我们对标准中的语法产生式做一些对比，不难发现，实际上模块和脚本之间的区别仅仅在于是否包含<code> import</code> 和<code> export</code>。</p></li><li><p>脚本是一种兼容之前的版本的定义，在这个模式下，没有<code>import</code>就不需要处理加载“<code>.js</code>”文件问题。<br>现代浏览器可以支持用 <code>script </code>标签引入模块或者脚本，如果要引入模块，必须给 <code>script </code>标签添加 <code>type=“module”</code>。如果引入脚本，则不需要 type。</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxxxx.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p> <code>    script</code> 标签如果不加<code>type=“module”</code>，默认认为我们加载的文件是脚本而非模块，如果我们在脚本中写了 <code>export</code>，当然会抛错。</p></li></ol><p>脚本中可以包含语句。</p><p>模块中可以包含三种内容：<code>import 声明，</code>export <code>声明和语句。下面来讲讲 </code>import <code>声明和</code>export<code> 声明。</code><br><img src="https://img-blog.csdnimg.cn/20200207165028985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="import-声明"><a href="#import-声明" class="headerlink" title="import 声明"></a>import 声明</h4><p><code>import </code>声明有两种用法:</p><ul><li>一个是直接 <code>import </code>一个模块。只是保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。</li><li>另一个是带<code>from</code>的 <code>import</code>，它能引入模块里的一些信息。可以把它们变成本地的变量。</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;mod&quot;</span>; <span class="hljs-comment">// 引入一个模块</span><br><span class="hljs-keyword">import</span> v <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mod&quot;</span>; <span class="hljs-comment">// 把模块默认的导出值放入变量 v</span><br></code></pre></td></tr></table></figure><p>带<code>from</code>的 <code>import</code> 细分又有三种用法，我们可以分别看下例子:</p><ul><li><code>import x from &quot;./a.js&quot; </code>引入模块中导出的默认值。</li><li><code>import &#123;a as x, modify&#125; from &quot;./a.js&quot;; </code>引入模块中的变量。</li><li><code>import * as x from &quot;./a.js&quot;</code> 把模块中所有的变量以类似对象属性的方式引入。</li></ul><p>第一种方式还可以跟后两种组合使用:(语法要求不带 <code>as </code>的默认值永远在最前。)</p><ul><li><code>import d, &#123;a as x, modify&#125; from &quot;./a.js&quot;</code></li><li><code>import d, * as x from &quot;./a.js&quot;</code></li></ul><h4 id="export-声明"><a href="#export-声明" class="headerlink" title="export 声明"></a>export 声明</h4><p>与<code>import</code>相对，<code>export </code>声明承担的是导出的任务。</p><p>模块中导出变量的方式有两种:</p><ul><li><p>一种是独立使用 <code>export </code>声明</p><p>独立使用<code>export</code>声明就是一个<code>export</code>关键字加上变量名列表，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">export &#123;<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c&#125;;<br></code></pre></td></tr></table></figure></li><li><p>另一种是直接在声明型语句前添加 <code>export </code>关键字</p><p>这里的 <code>export </code>可以加在任何声明性质的语句之前，整理如下：</p><ul><li><code>var</code></li><li><code>function</code> (含 <code>async</code> 和 <code>generator</code>)</li><li><code>class</code></li><li><code>let</code></li><li><code>const</code></li></ul></li><li><p><code>export</code> 还有一种特殊的用法，就是跟 <code>default </code>联合使用。</p><p><code>export default </code>表示导出一个默认变量值，它可以用于 <code>function</code> 和<code> class</code>。这里导出的变量是没有名称的，可以使用<code>import x from &quot;./a.js&quot;</code>这样的语法，在模块中引入。</p></li></ul><p> <code> export default</code> 还支持一种语法，后面跟一个表达式，</p>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> a = &#123;&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br></code></pre></td></tr></table></figure><p>  但是，这里的行为跟导出变量是不一致的，这里导出的是值，导出的就是普通变量 a 的值，以后 a 的变化与导出的值就无关了，修改变量 a，不会使得其他模块中引入的 default 值发生改变。</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>执行函数的行为通常是在 JavaScript 代码执行时，注册宿主环境的某些事件触发的，而执行的过程，就是执行函数体（函数的花括号中间的部分）。</p><p>函数体其实也是一个语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了<code>return</code>语句可以用。</p><p>函数体实际上有四种:</p><ul><li><p>普通函数体</p></li><li><p>异步函数体</p></li><li><p>生成器函数体，例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">*foo</span>()&#123;<br> //<span class="hljs-keyword">Function</span> <span class="hljs-title">body</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>异步生成器函数体，例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">async <span class="hljs-keyword">function</span> <span class="hljs-title">*foo</span>()&#123;<br> //<span class="hljs-keyword">Function</span> <span class="hljs-title">body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面四种函数体的区别在于：能否使用 <code>await </code>或者 <code>yield </code>语句。</p></li></ul><p>关于函数体、模块和脚本能使用的语句，有个表格，可以参考：<br><img src="https://img-blog.csdnimg.cn/20200207165210914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>讲完了三种语法结构，下面介绍两个 JavaScript 语法的全局机制：预处理和指令序言。</p><p>这两个机制对于我们解释一些 JavaScript 的语法现象非常重要。不理解预处理机制我们就无法理解 var 等声明类语句的行为，而不理解指令序言，我们就无法解释严格模式。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。</p><h4 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h4><p>var 声明永远作用于脚本、模块和函数体这个级别，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。</p><p>var 的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构。</p><p>一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">var</span> o= &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">3</span>&#125;<br> <span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">o</span>)</span> &#123;<br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br> &#125;<br> <span class="hljs-built_in">console</span>.log(o.a);<br> <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br>foo();<br></code></pre></td></tr></table></figure><ol><li><p>这个例子中，引入了<code>with</code>语句，用<code>with(o)</code>创建了一个作用域，并把 o 对象加入词法环境，在其中使用了<code>var a = 2;</code>语句。</p></li><li><p>在预处理阶段，只认var中声明的变量，所以同样为 foo 的作用域创建了 a 这个变量，但是没有赋值。</p></li><li><p>在执行阶段，当执行到<code>var a = 2</code>时，作用域变成了<code>with</code>语句内，这时候的 a 被认为访问到了对象 o 的属性 a，所以最终执行的结果，我们得到了 2 和undefined。</p><p>这个行为是 JavaScript 公认的设计失误之一，一个语句中的 a 在预处理阶段和执行阶段被当做两个不同的变量，严重违背了直觉，但是今天，在 JavaScript 设计原则“don’t break the web”之下，已经无法修正了，所以你需要特别注意。</p></li></ol><h4 id="function-声明"><a href="#function-声明" class="headerlink" title="function 声明"></a>function 声明</h4><p><code>function</code> 声明的行为原本跟 <code>var</code> 非常相似，但是在最新的 JavaScript 标准中，对它进行了一定的修改，这让情况变得更加复杂了。</p><ul><li><p>在全局（脚本、模块和函数体），<code>function </code>声明表现跟 var 相似，不同之处在于，<code>function </code>声明不但在作用域中加入变量，还会给它赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(foo);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里声明了函数 foo，在声明之前，我们用 <code>console.log</code> 打印函数 foo，我们可以发现，已经是函数 foo 的值了。</p></li><li><p><code>function </code>声明出现在<code>if</code>等语句中的情况有点复杂，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，它不再被提前赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(foo);<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码得到 <code>undefined</code>。如果没有函数声明，则会抛出错误。</p><p>这说明 <code>function</code> 在预处理阶段仍然发生了作用，在作用域中产生了变量，没有产生赋值，赋值行为发生在了执行阶段。</p><p>出现在<code> if</code> 等语句中的<code> function</code>，在<code>if</code>创建的作用域中仍然会被提前，产生赋值效果。</p></li></ul><h4 id="class-声明"><a href="#class-声明" class="headerlink" title="class 声明"></a>class 声明</h4><p><code>class </code>声明在全局的行为跟 <code>function </code>和 <code>var</code> 都不一样。</p><ul><li><p>在 class 声明之前使用<code>class</code>名，会抛错：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r">console.log(<span class="hljs-built_in">c</span>);<br><span class="hljs-built_in">class</span> <span class="hljs-built_in">c</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码我们试图在<code> class</code> 前打印变量 c，我们得到了个错误，这个行为很像是 <code>class </code>没有预处理，但是实际上并非如此。</p></li><li><p>看个复杂一点的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(c);<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c</span> </span>&#123;&#125;<br>&#125;<br>foo();<br></code></pre></td></tr></table></figure><p>这个例子中，我们把<code>class</code>放进了一个函数体中，在外层作用域中有变量 c。然后试图在 <code>class </code>之前打印 c。执行后，仍然抛出了错误，如果去掉 <code>class </code>声明，则会正常打印出 1，也就是说，出现在后面的<code>class</code>声明影响了前面语句的结果。</p><p>这说明，<code>class </code>声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。</p></li></ul><p><code>class </code>的声明作用不会穿透<code> if</code> 等语句结构，所以只有写在全局环境才会有声明作用</p><p>这样的 <code>class </code>设计比 <code>function</code> 和 <code>var</code> 更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。</p><h2 id="指令序言机制"><a href="#指令序言机制" class="headerlink" title="指令序言机制"></a>指令序言机制</h2><p>脚本和模块都支持一种特别的语法，叫做指令序言（Directive Prologs）。</p><p>这里的指令序言最早是为了<code>use strict</code>设计的，它规定了一种给 JavaScript 代码添加元信息的方式。</p><p>“<code>use strict</code>“是 JavaScript 标准中规定的唯一一种指令序言，但是设计指令序言的目的是，留给 JS 的引擎和实现者一些统一的表达方式，在静态扫描时指定 JS 代码的一些特性。</p>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(7)</title>
    <link href="/2020/02/07/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)/"/>
    <url>/2020/02/07/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的文法：词法"><a href="#JavaScript-的文法：词法" class="headerlink" title="JavaScript 的文法：词法"></a>JavaScript 的文法：词法</h1><p>文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。</p><p>词法规定了语言的最小语义单元：<code>token</code>，可以翻译成“标记”或者“词”，在此专栏文章中，统一把 token 翻译成词。</p><p>从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类：</p><ul><li><p>WhiteSpace 空白字符</p></li><li><p>LineTerminator 换行符</p></li><li><p>Comment 注释</p></li><li><p>Token 词</p><ul><li><p>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。</p></li><li><p>Punctuator 符号，我们使用的运算符和大括号等符号。</p></li><li><p>NumericLiteral 数字直接量，就是我们写的数字。</p></li><li><p>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。</p></li><li><p>Template 字符串模板，用反引号` 括起来的直接量</p></li></ul></li></ul><p>这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，下面讲特别在哪里。</p><ul><li><p>除法和正则表达式冲突问题</p><p>JavaScript 不但支持除法运算符“<code>/</code>”和“<code>/=</code>”，还支持用斜杠括起来的正则表达式“<code> /abc/</code>”</p><p>但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪<br>一套词法。</p></li><li><p>是字符串模板</p><p>模板语法大概是这样的：</p><figure class="highlight arcade"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span><br></code></pre></td></tr></table></figure><p>理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。</p></li></ul><p>是否允许“ } ”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义：</p><ul><li>InputElementDiv；</li><li>InputElementRegExp；</li><li>InputElementRegExpOrTemplateTail；</li><li>InputElementTemplateTail。</li></ul><p>为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为 CommonToken。在本文档，我们依然把它们归类到 token 来理解。</p><p>对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript 来说，不太一样，换行符和注释还会影响语法分析过程，这个将会在语法部分详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。</p><h2 id="空白符号-Whitespace"><a href="#空白符号-Whitespace" class="headerlink" title="空白符号 Whitespace"></a>空白符号 Whitespace</h2><p>说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。</p><ul><li><code>&lt;HT&gt;</code>(或称<code>&lt;TAB&gt;</code>) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \t 。</li><li><code>&lt;VT&gt;</code>是 U+000B，也就是垂直方向的 TAB 符<code> \v</code>，这个字符在键盘上很难打出来，所以很少用到。</li><li><code>&lt;FF&gt;</code>是 U+000C，Form Feed，分页符，字符串直接量中写作 <code>\f </code>，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。</li><li><code>&lt;SP&gt;</code>是 U+0020，就是最普通的空格了。</li><li><code>&lt;NBSP&gt;</code>是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript<br>编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的   最后生成的就是它了。</li><li><code>&lt;ZWNBSP&gt;</code>(旧称<code>&lt;BOM&gt;</code>) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF 格式编码的文件中，常常在文件首插入一个额外的<br>U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。<br>此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格.</li></ul><h2 id="换行符-LineTerminator"><a href="#换行符-LineTerminator" class="headerlink" title="换行符 LineTerminator"></a>换行符 LineTerminator</h2><p>接下来我们来看看换行符，JavaScript 中只提供了 4 种字符作为换行符。</p><ul><li><code>&lt;LF&gt;</code></li><li><code>&lt;CR&gt;</code></li><li><code>&lt;LS&gt;</code></li><li><code>&lt;PS&gt;</code></li></ul><p>其中，<code>&lt;LF&gt;</code>是 U+000A，就是最正常换行符，在字符串中的<code>\n</code></p><p><code>&lt;CR&gt;</code>是 U+000D，这个字符真正意义上的“回车”，在字符串中是<code>\r</code>，在一部分 Windows 风格文本编辑器中，换行是两个字符<code>\r\n</code>。<br><code>&lt;LS&gt;</code>是 U+2028，是 Unicode 中的行分隔符。<code>&lt;PS&gt;</code>是 U+2029，是 Unicode 中的段落分隔符。<br>大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。</p><h2 id="注释-Comment"><a href="#注释-Comment" class="headerlink" title="注释 Comment"></a>注释 Comment</h2><p>JavaScript 的注释分为单行注释和多行注释两种：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* MultiLineCommentChars */</span><br><span class="hljs-regexp">//</span> SingleLineCommentChars<br></code></pre></td></tr></table></figure><p>多行注释中允许自由地出现<code>MultiLineNotAsteriskChar</code>，也就是除了<code>*</code>之外的所有字符。而每一个<code>*</code>之后，不能出现正斜杠符<code>/</code>。<br>除了四种 LineTerminator 之外，所有字符都可以作为单行注释。<br>我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。</p><h2 id="标识符名称-IdentifierName"><a href="#标识符名称-IdentifierName" class="headerlink" title="标识符名称 IdentifierName"></a>标识符名称 IdentifierName</h2><ul><li><code>IdentifierName</code>可以以美元符<code>$</code>下划线<code>_</code>或者 Unicode 字母开始，除了开始字符以外，<code>IdentifierName</code>中还可以使用 Unicode 中的连接标记、数字、以及连接符<br>号。</li><li><code>IdentifierName</code>的任意字符可以使用 JavaScript 的 Unicode 转义写法，使用 Unicode 转义写法时，没有任何字符限制。</li><li><code>IdentifierName</code>可以是<code>Identifier</code>、<code>NullLiteral</code>、<code>BooleanLiteral</code>或者<code>keyword</code>，在<code>ObjectLiteral</code>中，<code>IdentifierName</code>还可以被直接当做属性名称使用。仅当不是保留字的时候，<code>IdentifierName</code>会被解析为<code>Identifier</code>。<br>注意<code>&lt;ZWNJ&gt;</code>和<code>&lt;ZWJ&gt;</code>是 ES5 新加入的两个格式控制字符，它们都是 0 宽的。</li></ul><p>(这节还看完…)</p>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(6)</title>
    <link href="/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)/"/>
    <url>/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript执行-四-：Completion-类型"><a href="#JavaScript执行-四-：Completion-类型" class="headerlink" title="JavaScript执行(四)：Completion 类型"></a>JavaScript执行(四)：Completion 类型</h1><p>语句是任何编程语言的基础结构，与 JavaScript 对象一样，JavaScript 语句同样具有“看起来很像其它语言，但是其实一点都不一样”的特点。</p><h2 id="Completion-类型"><a href="#Completion-类型" class="headerlink" title="Completion 类型"></a>Completion 类型</h2><ul><li><p>在<code>try</code>中有<code>return</code>语句，<code>finally</code> 中的内容还会执行吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-keyword">try</span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br> &#125; <span class="hljs-keyword">finally</span> &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>)<br> &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(foo());<br></code></pre></td></tr></table></figure><p><code>finally </code>确实执行了，而且 <code>return </code>语句也生效了，<code>foo()</code> 返回了结果 <code>0</code>。</p><p>虽然 <code>return</code> 执行了，但是函数并没有立即返回，又执行了 <code>finally</code> 里面的内容，这样的行为违背了很多人的直觉。</p></li><li><p>在<code>finally</code>中加入<code> return</code> 语句，会发生什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-keyword">try</span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br> &#125; <span class="hljs-keyword">finally</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(foo());<br></code></pre></td></tr></table></figure><p><code>finally</code> 中的<code>return</code>“覆盖”了 <code>try</code> 中的 <code>return</code>。在一个函数中执行了两次 <code>return</code>，这已经超出了很多人的常识，也是其它语言中不会出现的一种行为。</p></li></ul><p>面对如此怪异的行为，我们当然可以把它作为一个孤立的知识去记忆，但是实际上，这背后有一套机制在运作</p><p>这一机制的基础正是 JavaScript 语句执行的完成状态，我们用一个标准类型来表示：CompletionRecord。（Completion Record 用于描述异常、跳出等语句执行过程）</p><p>Completion Record`表示一个语句执行完之后的结果，它有三个字段：</p><p>-<code> [[type]]</code> 表示完成的类型，有 <code>break</code>, <code>continue</code> ,<code>return</code>, <code>throw </code>和 <code>normal</code> 几种类型；<br>-<code>[[value]]</code>表示语句的返回值，如果语句没有，则是    <code>empty   </code>；<br>-<code>[[target]]</code>表示语句的目标，通常是一个 JavaScript 标签</p><p>JavaScript 正是依靠语句的 Completion Record类型，方才可以在语句的复杂嵌套结构中，实现各种控制。</p><h4 id="语句分类"><a href="#语句分类" class="headerlink" title="语句分类"></a>语句分类</h4><p><img src="https://img-blog.csdnimg.cn/20200206204208695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200206204228132.png" alt="在这里插入图片描述"></p><ul><li><p><strong>普通的语句</strong></p><ol><li><p>普通语句在执行时，从前到后顺次执行（我们这里先忽略<code>var</code>和函数声明的预处理机制），没有任何分支或者重复执行逻辑。</p></li><li><p>普通语句执行后，会得到<code>[[type]]</code>为 <code>normal</code> 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。</p></li><li><p>普通语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。</p></li><li><p>使用 chrome 自带的调试工具，可以知道，输入一个表达式，在控制台可以得到结果，但是在前面加上<code> var</code>，就变成了<code> undefined</code>。Chrome 控制台显示的正是语句的 Completion Record 的 <code>[[value]]</code>。</p></li></ol></li><li><p><strong>语句块</strong></p><ol><li><p>语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。</p></li><li><p>语句块本身并不复杂，我们需要注意的是语句块内部的语句的 Completion Record 的 <code>[[type]] </code>如果不为<code> normal</code>，会打断语句块后续的语句执行。</p></li><li><p>在一个 block 中，如果每一个语句都是 <code>normal</code> 类型，那么它会顺次执行。但是假如我们在 block 中插入了一条<code>return</code>语句，产生了一个非<code>normal</code>记录，那么整个 <code>block </code>会成为非<code>normal</code>。这个结构就保证了非<code> normal</code> 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。</p></li></ol></li><li><p><strong>控制型语句</strong></p><ol><li><p>控制型语句带有 <code>if</code>、<code>switch </code>关键字，它们会对不同类型的 Completion Record 产生反应。</p></li><li><p>控制类语句分成两部分，一类是对其内部造成影响，如 <code>if</code>、<code>switch</code>、<code>while/for</code>、<code>try</code>。另一类是对外部造成影响如 <code>break</code>、<code>continue</code>、<code>return</code>、<code>throw</code>，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。</p></li><li><p>一般来说，<code> for/while</code> - <code>break/continue</code> 和 <code>try - throw </code>这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟 <code>break</code> 、<code>continue </code>、<code>return </code>、<code>throw </code>四种类型与控制语句两两组合产生的效果。</p></li></ol><p>  <img src="https://img-blog.csdnimg.cn/20200206204432649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>   因为 <code>finally</code> 中的内容必须保证执行，所以 <code>try/catch </code>执行完毕，即使得到的结果是非 <code>normal </code>型的完成记录，也必须要执行<code> finally</code>。<br>   而当<code>finally</code> 执行也得到了非<code>normal</code>记录，则会使<code> finally</code> 中的记录作为整个 try 结构的结果。</p></li><li><p><strong>带标签的语句</strong></p><ol><li><p>实际上，任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">firstStatement: <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的 <code>target </code>相配合，用于跳出多层循环。</p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(5)</title>
    <link href="/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)/"/>
    <url>/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript执行-三-：函数"><a href="#JavaScript执行-三-：函数" class="headerlink" title="JavaScript执行(三)：函数"></a>JavaScript执行(三)：函数</h1><p>在 JavaScript，切换上下文最主要的场景是函数调用。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在 ES2018 中，函数已经是一个很复杂的体系了。</p><ul><li><p>普通函数：用 function 关键字定义的函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// code</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>箭头函数：用 =&gt; 运算符定义的函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"> foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// code</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>方法：在 class 中定义的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-comment">//code</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生成器函数：用 function * 定义的函数</p></li><li><p>类：用 class 定义的类，实际上也是函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-comment">//code</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第六 / 七 / 八种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-comment">// code</span><br>&#125;<br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> () =&gt; &#123;<br> <span class="hljs-comment">// code</span><br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>*(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-comment">// code</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>对普通变量而言，这些函数并没有本质区别，都是遵循了“继承定义时环境”的规则，它们的一个行为差异在于 this 关键字。</p><h2 id="this-关键字的行为"><a href="#this-关键字的行为" class="headerlink" title="this 关键字的行为"></a>this 关键字的行为</h2><p>this 是 JavaScript 中的一个关键字，它的使用方法类似于一个变量。但是 this 跟变量的行为有很多不同。</p><p><strong>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同</strong></p><p>普通函数的 this 值由“调用它所使用的引用”决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个 Reference 类型。Reference 类型由两部分组成：一个对象和一个属性值。</p><p><strong>调用函数时使用的引用，决定了函数执行时刻的 this 值。</strong></p><p>从运行时的角度来看，this 跟面向对象毫无关联，它是与函数调用时使用的表达式相关。</p><p>生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的</p><h2 id="this-关键字的机制"><a href="#this-关键字的机制" class="headerlink" title="this 关键字的机制"></a>this 关键字的机制</h2><p>函数能够引用定义时的变量，如上文分析，函数也能记住定义时的 this，因此，函数内部必定有一个机制来保存这些信息。<br>在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性 [[Environment]]。</p><p>当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的 [[Environment]]。这个动作就是<strong>切换上下文</strong></p><p>JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200206174013715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。<br>而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。</p><p><strong>[[thisMode]] 私有属性有三个取值</strong>:</p><ul><li>lexical：表示从上下文中找 this，这对应了箭头函数。</li><li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li><li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li></ul><p>非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行</p><p>函数创建新的执行上下文中的词法环境记录时，会根据 [[thisMode]] 来标记新纪录的 [[ThisBindingStatus]] 私有属性。<br>代码执行遇到 this 时，会逐层检查当前词法环境记录中的 [[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。</p><h2 id="操作-this-的内置函数"><a href="#操作-this-的内置函数" class="headerlink" title="操作 this 的内置函数"></a>操作 this 的内置函数</h2><p><code>Function.prototype.call</code> 和 <code>Function.prototype.apply </code>可以指定函数调用时传入的 this 值</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">foo</span>(a, b, c)&#123;<br> <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(this);<br> <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a, b, c);<br>&#125;<br><span class="hljs-selector-tag">foo</span><span class="hljs-selector-class">.call</span>(&#123;&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">// &#123;&#125;  1 2 3</span><br><span class="hljs-selector-tag">foo</span><span class="hljs-selector-class">.apply</span>(&#123;&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<span class="hljs-comment">// &#123;&#125;  1 2 3</span><br></code></pre></td></tr></table></figure><p>这里 call 和 apply 作用是一样的，只是传参方式有区别</p>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(4)</title>
    <link href="/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)/"/>
    <url>/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript执行-一-：Promise里的代码为什么比setTimeout先执行？"><a href="#JavaScript执行-一-：Promise里的代码为什么比setTimeout先执行？" class="headerlink" title="JavaScript执行(一)：Promise里的代码为什么比setTimeout先执行？"></a>JavaScript执行(一)：Promise里的代码为什么比setTimeout先执行？</h1><p>当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。</p><p>所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p><p>在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。<br>但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。</p><p>由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。</p><h1 id="JavaScript执行-二-：闭包和执行上下文到底是怎么回事？"><a href="#JavaScript执行-二-：闭包和执行上下文到底是怎么回事？" class="headerlink" title="JavaScript执行(二)：闭包和执行上下文到底是怎么回事？"></a>JavaScript执行(二)：闭包和执行上下文到底是怎么回事？</h1><p><img src="https://img-blog.csdnimg.cn/20200206164502323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在编程语言领域，它表示一种函数。</p><p>对函数式语言而言，λ表达式其实就是函数。</p><p>闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。</p><p>这个古典的闭包定义中，闭包包含两个部分。</p><ul><li>环境部分</li><li>表达式部分</li></ul><p>当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在 JavaScript 中找到对应的闭包组成部分。</p><ul><li>环境部分<ul><li>环境：函数的词法环境（执行上下文的一部分）</li><li>标识符列表：函数中用到的未声明的变量</li></ul></li><li>表达式部分：函数体</li></ul><p>至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式<br>部分就是函数体。</p><h2 id="执行上下文：执行的基础设施"><a href="#执行上下文：执行的基础设施" class="headerlink" title="执行上下文：执行的基础设施"></a>执行上下文：执行的基础设施</h2><p>JavaScript 中与闭包“环境部分”相对应的术语是“词法环境”，但是 JavaScript 函数比λ函数要复杂得多，我们还要处理 this、变量声明、with 等等一系列的复杂语法，λ函数中可没有这些东西，所以，在JavaScript 的设计中，词法环境只是 JavaScript 执行上下文的一部分。</p><p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“<strong>执行上下文</strong>”。</p><p>因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下 JavaScript 中的概念。</p><h4 id="执行上下文在-ES3-中，包含三个部分。"><a href="#执行上下文在-ES3-中，包含三个部分。" class="headerlink" title="执行上下文在 ES3 中，包含三个部分。"></a>执行上下文在 ES3 中，包含三个部分。</h4><ul><li>scope：作用域，也常常被叫做作用域链。</li><li>variable object：变量对象，用于存储变量的对象。</li><li>this value：this 值。</li></ul><h4 id="在-ES5-中"><a href="#在-ES5-中" class="headerlink" title="在 ES5 中"></a>在 ES5 中</h4><p>我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。</p><ul><li>lexical environment：词法环境，当获取变量时使用。</li><li>variable environment：变量环境，当声明变量时使用。</li><li>this value：this 值。</li></ul><h4 id="在-ES2018-中"><a href="#在-ES2018-中" class="headerlink" title="在 ES2018 中"></a>在 ES2018 中</h4><p>执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容.</p><ul><li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li><li>variable environment：变量环境，当声明变量时使用</li><li>code evaluation state：用于恢复代码执行位置。</li><li>Function：执行的任务是函数时使用，表示正在被执行的函数。</li><li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li><li>Realm：使用的基础库和内置对象实例。</li><li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li></ul><p>我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的 ES2018 中规定的术语定义。</p><h4 id="立即执行的函数表达式（IIFE）"><a href="#立即执行的函数表达式（IIFE）" class="headerlink" title="立即执行的函数表达式（IIFE）"></a>立即执行的函数表达式（IIFE）</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs actionscript">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">var</span> a;<br> <span class="hljs-comment">//code</span><br>&#125;());<br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">var</span> a;<br> <span class="hljs-comment">//code</span><br>&#125;)();<br><br>;(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">var</span> a;<br> <span class="hljs-comment">//code</span><br>&#125;())<br><br>;(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">var</span> a;<br> <span class="hljs-comment">//code</span><br>&#125;)()<br></code></pre></td></tr></table></figure><p>我比较推荐的写法是使用 void 关键字。也就是下面的这种形式:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">var</span> a;<br> <span class="hljs-comment">//code</span><br>&#125;();<br></code></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。<br>为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。</p><p>以下常见语句会产生 let 使用的作用域：</p><ul><li>for；</li><li>if；</li><li>switch；</li><li>try/catch/finally。</li></ul>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(3)</title>
    <link href="/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)/"/>
    <url>/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><h2 id="JavaScript-中的对象分类"><a href="#JavaScript-中的对象分类" class="headerlink" title="JavaScript 中的对象分类"></a>JavaScript 中的对象分类</h2><ul><li>宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</li><li>内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。<ul><li>固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</li><li>原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</li><li>普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</li></ul></li></ul><h4 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h4><p>JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。<br>在浏览器环境中，我们都知道全局对象是 window，window 上又有很多属性，如 document。<br>实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。<br>JavaScript 标准中规定了全局对象属性，w3c 的各种标准中规定了 Window 对象的其它属性。<br>宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 dom 对象。<br>宿主也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素。</p><h4 id="内置对象·固有对象"><a href="#内置对象·固有对象" class="headerlink" title="内置对象·固有对象"></a>内置对象·固有对象</h4><p>固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</p><p>固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。</p><h4 id="内置对象·原生对象"><a href="#内置对象·原生对象" class="headerlink" title="内置对象·原生对象"></a>内置对象·原生对象</h4><p>我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。<br><img src="https://img-blog.csdnimg.cn/20200206142142915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。<br>几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。</p><h4 id="用对象来模拟函数与构造器：函数对象与构造器对象"><a href="#用对象来模拟函数与构造器：函数对象与构造器对象" class="headerlink" title="用对象来模拟函数与构造器：函数对象与构造器对象"></a>用对象来模拟函数与构造器：函数对象与构造器对象</h4><p>我在前面介绍了对象的一般分类，在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。<br>事实上，JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。<br>函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。</p><h4 id="特殊行为的对象"><a href="#特殊行为的对象" class="headerlink" title="特殊行为的对象"></a>特殊行为的对象</h4><p>除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。<br>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。</p><ul><li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li><li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li><li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li><li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li>bind 后的 function：跟原来的函数相关联。</li></ul>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(2)</title>
    <link href="/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2020/02/06/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript原型"><a href="#JavaScript原型" class="headerlink" title="JavaScript原型"></a>JavaScript原型</h1><p>早期的 JavaScript 程序员一般都有过使用 JavaScript“模拟面向对象”的经历。</p><p>JavaScript 本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会。<br>那些“模拟面向对象”，实际上做的事情就是“模拟基于类的面向对象”。</p><h2 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h2><p>原型是顺应人类自然思维的产物。</p><h4 id="在不同的编程语言中，设计者利用各种不同的语言特性来抽象描述对象。"><a href="#在不同的编程语言中，设计者利用各种不同的语言特性来抽象描述对象。" class="headerlink" title="在不同的编程语言中，设计者利用各种不同的语言特性来抽象描述对象。"></a>在不同的编程语言中，设计者利用各种不同的语言特性来抽象描述对象。</h4><ul><li><p>最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做基于类的编程语言。</p><p>“基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。</p></li><li><p>还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。</p><p>“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。基于原型的面向对象系统通过“复制”的方式来创建新对象。一些语言的实现中，还允许复制一个空对象。这实际上就是创建一个全新的对象。<br>基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。</p></li></ul><p>基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。</p><h4 id="原型系统的“复制操作”有两种实现思路："><a href="#原型系统的“复制操作”有两种实现思路：" class="headerlink" title="原型系统的“复制操作”有两种实现思路："></a>原型系统的“复制操作”有两种实现思路：</h4><ul><li>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；</li><li>另一个是切实地复制对象，从此两个对象再无关联。<br>历史上的基于原型语言因此产生了两个流派，显然，JavaScript 显然选择了前一种方式。</li></ul><h2 id="JavaScript-的原型"><a href="#JavaScript-的原型" class="headerlink" title="JavaScript 的原型"></a>JavaScript 的原型</h2><p>如果抛开 JavaScript 用于模拟 Java 类的复杂语法设施（如 new、Function Object、函数的 prototype 属性等），原型系统可以说相当简单，我可以用两条概括：</p><ul><li>如果所有对象都有私有字段 [[prototype]]，就是对象的原型；</li><li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li></ul><p>这个模型在 ES 的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为：</p><ul><li><code>Object.create </code>根据指定的原型创建新对象，原型可以是 null；</li><li><code>Object.getPrototypeOf</code> 获得一个对象的原型；</li><li><code>Object.setPrototypeOf </code>设置一个对象的原型。</li></ul><h2 id="ES6-中的类"><a href="#ES6-中的类" class="headerlink" title="ES6 中的类"></a>ES6 中的类</h2><p>在 ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。下面我们就来看一下 ES6 中的类。</p><p>ES6 中引入了 class 关键字，并且在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了JavaScript 的官方编程范式。</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> &#123;</span><br> <span class="hljs-built_in">constructor</span>(height, width) &#123;<br> <span class="hljs-keyword">this</span>.height = height;<br> <span class="hljs-keyword">this</span>.width = width;<br> &#125;<br> <span class="hljs-comment">// Getter</span><br> <span class="hljs-function">get <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-built_in">calcArea</span>();<br> &#125;<br> <span class="hljs-comment">// Method</span><br> <span class="hljs-built_in">calcArea</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在现有的类语法中，getter/setter 和 method 是兼容性最好的。<br>我们通过 get/set 关键字来创建 getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。<br>类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。</p><p>此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br> <span class="hljs-built_in">this</span>.name = name;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; makes a noise.&#x27;</span>);<br> &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br> <span class="hljs-built_in">super</span>(name); <span class="hljs-comment">// call the super class constructor and pass in the name parameter</span><br> &#125;<br> <span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; barks.&#x27;</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;Mitzie&#x27;</span>);<br>d.speak(); <span class="hljs-comment">// Mitzie barks.</span><br></code></pre></td></tr></table></figure><p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。<br>比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。<br>所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。<br>一些激进的观点认为，class 关键字和箭头运算符可以完全替代旧的 function 关键字，它更明确地区分了定义函数和定义类两种意图，我认为这是有一定道理的。</p>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入之执行上下文栈</title>
    <link href="/2020/02/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <url>/2020/02/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript深入之执行上下文栈"><a href="#JavaScript深入之执行上下文栈" class="headerlink" title="JavaScript深入之执行上下文栈"></a>JavaScript深入之执行上下文栈</h1><h2 id="顺序执行？"><a href="#顺序执行？" class="headerlink" title="顺序执行？"></a>顺序执行？</h2><p>如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br><br>&#125;<br><br>foo();  <span class="hljs-comment">// foo1</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br><br>&#125;<br><br>foo(); <span class="hljs-comment">// foo2</span><br></code></pre></td></tr></table></figure><p>然而去看这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br><br>&#125;<br><br>foo();  <span class="hljs-comment">// foo2</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br><br>&#125;<br><br>foo(); <span class="hljs-comment">// foo2</span><br></code></pre></td></tr></table></figure><p>打印的结果却是两个 <code>foo2</code>。</p><p>这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。</p><p>但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？</p><p>到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？</p><h2 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h2><p> JavaScript 的可执行代码(executable code)的类型：全局代码、函数代码、eval代码。</p><p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>我们写的函数多了去了，如何管理创建的那么多执行上下文呢？</p><p> JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p><p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = []<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    globalContext<br>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>现在 JavaScript 遇到下面的这段代码了：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">fun3</span>() &#123;<br>    console.log(&#x27;fun3&#x27;)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>() &#123;<br>    fun3();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>() &#123;<br>    fun2();<br>&#125;<br><br>fun1();<br></code></pre></td></tr></table></figure><p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 伪代码</span><br><br><span class="hljs-comment">// fun1()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>push(&lt;fun1&gt; functionContext);<br><br><span class="hljs-comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>push(&lt;fun2&gt; functionContext);<br><br><span class="hljs-comment">// 擦，fun2还调用了fun3！</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>push(&lt;fun3&gt; functionContext);<br><br><span class="hljs-comment">// fun3执行完毕</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>pop<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// fun2执行完毕</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>pop<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// fun1执行完毕</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>pop<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><br></code></pre></td></tr></table></figure><h2 id="解答思考题："><a href="#解答思考题：" class="headerlink" title="解答思考题："></a>解答思考题：</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f();<br>&#125;<br>checkscope();<br><br><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br>checkscope()();<br></code></pre></td></tr></table></figure><p>两段代码执行的结果一样,为local scope，但是两段代码究竟有哪些不同呢？</p><p>答案就是执行上下文栈的变化不一样。</p><p>让我们模拟第一段代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>push(&lt;checkscope&gt; functionContext);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>push(&lt;f&gt; functionContext);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>pop<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>pop<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>让我们模拟第二段代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>push(&lt;checkscope&gt; functionContext);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>pop<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>push(&lt;f&gt; functionContext);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ECStack</span>.</span></span>pop<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入之词法作用域和动态作用域</title>
    <link href="/2020/02/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2020/02/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript深入之词法作用域和动态作用域"><a href="#JavaScript深入之词法作用域和动态作用域" class="headerlink" title="JavaScript深入之词法作用域和动态作用域"></a>JavaScript深入之词法作用域和动态作用域</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p><h2 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h2><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p><p>让我们认真看个例子就能明白之间的区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br>    foo();<br>&#125;<br><br>bar();<br><br><span class="hljs-comment">// 结果是 ???</span><br></code></pre></td></tr></table></figure><ul><li><p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p></li><li><p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p></li></ul><p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>最后，看一个《JavaScript权威指南》中的例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f();<br>&#125;<br>checkscope();<br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br>checkscope()();<br></code></pre></td></tr></table></figure><p>猜猜两段代码各自的执行结果是多少？</p><p>这里直接告诉大家结果，两段代码都会打印：<code>local scope</code>。</p><p>原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。</p><p>而引用《JavaScript权威指南》的回答就是：</p><p>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入之从原型到原型链</title>
    <link href="/2020/02/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2020/02/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript深入之从原型到原型链"><a href="#JavaScript深入之从原型到原型链" class="headerlink" title="JavaScript深入之从原型到原型链"></a>JavaScript深入之从原型到原型链</h1><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p><figure class="highlight delphi"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">var</span> <span class="hljs-title">person</span> = <span class="hljs-title">new</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span>;</span><br>person.<span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;Kevin&#x27;</span>;<br>console.log(person.<span class="hljs-keyword">name</span>) <span class="hljs-comment">// Kevin</span><br></code></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个函数都有一个 prototype 属性，prototype是函数才会有的属性，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;<br>Person.prototype.name = <span class="hljs-string">&#x27;Kevin&#x27;</span>;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(person1.name) <span class="hljs-comment">// Kevin</span><br><span class="hljs-built_in">console</span>.log(person2.name) <span class="hljs-comment">// Kevin</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</strong></p><p>函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p></li><li><p><strong>那什么是原型呢？</strong></p><p>每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是原型，每一个对象都会从原型”继承”属性。</p></li><li><p>构造函数和实例原型之间的关系：<br><img src="https://img-blog.csdnimg.cn/20200204131806266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p></li></ul><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Person()</span> &#123;<br><br>&#125;<br>var person = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person()</span>;<br>console.log(person.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>于是我们更新下关系图：<br><img src="https://img-blog.csdnimg.cn/20200204131757945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>原型指向实例的属性是没有的，因为一个构造函数可以生成多个实例。</p><p>原型指向构造函数是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(Person === Person.prototype.<span class="hljs-keyword">constructor</span>)</span>;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>所以再更新下关系图：<br><img src="https://img-blog.csdnimg.cn/20200204131744119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>综上我们已经得出：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Person()</span> &#123;<br><br>&#125;<br><br>var person = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person()</span>;<br><br>console.log(person.__proto__<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype) <span class="hljs-comment">// true</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.constructor<span class="hljs-operator"> == </span>Person) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">person</span>)</span><span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性。</p><p>如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> Person() &#123;<br><br>&#125;<br><br>Person.prototype.name = <span class="hljs-string">&#x27;Kevin&#x27;</span>;<br><br>var person = <span class="hljs-built_in">new</span> Person();<br><br>person.name = <span class="hljs-string">&#x27;Daisy&#x27;</span>;<br>console.log(person.name) // Daisy<br><br><span class="hljs-keyword">delete</span> person.name;<br>console.log(person.name) // Kevin<br></code></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> obj = new <span class="hljs-keyword">Object</span>();<br>obj.<span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;Kevin&#x27;</span><br>console.log(obj.<span class="hljs-keyword">name</span>) <span class="hljs-comment">// Kevin</span><br></code></pre></td></tr></table></figure><p>原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：<br><img src="https://img-blog.csdnimg.cn/20200204131727271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>那 Object.prototype 的原型呢？</strong> <strong>null</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span>) <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>null 究竟代表了什么呢？</strong>   null 表示“没有对象”，即该处不应该有值。</p><p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。<br><img src="https://img-blog.csdnimg.cn/20200204131714754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p><h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(person.constructor === Person); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">person.<span class="hljs-built_in">constructor</span> === Person.prototype.<span class="hljs-built_in">constructor</span><br></code></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中的执行上下文和执行栈</title>
    <link href="/2020/02/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%20%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <url>/2020/02/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%20%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的执行上下文和执行栈"><a href="#JavaScript-中的执行上下文和执行栈" class="headerlink" title="JavaScript 中的执行上下文和执行栈"></a>JavaScript 中的执行上下文和执行栈</h1><h2 id="1-什么是执行上下文？"><a href="#1-什么是执行上下文？" class="headerlink" title="1. 什么是执行上下文？"></a>1. 什么是执行上下文？</h2><p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><p>JavaScript 中有三种执行上下文类型。</p><ul><li><strong>全局执行上下文</strong>(GlobalExectionContext) ： 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li><strong>函数执行上下文</strong>(FunctionExectionContext) ： 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li><li><strong>Eval 函数执行上下文</strong> ：执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>，所以在这里我不会讨论它。</li></ul><h2 id="2-执行栈"><a href="#2-执行栈" class="headerlink" title="2.执行栈"></a>2.执行栈</h2><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><ul><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  second();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">second</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><br>first();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Global Execution Context&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200203215727640.png" alt="在这里插入图片描述"></p></li></ul><ol><li><p>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 <code>first()</code> 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p></li><li><p>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，JavaScript 引擎为 <code>second()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>second()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 <code>first()</code> 函数的执行上下文。</p></li><li><p>当 <code>first()</code> 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p></li></ol><h2 id="3-怎么创建执行上下文？"><a href="#3-怎么创建执行上下文？" class="headerlink" title="3. 怎么创建执行上下文？"></a>3. 怎么创建执行上下文？</h2><p>创建执行上下文有两个阶段：<strong>1) 创建阶段</strong> 和 <strong>2) 执行阶段</strong>。</p><h4 id="创建阶段："><a href="#创建阶段：" class="headerlink" title="创建阶段："></a>创建阶段：</h4><p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p><ul><li><p><strong>this</strong> 值的决定，即 <strong>This 绑定</strong>(ThisBinding)。</p></li><li><p>创建<strong>词法环境</strong>(LexicalEnvironment)组件。</p></li><li><p>创建<strong>变量环境</strong>(VariableEnvironment)组件。</p></li></ul><p>所以执行上下文在概念上表示如下：    </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">ExecutionContext = &#123;<br>  ThisBinding = &lt;this value&gt;,<span class="hljs-regexp">//</span>This 绑定<br>  LexicalEnvironment = &#123; ... &#125;,<span class="hljs-regexp">//</span>词法环境<br>  VariableEnvironment = &#123; ... &#125;,<span class="hljs-regexp">//</span>变量环境<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="This-绑定："><a href="#This-绑定：" class="headerlink" title="This 绑定："></a><strong>This 绑定：</strong></h4><ul><li><p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。</p></li><li><p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。</p></li><li><p>例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">let foo = &#123;<br>  baz: <span class="hljs-keyword">function</span>() &#123;<br>  console.log(this);<br>  &#125;<br>&#125;<br><br>foo.baz();   <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;this&#x27;</span> 引用 <span class="hljs-string">&#x27;foo&#x27;</span>, 因为 <span class="hljs-string">&#x27;baz&#x27;</span> 被<br>             <span class="hljs-regexp">//</span> 对象 <span class="hljs-string">&#x27;foo&#x27;</span> 调用<br><br>let bar = foo.baz;<br><br>bar();       <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;this&#x27;</span> 指向全局 window 对象，因为<br>             <span class="hljs-regexp">//</span> 没有指定引用对象<br></code></pre></td></tr></table></figure></li></ul><h4 id="词法环境："><a href="#词法环境：" class="headerlink" title="词法环境："></a>词法环境：</h4><ul><li><p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>外部</strong>词法环境的空值组成。</p><p>简单来说<strong>词法环境</strong>是一种持有<strong>标识符—变量映射</strong>的结构。（这里的<strong>标识符</strong>指的是变量/函数的名字，而<strong>变量</strong>是对实际对象[包含函数类型对象]或原始数据的引用）。</p></li><li><p><strong>词法环境</strong>有两种类型：</p><ol><li><p><strong>全局环境</strong>：（在全局执行上下文中）是没有外部环境引用的词法环境。其外部环境引用是 <strong>null</strong>。它拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，<code>this</code> 的值指向这个全局对象。</p></li><li><p>在<strong>函数环境</strong>：用户在函数中定义的变量被存储在<strong>环境记录</strong>中，包含了<code>arguments</code> 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ol><p>直接看伪代码可能更加直观</p></li><li><p>词法环境的<strong>内部</strong>有两个组件：</p><ol><li><strong>环境记录器</strong> (EnvironmentRecord)：存储变量和函数声明的实际位置。</li><li><strong>外部环境的引用</strong>(outer) ：可以访问其父级（其外部）词法环境（作用域）。</li></ol></li><li><p><strong>环境记录器</strong>也有两种类型：</p><ol><li><strong>声明式环境记录器</strong>存储变量、函数和参数。</li><li><strong>对象环境记录器</strong>用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系。</li></ol><p>简而言之:</p><ol><li>在<strong>全局环境</strong>中，环境记录器是<strong>对象环境记录器</strong>。</li><li>在<strong>函数环境</strong>中，环境记录器是<strong>声明式环境记录器</strong>。</li></ol><p>对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p></li><li><p>抽象地讲，词法环境在伪代码中看起来像这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>以下是全局执行上下文中的词法环境<br>GlobalExectionContext = &#123;<br>  LexicalEnvironment: &#123;<span class="hljs-regexp">//</span>词法环境<br>    EnvironmentRecord: &#123;<span class="hljs-regexp">//</span>声明式环境记录器<br>      Type: <span class="hljs-string">&quot;Object&quot;</span>,<br>      <span class="hljs-regexp">//</span> 在这里绑定标识符<br>    &#125;<br>    outer: &lt;null&gt;<span class="hljs-regexp">//</span>外部环境的引用<br>  &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span>以下函数执行上下文中的词法环境<br>FunctionExectionContext = &#123;<br>  LexicalEnvironment: &#123;<span class="hljs-regexp">//</span>词法环境<br>    EnvironmentRecord: &#123;<span class="hljs-regexp">//</span>对象环境记录器<br>      Type: <span class="hljs-string">&quot;Declarative&quot;</span>,<br>      <span class="hljs-regexp">//</span> 在这里绑定标识符<br>    &#125;<br>    outer: &lt;Global or outer <span class="hljs-keyword">function</span> environment reference&gt;<span class="hljs-regexp">//</span>外部环境的引用<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="变量环境："><a href="#变量环境：" class="headerlink" title="变量环境："></a>变量环境：</h4><ul><li><p>它同样是一个词法环境，其环境记录器持有<strong>变量声明语句</strong>在执行上下文中创建的绑定关系。</p></li><li><p>变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。</p></li><li><p>在 ES6 中，<strong>词法环境</strong>组件和<strong>变量环境</strong>的一个不同就是前者被用来存储函数声明和变量（<code>let</code> 和 <code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p></li></ul><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">var</span> c;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">e, f</span>) </span>&#123;<br> <span class="hljs-keyword">var</span> g = <span class="hljs-number">20</span>;<br> <span class="hljs-keyword">return</span> e * f * g;<br>&#125;<br><br>c = multiply(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>执行上下文看起来像这样：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//以下是全局执行上下文,包括This 绑定，词法环境，变量环境</span><br>GlobalExectionContext = &#123;<br><span class="hljs-symbol">  ThisBinding:</span> <span class="hljs-params">&lt;Global Object&gt;</span>, <span class="hljs-comment">//This 绑定</span><br><span class="hljs-symbol">  LexicalEnvironment:</span> &#123;<span class="hljs-comment">//词法环境，包括对象环境记录器,外部环境的引用</span><br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<span class="hljs-comment">//对象环境记录器</span><br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Object&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br><span class="hljs-symbol">      a:</span> <span class="hljs-params">&lt; uninitialized &gt;</span>,<br><span class="hljs-symbol">      b:</span> <span class="hljs-params">&lt; uninitialized &gt;</span>,<br><span class="hljs-symbol">      multiply:</span> <span class="hljs-params">&lt; func &gt;</span><br>    &#125;<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;null&gt;</span><span class="hljs-comment">//外部环境的引用</span><br>  &#125;,<br><span class="hljs-symbol">  VariableEnvironment:</span> &#123;<span class="hljs-comment">//变量环境，包括对象环境记录器,外部环境的引用</span><br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<span class="hljs-comment">//对象环境记录器</span><br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Object&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br><span class="hljs-symbol">      c:</span> undefined,<br>    &#125;<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;null&gt;</span><span class="hljs-comment">//外部环境的引用</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//以下函数执行上下文，包括This 绑定，词法环境，变量环境</span><br>FunctionExectionContext = &#123;<br><span class="hljs-symbol">  ThisBinding:</span> <span class="hljs-params">&lt;Global Object&gt;</span>,<span class="hljs-comment">//This 绑定</span><br><span class="hljs-symbol">  LexicalEnvironment:</span> &#123;<span class="hljs-comment">//词法环境，包括声明式环境记录器,外部环境的引用</span><br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<span class="hljs-comment">//声明式环境记录器</span><br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Declarative&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br><span class="hljs-symbol">      Arguments:</span> &#123;<span class="hljs-number">0</span>: <span class="hljs-number">20</span>, <span class="hljs-number">1</span>: <span class="hljs-number">30</span>, length: <span class="hljs-number">2</span>&#125;,<br>    &#125;,<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;GlobalLexicalEnvironment&gt;</span><span class="hljs-comment">//外部环境的引用</span><br>  &#125;,<br><span class="hljs-symbol">VariableEnvironment:</span> &#123;<span class="hljs-comment">//变量环境，包括声明式环境记录器,外部环境的引用</span><br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<span class="hljs-comment">//声明式环境记录器</span><br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Declarative&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br><span class="hljs-symbol">      g:</span> undefined<br>    &#125;,<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;GlobalLexicalEnvironment&gt;</span><span class="hljs-comment">//外部环境的引用</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong> ：只有遇到调用函数 <code>multiply</code> 时，函数执行上下文才会被创建。</p><p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p><p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p><p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p><p>这就是我们说的变量声明提升。</p><h3 id="执行阶段："><a href="#执行阶段：" class="headerlink" title="执行阶段："></a>执行阶段：</h3><p>在此阶段，完成对所有这些变量的分配，最后执行代码。</p><p><strong>注意</strong> — 在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 <code>let</code> 变量的值，它会被赋值为 <code>undefined</code>。</p><p>参考整理于：<a href="https://juejin.im/post/5ba32171f265da0ab719a6d7">link</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js运行机制</title>
    <link href="/2020/02/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/02/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Js运行机制"><a href="#Js运行机制" class="headerlink" title="Js运行机制"></a>Js运行机制</h1><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h3><ul><li><p>JavaScript 是一门<strong>单线程</strong>语言，在最新的HTML5 中提出了Web-Worker，但JavaScript 是单线程这一核心仍未改变。</p></li><li><p>Js 作为浏览器脚本语言，它的主要用途是与用户互动，以及操作DOM，因此Js是单线程，也避免了同时操作同一个DOM的矛盾问题；</p></li><li><p>为了利用多核CPU的计算能力，H5的Web Worker实现的“多线程”实际上指的是“多子线程”，完全受控于主线程，且不允许操作DOM；</p></li><li><p>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）；</p></li><li><p>如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行；</p></li></ul><h3 id="2-Js中的异步操作"><a href="#2-Js中的异步操作" class="headerlink" title="2.Js中的异步操作"></a>2.Js中的异步操作</h3><ul><li>setTimeOut</li><li>setInterval</li><li>ajax</li><li>promise</li><li>I/O</li></ul><h3 id="3-同步任务-or-异步任务"><a href="#3-同步任务-or-异步任务" class="headerlink" title="3.同步任务 or 异步任务"></a>3.同步任务 or 异步任务</h3><ul><li>同步任务(synchronous)：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li><li>异步任务(asynchronous)：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><h3 id="4-宏任务-or-微任务"><a href="#4-宏任务-or-微任务" class="headerlink" title="4.宏任务 or 微任务"></a>4.宏任务 or 微任务</h3><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>宏任务(macro-task)：整体代码script、setTimeOut、setInterval</li><li>微任务(mincro-task)：promise.then、promise.nextTick(node)</li></ul><h3 id="5-JavaScript事件循环"><a href="#5-JavaScript事件循环" class="headerlink" title="5.JavaScript事件循环"></a>5.JavaScript事件循环</h3><p><img src="https://img-blog.csdnimg.cn/20200203155133427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>Js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。上述过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）</li></ul><h3 id="6-setTimeout"><a href="#6-setTimeout" class="headerlink" title="6. setTimeout"></a>6. setTimeout</h3><ul><li><p>```<br>setTimeout(() =&gt; {</p><div class="code-wrapper"><pre><code class="hljs">task();</code></pre></div><p>},3000)<br>console.log(‘执行console’);</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs autohotkey"><br>  `setTimeout`是异步的，上面代码先执行`console.log`这个同步任务，再执行task()。<br><br>- ```<br>  setTimeout(() =&gt; &#123;<br>      task()<br>  &#125;,<span class="hljs-number">3000</span>)<br>  <br>  sleep(<span class="hljs-number">10000000</span>)<br></code></pre></td></tr></table></figure><p>上面代码执行<code>task()</code>需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p><p>我们先说上述代码是怎么执行的：</p><ol><li><code>task()</code>进入Event Table并注册,计时开始。</li><li>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</li><li><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</li></ol><p><strong><code>setTimeout</code>这个函数，是经过指定时间后，把要执行的任务</strong>(本例中为<code>task()</code>)<strong>加入到Event Queue中。</strong>又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p><p>答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。</p></li></ul><h3 id="7-setInterval"><a href="#7-setInterval" class="headerlink" title="7. setInterval"></a>7. setInterval</h3><ul><li><p>对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p></li><li><p>注意的是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦<strong>setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了</strong>。</p></li></ul><h3 id="8-Promise与process-nextTick-callback"><a href="#8-Promise与process-nextTick-callback" class="headerlink" title="8. Promise与process.nextTick(callback)"></a>8. Promise与process.nextTick(callback)</h3><ul><li><p>new Promise是会进入到主线程中立刻执行，而promise.then则属于微任务。</p></li><li><p><code>process.nextTick(callback)</code>类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p></li></ul><h3 id="9-事件循环的顺序"><a href="#9-事件循环的顺序" class="headerlink" title="9. 事件循环的顺序"></a>9. 事件循环的顺序</h3><p>事件循环的顺序，决定Js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。</p><ul><li><h4 id="事件循环，宏任务，微任务的关系如图所示："><a href="#事件循环，宏任务，微任务的关系如图所示：" class="headerlink" title="事件循环，宏任务，微任务的关系如图所示："></a>事件循环，宏任务，微任务的关系如图所示：</h4><p><img src="https://img-blog.csdnimg.cn/2020020315511331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a><strong>例子1</strong>：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;console&#x27;</span>);<br></code></pre></td></tr></table></figure><ol><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li><li>遇到<code>console.log()</code>，立即执行。</li><li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</li><li>结束。</li></ol></li><li><h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a><strong>例子2</strong>：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>)<br>    &#125;)<br>&#125;)<br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>    resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>);<br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>);<br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>第一轮事件循环流程分析如下</strong>：</p><ol><li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。<br><img src="https://img-blog.csdnimg.cn/20200203155045497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li><li>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</li><li>执行<code>process1</code>,输出6。</li><li>执行<code>then1</code>，输出8。</li><li>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</li></ol><p><strong>那么第二轮事件循环从<code>setTimeout1</code>宏任务开始：</strong></p><ol><li><p>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。<br><img src="https://img-blog.csdnimg.cn/20200203155009321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</p></li><li><p>输出3。</p></li><li><p>输出5。</p></li><li><p>第二轮事件循环结束，第二轮输出2，4，3，5。</p></li></ol><p><strong>第三轮事件循环开始：</strong></p><ol><li><p>此时只剩setTimeout2了，执行。直接输出9。</p></li><li><p>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</p></li><li><p>直接执行<code>new Promise</code>，输出11。</p></li><li><p>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。<br><img src="https://img-blog.csdnimg.cn/20200203154824999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</p></li><li><p>输出10。</p></li><li><p>输出12。</p></li><li><p>第三轮事件循环结束，第三轮输出9，11，10，12。</p></li></ol></li></ul><p>  <strong>整段代码，共进行了三次事件循环</strong>完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。<br>  (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><h3 id="10-最后"><a href="#10-最后" class="headerlink" title="10. 最后"></a>10. 最后</h3><ul><li><h6 id="事件循环Event-Loop是js实现异步的一种方法，也是js的执行机制。"><a href="#事件循环Event-Loop是js实现异步的一种方法，也是js的执行机制。" class="headerlink" title="事件循环Event Loop是js实现异步的一种方法，也是js的执行机制。"></a>事件循环Event Loop是js实现异步的一种方法，也是js的执行机制。</h6></li><li><h6 id="javascript的执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。"><a href="#javascript的执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。" class="headerlink" title="javascript的执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。"></a>javascript的执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</h6></li><li><h6 id="微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。"><a href="#微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。" class="headerlink" title="微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。"></a>微任务和宏任务还有很多种类，比如<code>setImmediate</code>等等，执行都是有共同点的，有兴趣的同学可以自行了解。</h6></li></ul><p>参考：<a href="https://juejin.im/post/59e85eebf265da430d571f89#heading-9">link</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重学前端》学习笔记(1)</title>
    <link href="/2020/02/01/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2020/02/01/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript类型"><a href="#JavaScript类型" class="headerlink" title="JavaScript类型"></a>JavaScript类型</h1><p><strong>关于前端工程师成长，需要两个视角：</strong></p><ul><li>立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；</li><li>放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。</li></ul><p><strong>两个前端学习方法：</strong></p><ul><li><p>建立知识架构</p><p>是建立自己的知识架构，并且在这个架构上，不断地进行优化。</p></li><li><p>追本溯源，找到知识的源头。</p></li></ul><h2 id="JavaScript类型-1"><a href="#JavaScript类型-1" class="headerlink" title="JavaScript类型"></a>JavaScript类型</h2><p>运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript 代码运行过程中产生的数据，都具有运行时类型。</p><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><p>JavaScript 语言的每一个值都属于某一种数据类型。 JavaScript 语言规定了 7 种语言类型：</p><ul><li>Undefined；</li><li>Null；</li><li>Boolean；</li><li>String；</li><li>Number；</li><li>Symbol；</li><li>Object。</li><li>Undefined、Null</li></ul><h4 id="Undefined-、Null"><a href="#Undefined-、Null" class="headerlink" title="Undefined  、Null"></a>Undefined  、Null</h4><ul><li><p><code>undefined</code>:未定义，如果一个变量只声明但是未赋值，默认值就是undefined</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">var <span class="hljs-keyword">a</span>; <br>console.<span class="hljs-built_in">log</span> ( <span class="hljs-keyword">a</span> )<span class="hljs-comment">;//undefined  变量的值 </span><br>console.<span class="hljs-built_in">log</span> ( typeof  <span class="hljs-keyword">a</span> )<span class="hljs-comment">;//undefined  变量值的数据类型</span><br></code></pre></td></tr></table></figure></li><li><p><code> null</code>：空值 ，null这个值只能手动去设置，一个变量在任何情况下它的值都不会主动是null</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">var b = <span class="hljs-literal">null</span>; <br><span class="hljs-built_in">console</span>.log ( b );//<span class="hljs-literal">null</span> <br><span class="hljs-built_in">console</span>.log ( <span class="hljs-keyword">typeof</span> b );//object  注意：<span class="hljs-literal">null</span>这个数据类型在使用<span class="hljs-keyword">typeof</span>检测的时候得到object　<br></code></pre></td></tr></table></figure></li><li><p>undefined与null的区别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span> ( undefined <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span> );<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-literal">true</span>   它们的值是一样都是没有值得意思 console.<span class="hljs-built_in">log</span> ( undefined <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span> );<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-literal">false</span>    它们的值一样但是数据类型不一样<br></code></pre></td></tr></table></figure></li><li><p>为什么有的编程规范要求用 <code>void 0 </code>代替 <code>undefined</code>？</p><p>因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。</p></li></ul><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>Boolean 类型有两个值，<code> true</code> 和<code>false</code>，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是这个所谓最大长度，并不完全是你理解中的字符数。因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 <code>charAt</code>、<code>charCodeAt</code>、<code>length</code> 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。</p><ul><li>JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。</li><li>JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。</li><li>JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。</li></ul><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ul><li><p>JavaScript 中的 Number 类型有 <code>18437736874454810627</code>(即 <code>2^64-2^53+3</code>) 个值。</p></li><li><p>JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：</p><ul><li><code>NaN</code>，占用了 <code>9007199254740990</code>，这原本是符合 IEEE 规则的数字；</li><li><code>Infinity</code>，无穷大；</li><li><code> -Infinity</code>，负无穷大。</li></ul></li><li><p>JavaScript 中有 <code>+0 </code>和<code> -0</code>，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0的方式，正是检测 <code>1/x</code> 是Infinity 还是 -Infinity。</p></li><li><p>同样根据浮点数的定义，非整数的 Number 类型无法用 <code>==</code>（<code>===</code> 也不行） 来比较，一段著名的代码，这也正是，为什么在 JavaScript 中，<code>0.1+0.2 </code>不能<code> =0.3</code>;的原因。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log( <span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span> == <span class="hljs-number">0</span>.<span class="hljs-number">3</span>); //false<br></code></pre></td></tr></table></figure><p>所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log( Math.abs(<span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span> - <span class="hljs-number">0</span>.<span class="hljs-number">3</span>) &lt;= Number.EPSILON);<br></code></pre></td></tr></table></figure><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 。</p></li></ul><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。</p><p>Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。</p><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p><ul><li><p>JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Symbol</li></ul><p>所以，我们必须认识到 <code>3</code> 与 <code>new Number(3) </code>是完全不同的值，它们一个是 Number 类型， 一个是对象类型</p></li><li><p>Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li>StringToNumber</li><li>NumberToString</li><li>装箱转换</li><li>拆箱转换</li></ul><p>事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了<code> typeof</code> 这样的运算，用来返回操作<br>数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。<br><img src="https://img-blog.csdnimg.cn/20200202203302781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>《重学前端》学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Github远程仓库的基础使用快查</title>
    <link href="/2020/01/31/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%20Github%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%9F%A5/"/>
    <url>/2020/01/31/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%20Github%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-Github远程仓库的基础使用快查"><a href="#Git-Github远程仓库的基础使用快查" class="headerlink" title="Git Github远程仓库的基础使用快查"></a>Git Github远程仓库的基础使用快查</h2><h3 id="1-配置验证信息"><a href="#1-配置验证信息" class="headerlink" title="1. 配置验证信息"></a>1. 配置验证信息</h3><p>由于本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p><ul><li><p>使用以下命令生成 SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>后面的 <a href="mailto:&#x79;&#111;&#x75;&#x72;&#x5f;&#x65;&#x6d;&#x61;&#105;&#108;&#x40;&#x79;&#x6f;&#x75;&#114;&#101;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;">&#x79;&#111;&#x75;&#x72;&#x5f;&#x65;&#x6d;&#x61;&#105;&#108;&#x40;&#x79;&#x6f;&#x75;&#114;&#101;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;</a>改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 <strong>id_rsa.pub</strong>，复制里面的 <strong>key</strong>。</p></li><li><p>回到 Github 上，进入 Account =&gt; Settings（账户配置）后：</p><p>左边选择 <strong>SSH and GPG keys</strong>，然后点击 <strong>New SSH key</strong> 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p></li><li><p>验证是否成功，输入以下命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure></li><li><p>在GitHub点击” New repository “ ，创建一个仓库。比如git-test。</p></li></ul><h3 id="2-添加远程仓库"><a href="#2-添加远程仓库" class="headerlink" title="2. 添加远程仓库"></a>2. 添加远程仓库</h3><ul><li><p>添加一个新的远程 Git 仓库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git remote <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;shortname&gt;</span> <span class="hljs-symbol">&lt;url&gt;</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>tianqixin/git-test.git<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-查看远程仓库"><a href="#3-查看远程仓库" class="headerlink" title="3. 查看远程仓库"></a>3. 查看远程仓库</h3><ul><li><p>查看已经配置的远程仓库服务器：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote</span><br></code></pre></td></tr></table></figure></li><li><p>可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-从远程仓库中抓取与拉取"><a href="#4-从远程仓库中抓取与拉取" class="headerlink" title="4. 从远程仓库中抓取与拉取"></a>4. 从远程仓库中抓取与拉取</h3><ul><li><p>从远程仓库中获得数据，可以执行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git fetch &lt;remote-name&gt;</span><br></code></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p></li></ul><h3 id="5-推送到远程仓库"><a href="#5-推送到远程仓库" class="headerlink" title="5. 推送到远程仓库"></a>5. 推送到远程仓库</h3><ul><li><p>当你想分享你的项目时，必须将其推送到上游：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ git push &lt;remote-<span class="hljs-built_in">name</span>&gt; &lt;branch-<span class="hljs-built_in">name</span>&gt;<br></code></pre></td></tr></table></figure><p>比如：当你想要将 master 分支推送到 <code>origin</code> 服务器时，那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin master</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-查看某个远程仓库"><a href="#6-查看某个远程仓库" class="headerlink" title="6. 查看某个远程仓库"></a>6. 查看某个远程仓库</h3><ul><li><p>如果想要查看某一个远程仓库的更多信息，可以使用：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git remote <span class="hljs-keyword">show</span> &lt;remote-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote show origin</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="7-远程仓库的移除与重命名"><a href="#7-远程仓库的移除与重命名" class="headerlink" title="7. 远程仓库的移除与重命名"></a>7. 远程仓库的移除与重命名</h3><ul><li><p>如果想要重命名引用的名字可以运行:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">git remote <span class="hljs-built_in">rename</span> <br></code></pre></td></tr></table></figure><p>例如：想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote rename pb paul</span><br></code></pre></td></tr></table></figure></li><li><p>移除一个远程仓库：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> paul<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目开发常用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Router学习笔记</title>
    <link href="/2020/01/30/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%20Router%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/01/30/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%20Router%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-Router-学习笔记"><a href="#Vue-Router-学习笔记" class="headerlink" title="Vue Router 学习笔记"></a>Vue Router 学习笔记</h2><h3 id="1-lt-router-view-gt-lt-router-view-gt"><a href="#1-lt-router-view-gt-lt-router-view-gt" class="headerlink" title="1. &lt;router-view&gt;&lt;/router-view&gt;:"></a>1. <strong><code>&lt;router-view&gt;&lt;/router-view&gt;</code></strong>:</h3><p>Vue Router提供<code>&lt;router-view&gt;&lt;/router-view&gt;</code>来做 路由出口，渲染路径匹配到的视图组件。</p><p><code>&lt;router-view&gt;</code> 渲染的组件还可以内嵌自己的 <code>&lt;router-view&gt;</code>，根据嵌套路径，渲染嵌套组件。</p><p>App.vue中：</p><p><code> &lt;router-view/&gt;</code></p><p>路由文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/movieDetail&#x27;</span>,<br>    <span class="hljs-attr">component</span>:MovieDetail<br>  &#125;,<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-命名视图"><a href="#2-命名视图" class="headerlink" title="2. 命名视图"></a>2. 命名视图</h3><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view two&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view three&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-attr">default</span>: Foo,<br>        <span class="hljs-attr">a</span>: Bar,<br>        <span class="hljs-attr">b</span>: Baz<br>      &#125;<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>​    <strong>嵌套命名视图</strong>：</p><p>​    我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 <code>router-view</code> 组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- UserSettings.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>User Settings<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;helper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/settings&#x27;</span>,<br>  <span class="hljs-comment">// 你也可以在顶级路由就配置命名视图</span><br>  <span class="hljs-attr">component</span>: UserSettings,<br>  <span class="hljs-attr">children</span>: [&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;emails&#x27;</span>,<br>    <span class="hljs-attr">component</span>: UserEmailsSubscriptions<br>  &#125;, &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,<br>    <span class="hljs-attr">components</span>: &#123;<br>      <span class="hljs-attr">default</span>: UserProfile,<br>      <span class="hljs-attr">helper</span>: UserProfilePreview<br>    &#125;<br>  &#125;]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-this-router"><a href="#3-this-router" class="headerlink" title="3. this.$router :"></a>3. <strong><code>this.$router</code></strong> :</h3><p>通过<code>this,$router</code>访问路由器，或访问当前路由。</p><ul><li><p><code>$route.path</code></p><ul><li><p>类型: <code>string</code></p><p>字符串，对应当前路由的路径，总是解析为绝对路径，如 <code>&quot;/foo/bar&quot;</code>。</p></li></ul></li><li><p><code>$route.params</code></p><ul><li><p>类型: <code>Object</code></p><p>一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。</p></li></ul><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>/user/:username</td><td>/user/evan</td><td><code>&#123; username: &#39;evan&#39; &#125;</code></td></tr><tr><td>/user/:username/post/:post_id</td><td>/user/evan/post/123</td><td><code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></td></tr></tbody></table></li><li><p><code>$route.query</code></p><ul><li><p>类型: <code>Object</code></p><p>一个 key/value 对象，表示 URL 查询参数。例如，对于路径 <code>/foo?user=1</code>，则有 <code>$route.query.user == 1</code>，如果没有查询参数，则是个空对象。</p></li></ul></li><li><p><code>$route.hash</code></p><ul><li><p>类型: <code>string</code></p><p>当前路由的 hash 值 (带 <code>#</code>) ，如果没有 hash 值，则为空字符串。</p></li></ul></li><li><p><code>$route.name</code></p><p>当前路由的名称，如果有的话。</p></li></ul><h3 id="4-命名路由："><a href="#4-命名路由：" class="headerlink" title="4.命名路由："></a>4.命名路由：</h3><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:userId&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>      <span class="hljs-attr">component</span>: User<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>要链接到一个命名路由，可以给 <code>router-link</code> 的 <code>to</code> 属性传一个对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这跟代码调用 <code>router.push()</code> 是一回事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-number">123</span> &#125;&#125;)<br></code></pre></td></tr></table></figure><p>这两种方式都会把路由导航到 <code>/user/123</code> 路径。</p><h3 id="5-lt-router-link-gt-lt-router-link-gt"><a href="#5-lt-router-link-gt-lt-router-link-gt" class="headerlink" title="5. &lt;router-link&gt;&lt;/router-link&gt;:"></a>5. <code>&lt;router-link&gt;&lt;/router-link&gt;</code>:</h3><p>Vue Router提供<code>&lt;router-link&gt;&lt;/router-link&gt;</code>来导航。</p><p>该组件通过传入 ‘ to ’ 属性指定目标地址，该组件默认会被渲染成一个<code>&lt;a&gt;</code>标签。</p><p>其中：</p><ul><li><p><code>to</code>属性：其值表示目标路由的链接。当被点击后，内部会立刻把 <code>to</code> 的值传到 <code>router.push()</code>，所以这个值可以是一个字符串或者是描述目标位置的对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 字符串 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 渲染结果 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">v-bind:to</span>=<span class="hljs-string">&quot;&#x27;home&#x27;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;home&#x27;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 同上 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;home&#x27; &#125;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 命名的路由 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;&quot;</span></span><br><span class="hljs-tag">  &gt;</span>Register&lt;/router-link<br>&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>replace</code>：</p><p>设置 <code>replace</code> 属性的话，当点击时，会调用 <code>router.replace()</code> 而不是 <code>router.push()</code>，于是导航后不会留下 history 记录。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/abc&#x27;&#125;&quot;</span> <span class="hljs-attr">replace</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-嵌套路由："><a href="#6-嵌套路由：" class="headerlink" title="6.嵌套路由："></a>6.<strong>嵌套路由：</strong></h3><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。</p><p>App.vue:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的 <code>&lt;router-view&gt;</code> 是最顶层的出口，渲染最高级路由匹配到的组件。</p><p>同样地，一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code>。例如，在 <code>User</code> 组件的模板添加一个 <code>&lt;router-view&gt;</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> User = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div class=&quot;user&quot;&gt;</span><br><span class="hljs-string">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>要在嵌套的出口中渲染组件，需要在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: User,<br>      <span class="hljs-attr">children</span>: [<br>        &#123;<br>          <span class="hljs-comment">// 当 /user/:id/profile 匹配成功，</span><br>          <span class="hljs-comment">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span><br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,<br>          <span class="hljs-attr">component</span>: UserProfile<br>        &#125;,<br>        &#123;<br>          <span class="hljs-comment">// 当 /user/:id/posts 匹配成功</span><br>          <span class="hljs-comment">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span><br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;posts&#x27;</span>,<br>          <span class="hljs-attr">component</span>: UserPosts<br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。</strong></p><h3 id="7-路由组件传参"><a href="#7-路由组件传参" class="headerlink" title="7. 路由组件传参"></a>7. 路由组件传参</h3><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p><p>使用 <code>props</code> 将组件和路由解耦：</p><p><strong>取代与 $route 的耦合</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> User = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: User &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>通过 props 解耦</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> User = &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;id&#x27;</span>],<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: User, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> &#125;,<br><br>    <span class="hljs-comment">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>      <span class="hljs-attr">components</span>: &#123; <span class="hljs-attr">default</span>: User, <span class="hljs-attr">sidebar</span>: Sidebar &#125;,<br>      <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sidebar</span>: <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="8-编程式路由："><a href="#8-编程式路由：" class="headerlink" title="8. 编程式路由："></a>8. 编程式路由：</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><ul><li><p><strong><code>router.push(location, onComplete?, onAbort?)</code></strong></p><p>在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。</p><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串</span><br>router.push(<span class="hljs-string">&#x27;home&#x27;</span>)<br><br><span class="hljs-comment">// 对象</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br><br><span class="hljs-comment">// 带查询参数，变成 /register?plan=private</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)<br></code></pre></td></tr></table></figure><p><strong>如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userId = <span class="hljs-string">&#x27;123&#x27;</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user/123</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/123</span><br><span class="hljs-comment">// 这里的 params 不生效</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user</span><br></code></pre></td></tr></table></figure><p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p></li><li><p><strong><code>router.replace(location, onComplete?, onAbort?)</code></strong></p><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td><td><code>router.replace(...)</code></td></tr></tbody></table></li><li><p><strong><code>router.go(n) </code></strong>:</p><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在浏览器记录中前进一步，等同于 history.forward()</span><br>router.go(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 后退一步记录，等同于 history.back()</span><br>router.go(-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 前进 3 步记录</span><br>router.go(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 如果 history 记录不够用，那就默默地失败呗</span><br>router.go(-<span class="hljs-number">100</span>)<br>router.go(<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零碎前端基础知识笔记</title>
    <link href="/2020/01/17/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E9%9B%B6%E7%A2%8E%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/01/17/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E9%9B%B6%E7%A2%8E%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li><p><strong>HTML</strong>：超文本标记语言，是一种用于创建网页的标准标记语言。</p><p><em>对于中文网页需要使用</em> <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> <em>声明编码，否则会出现乱码。有些浏览器(如 360 浏览器)会设置 GBK 为默认编码，则你需要设置为</em> <code>&lt;meta charset=&quot;gbk&quot;&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>HTML链接：</strong></p><ol><li><p>使用 <code>target</code> 属性，你可以定义被链接的文档在何处显示。</p><p>下面的这行会在新窗口打开文档：</p></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://www.runoob.com/&quot;</span> <span class="hljs-attribute">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;noopener noreferrer&quot;</span>&gt;访问菜鸟教程!&lt;/a&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>在HTML文档中插入ID:<code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code></p><p>在HTML文档中创建一个链接到”有用的提示部分(<code>id=&quot;tips&quot;</code>）”：<code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p><p>或者，从另一个页面创建一个链接到”有用的提示部分(<code>id=&quot;tips&quot;</code>）”：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.runoob.com/html/html-links.html#tips&quot;</span>&gt;</span>访问有用的提示部分<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>HTML<code>&lt;head&gt;</code>:</strong></p><ol><li><p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。</p><p>可以添加在头部区域的元素标签为: <code>&lt;title&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;noscript&gt;</code>, and <code>&lt;base&gt;</code>.</p></li><li><p><code>&lt;title&gt;</code> 标签定义了不同文档的标题。</p></li><li><p><code>&lt;link&gt;</code> 标签定义了文档与外部资源之间的关系。通常用于链接到样式表.</p></li><li><p>meta标签描述了一些基本的元数据。</p></li><li><p><code>&lt;meta&gt;</code> 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。</p><p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p><p><code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p><p>为搜索引擎定义关键词:<code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</code></p><p>为网页定义描述内容:<code>&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</code></p><p>定义网页作者:<code>&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</code></p><p>每30秒钟刷新当前页面:<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></p></li><li><p>HTML5 中 <code>&lt;title&gt; </code>元素是必须的，标题名描述了页面的主题</p></li></ol></li></ul><ul><li><p><strong>HTML样式：</strong></p><p> CSS 可以通过以下方式添加到HTML中:</p><ol><li><p>内联样式- 在HTML元素中使用”style” <strong>属性</strong></p></li><li><p>内部样式表 -在HTML文档头部 <code>&lt;head&gt; </code>区域使用<code>&lt;style&gt; </code><strong>元素</strong> 来包含CSS</p></li><li><p>外部引用 - 使用外部 CSS <strong>文件</strong></p><p>最好的方式是通过外部引用CSS文件</p></li></ol></li></ul><ul><li><p><strong>HTML图片：</strong></p><ol><li><p><code>&lt;img src=&quot;url&quot; alt=&quot;some_text&quot;&gt;</code></p><p>src 指 “source”，源属性。源属性的值是图像的 URL 地址,URL 指存储图像的位置。</p><p>alt 属性用来为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。</p></li><li><p><code>&lt;img src=&quot;pulpit.jpg&quot; alt=&quot;Pulpit rock&quot; width=&quot;304&quot; height=&quot;228&quot;&gt;</code></p><p>height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。</p></li></ol></li></ul><ul><li><p><strong>HTML表单和输入：</strong></p><p>表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列  表、单选框(radio-buttons)、复选框(checkboxes)等等。</p><p>表单使用表单标签 <code>&lt;form&gt;</code> 来设置:<code>&lt;form&gt;.input 元素.&lt;/form&gt;</code></p><ol><li><p>文本域通过<code>&lt;input type=&quot;text&quot;&gt; </code>标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p></li><li><p>密码字段通过标签<code>&lt;input type=&quot;password&quot;&gt;</code> 来定义,密码字段字符不会明文显示，而是以星号或圆点替代。</p></li><li><p>表单单选框选项通过<code>&lt;input type=&quot;radio&quot;&gt;</code>来定义，<code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;</code></p></li><li><p>复选框通过<code>&lt;input type=&quot;checkbox&quot;&gt; </code>定义：<code>&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;  checked&gt;</code></p></li><li><p>提交按钮通过<code>&lt;input type=&quot;submit&quot;&gt; </code>定义：<code>&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</code></p></li><li><p>下拉列表：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> <span class="hljs-type">name</span>=&quot;cars&quot;&gt;<br>&lt;<span class="hljs-keyword">option</span> <span class="hljs-keyword">value</span>=&quot;volvo&quot;&gt;Volvo&lt;/<span class="hljs-keyword">option</span>&gt;<br>&lt;<span class="hljs-keyword">option</span> <span class="hljs-keyword">value</span>=&quot;saab&quot; selected&gt;Saab&lt;/<span class="hljs-keyword">option</span>&gt;<br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>多行输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><br>我是一个文本框。<br><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>按钮：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;Hello&quot;</span>&gt;` 或`&lt;button <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;点我!&lt;/button&gt;<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>XHTML</strong>是以 XML 格式编写的 HTML。</p><p>XHTML 指的是可扩展超文本标记语言，XHTML 是更严格更纯净的 HTML 版本。XML 是一种必须正确标记且格式良好的标记语言。</p></li></ul><ul><li><p><strong>HTML Canvas</strong></p><p>HTML5 <code>&lt;canvas&gt; </code>元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.</p><p><code>&lt;canvas&gt; </code>标签只是图形容器，元素本身是没有绘图能力,您必须使用脚本来绘制图形。</p><p>你可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。</p></li></ul><ul><li><p><strong>SVG</strong></p><ol><li><p>什么是SVG：</p><p>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</p><p>SVG 用于定义用于网络的基于矢量的图形</p><p>SVG 使用 XML 格式定义图形</p><p>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</p><p>SVG 是万维网联盟的标准</p></li><li><p>SVG 的优势：</p><p>SVG 图像可通过文本编辑器来创建和修改</p><p>SVG 图像可被搜索、索引、脚本化或压缩</p><p>SVG 是可伸缩的</p><p>SVG 图像可在任何的分辨率下被高质量地打印</p><p>SVG 可在图像质量不下降的情况下被放大</p></li><li><p>SVG与Canvas两者间区别：</p><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p><p>Canvas 通过 JavaScript 来绘制 2D 图形。</p><p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p></li><li><p>Canvas与SVG的比较：</p></li></ol></li></ul><table><thead><tr><th align="left">Canvas</th><th align="right">SVG</th></tr></thead><tbody><tr><td align="left">依赖分辨率不支持事件处理器弱的文本渲染能力能够以 .png 或 .jpg 格式保存结果图像最适合图像密集型的游戏，其中的许多对象会被频繁重绘</td><td align="right">不依赖分辨率支持事件处理器最适合带有大型渲染区域的应用程序（比如谷歌地图）复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）不适合游戏应用</td></tr></tbody></table><ul><li><p><strong>HTML应用程序缓存：</strong></p><p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。</p><p>应用程序缓存为应用带来三个优势：</p><ol><li><p>离线浏览 - 用户可在应用离线时使用它们</p></li><li><p>速度 - 已缓存资源加载得更快减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</p></li></ol></li></ul><ul><li><p><strong>HTML  Web  Workers：</strong></p><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p><p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p><strong>CSS</strong></p><p>CSS 指层叠样式表 (Cascading Style Sheets)</p><p>样式定义<strong>如何显示</strong> HTML 元素</p><p>样式通常存储在<strong>样式表</strong>中</p><p>CSS注释以 “/<em>“ 开始, 以 “</em>/“ 结束: /<em>这是个注释</em>/</p></li></ul><ul><li><p><strong>插入样式表</strong>的方法有三种:</p><p>外部样式表(External style sheet)</p><p>内部样式表(Internal style sheet)</p><p>内联样式(Inline style)</p><p>优先级如下：</p><p>( 内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</p></li></ul><ul><li>不要在属性值与单位之间留有空格（如：<code>&quot;margin-left: 20 px&quot;</code> ），正确的写法是<code> &quot;margin-left: 20px&quot;</code></li></ul><ul><li><p>为了避免Internet Explorer 中无法调整文本的问题，许多开发者使用 em 单位代替像素。</p><p>em的尺寸单位由W3C建议。</p><p>1em和当前字体大小相等。在浏览器中默认的文字大小是16px。</p><p>因此，1em的默认大小是16px。可以通过下面这个公式将像素转换为em：<strong>px/16=em</strong></p></li></ul><ul><li><p><strong>嵌套选择器：</strong></p><p><strong><code>.marked p&#123; &#125;</code></strong>: 为所有 <code>class=&quot;marked&quot;</code> 元素内的 <strong>p</strong> 元素指定一个样式。</p><p><strong><code>p.marked&#123; &#125;</code></strong>: 为所有 <code>class=&quot;marked&quot;</code> 的 <strong>p</strong> 元素指定一个样式。</p></li></ul><ul><li><p>隐藏一个元素可以通过把<code>display</code>属性设置为<code>&quot;none&quot;</code>，或把<code>visibility</code>属性设置为<code>&quot;hidden&quot;</code>。</p><p>但这两种方法会产生不同的结果：</p><p>​    <code>visibility:hidden</code>可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。</p><p>​    <code>display:none</code>可以隐藏某个元素，且隐藏的元素不会占用任何空间。</p></li></ul><ul><li><p><strong>CSS Position</strong>：</p><ol><li><p><code>static </code>     ：HTML 元素的默认值，即没有定位，遵循正常的文档流对象。静态定位的元素不会受到 top, bottom, left, right影响。</p></li><li><p><code>fixed </code>      ：固定定位元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。Fixed定位的元素和其他元素重叠。</p></li><li><p><code>relative </code> ：相对定位元素的定位是相对其正常位置。移动相对定位元素，但它原本所占的空间不会改变。相对定位元素经常被用来作为绝对定位元素的容器块。</p></li><li><p><code>absolute</code>  ：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>&lt;html&gt;</code>。absolute 定位使元素的位置与文档流无关，因此不占据空间。absolute 定位的元素和其他元素重叠。</p></li><li><p><code>sticky</code>  ：粘性定位的元素是依赖于用户的滚动。在<code> position:relative</code> 与 <code>position:fixed </code>定位之间切换。</p><p>它的行为就像 <code>position:relative;</code>而当页面滚动超出目标区域时，它的表现就像<code>position:fixed;</code>它会固定在目标位置。</p><p>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p><p>这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p></li></ol></li></ul><ul><li><p><strong>CSS组合选择符</strong>：</p><p>在 CSS3 中包含了四种组合方式:</p><ol><li><p>后代选择器(以空格分隔)</p></li><li><p>子元素选择器(以大于号分隔）</p></li><li><p>相邻兄弟选择器（以加号分隔）</p></li><li><p>普通兄弟选择器（以破折号分隔）</p><p>其中：</p><p>后代选择器 用于选取某元素的后代元素。<code>div p&#123;&#125;</code></p><p>子元素选择器  只能选择作为某元素子元素的元素。<code>div&gt;p&#123;&#125;</code></p><p>相邻兄弟选择器  可选择紧接在另一元素后的元素，且二者有相同父元素。  <code>div+p&#123;&#125;</code>:选取了所有位于 <code>&lt;div&gt; </code>元素后的第一个 <code>&lt;p&gt; </code>元素</p><p>后续兄弟选择器  选取所有指定元素之后的相邻兄弟元素。<code>div~p&#123;&#125;</code>:选取了所有<code>&lt;div&gt;</code>元素之后的所有相邻兄弟元素 <code>&lt;p&gt;</code></p></li></ol></li></ul><ul><li><code>text-decoration: none;</code>可以清除<code>&lt;a&gt;</code>自带的字体颜色</li></ul><ul><li>导航栏一般用<code>&lt;ul&gt;</code>, <code>&lt;li&gt;</code>实现</li></ul><ul><li><p>当鼠标移动到指定元素上时，会出现下拉菜单。当鼠标指针在类名为dropown的元素上时，类名为dropdown-content的元素会显示，切类名为droptn的元素背景色会改变。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.dropdown-content</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <br><span class="hljs-selector-class">.dropdown</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.dropdown-content</span> &#123;<br>    <span class="hljs-attribute">display</span>: block;<br>&#125; <br><br><span class="hljs-selector-class">.dropdown</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.dropbtn</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3e8e41</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>小三角的实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.tooltiptext</span><span class="hljs-selector-pseudo">::after</span> &#123;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 提示工具底部 */</span><br><span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">5px</span>;<br><span class="hljs-attribute">border-width</span>: <span class="hljs-number">5px</span>;<br><span class="hljs-attribute">border-style</span>: solid;<br><span class="hljs-attribute">border-color</span>: black transparent transparent transparent;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>网页布局有很多种方式，一般分为以下几个部分：<strong>头部区域、菜单导航区域、内容区域、底部区域</strong>。</p></li></ul><ul><li><div class="code-wrapper"><pre><code class="hljs">ul.pagination li a:hover:not(.active) &#123;background-color: #ddd;&#125;`&lt;ul class=&quot;pagination&quot;&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;«&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;6&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;7&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;»&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs autohotkey"><br><br><br>* 为了让开发的网站对移动设备友好，确保适当的绘制和触屏缩放，需要在网页的 `head` 之中添加 `viewport meta `标签，如下所示：<br><br></code></pre></td></tr></table></figure>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;width=device-width  表示宽度是设备屏幕的宽度。initial-scale=1  表示初始的缩放比例。shrink-to-fit=no  自动适应手机屏幕的宽度。</code></pre></li></ul><h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h2><ul><li><p>DOM 是 W3C（万维网联盟）的标准。</p><p>DOM 定义了访问 HTML 和 XML 文档的标准：</p><p>“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”</p></li></ul><ul><li><p><strong>HTML DOM</strong> 是：</p><ol><li><p>HTML 的标准对象模型</p></li><li><p>HTML 的标准编程接口</p></li><li><p>W3C 标准</p></li></ol><p>HTML DOM 定义了所有 HTML 元素的<em>对象</em>和<em>属性</em>，以及访问它们的<em>方法</em>。</p><p><em>换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。</em></p></li></ul><ul><li><p><strong>DOM节点</strong></p><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：</p><ol><li><p>整个文档是一个文档节点</p></li><li><p>每个 HTML 元素是元素节点</p></li><li><p>HTML 元素内的文本是文本节点</p></li><li><p>每个 HTML 属性是属性节点</p></li><li><p>注释是注释节点</p></li></ol></li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ul><li><p><strong>AJAX</strong>：</p><ol><li><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。</p></li><li><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p></li><li><p>AJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。</p></li><li><p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p></li><li><p>AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p></li></ol></li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul><li><p><strong>JSON</strong>：</p><ol><li><p>JSON: <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation(JavaScript 对象表示法)</p></li><li><p>JSON 是存储和交换文本信息的语法。类似 XML。</p></li><li><p>JSON 比 XML 更小、更快，更易解析。</p></li><li><p>JSON 指的是 JavaScript 对象表示法（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）</p></li><li><p>JSON 是轻量级的文本数据交换格式</p></li><li><p>JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</p></li><li><p>JSON 具有自我描述性，更易理解</p></li></ol></li></ul><ul><li>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术知识归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《现代前端技术解析》阅读笔记</title>
    <link href="/2020/01/06/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E3%80%8A%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/01/06/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E3%80%8A%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="《现代前端技术解析》阅读笔记"><a href="#《现代前端技术解析》阅读笔记" class="headerlink" title="《现代前端技术解析》阅读笔记"></a>《现代前端技术解析》阅读笔记</h1><h2 id="第一章-Web前端技术基础"><a href="#第一章-Web前端技术基础" class="headerlink" title="第一章  Web前端技术基础"></a>第一章  Web前端技术基础</h2><p><strong>思考一些问题：</strong> </p><ol><li><p>页面内容多而复杂，怎样保证开发效率？<br>需要借助符合特定场合的前端框架来提高效率。</p></li><li><p>页面内容多且复杂，项目管理和维护该如何去做？<br>考虑用模块化和组件化的思路管理，所谓模块化和组件化是指采用代码管理中分治的思想，将复杂的代码拆分成多个独立，简单，解耦合的结构或文件分开管理，使项目结构更加清晰。</p></li><li><p>页面加载内容很多，怎样保证尽快将网页内容显示给用户？<br>通过异步的方式来实现，即将一部分内容先展示给用户，然后根据用户的操作，异步加载用户需要的其他内容，避免用户长时间等待。</p></li><li><p>怎样限制页面内图片的大小以保证页面快速展示？<br>需要考虑图片的优化处理。</p></li><li><p>对于重复打开的页面，能否让浏览器不再向服务器重复请求的内容呢？<br>合理的文件缓存就能做到这一点，这样可以大幅度提高网页资源的加载速度。</p><p><strong>以上问题，涉及了前端开发框架，模块化和组件化开发，资源异步加载，响应式站点开发，缓存和前端优化等多个方面。</strong></p></li></ol><p><strong>前端应用开发模式演变：</strong></p><ol><li>静态黄页</li><li>服务器组装动态网页数据</li><li>后端为主的MVC</li><li>前后端分离</li><li>纯前端MV*为主，中间层直出</li><li>前端Virtual DOM，MNV*，前后端同构</li></ol><h3 id="1-2-浏览器应用基础"><a href="#1-2-浏览器应用基础" class="headerlink" title="1.2 浏览器应用基础"></a>1.2 浏览器应用基础</h3><h4 id="1-2-1-浏览器组成结构"><a href="#1-2-1-浏览器组成结构" class="headerlink" title="1.2.1 浏览器组成结构"></a>1.2.1 浏览器组成结构</h4><p><strong>1. 打开浏览器输入一个网址后：</strong></p><ol><li>在接收到用户输入的网址后， 浏览器会开启一个线程来处理这个请求，对用户输入的URL地址进行分析判断，如果是HTTP协议就按照HTTP方式来处理。</li><li>调用浏览器引擎中的对应方法，分析并加载这个URL地址。</li><li>通过DNS解析获取该网站地址对应的IP 地址，查询完成后连同浏览器的Cookis，userAgent等信息向网站目的IP发出GET请求。</li><li>进行 HTTP协议会话，浏览器客户端向Web服务器发送报文。</li><li>进入网站后台上的Web 服务器处理请求，如Apache Tomcat. Nodejs等服务器。</li><li>进入部署好的后端应用， 如PHP、Java， JavaScript， Python 等后端程序，找到对应请求处理逻辑，这期间可能会读取服务器级存或查询数据库等。</li><li>服务器处理请求并返回响应报文， 此时如果浏览器访问过该页面，缓存上有对应资源，会与服务器最后修改记录对比，一致则返回304,否则返回!200和对应的内容。</li><li>浏览器开始下载 HTML文档(响应报头状态码为200时) 或者从本地缓有更存读取文件 (浏览器缓存有效或响应报头状态码为304时)。  </li><li>浏览器根据下载接收到的HTML文件解析结构建立DOM 文档树，井根据HTML中的标记请求下载指定的MIME类型文件(如CSS、JavaScript 脚本等)，同时设置缓存等内容。</li><li>页面开始解析谊染 DOM, CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染，JavaScript 根据DOM API 操作DOM，并读取浏览器缓存、执行事件绑定等，页面整个展示过程完成。</li></ol><p><strong>2. 浏览器组成部分：</strong></p><ol><li>用户界面</li><li>网络</li><li>JavaScript引擎</li><li><strong>渲染引擎</strong></li><li>UI后端</li><li>JavaScript解释器</li><li>持久化数据存储</li></ol><h4 id="1-2-2-浏览器渲染引擎简介"><a href="#1-2-2-浏览器渲染引擎简介" class="headerlink" title="1.2.2 浏览器渲染引擎简介"></a>1.2.2 浏览器渲染引擎简介</h4><p>浏览器渲染引擎（浏览器内核）的主要用于解析HTML文档和CSS文档，然后将CSS规则运用到HTML标签元素上并将HTML渲染到浏览器窗口中以展示具体DOM内容。</p><p><strong>工作流程:</strong></p><ol><li>解析HTML构建DOM树</li><li>构建渲染树</li><li>渲染树布局阶段</li><li>绘制渲染树</li></ol><h4 id="1-2-3-浏览器数据持久化存储技术"><a href="#1-2-3-浏览器数据持久化存储技术" class="headerlink" title="1.2.3 浏览器数据持久化存储技术"></a>1.2.3 浏览器数据持久化存储技术</h4><p>这里所说的数据持久化存储主要是针对浏览器的，所以我们统称为浏览器缓存(Browser Caching)，浏览器缓存是浏览器端用于在本地保存数据并进行快速读取以避免重复资源请求的传输机制的统称。有效的缓存可以避免重复的网络资源请求并让浏览器快速地响应用户操作，提高页面内容的加载速度。</p><p>浏览器端缓存的实现机制种类较多，一般可以分为九种</p><ol><li><p><strong>HTTP文件缓存</strong>：</p><p> 是基于HTTP协议的浏览器文件缓存机制。在文件重复请求的情况下，浏览器可以根据HTTP响应的协议头判断是从服务器请求文件还是从本地读取文件。</p></li></ol><p>流程：<br><img src="https://img-blog.csdnimg.cn/20200105211453932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><p><strong>localStorage</strong>：</p><p>是一种HTML5的一种本地缓存方案。主要用于浏览器端保存体积较大的数据（如Ajax返回结果等）。localStorage在不同浏览器的长度限制各不相同。将数据保存在客户端本地硬件设备上，即使浏览器被关闭，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p></li><li><p><strong>sessionStorage</strong>：</p><p>和localStorage功能类似，但是其将数据保存在session对象中，（所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭经过的这段时间。session对象可以用来保存这段时间内要求保存的任何数据）sessionStorage在浏览器关闭时会自动清空。</p></li><li><p><strong>Cookie</strong>：</p><p>指网站为了辨别用户身份或者Session跟踪而存储在用户浏览器端的数据。Cookie信息一般会通过HTTP发送到服务器端。Cookie分两种：Session Cookie 和持久型Cookie。</p></li><li><p><strong>WebSQL</strong>：</p><p>浏览器端用于存储大量数据的缓存机制。</p></li><li><p><strong>IndexDB</strong>：</p><p>也是一个可在客户端存储大量结构化数据并且这些数据上使用索引进行高性能检索的一套API。由于WebSQL不是HTML5规范，很多浏览器不兼容，一般推荐使用IndexDB进行大量数据存储。</p></li><li><p><strong>CacheStorage</strong></p></li><li><p><strong>Application Cache</strong></p></li><li><p><strong>Flash 缓存方式</strong></p></li></ol><h2 id="第二章-前端与协议"><a href="#第二章-前端与协议" class="headerlink" title="第二章 前端与协议"></a>第二章 前端与协议</h2><p> 浏览器上解析执行的HTML、CSS和JavaScript文件通常是通过网络请求从Web服务器上下载解析的，加载过程中，浏览器通过网络模块创建下载进程，发起HTTP请求，将HTML文本、CSS 样式或JavaScript脚本装载进浏览器解析或运行。这里就涉及了一些相关的网络协议，我们可以认为与前端关系最密切的协议是HTTP协议，因为几乎所有的前端相关资源文件均是通过HTTP协议请求完成的。前端Web应用的发展加速了前后端技术的分离，这种开发模式降低了前端与服务端的耦合，但是前端和服务端之间的交互数据通信仍是通过协议来完成的，这里的协议可以认为是前后端开发者之间主观协商形成的一层数据接口规范。当然，还有基于SSL (Secure Sockets Layer,安全套接字层)层的HTTPS协议。进入移动互联网时代后，移动端Web脚本开始需要与移动端原生程序进行交互，这便涉及与移动端Native原生程序交互的协议。除了这些还有HTML5的WebSocket实时通信协议、与服务端交互的RESTful协议等。</p><h3 id="2-1-HTTP协议简介"><a href="#2-1-HTTP协议简介" class="headerlink" title="2.1 HTTP协议简介"></a>2.1 HTTP协议简介</h3><h4 id="2-1-1-HTTP协议概述"><a href="#2-1-1-HTTP协议概述" class="headerlink" title="2.1.1 HTTP协议概述"></a>2.1.1 HTTP协议概述</h4><p>HTTP（超文本传输协议）协议是www服务器和用户请求代理之间通过请求模式传输超文本内容的一种协议。</p><p><strong>HTTP请求头部结构</strong>：<br><img src="https://img-blog.csdnimg.cn/20200105211646780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>HTTP协议响应头</strong>：<br><img src="https://img-blog.csdnimg.cn/2020010521170894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>HTTP报文的头部域字段的设置</strong>：<br><img src="https://img-blog.csdnimg.cn/20200105211927585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200105211942454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020010521201331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200105212026981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200105212046558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200105212114126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-2-Web安全机制"><a href="#2-2-Web安全机制" class="headerlink" title="2.2 Web安全机制"></a>2.2 Web安全机制</h3><h4 id="2-1-1-基础安全知识"><a href="#2-1-1-基础安全知识" class="headerlink" title="2.1.1 基础安全知识"></a>2.1.1 基础安全知识</h4><p>XSS（跨站脚本攻击），SQL（结构化查询语言）注入，CSRF（跨站请求伪造）均属于基础的前端安全知识。</p><p><strong>XSS</strong>：通常是由带有页面可解析内容的数据未经处理直接到页面上解析导致的。</p><p>需要注意，XSS分为 存储型XSS，反射性XSS，MXSS三种。这里区分不同类型主要是根据攻击脚本的引入位置。</p><p>存储型XSS的攻击脚本常常是由前端提交的数据未经处理直接存储到数据库中读取出来后有直接插入到页面所导致的。</p><p>反射型XSS可能是在网页URL参数中注入了课解析内容的数据导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击。</p><p>MXSS则是在渲染DOM属性时将脚本插入DOM属性中被解析而导致的。</p><p>XSS主要的防范方法是验证输入到页面上所有内容来源数据是否安全，如果可能含有脚本标签等内容则需要进行必要的转义。</p><p><strong>SQL</strong>：主要是因为页面提交数据到服务器端后，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因为产生执行与预期不同的现象。</p><p>SQL主要防范措施是对前端网页提交的数据内容进行严格的检查效验。</p><p><strong>CSRF</strong>：是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。非源站点在取得用户登录验证信息的情况下，可以直接对源站点的某个数据接口进行提交，如果源站点对该提交请求的数据来源未经验证，该请求可能被成功执行，这其实并不合理。</p><p>通常比较安全的是通过页面Token（令牌）提交验证的方式来验证请求是否为源站点页面提交的，来阻止伪请求的发生。</p><p>CSRL攻击原理图：</p><p><img src="https://img-blog.csdnimg.cn/20200105212226960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>CSRF预防机制：</p><p><img src="https://img-blog.csdnimg.cn/20200105212233800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-2-2-请求劫持与HTTPS"><a href="#2-2-2-请求劫持与HTTPS" class="headerlink" title="2.2.2 请求劫持与HTTPS"></a>2.2.2 请求劫持与HTTPS</h4><p>除了正常的前后端脚本安全问题，网络请求劫持的发生也越来越频繁。网络劫持一般指网站资源请求在请求过程中因为人为的攻击导致没有加载到预期的资源内容。</p><p>网络劫持目前主要分两种：DNS劫持与HTTP劫持。</p><p><strong>DNS劫持</strong>：</p><p>通常是指攻击者劫持了DNS服务器，通过某些手段取得域名记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，其结果就是让正确的网址不能解析或指向另一个网站IP，实现获取用户资料或者破坏原有网站正常服务的目的。DNS劫持一般通过篡改DNS服务器上的域名解析记录，来返回给用户一个错误的DNS查询结果实现。</p><p>DNS劫持原理：</p><p><img src="https://img-blog.csdnimg.cn/20200105212411931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>HTTP劫持</strong>：</p><p>HTTP劫持是指，在用户浏览器与访问的目的服务器之间所建立的网络数据通道中从网关或防火墙层上监视特定数据信息，当满足一定条件时，就会在正常的数据包中插入或修改成为攻击者设计的网络数据包，目的是让用户浏览器解释“错误”的数据，或者以弹出新窗口的形式在使用者浏览器界面上展示宣传栏广告或者直接显示其他内容。</p><p>HTTP劫持原理：<br><img src="https://img-blog.csdnimg.cn/20200105212419126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-2-3-HTTPS协议通信过程"><a href="#2-2-3-HTTPS协议通信过程" class="headerlink" title="2.2.3 HTTPS协议通信过程"></a>2.2.3 HTTPS协议通信过程</h4><p>HTTPS协议是通过加入SSL层来加密HTTP数据进行安全传输的HTTP协议。同时启用默认的443端口进行数据传输。</p><h3 id="2-3-前端实时协议"><a href="#2-3-前端实时协议" class="headerlink" title="2.3 前端实时协议"></a>2.3 前端实时协议</h3><p>前端浏览器进行实时通信的功能实现方式主要有WebSocket，Poll，Long-poll，DDP协议。</p><h3 id="2-4-RESTful数据协议规范"><a href="#2-4-RESTful数据协议规范" class="headerlink" title="2.4 RESTful数据协议规范"></a>2.4 RESTful数据协议规范</h3><p>REST并不是某一种数据交互调用接口的协议，而是定义了一种网络应用软件之间的架构关系，并提出了一套与之对应的网络之间交互调用的规则。</p><p>在REST形式的软件应用服务中。每个资源都有一个与之对应的URL地址，资源本身都有方法调用的目标。</p><p>RESTful是一种软件架构之间交互调用数据的协议风格规范，它建议以一种通用的方式定义和管理</p><h3 id="2-5-与Native交互协议"><a href="#2-5-与Native交互协议" class="headerlink" title="2.5 与Native交互协议"></a>2.5 与Native交互协议</h3><p>一般将移动端原生应用的开发称为移动端Native开发。</p><p>Hybrid App是在Native App应用的基础上结合了Web App应用所形成的模式，称为混合App。</p><h1 id="第三章-前端三层结构与应用"><a href="#第三章-前端三层结构与应用" class="headerlink" title="第三章  前端三层结构与应用"></a>第三章  前端三层结构与应用</h1><h3 id="3-1-HTML结构层基础"><a href="#3-1-HTML结构层基础" class="headerlink" title="3.1 HTML结构层基础"></a>3.1 HTML结构层基础</h3><p>前端三个基本构成：</p><p>结构层：HTML</p><p>表现层：CSS</p><p>行为层：JavaScript</p><h4 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1"></a>3.1.1</h4><p>虽然目前几乎所有浏览器均支持以HTML5的方式声明文档类型，即&lt;！DOCUTYPE html&gt;，但不代表HTML5的新标签元素就可以在这些浏览器上正常解析。这是因为DOCUTYPE声明只用于指示Web浏览器页面使用哪个HTML版本编写的指令进行解析。</p><h4 id="3-1-2-Web语义化标签"><a href="#3-1-2-Web语义化标签" class="headerlink" title="3.1.2 Web语义化标签"></a>3.1.2 Web语义化标签</h4><p>Web语义化：是指在HTML结构的恰当位置上使用语义恰当的标签，使页面具有良好的结构，使页面标签元素具有含义，能够让人或搜索引擎更容易理解。</p><p><strong>根据标签元素的display属性特点，可以将HTML标签分为以下几类</strong>：</p><ol><li>行内元素：<a>, <b>, <span>, <img>, <input>, <button>, <select>, <strong>等，其默认宽度是由内容宽度决定的。</li><li>块级元素：<div>, <ul>, <ol>, <li>, <dl>, <dt>, <dd>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <p>, <table>等，其默认宽度为父元素的100%。</li><li>常见空元素：<hr>, <br>, <link>, <meta>, <area>, <base>, <col>, <command>, <embed>, <keygen>, <param>, <source>, <track>等不能显示内容甚至不会在页面出现，但对页面的解析有着其他重要作用的元素。</li></ol><h4 id="3-1-3-HTML糟糕部分"><a href="#3-1-3-HTML糟糕部分" class="headerlink" title="3.1.3 HTML糟糕部分"></a>3.1.3 HTML糟糕部分</h4><h4 id="3-1-4-AMP-HTML"><a href="#3-1-4-AMP-HTML" class="headerlink" title="3.1.4 AMP HTML"></a>3.1.4 AMP HTML</h4><p>流动网页提速（AMP）是Google推行的一个提升页面资源载入效率的HTML提议规范。</p><p>基本思路有两点：使用严格受限的高效HTML标签以及使用静态网页缓存技术来提高网络访问静态资源的性能和用户体验。也就是，尽量避免使用目前网页上渲染或展示性能比较差的标签，并将部分网页静态内容缓存到页面上进行分发，例如内联体积较小的样式和图片，延时加载较大的静态资源文件，进而提高网页的初始加入速度。</p><p>使用AMP提升网页性能的基本原则：</p><ol><li>只允许异步的script脚本</li><li>只加载静态的资源</li><li>不能让内容阻塞</li><li>不在关键路径中加载第三方JavaScript</li><li>所有CSS必须内联</li><li>字体使用声明必须高效</li><li>最小化样式声明</li><li>只运行GPU加速的动画</li><li>处理好资源加载顺序问题</li><li>页面必须立即加载</li><li>提升AMP元素性能</li></ol><h3 id="3-4-JavaScript标准实践"><a href="#3-4-JavaScript标准实践" class="headerlink" title="3.4 JavaScript标准实践"></a>3.4 JavaScript标准实践</h3><h4 id="3-4-1-ECMAScript-5"><a href="#3-4-1-ECMAScript-5" class="headerlink" title="3.4.1 ECMAScript 5"></a>3.4.1 ECMAScript 5</h4><ol><li><p><strong>严格模式</strong>：为开发者提供了更加安全规范的编程范围，限制了原有一些不规范的写法，让一些不合理的语法直接报错，从而提高代码安全性和规范性。</p><p>严格模式的添加消除了JavaScript语法的一些不合理，不严谨之处，减少了一些怪异行为，可以在一定程度上提高编译器效率，加快运行速度，为未来新版本的JavaScript标准化做铺垫。</p></li></ol><h3 id="3-6-前端界面技术"><a href="#3-6-前端界面技术" class="headerlink" title="3.6 前端界面技术"></a>3.6 前端界面技术</h3><h4 id="3-6-1-CSS样式统一化"><a href="#3-6-1-CSS样式统一化" class="headerlink" title="3.6.1 CSS样式统一化"></a>3.6.1 CSS样式统一化</h4><p>由于浏览器间内核实现的差异性，不同浏览器可能对同一元素标签的默认设置是不同的，如果不对CSS样式进行统一化处理，可能会出现同一个网页在不同浏览器下打开时显示不同或样式不一致的问题。</p><p>处理这一问题，目前主要有三种实现思路：reset，normalize，neat。</p><p><strong>reset</strong>：</p><p>将不同浏览器中标签元素的默认样式全部清除，消除不同浏览器下默认样式的差异性。</p><p>典型的reset默认样式的代码如下：</p><p><img src="C:\Users\lin\Desktop\1.png"></p><p>这种方法可以将不同浏览器上大多数标签的内外边距清除，但这个例子中的规则不能消除标签所有的差异性，只是针对消除内外边距。</p><p><strong>normalize</strong>：</p><p>它的做法是在整站样式基本确定的情况下对标签元素统一使用同一默认样式规则。</p><p>例如：</p><p><img src="C:\Users\lin\Desktop\2.png"></p><p><strong>neat</strong>：</p><p>是上面两种实现的综合。</p><p><img src="C:\Users\lin\Desktop\3.png"></p><h4 id="3-6-2-CSS预处理"><a href="#3-6-2-CSS预处理" class="headerlink" title="3.6.2 CSS预处理"></a>3.6.2 CSS预处理</h4><p>预处理工具：SASS，LESS，Stylus，postCSS等。</p><p>预处理工具的最终目的：通过编写更高效，易管理的类CSS脚本并将它们自动生成浏览器解释执行的CSS代码，现实高效开发和便捷管理。</p><h4 id="3-6-3-表现层动画实现"><a href="#3-6-3-表现层动画实现" class="headerlink" title="3.6.3 表现层动画实现"></a>3.6.3 表现层动画实现</h4><p>实现动画的方案主要有6种：</p><ol><li>JavaScript直接实现动画</li><li>可伸缩矢量图形（SVG）动画</li><li>CSS3 transition</li><li>CSS3 animation</li><li>Canvas动画</li><li>requestAnimationFrame</li></ol><h3 id="3-7-响应式网站开发技术"><a href="#3-7-响应式网站开发技术" class="headerlink" title="3.7 响应式网站开发技术"></a>3.7 响应式网站开发技术</h3><h4 id="3-7-1-响应式页面实现概述"><a href="#3-7-1-响应式页面实现概述" class="headerlink" title="3.7.1 响应式页面实现概述"></a>3.7.1 响应式页面实现概述</h4><p>​    通常认为，响应式设计是根据不同设备浏览器尺寸或分辨率来展示不同页面结构层，行为层，表现层的设计方式。</p><p>​    响应式设计网站，目前比较主流的实现方法有两种：一是通过前端或后端判断userAgent来跳转不同页面完成不同设备浏览器的适配，也就是维护两个不同的站点来根据用户设备进行对应的跳转；二是使用media query媒体查询等手段，让页面根据不同设备浏览器自动改变页面的布局和显示，但不做跳转。</p><p>​    <strong>第一种方案：</strong></p><p>典型响应式站点实现：</p><p><img src="C:\Users\lin\Desktop\4.png"></p><p>这种情况存在一些问题：</p><ol><li>需要开发为维护至少两个站点跳转来适配不同用户的设备浏览器。</li><li>下载使用哪个站点内容由设备的userAgent信息来判断，无法根据屏幕尺寸或分辨率来决定。</li><li>多一次跳转。</li></ol><p>​    <strong>第二种方案：</strong> 桌面浏览器和移动端浏览器使用同一个站点域名来加载内容，只需要开发维护一个站点就可以，然后根据media query来实现不同屏幕下的布局显示，适用于访问量较小，性能要求不高的应用场景。</p><p> 存在的问题：</p><ol><li>移动端加载了与桌面端浏览器相同的资源，例如图片，脚本资源等，导致移动端加载了冗余或体积较大的资源。</li><li>桌面端浏览器和移动端浏览器访问站点需要展示的内容可能不完全相同，这种响应式的方式只实现了内容布局显示的适应，但要做到更多差异性的功能布局难。</li><li>桌面端和移动端浏览器页面功能具有差异性，使用一套处理方式，会有更多兼容性问题。</li></ol><p>​    <strong>总结两种方式的所有问题：</strong></p><ol><li>能否使用同一个站点域名避免跳转的问题</li><li>能否保证移动端加载的资源内容最优</li><li>如何做移动端和桌面端浏览器的差异化功能</li><li>如何根据更多的信息进行更加灵活的判断，而不仅仅是userAgent</li></ol><p>合理开发方式和网站访问架构设计是可以解决上述四个问题。下面看看在响应式的三层结构上具体能做什么处理。</p><h4 id="3-7-2-结构层响应式"><a href="#3-7-2-结构层响应式" class="headerlink" title="3.7.2 结构层响应式"></a>3.7.2 结构层响应式</h4><p>结构层响应设计可以理解成HTML内容的自适应渲染实现方式，即根据不同的设备浏览器渲染不同的页面内容结构，而不是直接进行页面跳转。</p><p>这里页面中结构层渲染的方式可能不同，包括前端渲染数据和后端渲染数据，这样主要就有两种不同的设计思路：一是页面内容在前端渲染，二是页面内容在后端渲染。</p><ol><li><strong>前端数据渲染响应式</strong></li></ol><p>根据不同平台浏览器的情况加载不同的异步静态JavaScript。然后异步渲染不同的模块内容，生成不同的表现层结构。</p><p>这种方式尽管可以让桌面端和移动端附庸一个页面并做页面的差异性，但是由于使用了应该HTML结构层为基础进行渲染和操作，因此页面的功能实现仍然有部分耦合的地方。</p><ol start="2"><li><strong>后端数据渲染响应式</strong></li></ol><p>这种情况的处理方式其实可以做到更优化，只要尽可能将桌面端和移动端的业务层模板分开维护就可以。</p><ol start="3"><li><strong>结构层媒体响应式</strong></li></ol><p>通过对不同开发模式中的渲染思路的分析，我们基础解决了结构层HTML响应式所面临的主要问题。</p><p>细节上，有一点需要强调：结构层媒体响应式的实现。根据统计，目前主要的网站60%以上的流量数据来自图片，所以如何在保证用户访问网站体验不降低的前提下尽可能地降低网站图片的输出流量具有很重要的意义。</p><p>这里提到的媒体主要是指图片，即我们需要在根据浏览器设备屏幕分辨率和屏幕宽度来加载不同大小和尺寸的图片，避免在移动端上加载体积过大的资源，下面来看看前端图片响应式的几种解决方案。</p><div class="code-wrapper"><pre><code class="hljs">    1. 使用Media Query背景图片代替</code></pre></div><ol start="2"><li><p>  <picture>  标签元素 （HTML5标签，大多浏览器可能不兼容）</p></li><li><p>模板判断响应式图片</p><p>在前端渲染数据的开发模式下，使用前端模板进行判断渲染输出不同的图片是最简单，最直接的响应式图片实现方式。</p></li><li><p>图片服务器判断输出内容</p></li></ol><h4 id="3-7-3-表现层响应式"><a href="#3-7-3-表现层响应式" class="headerlink" title="3.7.3 表现层响应式"></a>3.7.3 表现层响应式</h4><p>这里至少要了解两个方面的内容：响应式布局和屏幕适配布局</p><p><strong>响应式布局</strong>是根据浏览器宽度，分辨率，横屏，竖屏等情况来自动改变页面元素展示的一种布局，一般可以使用栅格方式来实现，实现思路有两种：一种是桌面端优先。扩展到移动端浏览器适配，另一种则是以移动端浏览器优先，扩展到桌面端浏览器适配，由于移动端的网络和计算资源较少，所以一般比较推荐从移动端扩展到桌面端的方式进行适配，这样避免了在移动端加载冗余的桌面端CSS样式。</p><p><strong>屏幕适配布局</strong>则是主要针对移动端的，由于目前移动端屏幕大小各部相同，屏幕适配布局是为了实现网页内容根据移动端设备屏幕大小等比例缩放所提出的一种布局计算方式。</p><p>​    首先为了固定浏览器对HTML文件的渲染，会在HTML的<head> 里面加上下面一段<meta> 声明来控制页面使用移动端浏览器展示并保持内容不缩放。</p><div class="code-wrapper"><pre><code class="hljs">&lt;meta name=&#39;viewport&#39; content=&#39;width=device-width,initial-scale=1,maximum-scale=1,user-calable=no&#39;/&gt;</code></pre></div><h4 id="3-7-4-行为层响应式"><a href="#3-7-4-行为层响应式" class="headerlink" title="3.7.4 行为层响应式"></a>3.7.4 行为层响应式</h4><p>在页面响应式设计中。行为层脚本也是需要根据浏览器来执行不同逻辑的。</p><p>行为层的响应式分为：JavaScript内容在前端引入和在后端引入这两种情况。</p><h1 id="第四章-现代前端交互框架"><a href="#第四章-现代前端交互框架" class="headerlink" title="第四章 现代前端交互框架"></a>第四章 现代前端交互框架</h1><p>（需要进行理解，再完善笔记）</p><p>​    数据的处理和操作的核心就是DOM的处理和操作，即便是今天，所有前端JavaScript框架最终要解决的仍然是如何实现高效，高性能DOM交互操作的问题。</p><p>​    DOM API类型分为以下几种类型：节点查询型，节点创建型，节点修改型，节点关系型，节点属性型和内容加载型。</p><p>​    JQuery主要实现了选择器，DOM操作方法，事件绑定封装，AJAX，Deferred这五个方面的封装和常见的兼容性问题的处理，我们还可以基于jQuery扩展更多的方法功能来提高业务开发效率。</p><p>​    SPA的思路是将整个应用的内容都在一个页面中实现并完全通过异步交互来根据用户操作加载不同的内容。</p><p>​    通过DOM交互框架已经可以比较高效地处理DOM操作和事件绑定等问题。这种高效的方式带来了效率上的提升，但随着页面结构和交互复杂性的提升，仅靠这种方式会增加管理的难度。随着AJAX技术的盛行，SPA应用开始被广泛使用，而直接操作DOM的方式进行SPA的开发和维护是比较麻烦的。为解决这个问题，通常将页面上与DOM相关的内容抽象成数据模型，视图，事件控制函数三部分，这就有了前端MVC设计思路。</p><p>​    <strong>MVC</strong>可以认为是一种开发设计模式，其基本思路是将DOM交互的内容分为数据模型，视图和事件控制函数三个部分，并对他们进行统一管理。Model用来存放数据结果和数据对象，View用于页面DOM的更新与修改，Controller则用于根据前端路由条件来调用不同的Model给View渲染不同的数据内容。</p><p>​    前端框架从直接的DOM操作到MVC设计模式，然后到MVP，再到MVVM框架，前端设计模式改进原则一直向着高效，易实现，易维护，易扩展的基本方向发展。虽然目前前端各类框架也已经成熟并开始向高版本迭代。但是还没有结束，我们现在的编程对象依然没有脱离DOM编程的基本套路，一次次框架的改进大大提高了开发效率，但是DOM元素运行的效率仍然没有变。</p><h3 id="4-3-Virtual-DOM-交互模式"><a href="#4-3-Virtual-DOM-交互模式" class="headerlink" title="4.3 Virtual DOM 交互模式"></a>4.3 Virtual DOM 交互模式</h3><h4 id="4-3-1-Virtual-DOM-设计理念"><a href="#4-3-1-Virtual-DOM-设计理念" class="headerlink" title="4.3.1 Virtual DOM 设计理念"></a>4.3.1 Virtual DOM 设计理念</h4><p>​    MVVM的前端交互模式大大提高了编程效率，自动双向数据绑定让我们可以将页面逻辑实现的核心转移到数据层的修改操作上，而不再是在页面中直接操作DOM。但实际上，尽管MVVM改变了前端开发的逻辑方式，但是最终数据层反应到页面上View层的渲染和改变仍是通过对应的指令进行DOM操作来完成的。而且通常一次ViewModel的变化可能会触发页面上多个指令操作DOM的变化，带来大量的页面结构层DOM操作来渲染。</p><p>​    <strong>Virtual DOM是一个能够直接描述一段HTML DOM结构的JavaScript对象，浏览器可以根据它的结构按照一定规则创建出确定唯一的HTML DOM结构。</strong></p><p>​    整体来看，Virtual DOM的交互模式减少了MVVM或其他框架中对DOM的扫描和操作次数，并且在数据发生改变后只在合适的地方根据JavaScript对象来进行最小化的页面DOM操作，避免大量重新渲染。</p><h4 id="4-3-2-Virtual-DOM的核心实现"><a href="#4-3-2-Virtual-DOM的核心实现" class="headerlink" title="4.3.2 Virtual DOM的核心实现"></a>4.3.2 Virtual DOM的核心实现</h4><p>​    Virtual DOM模式来控制页面DOM结构更新的过程：创建原始页面或组件的Virtual DOM结构，用户操作后需要进行DOM更新时，生成用户操作后页面或组件的Virtual DOM结构并与之前的结构进行比对，找到最小变化Virtual DOM的差异化描述对象，最后把差异化的Virtual DOM根据特定的规则渲染到页面上。</p><p>​    所以<strong>核心操作</strong>可以抽象成三个步骤：</p><div class="code-wrapper"><pre><code class="hljs">    1. 创建Virtual DOM      2. 对比两个Virtual DOM生成差异化Virtual DOM        3. 将差异化Virtual DOM渲染到页面上</code></pre></div><p>其中 ： </p><p>​    创建Virtual DOM：创建Virtual DOM即把一段HTML字符串文本解析成一个能够描述它的JavaScript对象。</p><p>根据HTML字符串解析创建Virtual DOM的过程相当于实现一个HTML文本解析器，但是没有生成DOM对象树，只是生成一个操作效率更高的JavaScript对象，因此通常不会直接将HTML交给浏览器去解析，因为浏览器的DOM解析很慢，这也是Virtual DOM交互模式和普通DOM编程最本质的区别。</p><p>​    当用户进行了页面操作需要进行页面视图改变时，通常会生成一个新的Virtual DOM结构来表示改变后的状态，而且不会将这个改变后的Virtual DOM内容立即重新渲染到页面中，而是通过对比找出两个Virtual DOM的差异性，得到一个差异树对象。对于Virtual DOM的对比算法实际上是对于多叉树结构的遍历算法。对多叉树遍历就有广度优先算法和深度优先算法。</p><p>​    经过Virtual DOM的差异性对比，我们获得了用户操作后的差异性Virtual DOM，差异性类型和差异性的位置，那么剩下的操作就是根据对比返回的结构将差异化内容经过DOM操作渲染到页面上，整个交互过程就完成了。</p><p>​    </p><p><strong>Virtual DOM交互模式的优势</strong> 与以前交互模式相比，Virtual DOM最本质的区别在于减少了对DOM对象的操作，通过JavaScript 对象来代替DOM对象树，并且在页面结构改变进行最小代价的DOM渲染操作，提高了交互的性能和效率。这也是提高前端交互性能的根本原因。</p><h3 id="4-4-前端MNV-时代"><a href="#4-4-前端MNV-时代" class="headerlink" title="4.4 前端MNV*时代"></a>4.4 前端MNV*时代</h3><p>尽管Virtual DOM的交互模式能在页面数据的渲染和变更时尽可能地减少DOM操作，但仍无法完成脱离DOM交互的模式，我们知道DOM的操作效率不高，在移动设备的Hybrid WebView上表现会更慢，所以为了进一步改进Hybrid应用中DOM性能，希望完全脱离DOM的编程模式来进行结构层的操作。</p><p>为什么可以这样子实现：首先，目前，主要主流Hybrid App的Web内容通常是在原生应用中嵌入WebView来实现的，而原生应用的界面数据渲染可以通过调用原生控件来实现，它不仅没有HTML DOM的性能缺陷，而且还可以调用Native系统底层的API；其次，Hybrid App可以通过统一的JavaScript交互协议来调用原生的方法和控件，所以使用JavaScript直接调用和产生原生控件进行界面数据渲染的方式是可以实现的。</p><h4 id="4-4-1-MNV-模式简介"><a href="#4-4-1-MNV-模式简介" class="headerlink" title="4.4.1 MNV*模式简介"></a>4.4.1 MNV*模式简介</h4><p>我们把这种使用JavaScript调用原生控件或事件绑定生成应用程序的交互模式称为前端MNV*开发模式。这种模式目前仅使用于移动端Hybrid应用，因为需要依赖原生控件的调用支持，而只有这种特殊的应用场景才满足条件。</p><h4 id="4-4-2-MNV-模式的实现原理"><a href="#4-4-2-MNV-模式的实现原理" class="headerlink" title="4.4.2 MNV* 模式的实现原理"></a>4.4.2 MNV* 模式的实现原理</h4><p>主要是将JSBridge和DOM编程的方式进行结合，让前端能够快速构建开发原生界面的应用，从而脱离DOM的交互模式。</p><h1 id="第五章-前端项目与技术实践"><a href="#第五章-前端项目与技术实践" class="headerlink" title="第五章 前端项目与技术实践"></a>第五章 前端项目与技术实践</h1><p>现代前端技术飞速发展，最终形成了以效率和质量为核心的两大趋势。</p><h3 id="5-1-前端开发规范"><a href="#5-1-前端开发规范" class="headerlink" title="5.1 前端开发规范"></a>5.1 前端开发规范</h3><p>开发规范可以认为软件开发工程师之间的另一种语言，它在一定程度上决定了团队协作过程中开发的程序代码是否具有一致性和易维护性，统一的开发规范可以降低代码的出错率和团队开发的协作成本。</p><h4 id="5-1-1-前端通用规范"><a href="#5-1-1-前端通用规范" class="headerlink" title="5.1.1 前端通用规范"></a>5.1.1 前端通用规范</h4><ol><li><p>三层结构分离</p><p>前端页面开发应做到结构层（HTML），表现层（CSS），行为层（JavaScript）分离，保证它们之间的最小耦合，这对前端开发和后期维护都是至关重要。推荐相关样式和JavaScript逻辑在外部引入的CSS和JavaScript文件中。</p></li><li><p>缩进</p><p>统一使用tab（或4个进行缩进）来进行缩进，可以在开发编辑器或IDE里进行设置。</p></li><li><p>内容编码</p><p>在HTML文档中使用<meta charset='utf-8'>来指定编码，一避免出现页面乱码问题。</p></li><li><p>小写</p><p>所有的HTML标签，HTML标签属性，样式名及规则建议使用小写，我们一般习惯使用小写英文字符。</p><p>HTML属性的id属性可以使用驼峰大小写组合的命名方式，因为id属性常常只用于JavaScript的DOM查询引用，而JavaScript语言标准推荐使用驼峰大小写组合的命名方式，因此HTML页面上的id属性也尽量使用这种标准来写。</p></li><li><p>代码单行长度限制</p><p>代码单行长度不要超过120字符（或80字符，根据团队习惯决定），长字符串并接通常使用加号来连接换行的内容</p></li><li><p>注释</p><p>尽可能为代码写上注释，HTML，CSS 还是JavaScript，必要的注释是不能少的。</p></li><li><p>行尾空格与符号</p><p>删除行尾空格与多余的符号，这些内容是没有必要存在的。</p></li></ol><h4 id="5-1-2-前端HTML规范"><a href="#5-1-2-前端HTML规范" class="headerlink" title="5.1.2 前端HTML规范"></a>5.1.2 前端HTML规范</h4><ol><li><p>文档类型定义</p><p>统一使用HTML5 的标准文档类型&lt;! DOCTYPE html&gt;来定义，这样更简洁，而且向后兼容。不使用HTML4.01的DTD定义。</p></li><li><p>head内容</p><p>head中必须定义title，keyword，description，保证基本的SEO页面关键字和内容描述。移动端页面head要添加viewport控制页面缩放，有利于提高页面渲染性能。</p></li><li><p>省略type属性</p><p>在引用CSS或JavaScript时，可以省略type属性不写，因为HTML5在引入CSS时默认type值为text/css，在引入JavaScript时默认type为text/javaScritp</p></li><li><p>使用双引号包裹属性值</p><p>所有的标签属性值必须要用双引号包裹，不推荐单引号，不允许有的双引号，有的单引号。</p></li><li><p>属性值省略</p><p>非必要的属性值可以省略，例如输入框里的readonly，disabled，required等属性值是非必要的，可以省略不写。如<input type="text" disabled></p></li><li><p>嵌套</p><p>所有元素必须正确嵌套，尽量使用语义化标签，不允许交叉，也不允许在inline元素中包含block元素。</p></li><li><p>标签闭合</p><p>非自闭合标签必须添加标识，自闭合标签无须关闭。</p></li><li><p>使用img的alt属性</p><p>为img加上alt属性</p></li><li><p>使用lable的for属性</p><p>为表单内部元素<lable>加上for属性或者将对应的控件放在<lable>标签内部。这样在点击<lable>标签时，会关联到对应的input或textarea上选中，可以增加输入的响应区域。</p><p><img src="C:\Users\lin\Desktop\5.png"></p><ol start="10"><li><p>按模块添加注释</p><p>在每个大的模块的开始和结束的地方添加起始注释标记，便于开发者识别，维护。</p></li><li><p>标签元素格式</p><p>块级元素一般另起一行写，行内元素可以根据情况换行，尽量保证行内元素代码长度不超过一行，否则要考虑另起一行。HTML的子元素要尽量相对父级进行缩进，这样更有层次。</p><p><img src="C:\Users\lin\Desktop\6.png"></p></li><li><p>语义化标签</p><p>在合适的地方选择合适的标签。不要使用被HTML废弃用于样式表现的无语义标签。</p></li></ol><h4 id="5-1-3-前端CSS规范"><a href="#5-1-3-前端CSS规范" class="headerlink" title="5.1.3 前端CSS规范"></a>5.1.3 前端CSS规范</h4><ol><li><p>CSS引用规范</p><p>使用link的方式调用外部样式文件，外部样式文件可以复用并能用浏览器缓存提高加载速度。禁止在标签内使用内联样式，否则后期很不容易管理，强烈不建议使用。</p></li><li><p>样式的命名</p><p>CSS类名命名一般由单词，中画线，当然也有BEM方案，这里推荐一种规范—–所有命名都使用小写，加上ui-等前缀，表示这个类名只用于控制元素的样式展示，不推荐使用拼音作为样式名，尤其是使用缩写的拼音和英文混合的方式，很让人费解。尽量不以info，current，news等单个单词类名直接作为类名称，单独一级命名很容易造成冲突覆盖，并且很难理解。</p></li><li><p>CSS高效实现规范</p><p>标签名，与id或class组合的选择器会造成冗余，而且降低CSS的解析速度，应避免。</p></li><li><p>使用预处理脚本编码开发</p><p>使用预处理嵌套的方式描述元素之间的层次关系，尽可能使用预处理器的高效语法来提高开发效率，如嵌套，变量，嵌套属性，注释，继承等，避免直接使用CSS开发。使用SASS来编写CSS就高效很多。</p></li><li><p>简写方式</p><p>单位0的缩写。如果属性值为0，则不需要为0加单位，如果以0为个数为的小数，前面的0可以省略不写。尽量带上分号。如  opacity：.6</p><p>去掉url中引用资源的引号，这是没必要的。如background-image:url(sprites.png)</p><p>颜色值写法，所有的颜色值要使用小写并尽量缩写至3位 如#FF0000  可写成#f00</p></li><li><p>属性书写顺序</p><p>CSS属性书写顺序遵循先布局后内容，即先写元素的布局属性，再写元素的内容属性。常用布局属性有：position, display, float, overflow等</p></li><li><p>hack写法</p><p>尽可能减少对CSS hack的使用和依赖，可以使用其他的解决方案替代hack思路。如果必须要使用浏览器hack，尽量选择稳定，常用并易于理解的书写方式。</p></li></ol><h4 id="5-1-4-ECMAScript5-常用规范"><a href="#5-1-4-ECMAScript5-常用规范" class="headerlink" title="5.1.4 ECMAScript5 常用规范"></a>5.1.4 ECMAScript5 常用规范</h4><ol><li><p>分号</p><p>JavaScript语句后面统一加上分号</p></li><li><p>空格</p><p>在所有运算符，符号与英文单词之间添加必要的空格，利于开发者阅读。</p></li><li><p>空行</p><p>一般推荐在代码块后面保留一行空行，显得块内容层次更加分明</p></li><li><p>引号</p><p>推荐JavaScript字符串最外层统一使用单引号</p><p><img src="C:\Users\lin\Desktop\7.png"></p></li><li><p>变量命名</p><p>标准变量采用驼峰式命名。常量使用全大写形式命名，并采用下画线连接。构造函数首字母大写，jQuery对象推荐以”$”为开头命名，便于分辨JQuery对象和普通对象。</p></li><li><p>对象</p><p>对象属性名不需要加引号。对象属性键值以缩进的形式书写，不要写在同一行。数组，对象属性后不能有逗号，否则部分浏览器可能会解析出错。</p><p><img src="C:\Users\lin\Desktop\8.png"></p><ol start="7"><li><p>大括号</p><p>程序中的代码块推荐使用大括号包裹，要注意换行，这样更加清晰，而且方便后面扩展增加内容。</p></li><li><p>条件判断</p><p>尽量不要直接使用undefined进行变量判断，使用typeof和字符串“undefined”对变量类型进行判断。分别用===，！==代替==，！=更加严谨</p></li><li><p>不要在条件语句或循环语句中声明函数</p></li></ol><h4 id="5-1-5-ECMAScript-6-参考规范"><a href="#5-1-5-ECMAScript-6-参考规范" class="headerlink" title="5.1.5 ECMAScript 6+ 参考规范"></a>5.1.5 ECMAScript 6+ 参考规范</h4><ol><li><p>正确使用ECMAScript 6 的变量声明关键字</p></li><li><p>字符串拼接使用字符串模板完成</p><p><img src="C:\Users\lin\Desktop\9.png"></p></li><li><p>解析赋值尽量使用一层结构，否则声明变量嵌套太深难以理解</p></li><li><p>数组拷贝推荐使用…实现，更加简洁高效</p><p><img src="C:\Users\lin\Desktop\19.png"></p></li><li><p>数组循环遍历使用for…of非必须情况下不推荐使用forEach，map，简单循环</p><p><img src="C:\Users\lin\Desktop\10.png"></p></li><li><p>使用ECMAScript6 的类来代替之前的实现方式，尽量使用constructor进行属性成员变量赋值</p><p><img src="C:\Users\lin\Desktop\11.png"></p><p><img src="C:\Users\lin\Desktop\12.png"></p></li><li><p>模块化多变量导出时尽量使用对象解构，不使用全局导出。尽量不要把import和export写在一行</p><p><img src="C:\Users\lin\Desktop\13.png"></p></li><li><p>导出类名时，保持模块名称和文件名相同，类名首字母需要大写</p><p><img src="C:\Users\lin\Desktop\14.png"></p></li><li><p>生成器中yield进行异步操作时需要使用try…catch包裹，方便对异常进行处理。</p><p><img src="C:\Users\lin\Desktop\15.png"></p></li><li><p>推荐使用promise，避免使用第三方库或直接回调，原生的异步处理性能更好而且符合语言规范。</p><p><img src="C:\Users\lin\Desktop\16.png"></p></li><li><p>如果不是必须，避免使用迭代器</p></li><li><p>不要使用统一码，中文的正则匹配和计算较消耗时间，而且容易出问题</p></li><li><p>合理使用Generator，推荐使用ascyn/await，更加简洁</p></li></ol><h4 id="5-1-6-前端防御性编程规范"><a href="#5-1-6-前端防御性编程规范" class="headerlink" title="5.1.6 前端防御性编程规范"></a>5.1.6 前端防御性编程规范</h4><p>防御性编程是指通过检测任何可能存在的逻辑异常问题的代码实现，提高脚本执行过程的健壮性的一种编程手段。防御性编程要求我们对程序的实现进行更加全面，严谨的考虑。</p><ol><li><p>对外部数据的安全检测判断</p></li><li><p>规范化的错误处理</p><p>对于常用的AJAX请求或长时间文件读写等可能失败的异步操作，需要进行错误情况的处理或异常捕获处理，而不应该被静默，否则一旦出错，用户得不到正常的提示，对用户体验影响极大。</p><p><img src="C:\Users\lin\Desktop\17.png"></p><p><img src="C:\Users\lin\Desktop\18.png"></p></li></ol><h3 id="5-2-前端组件规范"><a href="#5-2-前端组件规范" class="headerlink" title="5.2 前端组件规范"></a>5.2 前端组件规范</h3><p>​    什么是组件规范?</p><p>​    为什么需要组件规范?</p><p>​    组件规范和开发规范有什么区别和联系呢?</p><p>​    组件通常是指采用代码管理中的分治思想，将复杂的项目代码结构拆分成多个独立、简单、解耦合的结构或文件的形式进行分开管理，达到让项目代码和模块更加清晰的目的。</p><p>​    组件规范则是我们进行拆分、组织、管理项目代码方法的一种约定。</p><p>​    所以，和开发规范相似，组件规范也是一种约定。不同的是，开发规范关注文件内部代码级别的一致性， 组件规范则更关注项目中业务功能模块内容组织的一致性。 一定程度上，组件规范包含了开发规范，因为若开发规范不统一，开发出来的组件风格便不一致，组件规范便也无从说起了。组件规范能够帮助我们对功能模块进行统一的约定管理， 通过这一约定， 任何一个独立的功能模块之间都应该是无耦合并能和其他模块很好对接和组合的。</p><p>​    目前前端主流的一些组件相关规范: UI (User Interface， 用户界面)组件规范、模块化规范、项目组件化设计规范。注意这三者的区别和联系，UI规范一般指UI层设计和实现的规范及统一性， 而模块化主要指的是JavaScript 模块化开发的文件模块封装方式，项目组件规范则指的是实际开发中整个项目业务代码之间的组织形式。</p><h4 id="5-2-1-UI组件规范"><a href="#5-2-1-UI组件规范" class="headerlink" title="5.2.1 UI组件规范"></a>5.2.1 UI组件规范</h4><p>简单来说，UI 组件规范强调了一个网站中所有网页结构层和表现层实现的一致性。 多个地方出现的相同按钮样式可以通过公共定义的样式规范类来描述，而不用每个地方都重复书写样式，避免使用不同的代码实现同一个效果。试想如果没有规范的存在，相同作用的按钮有时是红色，有时是绿色，开发维护时就比较难统一处理了。 从Web前端的角度来看，UI层的规范能带来一些明显的好处。</p><ol><li>UI层风格统一化。UI层风格统一化避免了不同页面的差异化设计风格，能让用户使<br>用Web站点的不同网页外观风格是一致的。</li><li>增加UI层复用性。使用UI规范的情况下，UI层代码复用性增强，可以提高开发效率，<br>相同功能的结构和样式不用重复实现。</li><li>更符合用户的体验习惯。例如红色按钮统一 用来表示警告，绿色按钮统一 表示安全或<br>成功操作等。</li><li>增加了 开发规范的统一-性。 遵循统一的规范， 避免重复开发，避免产生多种风格的代码。</li></ol><p>在实际团队开发中，UI组件规范的完成可能需要以下几个方面的协作：</p><ol><li><p>UI设计一致</p></li><li><p>，开发实现一致。这就涉及开始说的编码开发规范，尽可能让所有UI层实现使用同样的开发规范和方式。例如样式定义，图片引用，命名规范等，就图片引用来说，图标使用base64实现还是使用小图片实现，又或者使用iconfont实现，都需要统一，不能多种方法混合，否则增加UI组件的使用复杂度。</p><p>从开发实现上，如果想设计一个具有通用组件规范的UI库，必须考虑以下几个方面的问题。</p><ol><li>统一的页面布局方案。页面布局使用网格布局还是REM方案，是否需要支持响应式，<br>如果是移动端应该怎样适配，这些是需要优先考虑的。</li><li>基础UI结构和样式实现。样式reset、 按钮、图片、菜单、表单等基础结构与样式的统一化设计实现，可以极大提高页面内容的复用性和开发效率。</li><li>组件化UI结构和样式实现。例如按钮组、字体图标、下拉菜单、输入框组、导航组、面包屑、分页、标签、轮播、弹出框、列表、多媒体、警告框等常用组件的实现。当然网站可能不会一次性用到这么 多，但是如果要考虑设计一个通用的UI组件库，这些仍然是要考虑的。</li><li>响应式布局。如果需要支持页面响应式，布局、结构、样式、媒体、javascript响应式。</li></ol></li></ol><h4 id="5-2-2-模块化规范"><a href="#5-2-2-模块化规范" class="headerlink" title="5.2.2 模块化规范"></a>5.2.2 模块化规范</h4><p>模块化规范是JavaScript文件之间相互依赖引用的一种通用语法约定，就是按照一定的规范来写JavaScript文件，让它可以方便地被其他JavaScript文件引用。</p><p>就规范种类来说，主要包括AMD（异步模块定义），CMD（通用模块定义），CommonJS，import/export等。</p><ol><li><p>AMD</p><p>AMD是运行在浏览器端的模块异步加载规范，主要以requireJS为代表。基本原理是定义define和require方法异步请求对应的JavaScript模块文件到浏览器端运行。模块执行导出时可以使用函数中的return返回结果。</p></li><li><p>CMD</p><p>CMD是seajs提出的一种模块化规范，在浏览器端调用类似CommonJs的书写方式进行模块引用，但却不是完全的CommonJs规范，CMD遵循按需执行依赖的原则，只有在用到某个模块的时候才会执行模块内部的require语句，同时加载完某个依赖模块文件后并不会立即执行，在所有依赖模块加载完成后进入主模块逻辑，遇到模块运行语句的时候才执行对应的模块，这和AMD是有区别的。</p></li><li><p>CommonJs</p><p>CommonJs是Node端使用的JavaScript模块化规范，使用require进行模块引入，并使用modules.exports来定义模块导出。与前面两种方法来比，它的写法更加清晰简洁。</p></li><li><p>import/export</p><p>import/export是ECMAScript6定义的JavaScript模块引用方式，是唯一一个遵循JavaScript语言标准的模块化规范，使用import引入其他模块，export来进行模块导出。</p></li></ol><h4 id="5-2-3-项目组件化设计规范"><a href="#5-2-3-项目组件化设计规范" class="headerlink" title="5.2.3 项目组件化设计规范"></a>5.2.3 项目组件化设计规范</h4><p>目前组件化的方案已经越来越多，Web Component组件化，MVVM框架组件化，基于Virtual DOM框架组件化，直接基于目录管理的组件化等</p><p>高效组件化规范应该解决哪些问题：</p><ol><li>组件之间独立、松耦合。组件之间的HTML、JavaScript、 CSS之间相互独立，尽量不重复，相同部分通过父级或基础组件来实现，最大限度减少重复代码</li><li>组件间嵌套使用。组件可以嵌套使用，但嵌套后仍然是独立、松耦合的。</li><li>组件间通信。主要指组件之间的函数调用或通信，例如A组件完成某个操作后希望B组件执行某个行为，这种情况就可以使用监听或观察者模式在B组件中注册该行为的事件监听或加入观察者，然后选择合适的时机在A组件中触发这个事件监听或通知观察者来触发B组件中的行为操作，而不是在A组件中直接拿到B组件的引用并直接进行操作，因为这样组件之间的行为就会产生耦合。</li><li>组件公用部分设计。组件的公用部分应该被抽离出来形成基础库，用来增加代码的复用性。</li><li>组件的构建打包。构建工具能够自动解析和打包组件内容。</li><li>异步组件的加载模式。在移动端，通常考虑到页面首屏，异步的场景应用非常广泛，所有异步组件不能和同步组件一起处理。这时可以将异步组件区别于普通组件的目录存放，并在打包构建时进行异步打包处理。</li><li>组件继承与复用性。对于类似的组件要做到基础组件复用来减少重复编码。</li><li>私有组件的统一管理。为了提高协作效率，可以通过搭建私有源的方式来统- - 管理组件库，例如使用包管理工具等。但这点即使在大的团队里面也很难实施，因为业务组件的实现常常需要定制化而且经常变更，这样维护组件库成本反而更大，目前可以做的是将公用的组件模块使用私有源管理起来。</li><li>根据特定场景进行扩展或自定义。如果当前的组件框架不能满足需求，我们应该能够很便捷地拓展新的框架和样式，这样就能适应更多的场景需求。比如在通过目录管理组件的方案下，既可以使用MVVM框架进行开发，也可以使用Virtual DOM框架进行开发，但要保持基本的规范结构不变。</li></ol></li></ol></li></ol><h3 id="5-3-自动化构建"><a href="#5-3-自动化构建" class="headerlink" title="5.3 自动化构建"></a>5.3 自动化构建</h3><h4 id="5-3-1-自动化构建的目的"><a href="#5-3-1-自动化构建的目的" class="headerlink" title="5.3.1 自动化构建的目的"></a>5.3.1 自动化构建的目的</h4><p>前端构建工具的作用可以认为是对源项目文件或资源进行文件级处理，将文件或资源处理成需要的最佳输出结构和形式。在处理过程中，我们可以对文件进行模块化引入、依赖分析，资源合并、压缩优化、文件嵌入、路径替换、生成资源包等多种操作，这样就能完成很多原本需要手动完成的事情，极大地提高开发效率。</p><h4 id="5-3-2-自动化构建的原理"><a href="#5-3-2-自动化构建的原理" class="headerlink" title="5.3.2 自动化构建的原理"></a>5.3.2 自动化构建的原理</h4><p>构建的流程主要分为7个基本步骤（不同构建工具各有差异，但基本原理是类似的）：</p><p>读取入口文件  -&gt;    分析模块引用  -&gt;   按照引用加载模块   -&gt;   模块文件编译处理    -&gt;    模块文件合并  -&gt;   文件优化处理  -&gt;    写入生成目录</p><p><img src="C:\Users\lin\Desktop\20.png"></p><h3 id="5-4-前端性能优化"><a href="#5-4-前端性能优化" class="headerlink" title="5.4 前端性能优化"></a>5.4 前端性能优化</h3><p>​    前端优化的最终目的都是 提升用户体验，改善页面性能。</p><p>​    前端性能可以认为是用户获取所需要页面数据或执行某个页面动作的一个实时性指标，一般以用户希望获取的数据操作到用户实际获得数据的时间间隔来衡量。</p><p>​    例如用户希望获得数据的操作时打开某个页面，那么这个操作的前端性能就可以用用户操作开始到屏幕展示页面内容给用户的这段时间间隔来评判。</p><p>​    用户的等待延时可以分为两部分：可控等待延时和不可控等待延时。可控等待延时可以理解为能通过技术手段和优化来改进缩短的部分，例如减少图片大小让请求加载更快，减少HTTP请求数等。不可控等待延时则是不能或很难通过前后端技术手段来改进优化的，例如CPU计算时间延时，ISP网络传输延时等。</p><p>​    前端中，所有优化大师针对可控等待延时这部分来进行的。</p><h4 id="5-4-1-前端性能测试"><a href="#5-4-1-前端性能测试" class="headerlink" title="5.4.1 前端性能测试"></a>5.4.1 前端性能测试</h4><p>获取和衡量一个页面的性能，主要可以通过以下几个方面：Performance Timing API，Profile工具，页面埋点计时，资源加载时序图分析。</p><h4 id="5-4-2-桌面浏览器前端优化策略"><a href="#5-4-2-桌面浏览器前端优化策略" class="headerlink" title="5.4.2 桌面浏览器前端优化策略"></a>5.4.2 桌面浏览器前端优化策略</h4><p><strong>网络加载类</strong></p><ol><li>减少HTTP资源请求次数</li></ol><p> 在前端页面中，通常建议尽可能合并静态资源图片、JavaScript 或CSS代码，减少页面请求数和资源请求消耗，这样可以缩短页面首次访问的用户等待时间。通过构建工具合并雪碧图、CSS、JavaScript 文件等都是为了减少HTTP资源请求次数。另外也要尽量避免重复的资源，防止增加多余请求。</p><ol start="2"><li><p>减小HTTP请求大小.<br>除了减少HTTP资源请求次数，也要尽量减小每个HTTP请求的大小。如减少没必要的图片、JavaScript、 CSS及HTML代码，对文件进行压缩优化，或者使用gzip压缩传输内容等都可以用来减小文件大小，缩短网络传输等待时延。前面我们使用构建工具来压缩静态图片资源以及移除代码中的注释并压缩，目 的都是为了减小HTTP请求的大小。</p></li><li><p>将CSS或JavaScript放到外部文件中，避免使用<style>或<script>标签直接引入</p></li><li><p>避免页面中空的href和src</p></li><li><p>为HTML指定Cache-Control或Expires</p><p>为HTML内容设置Cache-Control或Expires可以将HTML内容缓存起来，避免频繁向服务器端发送请求。前面讲到，在页面Cache-Control或Expires 头部有效时，浏览器将直接从缓存中读取内容，不向服务器端发送请求。</p><meta http-equiv="Cache-Control" content= "max-age=7200" / ><meta http-equiv="Expires" content="Mon， 20 Jul 2016 23:00:00 GMT" /></li><li><p>合理设置Etag和Last-Modified</p><p>合理设置Etag和Last-Modified使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器端返回304，让浏览器从缓存中读取文件，减少Web资源下载的带宽消耗并降低服务器负载。</p><meta http-equiv="last -modified" content="Mon, 03 Oct 2016 17:45:57 GMT"/></li><li><p>减少页面重定向</p><p>页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要600毫秒的时间开销，为了保证用户尽快看到页面内容，要尽量避免页面重定向。</p></li><li><p>使用静态资源分域存放来增加下载并行数</p><p>浏览器在同一时刻向同一个域名请求文件的并行下载数是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数,缩短页面资源加载的时间。通常根据多个域名来分别存储JavaScript、CSS和图片文件。</p></li><li><p>使用静态资源CDN来存储文件</p></li><li><p>使用CDN Combo下载传输内容</p></li><li><p>使用可缓存的AJAX</p></li><li><p>使用GET来完成AJAX请求</p><p>使用XMLHttpRequest时,浏览器中的POST方法发送请求首先发送文件头,然后发送HTTP正文数据。而使用GET时只发送头部，所以在拉取服务端数据时使用GET请求效率更高。</p></li><li><p>减少Cookie的大小并进行Cookie隔离</p><p>HTTP请求通常默认带上浏览器端的Cookie一起发送给服务器，所以在非必要的情况下，要尽量减少Cookie来减小HTTP请求的大小。对于静态资源，尽量使用不同的域名来存放，因为Cookie默认是不能跨域的，这样就做到了不同域名下静态资源请求的Cookie隔离。</p></li><li><p>缩小favicon.ico并缓存</p></li><li><p>推荐使用异步JavaScript资源</p><p>异步的JavaScript 资源不会阻塞文档解析，所以允许在浏览器中优先渲染页面，延后加载脚本执行。例如JavaScript的引用可以如下设置，也可以使用模块化加载机制来实现。</p><script src="main. js" defer></script><script src="main.js" async></script></li><li><p>消除阻塞渲染的CSS及JavaScript</p><p>对于页面中加载时间过长的CSS或JavaScript文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成。</p></li><li><p>避免使用CSS import引用加载CSS</p><p>CSS中的@import可以从另一个样式文件中引入样式，但应该避免这种用法，因为这样会增加CSS资源加载的关键路径长度，带有@import的CSS样式需要在CSS文件串行解析到@import时才会加载另外的CSS文件，大大延后CSS渲染完成的时间。</p></li></ol><p><strong>页面渲染类</strong></p><ol><li><p>把CSS资源引用放在HTML文件顶部</p><p>一般推荐将所有CSS资源尽早指定在HTML文档<head>中，这样浏览器可以优先下载CSS并尽早完成页面渲染。</p></li><li><p>JavaScript资源引用放到HTML文件底部</p><p>JavaScript资源放到HTML文档底部可以防止JavaScript的加载和解析执行对页面渲染造成阻塞。由于JavaScript资源默认是解析阻塞的，除非被标记为异步或者通过其他的异步方式加载，否则会阻塞HTMLDOM解析和CSS渲染的过程。</p></li><li><p>不要在HTML中直接缩放图片</p></li><li><p>减少DOM元素数量和深度</p><p>HTML中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持DOM元素简洁和层级较少。</p></li><li><p>尽量避免使用<table>、<iframe>等慢元素</p><table>内容的渲染是将table的DOM渲染树全部生成完并--次性绘制到页面上的，所以在长表格渲染时很耗性能，应该尽量避免使用它，可以考虑使用列表元素<u1>代替。尽量使用异步的方式动态添加iframe,因为iframe内资源的下载进程会阻塞父页面静态资源的下载与CSS及HTML DOM的解析。</li><li><p>避免运行耗时的JavaScript</p><p>长时间运行的JavaScript会阻塞浏览器构建DOM树、DOM渲染树、渲染页面。所以，任何与页面初次渲染无关的逻辑功能都应该延迟加载执行，这和JavaScript资源的异步加载思路是一致的。</p></li><li><p>避免使用CSS表达式或CSS滤镜</p></li></ol><h3 id="5-6-前端搜索引擎优化基础"><a href="#5-6-前端搜索引擎优化基础" class="headerlink" title="5.6 前端搜索引擎优化基础"></a>5.6 前端搜索引擎优化基础</h3><p>搜索引擎优化简称SEO</p><h4 id="5-6-1-title-keywords-description的优化"><a href="#5-6-1-title-keywords-description的优化" class="headerlink" title="5.6.1 title, keywords, description的优化"></a>5.6.1 title, keywords, description的优化</h4><p>  title、keywords、 description 是可以在HTML的<meta>标签内定义的，有助于搜索引擎抓取到网页的内容。要注意的是，一般title的权重是最高的，也是最重要的，因此我们应该好好利用title来提高页面的权重。keywords相对权重较低，可以作为页面的辅助关键词搜索。description的描述一般会直接显示在搜索结果的介绍中，可以使用户快速了解页面内容的描述文字，所以要尽量让这段文字能够描述整个页面的内容，增加用户进入页面的概率。</p><ol><li><p>title的优化</p><p> 一般title的设置要尽量能够概括页面的内容，可以使用多个title关键字组合的形式，并用分隔符连接起来。分隔符一般有“_”, “-”, “ ”, “，”等，其中 “_” 分隔符比较容易被百度搜索引擎检索到，“-”分隔符则容易被谷歌搜索引擎检索到，“,”则在英文站点中使用比较多，可以使用空格。title 的长度在桌面浏览器端一般建 议控制在30个字以内，在移动端控制在20个字以内，若长度超出时浏览器会默认截断并显示省略号。</p><p> 关于title格式的优化设置可以遵循以下规则:</p><div class="code-wrapper"><pre><code class="hljs">   1. 每个网页都应该有独一无二的标题，切忌所有的页面都使用同样的默认标题 2. 标题主题明确， 应该包含网页中最重要的信息 3. 简明精练， 不应该罗列与网页内容不相关的信息 4. 用户浏览通常从左到右的， 建议将重要的内容放到title靠前的位置 5. 使用用户所熟知的语言描述，如果有中、英文两种网站名称，尽量使用用户熟知的语 言作为标题描述</code></pre></div><p>对于网站不同页面title的定义可以设置如下:</p><div class="code-wrapper"><pre><code class="hljs">1. 首页:网站名称_提供服务介绍或产品介绍 2. 列表页: 列表名称_网站名称 3. 文章页:文章标题_文章分类_网站名称</code></pre></div></li></ol><p><img src="C:\Users\lin\Desktop\21.png"></p><h4 id="5-6-2-语义化标签的优化"><a href="#5-6-2-语义化标签的优化" class="headerlink" title="5.6.2 语义化标签的优化"></a>5.6.2 语义化标签的优化</h4><ol><li>使用具有语义化的HTML5标签结构</li><li>唯一的H1标题</li><li><img>添加alt属性</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端技术知识归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端相关概念笔记</title>
    <link href="/2020/01/05/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/01/05/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>(查阅网上相关资料的总结笔记)</p><h2 id="前端学习建议"><a href="#前端学习建议" class="headerlink" title="前端学习建议"></a>前端学习建议</h2><p><strong>1.  夯实基础</strong><br>基础一定要掌握牢固，基础知识一问三不知，就是贻笑大方。css，js基础知识一定要掌握得很熟练。<br>到什么程度可以称为熟练？你能使用css实现斑马条纹背景，毛玻璃效果吗？能给图片实现滤镜效果，能实现所有自适应布局效果吗？原型，原型链，闭包是实现设计模式的必备知识，你真的弄懂了吗？闭包导致内存泄漏的原因是什么，你弄明白了吗？ajax跨域的解决方案你可以说几种？http协议有了解过吗？<br>掌握好这些老掉牙的基础，就是很重要。上层的技术可以变更的很快，基础变动很慢，投入时间学好基础，性价比很高。<br><strong>2. 深究原理</strong><br>Angular，React,Vue框架和脚手架的普及，越来越多的前端工程师浮于表面，调用框架的API完成任务就完事。要成为一名优秀的前端，绝不能成为单纯的”API调用工程师”，一定要掌握框架背后的原理性知识。<br>Virtual DOM diff算法，双向绑定原理等等框架背后的机制都值得我们去学习。框架API可以更新很快，而他们背后的原理都是相似的，学好原理既可以让我们对框架底层了解更深入，又可以使我们迅速掌握不断更新的框架表层。只会用框架永远也成不了大神。<br><strong>3. 注意细节</strong><br>“代码能用就行”的认识往往是初级程序员的通病。作为有在技术道路上有理想的工程师，一定要对自己的代码严格要求，精益求精。<br>比如HTML一定要注意语义化以方便SEO优化，该用<code>&lt;section&gt;</code>，<code>&lt;head&gt;</code>，<code>&lt;foot&gt;</code>的地方不能一股脑儿用<code>&lt;div&gt;</code>完事;css中编写样式时不能页面上样式是有了，类名和属性排序写得一塌糊涂，建议大家按照BEM规范编写风格良好的代码；js中变量命名随意是很常见的不规范行为，一个不直观的变量名往往使同事看了脑袋大。<br>“代码千万行，注释第一行。命名不规范，同事两行泪。“一首流行诗，饱含了多少程序员的血与泪。<br><strong>4. 登高见远</strong><br>前端经历了这么多年的飞速发展，早已成为浩瀚的大海。如果闷着头独自钻研苦学，那无疑是很慢的。</p><p><strong>技能图谱</strong><br>如果我们直接去跟随大神学习，那将会使我们快速成长。github上有很多优秀的前端项目，仔细研读这些项目的代码，在commit记录中查看编程思想和逻辑的进化过程，就是一场与大神直接的面对面交流，是一场绝妙的学习之旅。<br><img src="https://img-blog.csdnimg.cn/20200102191511308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="lt-一-gt-Web发展史"><a href="#lt-一-gt-Web发展史" class="headerlink" title="&lt;一&gt;Web发展史"></a>&lt;一&gt;Web发展史</h2><p>互联网就是指通过TCP/IP协议族互相连接在一起的计算机网络。<br>Web是World Wide Web的简称，中文译为万维网。是运行在互联网上的一个超大规模的分布式系统。</p><p>Web设计初衷是一个静态信息资源发布媒介，通过超文本标记语言（HTML）描述信息资源，通过统一资源标识符（URI）定位信息资源，通过超文本转移协议（HTTP）请求信息资源。HTML、URL和HTTP三个规范构成了Web的核心体系结构，是支撑着Web运行的基石。用通俗的一点的话来说，客户端（一般为浏览器）通过URL找到网站(如<a href="http://www.google.com),发出http请求,服务器收到请求后返回html页面.可见,web是基于tcp/IP%E5%8D%8F%E8%AE%AE%E7%9A%84%EF%BC%8CTCP/IP%E5%8D%8F%E8%AE%AE%E6%8A%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%9E%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E8%80%8CWeb%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%8D%8F%E8%AE%AE%E6%97%8F%E4%B9%8B%E4%B8%8A%EF%BC%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B0%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%BF%A1%E6%81%AF%E8%B5%84%E6%BA%90%E8%BF%9E%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%BD%A2%E6%88%90%E6%88%91%E4%BB%AC%E8%AF%B4%E7%9A%84%E4%B8%87%E7%BB%B4%E7%BD%91%E3%80%82">www.google.com)，发出HTTP请求，服务器收到请求后返回HTML页面。可见，Web是基于TCP/IP协议的，TCP/IP协议把计算机连接在一起，而Web在这个协议族之上，进一步将计算机的信息资源连接在一起，形成我们说的万维网。</a><br>参考链接：<a href="https://blog.csdn.net/u010598360/article/details/79379152">link</a></p><h2 id="lt-二-gt-前端开发中的MVC-MVP-MVVM"><a href="#lt-二-gt-前端开发中的MVC-MVP-MVVM" class="headerlink" title="&lt;二&gt;前端开发中的MVC/MVP/MVVM"></a>&lt;二&gt;前端开发中的MVC/MVP/MVVM</h2><p>MVC，MVP和MVVM都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。不同于设计模式（Design Pattern），只是为了解决一类问题而总结出的抽象方法，一种架构模式往往使用了多种设计模式。<br>MV*的目的是把应用程序的数据、业务逻辑和界面这三块解耦，分离关注点，不仅利于团队协作和测试，更有利于甩锅维护和管理。业务逻辑不再关心底层数据的读写，而这些数据又以对象的形式呈现给业务逻辑层。<br>从 MVC –&gt; MVP –&gt; MVVM，就像一个打怪升级的过程，它们都是在MVC的基础上随着时代和应用环境的发展衍变而来的。<br>参考链接：<br><a href="https://music.163.com/#/artist?id=1045123&market=baiduqk">link</a><br><a href="https://www.jianshu.com/p/39f8f0aefdc2">link</a><br><a href="https://github.com/livoras/blog/issues/11">link</a></p><h2 id="lt-三-gt-Vue"><a href="#lt-三-gt-Vue" class="headerlink" title="&lt;三&gt;Vue"></a>&lt;三&gt;Vue</h2><p>Vue就是基于MVVM模式实现的一套框架，在vue中：Model:指的是js中的数据，如对象，数组等等。View:指的是页面视图viewModel:指的是vue实例化对象</p><h5 id="1-为什么说Vue是渐进式的框架？"><a href="#1-为什么说Vue是渐进式的框架？" class="headerlink" title="1.为什么说Vue是渐进式的框架？"></a>1.为什么说Vue是渐进式的框架？</h5><ol><li>如果你已经有一个现成的服务端应用，你可以将vue 作为该应用的一部分嵌入其中，带来更加丰富的交互体验;</li><li>如果你希望将更多业务逻辑放到前端来实现，那么VUE的核心库及其生态系统也可以满足你的各式需求（core+vuex+vue-route）。和其它前端框架一样，VUE允许你将一个网页分割成可复用的组件，每个组件都包含属于自己的HTML、CSS、JAVASCRIPT以用来渲染网页中相应的地方。</li><li>如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成为各自的组件和文件，vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单（vue init webpack my-project）。我们可以使用VUE的单文件组件，它包含了各自的HTML、JAVASCRIPT以及带作用域的CSS或SCSS。以上这三个例子，是一步步递进的，也就是说对VUE的使用可大可小，它都会有相应的方式来整合到你的项目中。所以说它是一个渐进式的框架。<h5 id="2-Vue最独特的特点？"><a href="#2-Vue最独特的特点？" class="headerlink" title="2.Vue最独特的特点？"></a>2.Vue最独特的特点？</h5>VUE最独特的特性：响应式系统VUE是响应式的（reactive），也就是说当我们的数据变更时，VUE会帮你更新所有网页中用到它的地方。关于这个响应式原理，官方已经讲得很清楚，可以参考<a href="https://cn.vuejs.org/v2/guide/reactivity.html">link</a></li></ol><h5 id="3-主流框架实现双向绑定（响应式）的做法："><a href="#3-主流框架实现双向绑定（响应式）的做法：" class="headerlink" title="3.主流框架实现双向绑定（响应式）的做法："></a>3.主流框架实现双向绑定（响应式）的做法：</h5><ol><li>脏值检查：angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。</li><li>观察者-订阅者（数据劫持）：vueObserver 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。执行流程如下：<br><img src="https://img-blog.csdnimg.cn/20200102193350149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。</li></ol><h2 id="lt-四-gt-SPA"><a href="#lt-四-gt-SPA" class="headerlink" title="&lt;四&gt;SPA"></a>&lt;四&gt;SPA</h2><h5 id="1-什么是单页面应用程序（SPA）"><a href="#1-什么是单页面应用程序（SPA）" class="headerlink" title="1.什么是单页面应用程序（SPA）"></a>1.什么是单页面应用程序（SPA）</h5><ol><li>SPA是一种Web开发方法，整个应用功能都存在于单个页面中。</li><li>在SPA应用中，应用加载之后就不会再有整页刷新。相反，展示逻辑预先加载，并有赖于内容Region（区域）中的视图切换来展示内容。</li><li>SPA客户端与服务器端实行异步通信。常用的数据通信格式为JSON文本格式。</li><li>MV*框架提供机制，让SPA应用绑定服务器端请求数据与视图（用户所见并与之交互）。</li><li>与依赖全局变量和函数不同的是，SPA中的JavaScript代码通过模块来组织。模块提供了状态和/或数据封装。模块还有助于代码解耦及维护。</li><li>SPA的优势还包括类桌面应用的呈现效果、解耦的表现层、更快速轻量的符合、更少的用户等待时间以及更好的代码维护性等。<h5 id="2-SPA与传统Web应用的区别"><a href="#2-SPA与传统Web应用的区别" class="headerlink" title="2.SPA与传统Web应用的区别"></a>2.SPA与传统Web应用的区别</h5>SPA：无需刷新浏览器，将需要操作的DOM的变化放在浏览器中，如果页面需要变化的时候，由操作这些变化的JavaScript（已经加载于浏览器中的）来实现操作。<br>SPA实现的视图的刷新，是局部子容器（Region）的变化，而不是页面的重新加载，无重载页面是单页面应用程序的关键</li><li>无需刷新浏览器</li><li>表现逻辑位于客户端</li><li>服务器端事务处理<h5 id="3-关于SPA的使用"><a href="#3-关于SPA的使用" class="headerlink" title="3.关于SPA的使用"></a>3.关于SPA的使用</h5></li><li>使用模块模式<br>　　利用模块模式限制变量和函数作用域为模块自身。避开全局作用域相关的各种陷阱。<br>　　模块模式结合其他相关技术管理模块以及其依赖的可行方式，使得程序员能够借助页面构架方法来设计大型、健壮的Web应用程序。</li><li>为了让用户掌握其导航位置，单页面应用程序通常会在设计中融入路由选择（Routing）的设计思路：接触MV*框架或第三方库的代码实现，将URL风格的路径与功能关联起来。路径通常看起来像相对URL，其充当用户导航时到达特定视图的触发因素。路由器可以动态更新浏览器URL，并允许用户使用前进和后退按钮。这就进一步强化了当屏幕某部分变化时会到达新位置的设计理念。</li><li>SPA创建视图组成与布局<br>　　在单页面应用程序中，UI由视图而非新页面构成。内容Region的创建以及视图在这些Region中的位置，决定了应用程序的布局。客户端路由由于连接这些点。所有的这些要素有机结合起来就影响了应用程序的可用性和美感。</li><li>利用MV*框架实现SPA架构<ol><li>一种架构。传统式的Web架构是前端交互，通过请求服务器获取处理好的新的HTML文件从而进行页面的重载刷新，而SPA式的Web架构设计是用户体验倾向于原生软件开发式的，是让用户决定我们用的就是一个原生开发式的程序应用，但是这个程序应用又不像软件一样需要下载，需要不断的更新，他就只是一个页面，通过路由器、AJAX等技术实现这样的用户体验的架构设计。</li><li>SPA只是一种架构理念，是想要达到的某种Web应用的体验。最终实现这样的程序应用需要用到的技术有很多，诸如路由器、AJAX、客户端自动化等等的技术。</li><li>MV框架就是集成了各种可以实现SPA架构理念的技术的程序集合，这些集合又体现了传统的MVC、MVP、MVVM等设计模式，但是又不局限于某种设计模式，是多种设计模式的集合体，因此我们称之为MV框架。<br>参考:<a href="https://www.cnblogs.com/shcrk/p/9286768.html">link</a></li></ol></li></ol><h2 id="lt-五-gt-关注点分离"><a href="#lt-五-gt-关注点分离" class="headerlink" title="&lt;五&gt;关注点分离"></a>&lt;五&gt;关注点分离</h2><p>好的架构设计必须把变化点错落有致地封装到软件系统的不同部分。要做到这一点，必须进行关注点分离。Iuar Jacobson在《AOSD中文版》中写道：<br>“好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。”<br>上述论述中的三句话：<br>“系统中的一个部分发生了变化，不会影响其他部分。”</p><p>“即使需要改变，也能够清晰地识别出那些部分需要改变。”<br>“如果需要扩展架构，将影响最小化，已经可以工作的每个部分都将继续工作。”<br>可以说是对软件开发者的奋斗目标的最精辟的论述。也是软件设计要达到的最高目标。<br>关注点分离是实现上述目标的基本方法。</p><h5 id="关注点分离的基本方法有"><a href="#关注点分离的基本方法有" class="headerlink" title="关注点分离的基本方法有:"></a>关注点分离的基本方法有:</h5><ol><li>按职责分离关注点<br>将一个功能的实现分成展现层、业务层和数据层就是典型的按职责进行关注点分离的例子。</li><li>按通用性分离关注点<br>不同的通用程度意味着变化的可能性不同。可以将组成系统的元素分成技术通用部分、领域通用部分和特定应用部分。技术通用部分具有广泛的通用性，领域通用部分在对应领域具有普遍通用性。特定应用部分一般没有通用性。</li><li>按粒度级别分离关注点<br>在软件架构设计中，可以优先考虑大粒度的子系统和在集成系统中的互操作，忽略子系统的进一步分离。<br>参考：<a href="https://www.cnblogs.com/asis/p/architecture-Soc.html">link</a></li></ol><h2 id="lt-六-gt-前后端分离"><a href="#lt-六-gt-前后端分离" class="headerlink" title="&lt;六&gt;前后端分离"></a>&lt;六&gt;前后端分离</h2><h5 id="1-前后端不分离："><a href="#1-前后端不分离：" class="headerlink" title="1.前后端不分离："></a>1.前后端不分离：</h5><p><img src="https://img-blog.csdnimg.cn/20200102194355822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-前后端分离："><a href="#2-前后端分离：" class="headerlink" title="2.前后端分离："></a>2.前后端分离：</h5><p><img src="https://img-blog.csdnimg.cn/20200102194407878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEyNDIxNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="lt-七-gt-前端架构的工程化、模块化、组件化、规范化"><a href="#lt-七-gt-前端架构的工程化、模块化、组件化、规范化" class="headerlink" title="&lt;七&gt;前端架构的工程化、模块化、组件化、规范化"></a>&lt;七&gt;前端架构的工程化、模块化、组件化、规范化</h2><p>一个项目组成分为 前端，服务端。传统的前端项目用三剑客 javascript html css 就传统的项目结构已经不能满足日益壮大的大型应用的需求了。现在前端的生态圈很繁荣，各种框架，组件的出现。让前端发展迅速，快速开发已经成为了前端的一个标准。如果你想构建一个易维护，代码简洁，性能优化程度高的项目就离不开前端的架构。这也就解疑了架构是不是必须的？<br><strong>架构的目的是什么？答案是提升质量和效率。</strong><br><strong>那应该怎么进行架构呢？架构的目的是制定标准，提升质量和效率。</strong></p><ul><li>架构是一个抽象的过程，它是架构师根据自己的经验对大量具体的业务项目进行分析，发现其中的规律，抽象出具体的规范，最终又应用于具体的业务项目中去。比如常说的MVVM就是一种规范。</li><li>要把跟业务无关的问题都在架构层面处理掉。比如代码压缩，打包这种工程化的问题都要在架构层面统一解决的。要做到业务的归业务，架构的归架构。</li><li>架构要考虑到可以方便团队成员提供和使用通用技术解决方案。比如分页组件这种。</li><li>架构设计的时候要综合考虑当前的主流技术跟自己业务系统的实际情况。因为前端正处在高速发展，各种新技术，工具，插件，框架层出不穷，要结合项目实际情况运用已经成熟的技术，避免跳坑。。</li><li><em>合理的架构应该是怎么样的？<br>概括几点就是：模块化，组件化，工程化，规范化。</em>*<h4 id="1-浅谈工程化"><a href="#1-浅谈工程化" class="headerlink" title="1. 浅谈工程化"></a>1. 浅谈工程化</h4></li><li><em>将前端项目当成一项系统工程进行分析、组织和构建从而达到项目结构清晰、分工明确、团队配合默契、开发效率提高的目的.<br>工程化是一种思想而不是某种技术</em>*  （当然为了实现工程化我们会用一些技术）</li><li><em>前端工程化就是用做工程的思维看待和开发自己的项目，而不再是直接撸起袖子一个页面一个页面开写</em>*<br>工程化就像是百叶箱一样，减少人的操作，把工作所需要的工具做到的标准化，工作的流程做到的标准化。同时把很多重复的工作交给了代码来做，保证高质，标准统一。<br>先从工具入手，工程化包括哪些方面：</li><li>模块化与组件化: npm, es6,seajs, react/angularjs/Vue</li><li>代码版本管理: git</li><li>代码风格管理: jscs, editorconfig</li><li>代码编译: babel, less,sass,scss, imgmin, csssprit, inline-svg</li><li>代码质量管理 (QA): eslint, mocha</li><li> 代码构建: webpack</li><li>项目脚手架: yeoman</li><li>持续集成/持续交付/持续部署: jenkins</li><li>本地化与国际化</li><li><em>进行工程化：</em>*</li><li>在配置初始项目文件结构和基本文件依靠命令行（工具）自动生成。</li><li>确定代码规范，缩进，换行，以及各种预编译工具less，coffee，保证输出代码的标准一致</li><li>对JS文件是否规范化，进行单元测试，不用手动复制到jshint上去检测，现在配置grunt监听文件变动自动检验显示检验结果还可以通过配置构建工具自动刷新浏览器实现文件实时变动监听。</li><li>以前压缩合并文件用手工复制到压缩工具然后复制到一个文件里面，现在配置一下 grunt，gulp可以做自动任务，实时编译，并且监测文件改变而做出响应。</li><li>以前发布到服务器上，要手动使用 FTP 软件上传，现在也可以用工具自动打包上传。<h4 id="2-浅谈模块化"><a href="#2-浅谈模块化" class="headerlink" title="2.浅谈模块化"></a>2.浅谈模块化</h4>前端工程化是一个高层次的思想,而模块化和组件化是为工程化思想下相对较具体的开发方式,因此可以简单的认为模块化和组件化是工程化的表现形式。</li><li><em>模块化开发，一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。</em>*</li><li><em>模块化方案需解决什么问题？</em>*<div class="code-wrapper"><pre><code class="hljs">  模块化要实现两个东西：模块加载与模块封装。  面临的具体问题包括：</code></pre></div><ol><li>如何定义模块以确保模块的作用域独立，避免命名冲突？</li><li>如何管理模块间的依赖关系，避免重复加载与循环引用？</li><li>模块化的代码如何部署，以降低HTTP请求数？</li><li>如何实现按需加载？</li><li>如何在解决上述问题之后，保证性能且不影响debug？</li></ol></li></ul><p><strong>模块化开发的4点好处：</strong></p><ol><li>避免变量污染，命名冲突</li><li>提高代码复用率</li><li>提高维护性</li><li>依赖关系的管理</li></ol><p>通行的JavaScript模块规范主要有两种：CommonJS和AMD</p><p><strong>CommonJS</strong><br>我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。</p><ol><li>定义模块<br>根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。</li><li>模块输出<br>模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。</li><li>加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象。<br>不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）</li></ol><p><strong>AMD</strong><br>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思<br>requireJS主要解决两个问题</p><ol><li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li><li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li></ol><p><strong>CMD</strong><br>CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p><p><strong>AMD与CMD区别</strong><br>最明显的区别就是在模块定义时对依赖的处理不同</p><ol><li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li><li>CMD推崇异步依赖加载的，只有在用到某个模块的时候再去require<br>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同。很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</li></ol><p><strong>具体模块化比较可以查看:</strong><br><a href="https://www.cnblogs.com/dolphinX/p/4381855.html">link</a><br><a href="https://juejin.im/post/5c17ad756fb9a049ff4e0a62">link</a></p><p><strong>webpack时代</strong><br>webpack的优点：</p><ol><li>1require.js的所有功能它都有</li><li>编绎过程更快，因为require.js会去处理不需要的文件</li><li>还有一个额外的好处就是你不需要再做一个封装的函数，require.js中你得这样<br>define([‘jquery’], function(jquery){})</li><li>现在你需要一个很大的封装去定义每个模块，然后你需要在在require.js的配制文件中将每个模块的路径都配出来，用过requirejs都会遇到的好繁琐</li></ol><p><strong>对比requirejs seajs webpack特有的属性：</strong></p><ol><li>对 CommonJS 、 AMD 、ES6的语法做了兼容</li><li>对js、css、图片等资源文件都支持打包（css都可以合成多个css文件包，sass和less虽然也是模块化的加载合并，可是css和js分离的关联不大，这里的css可以和js有更大的关联，更细致区分加载的js）</li><li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</li><li>有独立的配置文件webpack.config.js</li><li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</li><li>支持 SourceUrls 和 SourceMaps，易于调试</li><li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</li><li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li><li>双服务器模式</li></ol><h4 id="3-浅谈组件化"><a href="#3-浅谈组件化" class="headerlink" title="3.浅谈组件化"></a>3.浅谈组件化</h4><p>组件化也是工程化的表现形式。</p><ol><li>页面上的每个独立的、可视/可交互区域视为一个组件;</li><li>每个组件对应一个工程目录,组件所需的各种资源都在这个目录下就近维护;</li><li>由于组件具有独立性,因此组件与组件之间可以 自由组合;</li><li>页面只不过是组件的容器,负责组合组件形成功能完整的界面;</li><li>当不需要某个组件,或者想要替换组件时,可以整个目录删除/替换。</li></ol><p><strong>组件化将页面视为一个容器,页面上各个独立部分例如:头部、导航、焦点图、侧边栏、底部等视为独立组件,不同的页面根据内容的需要,去盛放相关组件即可组成完整的页面。</strong><br>PS:模块化和组件化一个最直接的好处就是复用,同时我们也应该有一个理念,模块化和组件化除了复用之外还有就是分治,我们能够在不影响其他代码的情况下按需修改某一独立的模块或是组件,因此很多地方我们及时没有很强烈的复用需要也可以根据分治需求进行模块化或组件化开发。</p><p>组件化设计就是为了增加复用性，灵活性，提高系统设计，从而提高开发效率。</p><p>保证组件的封闭性。因为JS方面是模块化的。组件的功能界限问题。也就是什么是应该在组件内部实现，什么是应该由组件的调用者来实现的。对组件功能界限的定义是只负责UI相关的功能，所有的业务逻辑都是从调用者传递过的。也即是写在param.js。所以param.js文件是非常重要的一个文件，里面基本包涵了这个页面所有业务处理逻辑。很显然，随着页面业务逻辑变的复杂，js文件将会变得越来越大。没关系，把不同的组件参数分拆到不同的js文件里面去实现，然后建个专门的文件夹把它们组织起来。</p><h4 id="4-前端组件化与模块化之间的区别"><a href="#4-前端组件化与模块化之间的区别" class="headerlink" title="4.前端组件化与模块化之间的区别"></a>4.前端组件化与模块化之间的区别</h4><p><strong>组件化</strong></p><ol><li>就是”基础库”或者“基础组件”，意思是把代码重复的部分提炼出一个个组件供给功能使用。</li><li>使用：Dialog，各种自定义的UI控件、能在项目或者不同项目重复应用的代码等等。</li><li>目的：复用，解耦。</li><li>依赖：组件之间低依赖，比较独立。</li><li>架构定位：纵向分层（位于架构底层，被其他层所依赖）。</li></ol><p><strong>模块化</strong></p><ol><li>就是”业务框架”或者“业务模块”，也可以理解为“框架”，意思是把功能进行划分，将同一类型的代码整合在一起，所以模块的功能 相对复杂，但都同属于一个业务。</li><li>使用：按照项目功能需求划分成不同类型的业务框架（例如：注册、登录、外卖、直播…）</li><li>目的：隔离/封装 （高内聚）。</li><li>依赖：模块之间有依赖的关系，可通过路由器进行模块之间的耦合问题。</li><li>架构定位：横向分块（位于架构业务框架层）。</li></ol><p><strong>总结</strong></p><ol><li>其实组件相当于库，把一些能在项目里或者不同类型项目中可复用的代码进行工具性的封装。组件化更关注的是 UI 部分：弹出框、头部，内容区、按钮等，都可以编写成组件，然后在适用的地方进行引用。，组件化主要解决代码复用的问题。</li><li>而模块相应于业务逻辑模块，把同一类型项目里的功能逻辑进行进行需求性的封装。而模块化更侧重于功能或者数据的封装，比如全局的 JSON 配置文件，比如通用的验证方法，比如规范时间戳等。模块化能将复杂系统解耦。<h4 id="5-浅谈规范化"><a href="#5-浅谈规范化" class="headerlink" title="5.浅谈规范化"></a>5.浅谈规范化</h4>项目目录结构非常清晰。当进行开发的时候，哪些代码应该放到哪里都进行了明确的规定，并且每个文件的功能都尽量清晰并且单一。<br>架构是个不断完善的过程，而把架构尤其是跟规范相关的部分落实到具体业务系统里面更是个团队不断磨合的过程。它最终考验的，同时也是最终磨合出来的是团队的成熟度。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端技术知识归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js闭包</title>
    <link href="/2020/01/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Js%E9%97%AD%E5%8C%85/"/>
    <url>/2020/01/03/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Js%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>（本文是对网上一些关于闭包的资料的小总结，主要参考链接<a href="https://www.jianshu.com/p/26c81fde22fb">link</a>,对其中坑点例子的代码进行小修正，并加入自己的理解和代码注解，方便读者理解。）</p><p><strong>闭包定义：</strong>闭包就是能够读取其他函数内部变量的函数。清晰地说，闭包就是一个函数，这个函数能够访问其他函数作用域中的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">var</span>  a = <span class="hljs-string">&#x27;变量1&#x27;</span><br>     <span class="hljs-keyword">var</span>  inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.info(a)<br>     &#125;<br>    <span class="hljs-keyword">return</span> inner    <span class="hljs-comment">// inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（因为inner能够访问到outer作用域的变量，所以inner是个闭包函数）</p><p><strong>在说闭包前，先了解一下js函数和变量在堆栈中的如何存储：</strong></p><p>js基本类型：Undefined，Null，Boolean，Number，String</p><p>js引用类型：Object，Array，Function</p><p>基本类型值在内存中占固定大小，被保存在栈中。引用类型值是对象，保存在堆内存中。</p><ol><li>栈：stack是有结构的，先进先出，存放基本数据类型和对象的引用，每个区块的大小是明确的。</li><li>堆：heap没有结构，数据任意存放，js中主要存放的是引用类型。</li></ol><p>参考链接：<a href="https://blog.csdn.net/sinat_15951543/article/details/79228675">link</a></p><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(b);<br>    &#125;<br>    fn1();<br>&#125;<br>fn();<br></code></pre></td></tr></table></figure><p>他在栈中的存放情况：</p><p><img src="https://upload-images.jianshu.io/upload_images/7155532-ee4142a5b829d016.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><p>栈是一种先进后出的数据结构：<br> 1 在执行fn前，此时我们在全局执行环境(浏览器就是window作用域)，全局作用域里有个变量a；<br> 2 进入fn，此时栈内存就会push一个fn的执行环境，这个环境里有变量b和函数对象fn1，这里可以访问自身执行环境和全局执行环境所定义的变量<br> 3 进入fn1，此时栈内存就会push 一个fn1的执行环境，这里面没有定义其他变量，但是我们可以访问到fn和全局执行环境里面的变量，因为程序在访问变量时，是向底层栈一个个找，如果找到全局执行环境里都没有对应变量，则程序抛出underfined的错误。</p><p>4 随着fn1()执行完毕，fn1的执行环境被杯销毁，接着执行完fn()，fn的执行环境也会被销毁，只剩全局的执行环境下，现在没有b变量，和fn1函数对象了，只有a 和 fn(函数声明作用域是window下)</p><p>现在看回最初的例子outer与inner：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">var</span>  a = <span class="hljs-string">&#x27;变量1&#x27;</span><br>     <span class="hljs-keyword">var</span>  inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.info(a)<br>     &#125;<br>    <span class="hljs-keyword">return</span> inner    <span class="hljs-comment">// inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span><br>&#125;<br><span class="hljs-keyword">var</span>  inner = outer()   <span class="hljs-comment">// 获得inner闭包函数</span><br>inner()   <span class="hljs-comment">//&quot;变量1&quot;</span><br></code></pre></td></tr></table></figure><p>当程序执行完var inner = outer()，其实outer的执行环境并没有被销毁，因为他里面的变量a仍然被被inner的函数作用域链所引用，当程序执行完inner(), 这时候，inner和outer的执行环境才会被销毁调。</p><p>现在基本了解闭包，通过分析以下几个坑点，来深入了解闭包：</p><ol><li><p>坑点：<strong>引用的变量可能发生变化</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123; <br>      <span class="hljs-keyword">var</span> result = [];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>        result[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">//将函数赋值给每个result数组中的元素。</span><br>            <span class="hljs-built_in">console</span>.info(i)<br>        &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result  <span class="hljs-comment">//outer函数返回值result是一个包含10个元素的数组，而每个元素都是一个函数。</span><br>&#125;<br><span class="hljs-keyword">var</span> res = outer();  <span class="hljs-comment">//这里调用了outer函数，并将outer函数返回值result赋值给res，</span><br>res[<span class="hljs-number">3</span>]();<span class="hljs-comment">//这里调用res数组中的第四个函数。</span><br></code></pre></td></tr></table></figure></li></ol><p>看样子result每个闭包函数对打印对应数字，1,2,3,4,…,10, 实际不是，因为每个闭包函数访问变量i是outer执行环境下的变量i，随着循环的结束，i已经变成10了，所以执行每个闭包函数，结果打印10， 10， …, 10</p><p><strong>出现上面的原因是因为：</strong></p><p>在刚开始的一段代码中，我们只是在声明一个outer函数，并没有调用它，也没有调用outer返回值result中的函数。</p><p>而在运行了<code>var res = outer()</code>这段代码后，也只是调用了outer函数，也就是说，此时outer函数返回值result数组里只是存了10个函数，并没有被调用。当我们在运行<code>res[3]()</code>这句代码时，res数组里的第四个函数才被调用，这个函数被调用时，他需要打印出变量i，所以他得去栈里找到i，然而在他被调用前，for循环早已从0到10，i已经是10了，所以打印出的i就是10。</p><p>怎么解决这个问题呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> result = [];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>        result[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123; <span class="hljs-comment">//这里的num就是函数的输入变量，即i</span><br>             <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                   <span class="hljs-built_in">console</span>.info(num);    <span class="hljs-comment">// 此时访问的num，是上层函数执行环境的num，数组有10个函数对象，每个对象的执行环境下的number都不一样</span><br>             &#125;<br>        &#125;(i)  <span class="hljs-comment">//注意看这个加在函数后面（i）,说明在此赋值给result数组的10个元素都是立即执行函数，他们在创建之后立即被执行。</span><br>     &#125;<br>     <span class="hljs-keyword">return</span> result  <span class="hljs-comment">//因为赋值给result元素的函数是立即执行函数，他们在创建就已经被执行，所以此时result里面存的实际是立即执行函数执行完返回的10个函数 function() &#123;console.info(num);&#125;，他们的num不相同，分别是0-10</span><br>&#125;<br><span class="hljs-keyword">var</span> res = outer();<br>res[<span class="hljs-number">3</span>]();<span class="hljs-comment">//此时调用的是res元素的第四个元素，他是立即执行函数返回的函数function() &#123;console.info(num);&#125;，此时他去找的num就是3</span><br></code></pre></td></tr></table></figure><ol start="2"><li>坑点：<strong>this指向问题</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> object = &#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;object&quot;</span><br>     getName： <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>             <span class="hljs-built_in">console</span>.info(<span class="hljs-built_in">this</span>.name)<br>        &#125;<br>    &#125;<br>&#125;<br>object.getName()()    <span class="hljs-comment">// underfined  </span><br><span class="hljs-comment">// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows</span><br></code></pre></td></tr></table></figure><p>那为什么说里面的闭包函数是在weindow作用域下呢?</p><p>原因：主要看这句代码：<code>object.getName()()</code> ，其中，先看前面<code>object.getName()</code>这句是在调用对象object中的getName函数，执行完后这句话后，返回值是另一个函数<code>function() &#123; console.info(this.name) &#125;</code>此时这个返回的函数已经和object无关，他不在是在object里面，而是在window作用域中的函数。也就是说<code>object.getName()()</code> 这句话是在调用getName函数返回的一个已经和object无关的函数。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
